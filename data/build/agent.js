import __import_OS from "node:os";
import __import_TTY from "node:tty";
import __import_UTIL from "node:util";

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) =>
  function __init() {
    return (fn && (res = (0, fn[__getOwnPropNames(fn)[0]])((fn = 0))), res);
  };
var __commonJS = (cb, mod) =>
  function __require3() {
    return (
      mod ||
        (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod),
      mod.exports
    );
  };
var __export = (target, all) => {
  for (var name18 in all)
    __defProp(target, name18, { get: all[name18], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if ((from && typeof from === "object") || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, {
          get: () => from[key],
          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable,
        });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (
  (target = mod != null ? __create(__getProtoOf(mod)) : {}),
  __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule
      ? __defProp(target, "default", { value: mod, enumerable: true })
      : target,
    mod,
  )
);
var __toCommonJS = (mod) =>
  __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/fast-xml-parser/src/util.js
var require_util = __commonJS({
  "node_modules/fast-xml-parser/src/util.js"(exports) {
    "use strict";
    var nameStartChar =
      ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
    var nameChar =
      nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
    var nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
    var regexName = new RegExp("^" + nameRegexp + "$");
    var getAllMatches = function (string5, regex) {
      const matches = [];
      let match = regex.exec(string5);
      while (match) {
        const allmatches = [];
        allmatches.startIndex = regex.lastIndex - match[0].length;
        const len = match.length;
        for (let index = 0; index < len; index++) {
          allmatches.push(match[index]);
        }
        matches.push(allmatches);
        match = regex.exec(string5);
      }
      return matches;
    };
    var isName = function (string5) {
      const match = regexName.exec(string5);
      return !(match === null || typeof match === "undefined");
    };
    exports.isExist = function (v2) {
      return typeof v2 !== "undefined";
    };
    exports.isEmptyObject = function (obj) {
      return Object.keys(obj).length === 0;
    };
    exports.merge = function (target, a2, arrayMode) {
      if (a2) {
        const keys = Object.keys(a2);
        const len = keys.length;
        for (let i2 = 0; i2 < len; i2++) {
          if (arrayMode === "strict") {
            target[keys[i2]] = [a2[keys[i2]]];
          } else {
            target[keys[i2]] = a2[keys[i2]];
          }
        }
      }
    };
    exports.getValue = function (v2) {
      if (exports.isExist(v2)) {
        return v2;
      } else {
        return "";
      }
    };
    exports.isName = isName;
    exports.getAllMatches = getAllMatches;
    exports.nameRegexp = nameRegexp;
  },
});

// node_modules/fast-xml-parser/src/validator.js
var require_validator = __commonJS({
  "node_modules/fast-xml-parser/src/validator.js"(exports) {
    "use strict";
    var util2 = require_util();
    var defaultOptions3 = {
      allowBooleanAttributes: false,
      //A tag can have attributes without any value
      unpairedTags: [],
    };
    exports.validate = function (xmlData, options) {
      options = Object.assign({}, defaultOptions3, options);
      const tags = [];
      let tagFound = false;
      let reachedRoot = false;
      if (xmlData[0] === "\uFEFF") {
        xmlData = xmlData.substr(1);
      }
      for (let i2 = 0; i2 < xmlData.length; i2++) {
        if (xmlData[i2] === "<" && xmlData[i2 + 1] === "?") {
          i2 += 2;
          i2 = readPI(xmlData, i2);
          if (i2.err) return i2;
        } else if (xmlData[i2] === "<") {
          let tagStartPos = i2;
          i2++;
          if (xmlData[i2] === "!") {
            i2 = readCommentAndCDATA(xmlData, i2);
            continue;
          } else {
            let closingTag = false;
            if (xmlData[i2] === "/") {
              closingTag = true;
              i2++;
            }
            let tagName = "";
            for (
              ;
              i2 < xmlData.length &&
              xmlData[i2] !== ">" &&
              xmlData[i2] !== " " &&
              xmlData[i2] !== "	" &&
              xmlData[i2] !== "\n" &&
              xmlData[i2] !== "\r";
              i2++
            ) {
              tagName += xmlData[i2];
            }
            tagName = tagName.trim();
            if (tagName[tagName.length - 1] === "/") {
              tagName = tagName.substring(0, tagName.length - 1);
              i2--;
            }
            if (!validateTagName(tagName)) {
              let msg;
              if (tagName.trim().length === 0) {
                msg = "Invalid space after '<'.";
              } else {
                msg = "Tag '" + tagName + "' is an invalid name.";
              }
              return getErrorObject(
                "InvalidTag",
                msg,
                getLineNumberForPosition(xmlData, i2),
              );
            }
            const result = readAttributeStr(xmlData, i2);
            if (result === false) {
              return getErrorObject(
                "InvalidAttr",
                "Attributes for '" + tagName + "' have open quote.",
                getLineNumberForPosition(xmlData, i2),
              );
            }
            let attrStr = result.value;
            i2 = result.index;
            if (attrStr[attrStr.length - 1] === "/") {
              const attrStrStart = i2 - attrStr.length;
              attrStr = attrStr.substring(0, attrStr.length - 1);
              const isValid2 = validateAttributeString(attrStr, options);
              if (isValid2 === true) {
                tagFound = true;
              } else {
                return getErrorObject(
                  isValid2.err.code,
                  isValid2.err.msg,
                  getLineNumberForPosition(
                    xmlData,
                    attrStrStart + isValid2.err.line,
                  ),
                );
              }
            } else if (closingTag) {
              if (!result.tagClosed) {
                return getErrorObject(
                  "InvalidTag",
                  "Closing tag '" + tagName + "' doesn't have proper closing.",
                  getLineNumberForPosition(xmlData, i2),
                );
              } else if (attrStr.trim().length > 0) {
                return getErrorObject(
                  "InvalidTag",
                  "Closing tag '" +
                    tagName +
                    "' can't have attributes or invalid starting.",
                  getLineNumberForPosition(xmlData, tagStartPos),
                );
              } else if (tags.length === 0) {
                return getErrorObject(
                  "InvalidTag",
                  "Closing tag '" + tagName + "' has not been opened.",
                  getLineNumberForPosition(xmlData, tagStartPos),
                );
              } else {
                const otg = tags.pop();
                if (tagName !== otg.tagName) {
                  let openPos = getLineNumberForPosition(
                    xmlData,
                    otg.tagStartPos,
                  );
                  return getErrorObject(
                    "InvalidTag",
                    "Expected closing tag '" +
                      otg.tagName +
                      "' (opened in line " +
                      openPos.line +
                      ", col " +
                      openPos.col +
                      ") instead of closing tag '" +
                      tagName +
                      "'.",
                    getLineNumberForPosition(xmlData, tagStartPos),
                  );
                }
                if (tags.length == 0) {
                  reachedRoot = true;
                }
              }
            } else {
              const isValid2 = validateAttributeString(attrStr, options);
              if (isValid2 !== true) {
                return getErrorObject(
                  isValid2.err.code,
                  isValid2.err.msg,
                  getLineNumberForPosition(
                    xmlData,
                    i2 - attrStr.length + isValid2.err.line,
                  ),
                );
              }
              if (reachedRoot === true) {
                return getErrorObject(
                  "InvalidXml",
                  "Multiple possible root nodes found.",
                  getLineNumberForPosition(xmlData, i2),
                );
              } else if (options.unpairedTags.indexOf(tagName) !== -1) {
              } else {
                tags.push({ tagName, tagStartPos });
              }
              tagFound = true;
            }
            for (i2++; i2 < xmlData.length; i2++) {
              if (xmlData[i2] === "<") {
                if (xmlData[i2 + 1] === "!") {
                  i2++;
                  i2 = readCommentAndCDATA(xmlData, i2);
                  continue;
                } else if (xmlData[i2 + 1] === "?") {
                  i2 = readPI(xmlData, ++i2);
                  if (i2.err) return i2;
                } else {
                  break;
                }
              } else if (xmlData[i2] === "&") {
                const afterAmp = validateAmpersand(xmlData, i2);
                if (afterAmp == -1)
                  return getErrorObject(
                    "InvalidChar",
                    "char '&' is not expected.",
                    getLineNumberForPosition(xmlData, i2),
                  );
                i2 = afterAmp;
              } else {
                if (reachedRoot === true && !isWhiteSpace(xmlData[i2])) {
                  return getErrorObject(
                    "InvalidXml",
                    "Extra text at the end",
                    getLineNumberForPosition(xmlData, i2),
                  );
                }
              }
            }
            if (xmlData[i2] === "<") {
              i2--;
            }
          }
        } else {
          if (isWhiteSpace(xmlData[i2])) {
            continue;
          }
          return getErrorObject(
            "InvalidChar",
            "char '" + xmlData[i2] + "' is not expected.",
            getLineNumberForPosition(xmlData, i2),
          );
        }
      }
      if (!tagFound) {
        return getErrorObject("InvalidXml", "Start tag expected.", 1);
      } else if (tags.length == 1) {
        return getErrorObject(
          "InvalidTag",
          "Unclosed tag '" + tags[0].tagName + "'.",
          getLineNumberForPosition(xmlData, tags[0].tagStartPos),
        );
      } else if (tags.length > 0) {
        return getErrorObject(
          "InvalidXml",
          "Invalid '" +
            JSON.stringify(
              tags.map((t2) => t2.tagName),
              null,
              4,
            ).replace(/\r?\n/g, "") +
            "' found.",
          { line: 1, col: 1 },
        );
      }
      return true;
    };
    function isWhiteSpace(char) {
      return char === " " || char === "	" || char === "\n" || char === "\r";
    }
    function readPI(xmlData, i2) {
      const start = i2;
      for (; i2 < xmlData.length; i2++) {
        if (xmlData[i2] == "?" || xmlData[i2] == " ") {
          const tagname = xmlData.substr(start, i2 - start);
          if (i2 > 5 && tagname === "xml") {
            return getErrorObject(
              "InvalidXml",
              "XML declaration allowed only at the start of the document.",
              getLineNumberForPosition(xmlData, i2),
            );
          } else if (xmlData[i2] == "?" && xmlData[i2 + 1] == ">") {
            i2++;
            break;
          } else {
            continue;
          }
        }
      }
      return i2;
    }
    function readCommentAndCDATA(xmlData, i2) {
      if (
        xmlData.length > i2 + 5 &&
        xmlData[i2 + 1] === "-" &&
        xmlData[i2 + 2] === "-"
      ) {
        for (i2 += 3; i2 < xmlData.length; i2++) {
          if (
            xmlData[i2] === "-" &&
            xmlData[i2 + 1] === "-" &&
            xmlData[i2 + 2] === ">"
          ) {
            i2 += 2;
            break;
          }
        }
      } else if (
        xmlData.length > i2 + 8 &&
        xmlData[i2 + 1] === "D" &&
        xmlData[i2 + 2] === "O" &&
        xmlData[i2 + 3] === "C" &&
        xmlData[i2 + 4] === "T" &&
        xmlData[i2 + 5] === "Y" &&
        xmlData[i2 + 6] === "P" &&
        xmlData[i2 + 7] === "E"
      ) {
        let angleBracketsCount = 1;
        for (i2 += 8; i2 < xmlData.length; i2++) {
          if (xmlData[i2] === "<") {
            angleBracketsCount++;
          } else if (xmlData[i2] === ">") {
            angleBracketsCount--;
            if (angleBracketsCount === 0) {
              break;
            }
          }
        }
      } else if (
        xmlData.length > i2 + 9 &&
        xmlData[i2 + 1] === "[" &&
        xmlData[i2 + 2] === "C" &&
        xmlData[i2 + 3] === "D" &&
        xmlData[i2 + 4] === "A" &&
        xmlData[i2 + 5] === "T" &&
        xmlData[i2 + 6] === "A" &&
        xmlData[i2 + 7] === "["
      ) {
        for (i2 += 8; i2 < xmlData.length; i2++) {
          if (
            xmlData[i2] === "]" &&
            xmlData[i2 + 1] === "]" &&
            xmlData[i2 + 2] === ">"
          ) {
            i2 += 2;
            break;
          }
        }
      }
      return i2;
    }
    var doubleQuote = '"';
    var singleQuote = "'";
    function readAttributeStr(xmlData, i2) {
      let attrStr = "";
      let startChar = "";
      let tagClosed = false;
      for (; i2 < xmlData.length; i2++) {
        if (xmlData[i2] === doubleQuote || xmlData[i2] === singleQuote) {
          if (startChar === "") {
            startChar = xmlData[i2];
          } else if (startChar !== xmlData[i2]) {
          } else {
            startChar = "";
          }
        } else if (xmlData[i2] === ">") {
          if (startChar === "") {
            tagClosed = true;
            break;
          }
        }
        attrStr += xmlData[i2];
      }
      if (startChar !== "") {
        return false;
      }
      return {
        value: attrStr,
        index: i2,
        tagClosed,
      };
    }
    var validAttrStrRegxp = new RegExp(
      `(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`,
      "g",
    );
    function validateAttributeString(attrStr, options) {
      const matches = util2.getAllMatches(attrStr, validAttrStrRegxp);
      const attrNames = {};
      for (let i2 = 0; i2 < matches.length; i2++) {
        if (matches[i2][1].length === 0) {
          return getErrorObject(
            "InvalidAttr",
            "Attribute '" + matches[i2][2] + "' has no space in starting.",
            getPositionFromMatch(matches[i2]),
          );
        } else if (matches[i2][3] !== void 0 && matches[i2][4] === void 0) {
          return getErrorObject(
            "InvalidAttr",
            "Attribute '" + matches[i2][2] + "' is without value.",
            getPositionFromMatch(matches[i2]),
          );
        } else if (
          matches[i2][3] === void 0 &&
          !options.allowBooleanAttributes
        ) {
          return getErrorObject(
            "InvalidAttr",
            "boolean attribute '" + matches[i2][2] + "' is not allowed.",
            getPositionFromMatch(matches[i2]),
          );
        }
        const attrName = matches[i2][2];
        if (!validateAttrName(attrName)) {
          return getErrorObject(
            "InvalidAttr",
            "Attribute '" + attrName + "' is an invalid name.",
            getPositionFromMatch(matches[i2]),
          );
        }
        if (!attrNames.hasOwnProperty(attrName)) {
          attrNames[attrName] = 1;
        } else {
          return getErrorObject(
            "InvalidAttr",
            "Attribute '" + attrName + "' is repeated.",
            getPositionFromMatch(matches[i2]),
          );
        }
      }
      return true;
    }
    function validateNumberAmpersand(xmlData, i2) {
      let re2 = /\d/;
      if (xmlData[i2] === "x") {
        i2++;
        re2 = /[\da-fA-F]/;
      }
      for (; i2 < xmlData.length; i2++) {
        if (xmlData[i2] === ";") return i2;
        if (!xmlData[i2].match(re2)) break;
      }
      return -1;
    }
    function validateAmpersand(xmlData, i2) {
      i2++;
      if (xmlData[i2] === ";") return -1;
      if (xmlData[i2] === "#") {
        i2++;
        return validateNumberAmpersand(xmlData, i2);
      }
      let count = 0;
      for (; i2 < xmlData.length; i2++, count++) {
        if (xmlData[i2].match(/\w/) && count < 20) continue;
        if (xmlData[i2] === ";") break;
        return -1;
      }
      return i2;
    }
    function getErrorObject(code, message, lineNumber) {
      return {
        err: {
          code,
          msg: message,
          line: lineNumber.line || lineNumber,
          col: lineNumber.col,
        },
      };
    }
    function validateAttrName(attrName) {
      return util2.isName(attrName);
    }
    function validateTagName(tagname) {
      return util2.isName(tagname);
    }
    function getLineNumberForPosition(xmlData, index) {
      const lines = xmlData.substring(0, index).split(/\r?\n/);
      return {
        line: lines.length,
        // column number is last line's length + 1, because column numbering starts at 1:
        col: lines[lines.length - 1].length + 1,
      };
    }
    function getPositionFromMatch(match) {
      return match.startIndex + match[1].length;
    }
  },
});

// node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js
var require_OptionsBuilder = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js"(exports) {
    var defaultOptions3 = {
      preserveOrder: false,
      attributeNamePrefix: "@_",
      attributesGroupName: false,
      textNodeName: "#text",
      ignoreAttributes: true,
      removeNSPrefix: false,
      // remove NS from tag name or attribute name if true
      allowBooleanAttributes: false,
      //a tag can have attributes without any value
      //ignoreRootElement : false,
      parseTagValue: true,
      parseAttributeValue: false,
      trimValues: true,
      //Trim string values of tag and attributes
      cdataPropName: false,
      numberParseOptions: {
        hex: true,
        leadingZeros: true,
        eNotation: true,
      },
      tagValueProcessor: function (tagName, val) {
        return val;
      },
      attributeValueProcessor: function (attrName, val) {
        return val;
      },
      stopNodes: [],
      //nested tags will not be parsed even for errors
      alwaysCreateTextNode: false,
      isArray: () => false,
      commentPropName: false,
      unpairedTags: [],
      processEntities: true,
      htmlEntities: false,
      ignoreDeclaration: false,
      ignorePiTags: false,
      transformTagName: false,
      transformAttributeName: false,
      updateTag: function (tagName, jPath, attrs) {
        return tagName;
      },
      // skipEmptyListItem: false
    };
    var buildOptions = function (options) {
      return Object.assign({}, defaultOptions3, options);
    };
    exports.buildOptions = buildOptions;
    exports.defaultOptions = defaultOptions3;
  },
});

// node_modules/fast-xml-parser/src/xmlparser/xmlNode.js
var require_xmlNode = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/xmlNode.js"(exports, module) {
    "use strict";
    var XmlNode = class {
      constructor(tagname) {
        this.tagname = tagname;
        this.child = [];
        this[":@"] = {};
      }
      add(key, val) {
        if (key === "__proto__") key = "#__proto__";
        this.child.push({ [key]: val });
      }
      addChild(node) {
        if (node.tagname === "__proto__") node.tagname = "#__proto__";
        if (node[":@"] && Object.keys(node[":@"]).length > 0) {
          this.child.push({ [node.tagname]: node.child, [":@"]: node[":@"] });
        } else {
          this.child.push({ [node.tagname]: node.child });
        }
      }
    };
    module.exports = XmlNode;
  },
});

// node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js
var require_DocTypeReader = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js"(
    exports,
    module,
  ) {
    var util2 = require_util();
    function readDocType(xmlData, i2) {
      const entities = {};
      if (
        xmlData[i2 + 3] === "O" &&
        xmlData[i2 + 4] === "C" &&
        xmlData[i2 + 5] === "T" &&
        xmlData[i2 + 6] === "Y" &&
        xmlData[i2 + 7] === "P" &&
        xmlData[i2 + 8] === "E"
      ) {
        i2 = i2 + 9;
        let angleBracketsCount = 1;
        let hasBody = false,
          comment = false;
        let exp = "";
        for (; i2 < xmlData.length; i2++) {
          if (xmlData[i2] === "<" && !comment) {
            if (hasBody && isEntity(xmlData, i2)) {
              i2 += 7;
              let entityName, val;
              [entityName, val, i2] = readEntityExp(xmlData, i2 + 1);
              if (val.indexOf("&") === -1)
                entities[validateEntityName(entityName)] = {
                  regx: RegExp(`&${entityName};`, "g"),
                  val,
                };
            } else if (hasBody && isElement(xmlData, i2)) i2 += 8;
            else if (hasBody && isAttlist(xmlData, i2)) i2 += 8;
            else if (hasBody && isNotation(xmlData, i2)) i2 += 9;
            else if (isComment) comment = true;
            else throw new Error("Invalid DOCTYPE");
            angleBracketsCount++;
            exp = "";
          } else if (xmlData[i2] === ">") {
            if (comment) {
              if (xmlData[i2 - 1] === "-" && xmlData[i2 - 2] === "-") {
                comment = false;
                angleBracketsCount--;
              }
            } else {
              angleBracketsCount--;
            }
            if (angleBracketsCount === 0) {
              break;
            }
          } else if (xmlData[i2] === "[") {
            hasBody = true;
          } else {
            exp += xmlData[i2];
          }
        }
        if (angleBracketsCount !== 0) {
          throw new Error(`Unclosed DOCTYPE`);
        }
      } else {
        throw new Error(`Invalid Tag instead of DOCTYPE`);
      }
      return { entities, i: i2 };
    }
    function readEntityExp(xmlData, i2) {
      let entityName = "";
      for (
        ;
        i2 < xmlData.length && xmlData[i2] !== "'" && xmlData[i2] !== '"';
        i2++
      ) {
        entityName += xmlData[i2];
      }
      entityName = entityName.trim();
      if (entityName.indexOf(" ") !== -1)
        throw new Error("External entites are not supported");
      const startChar = xmlData[i2++];
      let val = "";
      for (; i2 < xmlData.length && xmlData[i2] !== startChar; i2++) {
        val += xmlData[i2];
      }
      return [entityName, val, i2];
    }
    function isComment(xmlData, i2) {
      if (
        xmlData[i2 + 1] === "!" &&
        xmlData[i2 + 2] === "-" &&
        xmlData[i2 + 3] === "-"
      )
        return true;
      return false;
    }
    function isEntity(xmlData, i2) {
      if (
        xmlData[i2 + 1] === "!" &&
        xmlData[i2 + 2] === "E" &&
        xmlData[i2 + 3] === "N" &&
        xmlData[i2 + 4] === "T" &&
        xmlData[i2 + 5] === "I" &&
        xmlData[i2 + 6] === "T" &&
        xmlData[i2 + 7] === "Y"
      )
        return true;
      return false;
    }
    function isElement(xmlData, i2) {
      if (
        xmlData[i2 + 1] === "!" &&
        xmlData[i2 + 2] === "E" &&
        xmlData[i2 + 3] === "L" &&
        xmlData[i2 + 4] === "E" &&
        xmlData[i2 + 5] === "M" &&
        xmlData[i2 + 6] === "E" &&
        xmlData[i2 + 7] === "N" &&
        xmlData[i2 + 8] === "T"
      )
        return true;
      return false;
    }
    function isAttlist(xmlData, i2) {
      if (
        xmlData[i2 + 1] === "!" &&
        xmlData[i2 + 2] === "A" &&
        xmlData[i2 + 3] === "T" &&
        xmlData[i2 + 4] === "T" &&
        xmlData[i2 + 5] === "L" &&
        xmlData[i2 + 6] === "I" &&
        xmlData[i2 + 7] === "S" &&
        xmlData[i2 + 8] === "T"
      )
        return true;
      return false;
    }
    function isNotation(xmlData, i2) {
      if (
        xmlData[i2 + 1] === "!" &&
        xmlData[i2 + 2] === "N" &&
        xmlData[i2 + 3] === "O" &&
        xmlData[i2 + 4] === "T" &&
        xmlData[i2 + 5] === "A" &&
        xmlData[i2 + 6] === "T" &&
        xmlData[i2 + 7] === "I" &&
        xmlData[i2 + 8] === "O" &&
        xmlData[i2 + 9] === "N"
      )
        return true;
      return false;
    }
    function validateEntityName(name18) {
      if (util2.isName(name18)) return name18;
      else throw new Error(`Invalid entity name ${name18}`);
    }
    module.exports = readDocType;
  },
});

// node_modules/strnum/strnum.js
var require_strnum = __commonJS({
  "node_modules/strnum/strnum.js"(exports, module) {
    var hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
    var numRegex = /^([\-\+])?(0*)([0-9]*(\.[0-9]*)?)$/;
    var consider = {
      hex: true,
      // oct: false,
      leadingZeros: true,
      decimalPoint: ".",
      eNotation: true,
      //skipLike: /regex/
    };
    function toNumber(str, options = {}) {
      options = Object.assign({}, consider, options);
      if (!str || typeof str !== "string") return str;
      let trimmedStr = str.trim();
      if (options.skipLike !== void 0 && options.skipLike.test(trimmedStr))
        return str;
      else if (str === "0") return 0;
      else if (options.hex && hexRegex.test(trimmedStr)) {
        return parse_int(trimmedStr, 16);
      } else if (trimmedStr.search(/[eE]/) !== -1) {
        const notation = trimmedStr.match(
          /^([-\+])?(0*)([0-9]*(\.[0-9]*)?[eE][-\+]?[0-9]+)$/,
        );
        if (notation) {
          if (options.leadingZeros) {
            trimmedStr = (notation[1] || "") + notation[3];
          } else {
            if (notation[2] === "0" && notation[3][0] === ".") {
            } else {
              return str;
            }
          }
          return options.eNotation ? Number(trimmedStr) : str;
        } else {
          return str;
        }
      } else {
        const match = numRegex.exec(trimmedStr);
        if (match) {
          const sign = match[1];
          const leadingZeros = match[2];
          let numTrimmedByZeros = trimZeros(match[3]);
          if (
            !options.leadingZeros &&
            leadingZeros.length > 0 &&
            sign &&
            trimmedStr[2] !== "."
          )
            return str;
          else if (
            !options.leadingZeros &&
            leadingZeros.length > 0 &&
            !sign &&
            trimmedStr[1] !== "."
          )
            return str;
          else if (options.leadingZeros && leadingZeros === str) return 0;
          else {
            const num = Number(trimmedStr);
            const numStr = "" + num;
            if (numStr.search(/[eE]/) !== -1) {
              if (options.eNotation) return num;
              else return str;
            } else if (trimmedStr.indexOf(".") !== -1) {
              if (numStr === "0" && numTrimmedByZeros === "") return num;
              else if (numStr === numTrimmedByZeros) return num;
              else if (sign && numStr === "-" + numTrimmedByZeros) return num;
              else return str;
            }
            if (leadingZeros) {
              return numTrimmedByZeros === numStr ||
                sign + numTrimmedByZeros === numStr
                ? num
                : str;
            } else {
              return trimmedStr === numStr || trimmedStr === sign + numStr
                ? num
                : str;
            }
          }
        } else {
          return str;
        }
      }
    }
    function trimZeros(numStr) {
      if (numStr && numStr.indexOf(".") !== -1) {
        numStr = numStr.replace(/0+$/, "");
        if (numStr === ".") numStr = "0";
        else if (numStr[0] === ".") numStr = "0" + numStr;
        else if (numStr[numStr.length - 1] === ".")
          numStr = numStr.substr(0, numStr.length - 1);
        return numStr;
      }
      return numStr;
    }
    function parse_int(numStr, base) {
      if (parseInt) return parseInt(numStr, base);
      else if (Number.parseInt) return Number.parseInt(numStr, base);
      else if (window && window.parseInt) return window.parseInt(numStr, base);
      else
        throw new Error(
          "parseInt, Number.parseInt, window.parseInt are not supported",
        );
    }
    module.exports = toNumber;
  },
});

// node_modules/fast-xml-parser/src/ignoreAttributes.js
var require_ignoreAttributes = __commonJS({
  "node_modules/fast-xml-parser/src/ignoreAttributes.js"(exports, module) {
    function getIgnoreAttributesFn(ignoreAttributes) {
      if (typeof ignoreAttributes === "function") {
        return ignoreAttributes;
      }
      if (Array.isArray(ignoreAttributes)) {
        return (attrName) => {
          for (const pattern of ignoreAttributes) {
            if (typeof pattern === "string" && attrName === pattern) {
              return true;
            }
            if (pattern instanceof RegExp && pattern.test(attrName)) {
              return true;
            }
          }
        };
      }
      return () => false;
    }
    module.exports = getIgnoreAttributesFn;
  },
});

// node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js
var require_OrderedObjParser = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js"(
    exports,
    module,
  ) {
    "use strict";
    var util2 = require_util();
    var xmlNode = require_xmlNode();
    var readDocType = require_DocTypeReader();
    var toNumber = require_strnum();
    var getIgnoreAttributesFn = require_ignoreAttributes();
    var OrderedObjParser = class {
      constructor(options) {
        this.options = options;
        this.currentNode = null;
        this.tagsNodeStack = [];
        this.docTypeEntities = {};
        this.lastEntities = {
          apos: { regex: /&(apos|#39|#x27);/g, val: "'" },
          gt: { regex: /&(gt|#62|#x3E);/g, val: ">" },
          lt: { regex: /&(lt|#60|#x3C);/g, val: "<" },
          quot: { regex: /&(quot|#34|#x22);/g, val: '"' },
        };
        this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" };
        this.htmlEntities = {
          space: { regex: /&(nbsp|#160);/g, val: " " },
          // "lt" : { regex: /&(lt|#60);/g, val: "<" },
          // "gt" : { regex: /&(gt|#62);/g, val: ">" },
          // "amp" : { regex: /&(amp|#38);/g, val: "&" },
          // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
          // "apos" : { regex: /&(apos|#39);/g, val: "'" },
          cent: { regex: /&(cent|#162);/g, val: "\xA2" },
          pound: { regex: /&(pound|#163);/g, val: "\xA3" },
          yen: { regex: /&(yen|#165);/g, val: "\xA5" },
          euro: { regex: /&(euro|#8364);/g, val: "\u20AC" },
          copyright: { regex: /&(copy|#169);/g, val: "\xA9" },
          reg: { regex: /&(reg|#174);/g, val: "\xAE" },
          inr: { regex: /&(inr|#8377);/g, val: "\u20B9" },
          num_dec: {
            regex: /&#([0-9]{1,7});/g,
            val: (_2, str) => String.fromCharCode(Number.parseInt(str, 10)),
          },
          num_hex: {
            regex: /&#x([0-9a-fA-F]{1,6});/g,
            val: (_2, str) => String.fromCharCode(Number.parseInt(str, 16)),
          },
        };
        this.addExternalEntities = addExternalEntities;
        this.parseXml = parseXml;
        this.parseTextData = parseTextData;
        this.resolveNameSpace = resolveNameSpace;
        this.buildAttributesMap = buildAttributesMap;
        this.isItStopNode = isItStopNode;
        this.replaceEntitiesValue = replaceEntitiesValue;
        this.readStopNodeData = readStopNodeData;
        this.saveTextToParentTag = saveTextToParentTag;
        this.addChild = addChild;
        this.ignoreAttributesFn = getIgnoreAttributesFn(
          this.options.ignoreAttributes,
        );
      }
    };
    function addExternalEntities(externalEntities) {
      const entKeys = Object.keys(externalEntities);
      for (let i2 = 0; i2 < entKeys.length; i2++) {
        const ent = entKeys[i2];
        this.lastEntities[ent] = {
          regex: new RegExp("&" + ent + ";", "g"),
          val: externalEntities[ent],
        };
      }
    }
    function parseTextData(
      val,
      tagName,
      jPath,
      dontTrim,
      hasAttributes,
      isLeafNode,
      escapeEntities,
    ) {
      if (val !== void 0) {
        if (this.options.trimValues && !dontTrim) {
          val = val.trim();
        }
        if (val.length > 0) {
          if (!escapeEntities) val = this.replaceEntitiesValue(val);
          const newval = this.options.tagValueProcessor(
            tagName,
            val,
            jPath,
            hasAttributes,
            isLeafNode,
          );
          if (newval === null || newval === void 0) {
            return val;
          } else if (typeof newval !== typeof val || newval !== val) {
            return newval;
          } else if (this.options.trimValues) {
            return parseValue(
              val,
              this.options.parseTagValue,
              this.options.numberParseOptions,
            );
          } else {
            const trimmedVal = val.trim();
            if (trimmedVal === val) {
              return parseValue(
                val,
                this.options.parseTagValue,
                this.options.numberParseOptions,
              );
            } else {
              return val;
            }
          }
        }
      }
    }
    function resolveNameSpace(tagname) {
      if (this.options.removeNSPrefix) {
        const tags = tagname.split(":");
        const prefix = tagname.charAt(0) === "/" ? "/" : "";
        if (tags[0] === "xmlns") {
          return "";
        }
        if (tags.length === 2) {
          tagname = prefix + tags[1];
        }
      }
      return tagname;
    }
    var attrsRegx = new RegExp(
      `([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`,
      "gm",
    );
    function buildAttributesMap(attrStr, jPath, tagName) {
      if (
        this.options.ignoreAttributes !== true &&
        typeof attrStr === "string"
      ) {
        const matches = util2.getAllMatches(attrStr, attrsRegx);
        const len = matches.length;
        const attrs = {};
        for (let i2 = 0; i2 < len; i2++) {
          const attrName = this.resolveNameSpace(matches[i2][1]);
          if (this.ignoreAttributesFn(attrName, jPath)) {
            continue;
          }
          let oldVal = matches[i2][4];
          let aName = this.options.attributeNamePrefix + attrName;
          if (attrName.length) {
            if (this.options.transformAttributeName) {
              aName = this.options.transformAttributeName(aName);
            }
            if (aName === "__proto__") aName = "#__proto__";
            if (oldVal !== void 0) {
              if (this.options.trimValues) {
                oldVal = oldVal.trim();
              }
              oldVal = this.replaceEntitiesValue(oldVal);
              const newVal = this.options.attributeValueProcessor(
                attrName,
                oldVal,
                jPath,
              );
              if (newVal === null || newVal === void 0) {
                attrs[aName] = oldVal;
              } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
                attrs[aName] = newVal;
              } else {
                attrs[aName] = parseValue(
                  oldVal,
                  this.options.parseAttributeValue,
                  this.options.numberParseOptions,
                );
              }
            } else if (this.options.allowBooleanAttributes) {
              attrs[aName] = true;
            }
          }
        }
        if (!Object.keys(attrs).length) {
          return;
        }
        if (this.options.attributesGroupName) {
          const attrCollection = {};
          attrCollection[this.options.attributesGroupName] = attrs;
          return attrCollection;
        }
        return attrs;
      }
    }
    var parseXml = function (xmlData) {
      xmlData = xmlData.replace(/\r\n?/g, "\n");
      const xmlObj = new xmlNode("!xml");
      let currentNode = xmlObj;
      let textData = "";
      let jPath = "";
      for (let i2 = 0; i2 < xmlData.length; i2++) {
        const ch = xmlData[i2];
        if (ch === "<") {
          if (xmlData[i2 + 1] === "/") {
            const closeIndex = findClosingIndex(
              xmlData,
              ">",
              i2,
              "Closing Tag is not closed.",
            );
            let tagName = xmlData.substring(i2 + 2, closeIndex).trim();
            if (this.options.removeNSPrefix) {
              const colonIndex = tagName.indexOf(":");
              if (colonIndex !== -1) {
                tagName = tagName.substr(colonIndex + 1);
              }
            }
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            if (currentNode) {
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
            }
            const lastTagName = jPath.substring(jPath.lastIndexOf(".") + 1);
            if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {
              throw new Error(
                `Unpaired tag can not be used as closing tag: </${tagName}>`,
              );
            }
            let propIndex = 0;
            if (
              lastTagName &&
              this.options.unpairedTags.indexOf(lastTagName) !== -1
            ) {
              propIndex = jPath.lastIndexOf(".", jPath.lastIndexOf(".") - 1);
              this.tagsNodeStack.pop();
            } else {
              propIndex = jPath.lastIndexOf(".");
            }
            jPath = jPath.substring(0, propIndex);
            currentNode = this.tagsNodeStack.pop();
            textData = "";
            i2 = closeIndex;
          } else if (xmlData[i2 + 1] === "?") {
            let tagData = readTagExp(xmlData, i2, false, "?>");
            if (!tagData) throw new Error("Pi Tag is not closed.");
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            if (
              (this.options.ignoreDeclaration && tagData.tagName === "?xml") ||
              this.options.ignorePiTags
            ) {
            } else {
              const childNode = new xmlNode(tagData.tagName);
              childNode.add(this.options.textNodeName, "");
              if (
                tagData.tagName !== tagData.tagExp &&
                tagData.attrExpPresent
              ) {
                childNode[":@"] = this.buildAttributesMap(
                  tagData.tagExp,
                  jPath,
                  tagData.tagName,
                );
              }
              this.addChild(currentNode, childNode, jPath);
            }
            i2 = tagData.closeIndex + 1;
          } else if (xmlData.substr(i2 + 1, 3) === "!--") {
            const endIndex = findClosingIndex(
              xmlData,
              "-->",
              i2 + 4,
              "Comment is not closed.",
            );
            if (this.options.commentPropName) {
              const comment = xmlData.substring(i2 + 4, endIndex - 2);
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
              currentNode.add(this.options.commentPropName, [
                { [this.options.textNodeName]: comment },
              ]);
            }
            i2 = endIndex;
          } else if (xmlData.substr(i2 + 1, 2) === "!D") {
            const result = readDocType(xmlData, i2);
            this.docTypeEntities = result.entities;
            i2 = result.i;
          } else if (xmlData.substr(i2 + 1, 2) === "![") {
            const closeIndex =
              findClosingIndex(xmlData, "]]>", i2, "CDATA is not closed.") - 2;
            const tagExp = xmlData.substring(i2 + 9, closeIndex);
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            let val = this.parseTextData(
              tagExp,
              currentNode.tagname,
              jPath,
              true,
              false,
              true,
              true,
            );
            if (val == void 0) val = "";
            if (this.options.cdataPropName) {
              currentNode.add(this.options.cdataPropName, [
                { [this.options.textNodeName]: tagExp },
              ]);
            } else {
              currentNode.add(this.options.textNodeName, val);
            }
            i2 = closeIndex + 2;
          } else {
            let result = readTagExp(xmlData, i2, this.options.removeNSPrefix);
            let tagName = result.tagName;
            const rawTagName = result.rawTagName;
            let tagExp = result.tagExp;
            let attrExpPresent = result.attrExpPresent;
            let closeIndex = result.closeIndex;
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            if (currentNode && textData) {
              if (currentNode.tagname !== "!xml") {
                textData = this.saveTextToParentTag(
                  textData,
                  currentNode,
                  jPath,
                  false,
                );
              }
            }
            const lastTag = currentNode;
            if (
              lastTag &&
              this.options.unpairedTags.indexOf(lastTag.tagname) !== -1
            ) {
              currentNode = this.tagsNodeStack.pop();
              jPath = jPath.substring(0, jPath.lastIndexOf("."));
            }
            if (tagName !== xmlObj.tagname) {
              jPath += jPath ? "." + tagName : tagName;
            }
            if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
              let tagContent = "";
              if (
                tagExp.length > 0 &&
                tagExp.lastIndexOf("/") === tagExp.length - 1
              ) {
                if (tagName[tagName.length - 1] === "/") {
                  tagName = tagName.substr(0, tagName.length - 1);
                  jPath = jPath.substr(0, jPath.length - 1);
                  tagExp = tagName;
                } else {
                  tagExp = tagExp.substr(0, tagExp.length - 1);
                }
                i2 = result.closeIndex;
              } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
                i2 = result.closeIndex;
              } else {
                const result2 = this.readStopNodeData(
                  xmlData,
                  rawTagName,
                  closeIndex + 1,
                );
                if (!result2)
                  throw new Error(`Unexpected end of ${rawTagName}`);
                i2 = result2.i;
                tagContent = result2.tagContent;
              }
              const childNode = new xmlNode(tagName);
              if (tagName !== tagExp && attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(
                  tagExp,
                  jPath,
                  tagName,
                );
              }
              if (tagContent) {
                tagContent = this.parseTextData(
                  tagContent,
                  tagName,
                  jPath,
                  true,
                  attrExpPresent,
                  true,
                  true,
                );
              }
              jPath = jPath.substr(0, jPath.lastIndexOf("."));
              childNode.add(this.options.textNodeName, tagContent);
              this.addChild(currentNode, childNode, jPath);
            } else {
              if (
                tagExp.length > 0 &&
                tagExp.lastIndexOf("/") === tagExp.length - 1
              ) {
                if (tagName[tagName.length - 1] === "/") {
                  tagName = tagName.substr(0, tagName.length - 1);
                  jPath = jPath.substr(0, jPath.length - 1);
                  tagExp = tagName;
                } else {
                  tagExp = tagExp.substr(0, tagExp.length - 1);
                }
                if (this.options.transformTagName) {
                  tagName = this.options.transformTagName(tagName);
                }
                const childNode = new xmlNode(tagName);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(
                    tagExp,
                    jPath,
                    tagName,
                  );
                }
                this.addChild(currentNode, childNode, jPath);
                jPath = jPath.substr(0, jPath.lastIndexOf("."));
              } else {
                const childNode = new xmlNode(tagName);
                this.tagsNodeStack.push(currentNode);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(
                    tagExp,
                    jPath,
                    tagName,
                  );
                }
                this.addChild(currentNode, childNode, jPath);
                currentNode = childNode;
              }
              textData = "";
              i2 = closeIndex;
            }
          }
        } else {
          textData += xmlData[i2];
        }
      }
      return xmlObj.child;
    };
    function addChild(currentNode, childNode, jPath) {
      const result = this.options.updateTag(
        childNode.tagname,
        jPath,
        childNode[":@"],
      );
      if (result === false) {
      } else if (typeof result === "string") {
        childNode.tagname = result;
        currentNode.addChild(childNode);
      } else {
        currentNode.addChild(childNode);
      }
    }
    var replaceEntitiesValue = function (val) {
      if (this.options.processEntities) {
        for (let entityName in this.docTypeEntities) {
          const entity = this.docTypeEntities[entityName];
          val = val.replace(entity.regx, entity.val);
        }
        for (let entityName in this.lastEntities) {
          const entity = this.lastEntities[entityName];
          val = val.replace(entity.regex, entity.val);
        }
        if (this.options.htmlEntities) {
          for (let entityName in this.htmlEntities) {
            const entity = this.htmlEntities[entityName];
            val = val.replace(entity.regex, entity.val);
          }
        }
        val = val.replace(this.ampEntity.regex, this.ampEntity.val);
      }
      return val;
    };
    function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
      if (textData) {
        if (isLeafNode === void 0) isLeafNode = currentNode.child.length === 0;
        textData = this.parseTextData(
          textData,
          currentNode.tagname,
          jPath,
          false,
          currentNode[":@"]
            ? Object.keys(currentNode[":@"]).length !== 0
            : false,
          isLeafNode,
        );
        if (textData !== void 0 && textData !== "")
          currentNode.add(this.options.textNodeName, textData);
        textData = "";
      }
      return textData;
    }
    function isItStopNode(stopNodes, jPath, currentTagName) {
      const allNodesExp = "*." + currentTagName;
      for (const stopNodePath in stopNodes) {
        const stopNodeExp = stopNodes[stopNodePath];
        if (allNodesExp === stopNodeExp || jPath === stopNodeExp) return true;
      }
      return false;
    }
    function tagExpWithClosingIndex(xmlData, i2, closingChar = ">") {
      let attrBoundary;
      let tagExp = "";
      for (let index = i2; index < xmlData.length; index++) {
        let ch = xmlData[index];
        if (attrBoundary) {
          if (ch === attrBoundary) attrBoundary = "";
        } else if (ch === '"' || ch === "'") {
          attrBoundary = ch;
        } else if (ch === closingChar[0]) {
          if (closingChar[1]) {
            if (xmlData[index + 1] === closingChar[1]) {
              return {
                data: tagExp,
                index,
              };
            }
          } else {
            return {
              data: tagExp,
              index,
            };
          }
        } else if (ch === "	") {
          ch = " ";
        }
        tagExp += ch;
      }
    }
    function findClosingIndex(xmlData, str, i2, errMsg) {
      const closingIndex = xmlData.indexOf(str, i2);
      if (closingIndex === -1) {
        throw new Error(errMsg);
      } else {
        return closingIndex + str.length - 1;
      }
    }
    function readTagExp(xmlData, i2, removeNSPrefix, closingChar = ">") {
      const result = tagExpWithClosingIndex(xmlData, i2 + 1, closingChar);
      if (!result) return;
      let tagExp = result.data;
      const closeIndex = result.index;
      const separatorIndex = tagExp.search(/\s/);
      let tagName = tagExp;
      let attrExpPresent = true;
      if (separatorIndex !== -1) {
        tagName = tagExp.substring(0, separatorIndex);
        tagExp = tagExp.substring(separatorIndex + 1).trimStart();
      }
      const rawTagName = tagName;
      if (removeNSPrefix) {
        const colonIndex = tagName.indexOf(":");
        if (colonIndex !== -1) {
          tagName = tagName.substr(colonIndex + 1);
          attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
        }
      }
      return {
        tagName,
        tagExp,
        closeIndex,
        attrExpPresent,
        rawTagName,
      };
    }
    function readStopNodeData(xmlData, tagName, i2) {
      const startIndex = i2;
      let openTagCount = 1;
      for (; i2 < xmlData.length; i2++) {
        if (xmlData[i2] === "<") {
          if (xmlData[i2 + 1] === "/") {
            const closeIndex = findClosingIndex(
              xmlData,
              ">",
              i2,
              `${tagName} is not closed`,
            );
            let closeTagName = xmlData.substring(i2 + 2, closeIndex).trim();
            if (closeTagName === tagName) {
              openTagCount--;
              if (openTagCount === 0) {
                return {
                  tagContent: xmlData.substring(startIndex, i2),
                  i: closeIndex,
                };
              }
            }
            i2 = closeIndex;
          } else if (xmlData[i2 + 1] === "?") {
            const closeIndex = findClosingIndex(
              xmlData,
              "?>",
              i2 + 1,
              "StopNode is not closed.",
            );
            i2 = closeIndex;
          } else if (xmlData.substr(i2 + 1, 3) === "!--") {
            const closeIndex = findClosingIndex(
              xmlData,
              "-->",
              i2 + 3,
              "StopNode is not closed.",
            );
            i2 = closeIndex;
          } else if (xmlData.substr(i2 + 1, 2) === "![") {
            const closeIndex =
              findClosingIndex(xmlData, "]]>", i2, "StopNode is not closed.") -
              2;
            i2 = closeIndex;
          } else {
            const tagData = readTagExp(xmlData, i2, ">");
            if (tagData) {
              const openTagName = tagData && tagData.tagName;
              if (
                openTagName === tagName &&
                tagData.tagExp[tagData.tagExp.length - 1] !== "/"
              ) {
                openTagCount++;
              }
              i2 = tagData.closeIndex;
            }
          }
        }
      }
    }
    function parseValue(val, shouldParse, options) {
      if (shouldParse && typeof val === "string") {
        const newval = val.trim();
        if (newval === "true") return true;
        else if (newval === "false") return false;
        else return toNumber(val, options);
      } else {
        if (util2.isExist(val)) {
          return val;
        } else {
          return "";
        }
      }
    }
    module.exports = OrderedObjParser;
  },
});

// node_modules/fast-xml-parser/src/xmlparser/node2json.js
var require_node2json = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/node2json.js"(exports) {
    "use strict";
    function prettify(node, options) {
      return compress(node, options);
    }
    function compress(arr, options, jPath) {
      let text2;
      const compressedObj = {};
      for (let i2 = 0; i2 < arr.length; i2++) {
        const tagObj = arr[i2];
        const property = propName(tagObj);
        let newJpath = "";
        if (jPath === void 0) newJpath = property;
        else newJpath = jPath + "." + property;
        if (property === options.textNodeName) {
          if (text2 === void 0) text2 = tagObj[property];
          else text2 += "" + tagObj[property];
        } else if (property === void 0) {
          continue;
        } else if (tagObj[property]) {
          let val = compress(tagObj[property], options, newJpath);
          const isLeaf = isLeafTag(val, options);
          if (tagObj[":@"]) {
            assignAttributes(val, tagObj[":@"], newJpath, options);
          } else if (
            Object.keys(val).length === 1 &&
            val[options.textNodeName] !== void 0 &&
            !options.alwaysCreateTextNode
          ) {
            val = val[options.textNodeName];
          } else if (Object.keys(val).length === 0) {
            if (options.alwaysCreateTextNode) val[options.textNodeName] = "";
            else val = "";
          }
          if (
            compressedObj[property] !== void 0 &&
            compressedObj.hasOwnProperty(property)
          ) {
            if (!Array.isArray(compressedObj[property])) {
              compressedObj[property] = [compressedObj[property]];
            }
            compressedObj[property].push(val);
          } else {
            if (options.isArray(property, newJpath, isLeaf)) {
              compressedObj[property] = [val];
            } else {
              compressedObj[property] = val;
            }
          }
        }
      }
      if (typeof text2 === "string") {
        if (text2.length > 0) compressedObj[options.textNodeName] = text2;
      } else if (text2 !== void 0) compressedObj[options.textNodeName] = text2;
      return compressedObj;
    }
    function propName(obj) {
      const keys = Object.keys(obj);
      for (let i2 = 0; i2 < keys.length; i2++) {
        const key = keys[i2];
        if (key !== ":@") return key;
      }
    }
    function assignAttributes(obj, attrMap, jpath, options) {
      if (attrMap) {
        const keys = Object.keys(attrMap);
        const len = keys.length;
        for (let i2 = 0; i2 < len; i2++) {
          const atrrName = keys[i2];
          if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
            obj[atrrName] = [attrMap[atrrName]];
          } else {
            obj[atrrName] = attrMap[atrrName];
          }
        }
      }
    }
    function isLeafTag(obj, options) {
      const { textNodeName } = options;
      const propCount = Object.keys(obj).length;
      if (propCount === 0) {
        return true;
      }
      if (
        propCount === 1 &&
        (obj[textNodeName] ||
          typeof obj[textNodeName] === "boolean" ||
          obj[textNodeName] === 0)
      ) {
        return true;
      }
      return false;
    }
    exports.prettify = prettify;
  },
});

// node_modules/fast-xml-parser/src/xmlparser/XMLParser.js
var require_XMLParser = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/XMLParser.js"(exports, module) {
    var { buildOptions } = require_OptionsBuilder();
    var OrderedObjParser = require_OrderedObjParser();
    var { prettify } = require_node2json();
    var validator2 = require_validator();
    var XMLParser2 = class {
      constructor(options) {
        this.externalEntities = {};
        this.options = buildOptions(options);
      }
      /**
       * Parse XML dats to JS object
       * @param {string|Buffer} xmlData
       * @param {boolean|Object} validationOption
       */
      parse(xmlData, validationOption) {
        if (typeof xmlData === "string") {
        } else if (xmlData.toString) {
          xmlData = xmlData.toString();
        } else {
          throw new Error("XML data is accepted in String or Bytes[] form.");
        }
        if (validationOption) {
          if (validationOption === true) validationOption = {};
          const result = validator2.validate(xmlData, validationOption);
          if (result !== true) {
            throw Error(
              `${result.err.msg}:${result.err.line}:${result.err.col}`,
            );
          }
        }
        const orderedObjParser = new OrderedObjParser(this.options);
        orderedObjParser.addExternalEntities(this.externalEntities);
        const orderedResult = orderedObjParser.parseXml(xmlData);
        if (this.options.preserveOrder || orderedResult === void 0)
          return orderedResult;
        else return prettify(orderedResult, this.options);
      }
      /**
       * Add Entity which is not by default supported by this library
       * @param {string} key
       * @param {string} value
       */
      addEntity(key, value) {
        if (value.indexOf("&") !== -1) {
          throw new Error("Entity value can't have '&'");
        } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {
          throw new Error(
            "An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'",
          );
        } else if (value === "&") {
          throw new Error("An entity with value '&' is not permitted");
        } else {
          this.externalEntities[key] = value;
        }
      }
    };
    module.exports = XMLParser2;
  },
});

// node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js
var require_orderedJs2Xml = __commonJS({
  "node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js"(
    exports,
    module,
  ) {
    var EOL = "\n";
    function toXml(jArray, options) {
      let indentation = "";
      if (options.format && options.indentBy.length > 0) {
        indentation = EOL;
      }
      return arrToStr(jArray, options, "", indentation);
    }
    function arrToStr(arr, options, jPath, indentation) {
      let xmlStr = "";
      let isPreviousElementTag = false;
      for (let i2 = 0; i2 < arr.length; i2++) {
        const tagObj = arr[i2];
        const tagName = propName(tagObj);
        if (tagName === void 0) continue;
        let newJPath = "";
        if (jPath.length === 0) newJPath = tagName;
        else newJPath = `${jPath}.${tagName}`;
        if (tagName === options.textNodeName) {
          let tagText = tagObj[tagName];
          if (!isStopNode(newJPath, options)) {
            tagText = options.tagValueProcessor(tagName, tagText);
            tagText = replaceEntitiesValue(tagText, options);
          }
          if (isPreviousElementTag) {
            xmlStr += indentation;
          }
          xmlStr += tagText;
          isPreviousElementTag = false;
          continue;
        } else if (tagName === options.cdataPropName) {
          if (isPreviousElementTag) {
            xmlStr += indentation;
          }
          xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
          isPreviousElementTag = false;
          continue;
        } else if (tagName === options.commentPropName) {
          xmlStr +=
            indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
          isPreviousElementTag = true;
          continue;
        } else if (tagName[0] === "?") {
          const attStr2 = attr_to_str(tagObj[":@"], options);
          const tempInd = tagName === "?xml" ? "" : indentation;
          let piTextNodeName = tagObj[tagName][0][options.textNodeName];
          piTextNodeName =
            piTextNodeName.length !== 0 ? " " + piTextNodeName : "";
          xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr2}?>`;
          isPreviousElementTag = true;
          continue;
        }
        let newIdentation = indentation;
        if (newIdentation !== "") {
          newIdentation += options.indentBy;
        }
        const attStr = attr_to_str(tagObj[":@"], options);
        const tagStart = indentation + `<${tagName}${attStr}`;
        const tagValue = arrToStr(
          tagObj[tagName],
          options,
          newJPath,
          newIdentation,
        );
        if (options.unpairedTags.indexOf(tagName) !== -1) {
          if (options.suppressUnpairedNode) xmlStr += tagStart + ">";
          else xmlStr += tagStart + "/>";
        } else if (
          (!tagValue || tagValue.length === 0) &&
          options.suppressEmptyNode
        ) {
          xmlStr += tagStart + "/>";
        } else if (tagValue && tagValue.endsWith(">")) {
          xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
        } else {
          xmlStr += tagStart + ">";
          if (
            tagValue &&
            indentation !== "" &&
            (tagValue.includes("/>") || tagValue.includes("</"))
          ) {
            xmlStr += indentation + options.indentBy + tagValue + indentation;
          } else {
            xmlStr += tagValue;
          }
          xmlStr += `</${tagName}>`;
        }
        isPreviousElementTag = true;
      }
      return xmlStr;
    }
    function propName(obj) {
      const keys = Object.keys(obj);
      for (let i2 = 0; i2 < keys.length; i2++) {
        const key = keys[i2];
        if (!obj.hasOwnProperty(key)) continue;
        if (key !== ":@") return key;
      }
    }
    function attr_to_str(attrMap, options) {
      let attrStr = "";
      if (attrMap && !options.ignoreAttributes) {
        for (let attr in attrMap) {
          if (!attrMap.hasOwnProperty(attr)) continue;
          let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
          attrVal = replaceEntitiesValue(attrVal, options);
          if (attrVal === true && options.suppressBooleanAttributes) {
            attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
          } else {
            attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
          }
        }
      }
      return attrStr;
    }
    function isStopNode(jPath, options) {
      jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
      let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
      for (let index in options.stopNodes) {
        if (
          options.stopNodes[index] === jPath ||
          options.stopNodes[index] === "*." + tagName
        )
          return true;
      }
      return false;
    }
    function replaceEntitiesValue(textValue, options) {
      if (textValue && textValue.length > 0 && options.processEntities) {
        for (let i2 = 0; i2 < options.entities.length; i2++) {
          const entity = options.entities[i2];
          textValue = textValue.replace(entity.regex, entity.val);
        }
      }
      return textValue;
    }
    module.exports = toXml;
  },
});

// node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js
var require_json2xml = __commonJS({
  "node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js"(exports, module) {
    "use strict";
    var buildFromOrderedJs = require_orderedJs2Xml();
    var getIgnoreAttributesFn = require_ignoreAttributes();
    var defaultOptions3 = {
      attributeNamePrefix: "@_",
      attributesGroupName: false,
      textNodeName: "#text",
      ignoreAttributes: true,
      cdataPropName: false,
      format: false,
      indentBy: "  ",
      suppressEmptyNode: false,
      suppressUnpairedNode: true,
      suppressBooleanAttributes: true,
      tagValueProcessor: function (key, a2) {
        return a2;
      },
      attributeValueProcessor: function (attrName, a2) {
        return a2;
      },
      preserveOrder: false,
      commentPropName: false,
      unpairedTags: [],
      entities: [
        { regex: new RegExp("&", "g"), val: "&amp;" },
        //it must be on top
        { regex: new RegExp(">", "g"), val: "&gt;" },
        { regex: new RegExp("<", "g"), val: "&lt;" },
        { regex: new RegExp("'", "g"), val: "&apos;" },
        { regex: new RegExp('"', "g"), val: "&quot;" },
      ],
      processEntities: true,
      stopNodes: [],
      // transformTagName: false,
      // transformAttributeName: false,
      oneListGroup: false,
    };
    function Builder(options) {
      this.options = Object.assign({}, defaultOptions3, options);
      if (
        this.options.ignoreAttributes === true ||
        this.options.attributesGroupName
      ) {
        this.isAttribute = function () {
          return false;
        };
      } else {
        this.ignoreAttributesFn = getIgnoreAttributesFn(
          this.options.ignoreAttributes,
        );
        this.attrPrefixLen = this.options.attributeNamePrefix.length;
        this.isAttribute = isAttribute;
      }
      this.processTextOrObjNode = processTextOrObjNode;
      if (this.options.format) {
        this.indentate = indentate;
        this.tagEndChar = ">\n";
        this.newLine = "\n";
      } else {
        this.indentate = function () {
          return "";
        };
        this.tagEndChar = ">";
        this.newLine = "";
      }
    }
    Builder.prototype.build = function (jObj) {
      if (this.options.preserveOrder) {
        return buildFromOrderedJs(jObj, this.options);
      } else {
        if (
          Array.isArray(jObj) &&
          this.options.arrayNodeName &&
          this.options.arrayNodeName.length > 1
        ) {
          jObj = {
            [this.options.arrayNodeName]: jObj,
          };
        }
        return this.j2x(jObj, 0, []).val;
      }
    };
    Builder.prototype.j2x = function (jObj, level, ajPath) {
      let attrStr = "";
      let val = "";
      const jPath = ajPath.join(".");
      for (let key in jObj) {
        if (!Object.prototype.hasOwnProperty.call(jObj, key)) continue;
        if (typeof jObj[key] === "undefined") {
          if (this.isAttribute(key)) {
            val += "";
          }
        } else if (jObj[key] === null) {
          if (this.isAttribute(key)) {
            val += "";
          } else if (key === this.options.cdataPropName) {
            val += "";
          } else if (key[0] === "?") {
            val += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
          } else {
            val += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
          }
        } else if (jObj[key] instanceof Date) {
          val += this.buildTextValNode(jObj[key], key, "", level);
        } else if (typeof jObj[key] !== "object") {
          const attr = this.isAttribute(key);
          if (attr && !this.ignoreAttributesFn(attr, jPath)) {
            attrStr += this.buildAttrPairStr(attr, "" + jObj[key]);
          } else if (!attr) {
            if (key === this.options.textNodeName) {
              let newval = this.options.tagValueProcessor(key, "" + jObj[key]);
              val += this.replaceEntitiesValue(newval);
            } else {
              val += this.buildTextValNode(jObj[key], key, "", level);
            }
          }
        } else if (Array.isArray(jObj[key])) {
          const arrLen = jObj[key].length;
          let listTagVal = "";
          let listTagAttr = "";
          for (let j = 0; j < arrLen; j++) {
            const item = jObj[key][j];
            if (typeof item === "undefined") {
            } else if (item === null) {
              if (key[0] === "?")
                val +=
                  this.indentate(level) + "<" + key + "?" + this.tagEndChar;
              else
                val +=
                  this.indentate(level) + "<" + key + "/" + this.tagEndChar;
            } else if (typeof item === "object") {
              if (this.options.oneListGroup) {
                const result = this.j2x(item, level + 1, ajPath.concat(key));
                listTagVal += result.val;
                if (
                  this.options.attributesGroupName &&
                  item.hasOwnProperty(this.options.attributesGroupName)
                ) {
                  listTagAttr += result.attrStr;
                }
              } else {
                listTagVal += this.processTextOrObjNode(
                  item,
                  key,
                  level,
                  ajPath,
                );
              }
            } else {
              if (this.options.oneListGroup) {
                let textValue = this.options.tagValueProcessor(key, item);
                textValue = this.replaceEntitiesValue(textValue);
                listTagVal += textValue;
              } else {
                listTagVal += this.buildTextValNode(item, key, "", level);
              }
            }
          }
          if (this.options.oneListGroup) {
            listTagVal = this.buildObjectNode(
              listTagVal,
              key,
              listTagAttr,
              level,
            );
          }
          val += listTagVal;
        } else {
          if (
            this.options.attributesGroupName &&
            key === this.options.attributesGroupName
          ) {
            const Ks = Object.keys(jObj[key]);
            const L = Ks.length;
            for (let j = 0; j < L; j++) {
              attrStr += this.buildAttrPairStr(Ks[j], "" + jObj[key][Ks[j]]);
            }
          } else {
            val += this.processTextOrObjNode(jObj[key], key, level, ajPath);
          }
        }
      }
      return { attrStr, val };
    };
    Builder.prototype.buildAttrPairStr = function (attrName, val) {
      val = this.options.attributeValueProcessor(attrName, "" + val);
      val = this.replaceEntitiesValue(val);
      if (this.options.suppressBooleanAttributes && val === "true") {
        return " " + attrName;
      } else return " " + attrName + '="' + val + '"';
    };
    function processTextOrObjNode(object4, key, level, ajPath) {
      const result = this.j2x(object4, level + 1, ajPath.concat(key));
      if (
        object4[this.options.textNodeName] !== void 0 &&
        Object.keys(object4).length === 1
      ) {
        return this.buildTextValNode(
          object4[this.options.textNodeName],
          key,
          result.attrStr,
          level,
        );
      } else {
        return this.buildObjectNode(result.val, key, result.attrStr, level);
      }
    }
    Builder.prototype.buildObjectNode = function (val, key, attrStr, level) {
      if (val === "") {
        if (key[0] === "?")
          return (
            this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar
          );
        else {
          return (
            this.indentate(level) +
            "<" +
            key +
            attrStr +
            this.closeTag(key) +
            this.tagEndChar
          );
        }
      } else {
        let tagEndExp = "</" + key + this.tagEndChar;
        let piClosingChar = "";
        if (key[0] === "?") {
          piClosingChar = "?";
          tagEndExp = "";
        }
        if ((attrStr || attrStr === "") && val.indexOf("<") === -1) {
          return (
            this.indentate(level) +
            "<" +
            key +
            attrStr +
            piClosingChar +
            ">" +
            val +
            tagEndExp
          );
        } else if (
          this.options.commentPropName !== false &&
          key === this.options.commentPropName &&
          piClosingChar.length === 0
        ) {
          return this.indentate(level) + `<!--${val}-->` + this.newLine;
        } else {
          return (
            this.indentate(level) +
            "<" +
            key +
            attrStr +
            piClosingChar +
            this.tagEndChar +
            val +
            this.indentate(level) +
            tagEndExp
          );
        }
      }
    };
    Builder.prototype.closeTag = function (key) {
      let closeTag = "";
      if (this.options.unpairedTags.indexOf(key) !== -1) {
        if (!this.options.suppressUnpairedNode) closeTag = "/";
      } else if (this.options.suppressEmptyNode) {
        closeTag = "/";
      } else {
        closeTag = `></${key}`;
      }
      return closeTag;
    };
    Builder.prototype.buildTextValNode = function (val, key, attrStr, level) {
      if (
        this.options.cdataPropName !== false &&
        key === this.options.cdataPropName
      ) {
        return this.indentate(level) + `<![CDATA[${val}]]>` + this.newLine;
      } else if (
        this.options.commentPropName !== false &&
        key === this.options.commentPropName
      ) {
        return this.indentate(level) + `<!--${val}-->` + this.newLine;
      } else if (key[0] === "?") {
        return (
          this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar
        );
      } else {
        let textValue = this.options.tagValueProcessor(key, val);
        textValue = this.replaceEntitiesValue(textValue);
        if (textValue === "") {
          return (
            this.indentate(level) +
            "<" +
            key +
            attrStr +
            this.closeTag(key) +
            this.tagEndChar
          );
        } else {
          return (
            this.indentate(level) +
            "<" +
            key +
            attrStr +
            ">" +
            textValue +
            "</" +
            key +
            this.tagEndChar
          );
        }
      }
    };
    Builder.prototype.replaceEntitiesValue = function (textValue) {
      if (textValue && textValue.length > 0 && this.options.processEntities) {
        for (let i2 = 0; i2 < this.options.entities.length; i2++) {
          const entity = this.options.entities[i2];
          textValue = textValue.replace(entity.regex, entity.val);
        }
      }
      return textValue;
    };
    function indentate(level) {
      return this.options.indentBy.repeat(level);
    }
    function isAttribute(name18) {
      if (
        name18.startsWith(this.options.attributeNamePrefix) &&
        name18 !== this.options.textNodeName
      ) {
        return name18.substr(this.attrPrefixLen);
      } else {
        return false;
      }
    }
    module.exports = Builder;
  },
});

// node_modules/fast-xml-parser/src/fxp.js
var require_fxp = __commonJS({
  "node_modules/fast-xml-parser/src/fxp.js"(exports, module) {
    "use strict";
    var validator2 = require_validator();
    var XMLParser2 = require_XMLParser();
    var XMLBuilder = require_json2xml();
    module.exports = {
      XMLParser: XMLParser2,
      XMLValidator: validator2,
      XMLBuilder,
    };
  },
});

// node_modules/he/he.js
var require_he = __commonJS({
  "node_modules/he/he.js"(exports, module) {
    (function (root) {
      var freeExports = typeof exports == "object" && exports;
      var freeModule =
        typeof module == "object" &&
        module &&
        module.exports == freeExports &&
        module;
      var freeGlobal = typeof global == "object" && global;
      if (
        freeGlobal.global === freeGlobal ||
        freeGlobal.window === freeGlobal
      ) {
        root = freeGlobal;
      }
      var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
      var regexAsciiWhitelist = /[\x01-\x7F]/g;
      var regexBmpWhitelist =
        /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;
      var regexEncodeNonAscii =
        /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g;
      var encodeMap = {
        "\xAD": "shy",
        "\u200C": "zwnj",
        "\u200D": "zwj",
        "\u200E": "lrm",
        "\u2063": "ic",
        "\u2062": "it",
        "\u2061": "af",
        "\u200F": "rlm",
        "\u200B": "ZeroWidthSpace",
        "\u2060": "NoBreak",
        "\u0311": "DownBreve",
        "\u20DB": "tdot",
        "\u20DC": "DotDot",
        "	": "Tab",
        "\n": "NewLine",
        "\u2008": "puncsp",
        "\u205F": "MediumSpace",
        "\u2009": "thinsp",
        "\u200A": "hairsp",
        "\u2004": "emsp13",
        "\u2002": "ensp",
        "\u2005": "emsp14",
        "\u2003": "emsp",
        "\u2007": "numsp",
        "\xA0": "nbsp",
        "\u205F\u200A": "ThickSpace",
        "\u203E": "oline",
        _: "lowbar",
        "\u2010": "dash",
        "\u2013": "ndash",
        "\u2014": "mdash",
        "\u2015": "horbar",
        ",": "comma",
        ";": "semi",
        "\u204F": "bsemi",
        ":": "colon",
        "\u2A74": "Colone",
        "!": "excl",
        "\xA1": "iexcl",
        "?": "quest",
        "\xBF": "iquest",
        ".": "period",
        "\u2025": "nldr",
        "\u2026": "mldr",
        "\xB7": "middot",
        "'": "apos",
        "\u2018": "lsquo",
        "\u2019": "rsquo",
        "\u201A": "sbquo",
        "\u2039": "lsaquo",
        "\u203A": "rsaquo",
        '"': "quot",
        "\u201C": "ldquo",
        "\u201D": "rdquo",
        "\u201E": "bdquo",
        "\xAB": "laquo",
        "\xBB": "raquo",
        "(": "lpar",
        ")": "rpar",
        "[": "lsqb",
        "]": "rsqb",
        "{": "lcub",
        "}": "rcub",
        "\u2308": "lceil",
        "\u2309": "rceil",
        "\u230A": "lfloor",
        "\u230B": "rfloor",
        "\u2985": "lopar",
        "\u2986": "ropar",
        "\u298B": "lbrke",
        "\u298C": "rbrke",
        "\u298D": "lbrkslu",
        "\u298E": "rbrksld",
        "\u298F": "lbrksld",
        "\u2990": "rbrkslu",
        "\u2991": "langd",
        "\u2992": "rangd",
        "\u2993": "lparlt",
        "\u2994": "rpargt",
        "\u2995": "gtlPar",
        "\u2996": "ltrPar",
        "\u27E6": "lobrk",
        "\u27E7": "robrk",
        "\u27E8": "lang",
        "\u27E9": "rang",
        "\u27EA": "Lang",
        "\u27EB": "Rang",
        "\u27EC": "loang",
        "\u27ED": "roang",
        "\u2772": "lbbrk",
        "\u2773": "rbbrk",
        "\u2016": "Vert",
        "\xA7": "sect",
        "\xB6": "para",
        "@": "commat",
        "*": "ast",
        "/": "sol",
        undefined: null,
        "&": "amp",
        "#": "num",
        "%": "percnt",
        "\u2030": "permil",
        "\u2031": "pertenk",
        "\u2020": "dagger",
        "\u2021": "Dagger",
        "\u2022": "bull",
        "\u2043": "hybull",
        "\u2032": "prime",
        "\u2033": "Prime",
        "\u2034": "tprime",
        "\u2057": "qprime",
        "\u2035": "bprime",
        "\u2041": "caret",
        "`": "grave",
        "\xB4": "acute",
        "\u02DC": "tilde",
        "^": "Hat",
        "\xAF": "macr",
        "\u02D8": "breve",
        "\u02D9": "dot",
        "\xA8": "die",
        "\u02DA": "ring",
        "\u02DD": "dblac",
        "\xB8": "cedil",
        "\u02DB": "ogon",
        "\u02C6": "circ",
        "\u02C7": "caron",
        "\xB0": "deg",
        "\xA9": "copy",
        "\xAE": "reg",
        "\u2117": "copysr",
        "\u2118": "wp",
        "\u211E": "rx",
        "\u2127": "mho",
        "\u2129": "iiota",
        "\u2190": "larr",
        "\u219A": "nlarr",
        "\u2192": "rarr",
        "\u219B": "nrarr",
        "\u2191": "uarr",
        "\u2193": "darr",
        "\u2194": "harr",
        "\u21AE": "nharr",
        "\u2195": "varr",
        "\u2196": "nwarr",
        "\u2197": "nearr",
        "\u2198": "searr",
        "\u2199": "swarr",
        "\u219D": "rarrw",
        "\u219D\u0338": "nrarrw",
        "\u219E": "Larr",
        "\u219F": "Uarr",
        "\u21A0": "Rarr",
        "\u21A1": "Darr",
        "\u21A2": "larrtl",
        "\u21A3": "rarrtl",
        "\u21A4": "mapstoleft",
        "\u21A5": "mapstoup",
        "\u21A6": "map",
        "\u21A7": "mapstodown",
        "\u21A9": "larrhk",
        "\u21AA": "rarrhk",
        "\u21AB": "larrlp",
        "\u21AC": "rarrlp",
        "\u21AD": "harrw",
        "\u21B0": "lsh",
        "\u21B1": "rsh",
        "\u21B2": "ldsh",
        "\u21B3": "rdsh",
        "\u21B5": "crarr",
        "\u21B6": "cularr",
        "\u21B7": "curarr",
        "\u21BA": "olarr",
        "\u21BB": "orarr",
        "\u21BC": "lharu",
        "\u21BD": "lhard",
        "\u21BE": "uharr",
        "\u21BF": "uharl",
        "\u21C0": "rharu",
        "\u21C1": "rhard",
        "\u21C2": "dharr",
        "\u21C3": "dharl",
        "\u21C4": "rlarr",
        "\u21C5": "udarr",
        "\u21C6": "lrarr",
        "\u21C7": "llarr",
        "\u21C8": "uuarr",
        "\u21C9": "rrarr",
        "\u21CA": "ddarr",
        "\u21CB": "lrhar",
        "\u21CC": "rlhar",
        "\u21D0": "lArr",
        "\u21CD": "nlArr",
        "\u21D1": "uArr",
        "\u21D2": "rArr",
        "\u21CF": "nrArr",
        "\u21D3": "dArr",
        "\u21D4": "iff",
        "\u21CE": "nhArr",
        "\u21D5": "vArr",
        "\u21D6": "nwArr",
        "\u21D7": "neArr",
        "\u21D8": "seArr",
        "\u21D9": "swArr",
        "\u21DA": "lAarr",
        "\u21DB": "rAarr",
        "\u21DD": "zigrarr",
        "\u21E4": "larrb",
        "\u21E5": "rarrb",
        "\u21F5": "duarr",
        "\u21FD": "loarr",
        "\u21FE": "roarr",
        "\u21FF": "hoarr",
        "\u2200": "forall",
        "\u2201": "comp",
        "\u2202": "part",
        "\u2202\u0338": "npart",
        "\u2203": "exist",
        "\u2204": "nexist",
        "\u2205": "empty",
        "\u2207": "Del",
        "\u2208": "in",
        "\u2209": "notin",
        "\u220B": "ni",
        "\u220C": "notni",
        "\u03F6": "bepsi",
        "\u220F": "prod",
        "\u2210": "coprod",
        "\u2211": "sum",
        "+": "plus",
        "\xB1": "pm",
        "\xF7": "div",
        "\xD7": "times",
        "<": "lt",
        "\u226E": "nlt",
        "<\u20D2": "nvlt",
        "=": "equals",
        "\u2260": "ne",
        "=\u20E5": "bne",
        "\u2A75": "Equal",
        ">": "gt",
        "\u226F": "ngt",
        ">\u20D2": "nvgt",
        "\xAC": "not",
        "|": "vert",
        "\xA6": "brvbar",
        "\u2212": "minus",
        "\u2213": "mp",
        "\u2214": "plusdo",
        "\u2044": "frasl",
        "\u2216": "setmn",
        "\u2217": "lowast",
        "\u2218": "compfn",
        "\u221A": "Sqrt",
        "\u221D": "prop",
        "\u221E": "infin",
        "\u221F": "angrt",
        "\u2220": "ang",
        "\u2220\u20D2": "nang",
        "\u2221": "angmsd",
        "\u2222": "angsph",
        "\u2223": "mid",
        "\u2224": "nmid",
        "\u2225": "par",
        "\u2226": "npar",
        "\u2227": "and",
        "\u2228": "or",
        "\u2229": "cap",
        "\u2229\uFE00": "caps",
        "\u222A": "cup",
        "\u222A\uFE00": "cups",
        "\u222B": "int",
        "\u222C": "Int",
        "\u222D": "tint",
        "\u2A0C": "qint",
        "\u222E": "oint",
        "\u222F": "Conint",
        "\u2230": "Cconint",
        "\u2231": "cwint",
        "\u2232": "cwconint",
        "\u2233": "awconint",
        "\u2234": "there4",
        "\u2235": "becaus",
        "\u2236": "ratio",
        "\u2237": "Colon",
        "\u2238": "minusd",
        "\u223A": "mDDot",
        "\u223B": "homtht",
        "\u223C": "sim",
        "\u2241": "nsim",
        "\u223C\u20D2": "nvsim",
        "\u223D": "bsim",
        "\u223D\u0331": "race",
        "\u223E": "ac",
        "\u223E\u0333": "acE",
        "\u223F": "acd",
        "\u2240": "wr",
        "\u2242": "esim",
        "\u2242\u0338": "nesim",
        "\u2243": "sime",
        "\u2244": "nsime",
        "\u2245": "cong",
        "\u2247": "ncong",
        "\u2246": "simne",
        "\u2248": "ap",
        "\u2249": "nap",
        "\u224A": "ape",
        "\u224B": "apid",
        "\u224B\u0338": "napid",
        "\u224C": "bcong",
        "\u224D": "CupCap",
        "\u226D": "NotCupCap",
        "\u224D\u20D2": "nvap",
        "\u224E": "bump",
        "\u224E\u0338": "nbump",
        "\u224F": "bumpe",
        "\u224F\u0338": "nbumpe",
        "\u2250": "doteq",
        "\u2250\u0338": "nedot",
        "\u2251": "eDot",
        "\u2252": "efDot",
        "\u2253": "erDot",
        "\u2254": "colone",
        "\u2255": "ecolon",
        "\u2256": "ecir",
        "\u2257": "cire",
        "\u2259": "wedgeq",
        "\u225A": "veeeq",
        "\u225C": "trie",
        "\u225F": "equest",
        "\u2261": "equiv",
        "\u2262": "nequiv",
        "\u2261\u20E5": "bnequiv",
        "\u2264": "le",
        "\u2270": "nle",
        "\u2264\u20D2": "nvle",
        "\u2265": "ge",
        "\u2271": "nge",
        "\u2265\u20D2": "nvge",
        "\u2266": "lE",
        "\u2266\u0338": "nlE",
        "\u2267": "gE",
        "\u2267\u0338": "ngE",
        "\u2268\uFE00": "lvnE",
        "\u2268": "lnE",
        "\u2269": "gnE",
        "\u2269\uFE00": "gvnE",
        "\u226A": "ll",
        "\u226A\u0338": "nLtv",
        "\u226A\u20D2": "nLt",
        "\u226B": "gg",
        "\u226B\u0338": "nGtv",
        "\u226B\u20D2": "nGt",
        "\u226C": "twixt",
        "\u2272": "lsim",
        "\u2274": "nlsim",
        "\u2273": "gsim",
        "\u2275": "ngsim",
        "\u2276": "lg",
        "\u2278": "ntlg",
        "\u2277": "gl",
        "\u2279": "ntgl",
        "\u227A": "pr",
        "\u2280": "npr",
        "\u227B": "sc",
        "\u2281": "nsc",
        "\u227C": "prcue",
        "\u22E0": "nprcue",
        "\u227D": "sccue",
        "\u22E1": "nsccue",
        "\u227E": "prsim",
        "\u227F": "scsim",
        "\u227F\u0338": "NotSucceedsTilde",
        "\u2282": "sub",
        "\u2284": "nsub",
        "\u2282\u20D2": "vnsub",
        "\u2283": "sup",
        "\u2285": "nsup",
        "\u2283\u20D2": "vnsup",
        "\u2286": "sube",
        "\u2288": "nsube",
        "\u2287": "supe",
        "\u2289": "nsupe",
        "\u228A\uFE00": "vsubne",
        "\u228A": "subne",
        "\u228B\uFE00": "vsupne",
        "\u228B": "supne",
        "\u228D": "cupdot",
        "\u228E": "uplus",
        "\u228F": "sqsub",
        "\u228F\u0338": "NotSquareSubset",
        "\u2290": "sqsup",
        "\u2290\u0338": "NotSquareSuperset",
        "\u2291": "sqsube",
        "\u22E2": "nsqsube",
        "\u2292": "sqsupe",
        "\u22E3": "nsqsupe",
        "\u2293": "sqcap",
        "\u2293\uFE00": "sqcaps",
        "\u2294": "sqcup",
        "\u2294\uFE00": "sqcups",
        "\u2295": "oplus",
        "\u2296": "ominus",
        "\u2297": "otimes",
        "\u2298": "osol",
        "\u2299": "odot",
        "\u229A": "ocir",
        "\u229B": "oast",
        "\u229D": "odash",
        "\u229E": "plusb",
        "\u229F": "minusb",
        "\u22A0": "timesb",
        "\u22A1": "sdotb",
        "\u22A2": "vdash",
        "\u22AC": "nvdash",
        "\u22A3": "dashv",
        "\u22A4": "top",
        "\u22A5": "bot",
        "\u22A7": "models",
        "\u22A8": "vDash",
        "\u22AD": "nvDash",
        "\u22A9": "Vdash",
        "\u22AE": "nVdash",
        "\u22AA": "Vvdash",
        "\u22AB": "VDash",
        "\u22AF": "nVDash",
        "\u22B0": "prurel",
        "\u22B2": "vltri",
        "\u22EA": "nltri",
        "\u22B3": "vrtri",
        "\u22EB": "nrtri",
        "\u22B4": "ltrie",
        "\u22EC": "nltrie",
        "\u22B4\u20D2": "nvltrie",
        "\u22B5": "rtrie",
        "\u22ED": "nrtrie",
        "\u22B5\u20D2": "nvrtrie",
        "\u22B6": "origof",
        "\u22B7": "imof",
        "\u22B8": "mumap",
        "\u22B9": "hercon",
        "\u22BA": "intcal",
        "\u22BB": "veebar",
        "\u22BD": "barvee",
        "\u22BE": "angrtvb",
        "\u22BF": "lrtri",
        "\u22C0": "Wedge",
        "\u22C1": "Vee",
        "\u22C2": "xcap",
        "\u22C3": "xcup",
        "\u22C4": "diam",
        "\u22C5": "sdot",
        "\u22C6": "Star",
        "\u22C7": "divonx",
        "\u22C8": "bowtie",
        "\u22C9": "ltimes",
        "\u22CA": "rtimes",
        "\u22CB": "lthree",
        "\u22CC": "rthree",
        "\u22CD": "bsime",
        "\u22CE": "cuvee",
        "\u22CF": "cuwed",
        "\u22D0": "Sub",
        "\u22D1": "Sup",
        "\u22D2": "Cap",
        "\u22D3": "Cup",
        "\u22D4": "fork",
        "\u22D5": "epar",
        "\u22D6": "ltdot",
        "\u22D7": "gtdot",
        "\u22D8": "Ll",
        "\u22D8\u0338": "nLl",
        "\u22D9": "Gg",
        "\u22D9\u0338": "nGg",
        "\u22DA\uFE00": "lesg",
        "\u22DA": "leg",
        "\u22DB": "gel",
        "\u22DB\uFE00": "gesl",
        "\u22DE": "cuepr",
        "\u22DF": "cuesc",
        "\u22E6": "lnsim",
        "\u22E7": "gnsim",
        "\u22E8": "prnsim",
        "\u22E9": "scnsim",
        "\u22EE": "vellip",
        "\u22EF": "ctdot",
        "\u22F0": "utdot",
        "\u22F1": "dtdot",
        "\u22F2": "disin",
        "\u22F3": "isinsv",
        "\u22F4": "isins",
        "\u22F5": "isindot",
        "\u22F5\u0338": "notindot",
        "\u22F6": "notinvc",
        "\u22F7": "notinvb",
        "\u22F9": "isinE",
        "\u22F9\u0338": "notinE",
        "\u22FA": "nisd",
        "\u22FB": "xnis",
        "\u22FC": "nis",
        "\u22FD": "notnivc",
        "\u22FE": "notnivb",
        "\u2305": "barwed",
        "\u2306": "Barwed",
        "\u230C": "drcrop",
        "\u230D": "dlcrop",
        "\u230E": "urcrop",
        "\u230F": "ulcrop",
        "\u2310": "bnot",
        "\u2312": "profline",
        "\u2313": "profsurf",
        "\u2315": "telrec",
        "\u2316": "target",
        "\u231C": "ulcorn",
        "\u231D": "urcorn",
        "\u231E": "dlcorn",
        "\u231F": "drcorn",
        "\u2322": "frown",
        "\u2323": "smile",
        "\u232D": "cylcty",
        "\u232E": "profalar",
        "\u2336": "topbot",
        "\u233D": "ovbar",
        "\u233F": "solbar",
        "\u237C": "angzarr",
        "\u23B0": "lmoust",
        "\u23B1": "rmoust",
        "\u23B4": "tbrk",
        "\u23B5": "bbrk",
        "\u23B6": "bbrktbrk",
        "\u23DC": "OverParenthesis",
        "\u23DD": "UnderParenthesis",
        "\u23DE": "OverBrace",
        "\u23DF": "UnderBrace",
        "\u23E2": "trpezium",
        "\u23E7": "elinters",
        "\u2423": "blank",
        "\u2500": "boxh",
        "\u2502": "boxv",
        "\u250C": "boxdr",
        "\u2510": "boxdl",
        "\u2514": "boxur",
        "\u2518": "boxul",
        "\u251C": "boxvr",
        "\u2524": "boxvl",
        "\u252C": "boxhd",
        "\u2534": "boxhu",
        "\u253C": "boxvh",
        "\u2550": "boxH",
        "\u2551": "boxV",
        "\u2552": "boxdR",
        "\u2553": "boxDr",
        "\u2554": "boxDR",
        "\u2555": "boxdL",
        "\u2556": "boxDl",
        "\u2557": "boxDL",
        "\u2558": "boxuR",
        "\u2559": "boxUr",
        "\u255A": "boxUR",
        "\u255B": "boxuL",
        "\u255C": "boxUl",
        "\u255D": "boxUL",
        "\u255E": "boxvR",
        "\u255F": "boxVr",
        "\u2560": "boxVR",
        "\u2561": "boxvL",
        "\u2562": "boxVl",
        "\u2563": "boxVL",
        "\u2564": "boxHd",
        "\u2565": "boxhD",
        "\u2566": "boxHD",
        "\u2567": "boxHu",
        "\u2568": "boxhU",
        "\u2569": "boxHU",
        "\u256A": "boxvH",
        "\u256B": "boxVh",
        "\u256C": "boxVH",
        "\u2580": "uhblk",
        "\u2584": "lhblk",
        "\u2588": "block",
        "\u2591": "blk14",
        "\u2592": "blk12",
        "\u2593": "blk34",
        "\u25A1": "squ",
        "\u25AA": "squf",
        "\u25AB": "EmptyVerySmallSquare",
        "\u25AD": "rect",
        "\u25AE": "marker",
        "\u25B1": "fltns",
        "\u25B3": "xutri",
        "\u25B4": "utrif",
        "\u25B5": "utri",
        "\u25B8": "rtrif",
        "\u25B9": "rtri",
        "\u25BD": "xdtri",
        "\u25BE": "dtrif",
        "\u25BF": "dtri",
        "\u25C2": "ltrif",
        "\u25C3": "ltri",
        "\u25CA": "loz",
        "\u25CB": "cir",
        "\u25EC": "tridot",
        "\u25EF": "xcirc",
        "\u25F8": "ultri",
        "\u25F9": "urtri",
        "\u25FA": "lltri",
        "\u25FB": "EmptySmallSquare",
        "\u25FC": "FilledSmallSquare",
        "\u2605": "starf",
        "\u2606": "star",
        "\u260E": "phone",
        "\u2640": "female",
        "\u2642": "male",
        "\u2660": "spades",
        "\u2663": "clubs",
        "\u2665": "hearts",
        "\u2666": "diams",
        "\u266A": "sung",
        "\u2713": "check",
        "\u2717": "cross",
        "\u2720": "malt",
        "\u2736": "sext",
        "\u2758": "VerticalSeparator",
        "\u27C8": "bsolhsub",
        "\u27C9": "suphsol",
        "\u27F5": "xlarr",
        "\u27F6": "xrarr",
        "\u27F7": "xharr",
        "\u27F8": "xlArr",
        "\u27F9": "xrArr",
        "\u27FA": "xhArr",
        "\u27FC": "xmap",
        "\u27FF": "dzigrarr",
        "\u2902": "nvlArr",
        "\u2903": "nvrArr",
        "\u2904": "nvHarr",
        "\u2905": "Map",
        "\u290C": "lbarr",
        "\u290D": "rbarr",
        "\u290E": "lBarr",
        "\u290F": "rBarr",
        "\u2910": "RBarr",
        "\u2911": "DDotrahd",
        "\u2912": "UpArrowBar",
        "\u2913": "DownArrowBar",
        "\u2916": "Rarrtl",
        "\u2919": "latail",
        "\u291A": "ratail",
        "\u291B": "lAtail",
        "\u291C": "rAtail",
        "\u291D": "larrfs",
        "\u291E": "rarrfs",
        "\u291F": "larrbfs",
        "\u2920": "rarrbfs",
        "\u2923": "nwarhk",
        "\u2924": "nearhk",
        "\u2925": "searhk",
        "\u2926": "swarhk",
        "\u2927": "nwnear",
        "\u2928": "toea",
        "\u2929": "tosa",
        "\u292A": "swnwar",
        "\u2933": "rarrc",
        "\u2933\u0338": "nrarrc",
        "\u2935": "cudarrr",
        "\u2936": "ldca",
        "\u2937": "rdca",
        "\u2938": "cudarrl",
        "\u2939": "larrpl",
        "\u293C": "curarrm",
        "\u293D": "cularrp",
        "\u2945": "rarrpl",
        "\u2948": "harrcir",
        "\u2949": "Uarrocir",
        "\u294A": "lurdshar",
        "\u294B": "ldrushar",
        "\u294E": "LeftRightVector",
        "\u294F": "RightUpDownVector",
        "\u2950": "DownLeftRightVector",
        "\u2951": "LeftUpDownVector",
        "\u2952": "LeftVectorBar",
        "\u2953": "RightVectorBar",
        "\u2954": "RightUpVectorBar",
        "\u2955": "RightDownVectorBar",
        "\u2956": "DownLeftVectorBar",
        "\u2957": "DownRightVectorBar",
        "\u2958": "LeftUpVectorBar",
        "\u2959": "LeftDownVectorBar",
        "\u295A": "LeftTeeVector",
        "\u295B": "RightTeeVector",
        "\u295C": "RightUpTeeVector",
        "\u295D": "RightDownTeeVector",
        "\u295E": "DownLeftTeeVector",
        "\u295F": "DownRightTeeVector",
        "\u2960": "LeftUpTeeVector",
        "\u2961": "LeftDownTeeVector",
        "\u2962": "lHar",
        "\u2963": "uHar",
        "\u2964": "rHar",
        "\u2965": "dHar",
        "\u2966": "luruhar",
        "\u2967": "ldrdhar",
        "\u2968": "ruluhar",
        "\u2969": "rdldhar",
        "\u296A": "lharul",
        "\u296B": "llhard",
        "\u296C": "rharul",
        "\u296D": "lrhard",
        "\u296E": "udhar",
        "\u296F": "duhar",
        "\u2970": "RoundImplies",
        "\u2971": "erarr",
        "\u2972": "simrarr",
        "\u2973": "larrsim",
        "\u2974": "rarrsim",
        "\u2975": "rarrap",
        "\u2976": "ltlarr",
        "\u2978": "gtrarr",
        "\u2979": "subrarr",
        "\u297B": "suplarr",
        "\u297C": "lfisht",
        "\u297D": "rfisht",
        "\u297E": "ufisht",
        "\u297F": "dfisht",
        "\u299A": "vzigzag",
        "\u299C": "vangrt",
        "\u299D": "angrtvbd",
        "\u29A4": "ange",
        "\u29A5": "range",
        "\u29A6": "dwangle",
        "\u29A7": "uwangle",
        "\u29A8": "angmsdaa",
        "\u29A9": "angmsdab",
        "\u29AA": "angmsdac",
        "\u29AB": "angmsdad",
        "\u29AC": "angmsdae",
        "\u29AD": "angmsdaf",
        "\u29AE": "angmsdag",
        "\u29AF": "angmsdah",
        "\u29B0": "bemptyv",
        "\u29B1": "demptyv",
        "\u29B2": "cemptyv",
        "\u29B3": "raemptyv",
        "\u29B4": "laemptyv",
        "\u29B5": "ohbar",
        "\u29B6": "omid",
        "\u29B7": "opar",
        "\u29B9": "operp",
        "\u29BB": "olcross",
        "\u29BC": "odsold",
        "\u29BE": "olcir",
        "\u29BF": "ofcir",
        "\u29C0": "olt",
        "\u29C1": "ogt",
        "\u29C2": "cirscir",
        "\u29C3": "cirE",
        "\u29C4": "solb",
        "\u29C5": "bsolb",
        "\u29C9": "boxbox",
        "\u29CD": "trisb",
        "\u29CE": "rtriltri",
        "\u29CF": "LeftTriangleBar",
        "\u29CF\u0338": "NotLeftTriangleBar",
        "\u29D0": "RightTriangleBar",
        "\u29D0\u0338": "NotRightTriangleBar",
        "\u29DC": "iinfin",
        "\u29DD": "infintie",
        "\u29DE": "nvinfin",
        "\u29E3": "eparsl",
        "\u29E4": "smeparsl",
        "\u29E5": "eqvparsl",
        "\u29EB": "lozf",
        "\u29F4": "RuleDelayed",
        "\u29F6": "dsol",
        "\u2A00": "xodot",
        "\u2A01": "xoplus",
        "\u2A02": "xotime",
        "\u2A04": "xuplus",
        "\u2A06": "xsqcup",
        "\u2A0D": "fpartint",
        "\u2A10": "cirfnint",
        "\u2A11": "awint",
        "\u2A12": "rppolint",
        "\u2A13": "scpolint",
        "\u2A14": "npolint",
        "\u2A15": "pointint",
        "\u2A16": "quatint",
        "\u2A17": "intlarhk",
        "\u2A22": "pluscir",
        "\u2A23": "plusacir",
        "\u2A24": "simplus",
        "\u2A25": "plusdu",
        "\u2A26": "plussim",
        "\u2A27": "plustwo",
        "\u2A29": "mcomma",
        "\u2A2A": "minusdu",
        "\u2A2D": "loplus",
        "\u2A2E": "roplus",
        "\u2A2F": "Cross",
        "\u2A30": "timesd",
        "\u2A31": "timesbar",
        "\u2A33": "smashp",
        "\u2A34": "lotimes",
        "\u2A35": "rotimes",
        "\u2A36": "otimesas",
        "\u2A37": "Otimes",
        "\u2A38": "odiv",
        "\u2A39": "triplus",
        "\u2A3A": "triminus",
        "\u2A3B": "tritime",
        "\u2A3C": "iprod",
        "\u2A3F": "amalg",
        "\u2A40": "capdot",
        "\u2A42": "ncup",
        "\u2A43": "ncap",
        "\u2A44": "capand",
        "\u2A45": "cupor",
        "\u2A46": "cupcap",
        "\u2A47": "capcup",
        "\u2A48": "cupbrcap",
        "\u2A49": "capbrcup",
        "\u2A4A": "cupcup",
        "\u2A4B": "capcap",
        "\u2A4C": "ccups",
        "\u2A4D": "ccaps",
        "\u2A50": "ccupssm",
        "\u2A53": "And",
        "\u2A54": "Or",
        "\u2A55": "andand",
        "\u2A56": "oror",
        "\u2A57": "orslope",
        "\u2A58": "andslope",
        "\u2A5A": "andv",
        "\u2A5B": "orv",
        "\u2A5C": "andd",
        "\u2A5D": "ord",
        "\u2A5F": "wedbar",
        "\u2A66": "sdote",
        "\u2A6A": "simdot",
        "\u2A6D": "congdot",
        "\u2A6D\u0338": "ncongdot",
        "\u2A6E": "easter",
        "\u2A6F": "apacir",
        "\u2A70": "apE",
        "\u2A70\u0338": "napE",
        "\u2A71": "eplus",
        "\u2A72": "pluse",
        "\u2A73": "Esim",
        "\u2A77": "eDDot",
        "\u2A78": "equivDD",
        "\u2A79": "ltcir",
        "\u2A7A": "gtcir",
        "\u2A7B": "ltquest",
        "\u2A7C": "gtquest",
        "\u2A7D": "les",
        "\u2A7D\u0338": "nles",
        "\u2A7E": "ges",
        "\u2A7E\u0338": "nges",
        "\u2A7F": "lesdot",
        "\u2A80": "gesdot",
        "\u2A81": "lesdoto",
        "\u2A82": "gesdoto",
        "\u2A83": "lesdotor",
        "\u2A84": "gesdotol",
        "\u2A85": "lap",
        "\u2A86": "gap",
        "\u2A87": "lne",
        "\u2A88": "gne",
        "\u2A89": "lnap",
        "\u2A8A": "gnap",
        "\u2A8B": "lEg",
        "\u2A8C": "gEl",
        "\u2A8D": "lsime",
        "\u2A8E": "gsime",
        "\u2A8F": "lsimg",
        "\u2A90": "gsiml",
        "\u2A91": "lgE",
        "\u2A92": "glE",
        "\u2A93": "lesges",
        "\u2A94": "gesles",
        "\u2A95": "els",
        "\u2A96": "egs",
        "\u2A97": "elsdot",
        "\u2A98": "egsdot",
        "\u2A99": "el",
        "\u2A9A": "eg",
        "\u2A9D": "siml",
        "\u2A9E": "simg",
        "\u2A9F": "simlE",
        "\u2AA0": "simgE",
        "\u2AA1": "LessLess",
        "\u2AA1\u0338": "NotNestedLessLess",
        "\u2AA2": "GreaterGreater",
        "\u2AA2\u0338": "NotNestedGreaterGreater",
        "\u2AA4": "glj",
        "\u2AA5": "gla",
        "\u2AA6": "ltcc",
        "\u2AA7": "gtcc",
        "\u2AA8": "lescc",
        "\u2AA9": "gescc",
        "\u2AAA": "smt",
        "\u2AAB": "lat",
        "\u2AAC": "smte",
        "\u2AAC\uFE00": "smtes",
        "\u2AAD": "late",
        "\u2AAD\uFE00": "lates",
        "\u2AAE": "bumpE",
        "\u2AAF": "pre",
        "\u2AAF\u0338": "npre",
        "\u2AB0": "sce",
        "\u2AB0\u0338": "nsce",
        "\u2AB3": "prE",
        "\u2AB4": "scE",
        "\u2AB5": "prnE",
        "\u2AB6": "scnE",
        "\u2AB7": "prap",
        "\u2AB8": "scap",
        "\u2AB9": "prnap",
        "\u2ABA": "scnap",
        "\u2ABB": "Pr",
        "\u2ABC": "Sc",
        "\u2ABD": "subdot",
        "\u2ABE": "supdot",
        "\u2ABF": "subplus",
        "\u2AC0": "supplus",
        "\u2AC1": "submult",
        "\u2AC2": "supmult",
        "\u2AC3": "subedot",
        "\u2AC4": "supedot",
        "\u2AC5": "subE",
        "\u2AC5\u0338": "nsubE",
        "\u2AC6": "supE",
        "\u2AC6\u0338": "nsupE",
        "\u2AC7": "subsim",
        "\u2AC8": "supsim",
        "\u2ACB\uFE00": "vsubnE",
        "\u2ACB": "subnE",
        "\u2ACC\uFE00": "vsupnE",
        "\u2ACC": "supnE",
        "\u2ACF": "csub",
        "\u2AD0": "csup",
        "\u2AD1": "csube",
        "\u2AD2": "csupe",
        "\u2AD3": "subsup",
        "\u2AD4": "supsub",
        "\u2AD5": "subsub",
        "\u2AD6": "supsup",
        "\u2AD7": "suphsub",
        "\u2AD8": "supdsub",
        "\u2AD9": "forkv",
        "\u2ADA": "topfork",
        "\u2ADB": "mlcp",
        "\u2AE4": "Dashv",
        "\u2AE6": "Vdashl",
        "\u2AE7": "Barv",
        "\u2AE8": "vBar",
        "\u2AE9": "vBarv",
        "\u2AEB": "Vbar",
        "\u2AEC": "Not",
        "\u2AED": "bNot",
        "\u2AEE": "rnmid",
        "\u2AEF": "cirmid",
        "\u2AF0": "midcir",
        "\u2AF1": "topcir",
        "\u2AF2": "nhpar",
        "\u2AF3": "parsim",
        "\u2AFD": "parsl",
        "\u2AFD\u20E5": "nparsl",
        "\u266D": "flat",
        "\u266E": "natur",
        "\u266F": "sharp",
        "\xA4": "curren",
        "\xA2": "cent",
        $: "dollar",
        "\xA3": "pound",
        "\xA5": "yen",
        "\u20AC": "euro",
        "\xB9": "sup1",
        "\xBD": "half",
        "\u2153": "frac13",
        "\xBC": "frac14",
        "\u2155": "frac15",
        "\u2159": "frac16",
        "\u215B": "frac18",
        "\xB2": "sup2",
        "\u2154": "frac23",
        "\u2156": "frac25",
        "\xB3": "sup3",
        "\xBE": "frac34",
        "\u2157": "frac35",
        "\u215C": "frac38",
        "\u2158": "frac45",
        "\u215A": "frac56",
        "\u215D": "frac58",
        "\u215E": "frac78",
        "\u{1D4B6}": "ascr",
        "\u{1D552}": "aopf",
        "\u{1D51E}": "afr",
        "\u{1D538}": "Aopf",
        "\u{1D504}": "Afr",
        "\u{1D49C}": "Ascr",
        "\xAA": "ordf",
        "\xE1": "aacute",
        "\xC1": "Aacute",
        "\xE0": "agrave",
        "\xC0": "Agrave",
        "\u0103": "abreve",
        "\u0102": "Abreve",
        "\xE2": "acirc",
        "\xC2": "Acirc",
        "\xE5": "aring",
        "\xC5": "angst",
        "\xE4": "auml",
        "\xC4": "Auml",
        "\xE3": "atilde",
        "\xC3": "Atilde",
        "\u0105": "aogon",
        "\u0104": "Aogon",
        "\u0101": "amacr",
        "\u0100": "Amacr",
        "\xE6": "aelig",
        "\xC6": "AElig",
        "\u{1D4B7}": "bscr",
        "\u{1D553}": "bopf",
        "\u{1D51F}": "bfr",
        "\u{1D539}": "Bopf",
        "\u212C": "Bscr",
        "\u{1D505}": "Bfr",
        "\u{1D520}": "cfr",
        "\u{1D4B8}": "cscr",
        "\u{1D554}": "copf",
        "\u212D": "Cfr",
        "\u{1D49E}": "Cscr",
        "\u2102": "Copf",
        "\u0107": "cacute",
        "\u0106": "Cacute",
        "\u0109": "ccirc",
        "\u0108": "Ccirc",
        "\u010D": "ccaron",
        "\u010C": "Ccaron",
        "\u010B": "cdot",
        "\u010A": "Cdot",
        "\xE7": "ccedil",
        "\xC7": "Ccedil",
        "\u2105": "incare",
        "\u{1D521}": "dfr",
        "\u2146": "dd",
        "\u{1D555}": "dopf",
        "\u{1D4B9}": "dscr",
        "\u{1D49F}": "Dscr",
        "\u{1D507}": "Dfr",
        "\u2145": "DD",
        "\u{1D53B}": "Dopf",
        "\u010F": "dcaron",
        "\u010E": "Dcaron",
        "\u0111": "dstrok",
        "\u0110": "Dstrok",
        "\xF0": "eth",
        "\xD0": "ETH",
        "\u2147": "ee",
        "\u212F": "escr",
        "\u{1D522}": "efr",
        "\u{1D556}": "eopf",
        "\u2130": "Escr",
        "\u{1D508}": "Efr",
        "\u{1D53C}": "Eopf",
        "\xE9": "eacute",
        "\xC9": "Eacute",
        "\xE8": "egrave",
        "\xC8": "Egrave",
        "\xEA": "ecirc",
        "\xCA": "Ecirc",
        "\u011B": "ecaron",
        "\u011A": "Ecaron",
        "\xEB": "euml",
        "\xCB": "Euml",
        "\u0117": "edot",
        "\u0116": "Edot",
        "\u0119": "eogon",
        "\u0118": "Eogon",
        "\u0113": "emacr",
        "\u0112": "Emacr",
        "\u{1D523}": "ffr",
        "\u{1D557}": "fopf",
        "\u{1D4BB}": "fscr",
        "\u{1D509}": "Ffr",
        "\u{1D53D}": "Fopf",
        "\u2131": "Fscr",
        "\uFB00": "fflig",
        "\uFB03": "ffilig",
        "\uFB04": "ffllig",
        "\uFB01": "filig",
        fj: "fjlig",
        "\uFB02": "fllig",
        "\u0192": "fnof",
        "\u210A": "gscr",
        "\u{1D558}": "gopf",
        "\u{1D524}": "gfr",
        "\u{1D4A2}": "Gscr",
        "\u{1D53E}": "Gopf",
        "\u{1D50A}": "Gfr",
        "\u01F5": "gacute",
        "\u011F": "gbreve",
        "\u011E": "Gbreve",
        "\u011D": "gcirc",
        "\u011C": "Gcirc",
        "\u0121": "gdot",
        "\u0120": "Gdot",
        "\u0122": "Gcedil",
        "\u{1D525}": "hfr",
        "\u210E": "planckh",
        "\u{1D4BD}": "hscr",
        "\u{1D559}": "hopf",
        "\u210B": "Hscr",
        "\u210C": "Hfr",
        "\u210D": "Hopf",
        "\u0125": "hcirc",
        "\u0124": "Hcirc",
        "\u210F": "hbar",
        "\u0127": "hstrok",
        "\u0126": "Hstrok",
        "\u{1D55A}": "iopf",
        "\u{1D526}": "ifr",
        "\u{1D4BE}": "iscr",
        "\u2148": "ii",
        "\u{1D540}": "Iopf",
        "\u2110": "Iscr",
        "\u2111": "Im",
        "\xED": "iacute",
        "\xCD": "Iacute",
        "\xEC": "igrave",
        "\xCC": "Igrave",
        "\xEE": "icirc",
        "\xCE": "Icirc",
        "\xEF": "iuml",
        "\xCF": "Iuml",
        "\u0129": "itilde",
        "\u0128": "Itilde",
        "\u0130": "Idot",
        "\u012F": "iogon",
        "\u012E": "Iogon",
        "\u012B": "imacr",
        "\u012A": "Imacr",
        "\u0133": "ijlig",
        "\u0132": "IJlig",
        "\u0131": "imath",
        "\u{1D4BF}": "jscr",
        "\u{1D55B}": "jopf",
        "\u{1D527}": "jfr",
        "\u{1D4A5}": "Jscr",
        "\u{1D50D}": "Jfr",
        "\u{1D541}": "Jopf",
        "\u0135": "jcirc",
        "\u0134": "Jcirc",
        "\u0237": "jmath",
        "\u{1D55C}": "kopf",
        "\u{1D4C0}": "kscr",
        "\u{1D528}": "kfr",
        "\u{1D4A6}": "Kscr",
        "\u{1D542}": "Kopf",
        "\u{1D50E}": "Kfr",
        "\u0137": "kcedil",
        "\u0136": "Kcedil",
        "\u{1D529}": "lfr",
        "\u{1D4C1}": "lscr",
        "\u2113": "ell",
        "\u{1D55D}": "lopf",
        "\u2112": "Lscr",
        "\u{1D50F}": "Lfr",
        "\u{1D543}": "Lopf",
        "\u013A": "lacute",
        "\u0139": "Lacute",
        "\u013E": "lcaron",
        "\u013D": "Lcaron",
        "\u013C": "lcedil",
        "\u013B": "Lcedil",
        "\u0142": "lstrok",
        "\u0141": "Lstrok",
        "\u0140": "lmidot",
        "\u013F": "Lmidot",
        "\u{1D52A}": "mfr",
        "\u{1D55E}": "mopf",
        "\u{1D4C2}": "mscr",
        "\u{1D510}": "Mfr",
        "\u{1D544}": "Mopf",
        "\u2133": "Mscr",
        "\u{1D52B}": "nfr",
        "\u{1D55F}": "nopf",
        "\u{1D4C3}": "nscr",
        "\u2115": "Nopf",
        "\u{1D4A9}": "Nscr",
        "\u{1D511}": "Nfr",
        "\u0144": "nacute",
        "\u0143": "Nacute",
        "\u0148": "ncaron",
        "\u0147": "Ncaron",
        "\xF1": "ntilde",
        "\xD1": "Ntilde",
        "\u0146": "ncedil",
        "\u0145": "Ncedil",
        "\u2116": "numero",
        "\u014B": "eng",
        "\u014A": "ENG",
        "\u{1D560}": "oopf",
        "\u{1D52C}": "ofr",
        "\u2134": "oscr",
        "\u{1D4AA}": "Oscr",
        "\u{1D512}": "Ofr",
        "\u{1D546}": "Oopf",
        "\xBA": "ordm",
        "\xF3": "oacute",
        "\xD3": "Oacute",
        "\xF2": "ograve",
        "\xD2": "Ograve",
        "\xF4": "ocirc",
        "\xD4": "Ocirc",
        "\xF6": "ouml",
        "\xD6": "Ouml",
        "\u0151": "odblac",
        "\u0150": "Odblac",
        "\xF5": "otilde",
        "\xD5": "Otilde",
        "\xF8": "oslash",
        "\xD8": "Oslash",
        "\u014D": "omacr",
        "\u014C": "Omacr",
        "\u0153": "oelig",
        "\u0152": "OElig",
        "\u{1D52D}": "pfr",
        "\u{1D4C5}": "pscr",
        "\u{1D561}": "popf",
        "\u2119": "Popf",
        "\u{1D513}": "Pfr",
        "\u{1D4AB}": "Pscr",
        "\u{1D562}": "qopf",
        "\u{1D52E}": "qfr",
        "\u{1D4C6}": "qscr",
        "\u{1D4AC}": "Qscr",
        "\u{1D514}": "Qfr",
        "\u211A": "Qopf",
        "\u0138": "kgreen",
        "\u{1D52F}": "rfr",
        "\u{1D563}": "ropf",
        "\u{1D4C7}": "rscr",
        "\u211B": "Rscr",
        "\u211C": "Re",
        "\u211D": "Ropf",
        "\u0155": "racute",
        "\u0154": "Racute",
        "\u0159": "rcaron",
        "\u0158": "Rcaron",
        "\u0157": "rcedil",
        "\u0156": "Rcedil",
        "\u{1D564}": "sopf",
        "\u{1D4C8}": "sscr",
        "\u{1D530}": "sfr",
        "\u{1D54A}": "Sopf",
        "\u{1D516}": "Sfr",
        "\u{1D4AE}": "Sscr",
        "\u24C8": "oS",
        "\u015B": "sacute",
        "\u015A": "Sacute",
        "\u015D": "scirc",
        "\u015C": "Scirc",
        "\u0161": "scaron",
        "\u0160": "Scaron",
        "\u015F": "scedil",
        "\u015E": "Scedil",
        "\xDF": "szlig",
        "\u{1D531}": "tfr",
        "\u{1D4C9}": "tscr",
        "\u{1D565}": "topf",
        "\u{1D4AF}": "Tscr",
        "\u{1D517}": "Tfr",
        "\u{1D54B}": "Topf",
        "\u0165": "tcaron",
        "\u0164": "Tcaron",
        "\u0163": "tcedil",
        "\u0162": "Tcedil",
        "\u2122": "trade",
        "\u0167": "tstrok",
        "\u0166": "Tstrok",
        "\u{1D4CA}": "uscr",
        "\u{1D566}": "uopf",
        "\u{1D532}": "ufr",
        "\u{1D54C}": "Uopf",
        "\u{1D518}": "Ufr",
        "\u{1D4B0}": "Uscr",
        "\xFA": "uacute",
        "\xDA": "Uacute",
        "\xF9": "ugrave",
        "\xD9": "Ugrave",
        "\u016D": "ubreve",
        "\u016C": "Ubreve",
        "\xFB": "ucirc",
        "\xDB": "Ucirc",
        "\u016F": "uring",
        "\u016E": "Uring",
        "\xFC": "uuml",
        "\xDC": "Uuml",
        "\u0171": "udblac",
        "\u0170": "Udblac",
        "\u0169": "utilde",
        "\u0168": "Utilde",
        "\u0173": "uogon",
        "\u0172": "Uogon",
        "\u016B": "umacr",
        "\u016A": "Umacr",
        "\u{1D533}": "vfr",
        "\u{1D567}": "vopf",
        "\u{1D4CB}": "vscr",
        "\u{1D519}": "Vfr",
        "\u{1D54D}": "Vopf",
        "\u{1D4B1}": "Vscr",
        "\u{1D568}": "wopf",
        "\u{1D4CC}": "wscr",
        "\u{1D534}": "wfr",
        "\u{1D4B2}": "Wscr",
        "\u{1D54E}": "Wopf",
        "\u{1D51A}": "Wfr",
        "\u0175": "wcirc",
        "\u0174": "Wcirc",
        "\u{1D535}": "xfr",
        "\u{1D4CD}": "xscr",
        "\u{1D569}": "xopf",
        "\u{1D54F}": "Xopf",
        "\u{1D51B}": "Xfr",
        "\u{1D4B3}": "Xscr",
        "\u{1D536}": "yfr",
        "\u{1D4CE}": "yscr",
        "\u{1D56A}": "yopf",
        "\u{1D4B4}": "Yscr",
        "\u{1D51C}": "Yfr",
        "\u{1D550}": "Yopf",
        "\xFD": "yacute",
        "\xDD": "Yacute",
        "\u0177": "ycirc",
        "\u0176": "Ycirc",
        "\xFF": "yuml",
        "\u0178": "Yuml",
        "\u{1D4CF}": "zscr",
        "\u{1D537}": "zfr",
        "\u{1D56B}": "zopf",
        "\u2128": "Zfr",
        "\u2124": "Zopf",
        "\u{1D4B5}": "Zscr",
        "\u017A": "zacute",
        "\u0179": "Zacute",
        "\u017E": "zcaron",
        "\u017D": "Zcaron",
        "\u017C": "zdot",
        "\u017B": "Zdot",
        "\u01B5": "imped",
        "\xFE": "thorn",
        "\xDE": "THORN",
        "\u0149": "napos",
        "\u03B1": "alpha",
        "\u0391": "Alpha",
        "\u03B2": "beta",
        "\u0392": "Beta",
        "\u03B3": "gamma",
        "\u0393": "Gamma",
        "\u03B4": "delta",
        "\u0394": "Delta",
        "\u03B5": "epsi",
        "\u03F5": "epsiv",
        "\u0395": "Epsilon",
        "\u03DD": "gammad",
        "\u03DC": "Gammad",
        "\u03B6": "zeta",
        "\u0396": "Zeta",
        "\u03B7": "eta",
        "\u0397": "Eta",
        "\u03B8": "theta",
        "\u03D1": "thetav",
        "\u0398": "Theta",
        "\u03B9": "iota",
        "\u0399": "Iota",
        "\u03BA": "kappa",
        "\u03F0": "kappav",
        "\u039A": "Kappa",
        "\u03BB": "lambda",
        "\u039B": "Lambda",
        "\u03BC": "mu",
        "\xB5": "micro",
        "\u039C": "Mu",
        "\u03BD": "nu",
        "\u039D": "Nu",
        "\u03BE": "xi",
        "\u039E": "Xi",
        "\u03BF": "omicron",
        "\u039F": "Omicron",
        "\u03C0": "pi",
        "\u03D6": "piv",
        "\u03A0": "Pi",
        "\u03C1": "rho",
        "\u03F1": "rhov",
        "\u03A1": "Rho",
        "\u03C3": "sigma",
        "\u03A3": "Sigma",
        "\u03C2": "sigmaf",
        "\u03C4": "tau",
        "\u03A4": "Tau",
        "\u03C5": "upsi",
        "\u03A5": "Upsilon",
        "\u03D2": "Upsi",
        "\u03C6": "phi",
        "\u03D5": "phiv",
        "\u03A6": "Phi",
        "\u03C7": "chi",
        "\u03A7": "Chi",
        "\u03C8": "psi",
        "\u03A8": "Psi",
        "\u03C9": "omega",
        "\u03A9": "ohm",
        "\u0430": "acy",
        "\u0410": "Acy",
        "\u0431": "bcy",
        "\u0411": "Bcy",
        "\u0432": "vcy",
        "\u0412": "Vcy",
        "\u0433": "gcy",
        "\u0413": "Gcy",
        "\u0453": "gjcy",
        "\u0403": "GJcy",
        "\u0434": "dcy",
        "\u0414": "Dcy",
        "\u0452": "djcy",
        "\u0402": "DJcy",
        "\u0435": "iecy",
        "\u0415": "IEcy",
        "\u0451": "iocy",
        "\u0401": "IOcy",
        "\u0454": "jukcy",
        "\u0404": "Jukcy",
        "\u0436": "zhcy",
        "\u0416": "ZHcy",
        "\u0437": "zcy",
        "\u0417": "Zcy",
        "\u0455": "dscy",
        "\u0405": "DScy",
        "\u0438": "icy",
        "\u0418": "Icy",
        "\u0456": "iukcy",
        "\u0406": "Iukcy",
        "\u0457": "yicy",
        "\u0407": "YIcy",
        "\u0439": "jcy",
        "\u0419": "Jcy",
        "\u0458": "jsercy",
        "\u0408": "Jsercy",
        "\u043A": "kcy",
        "\u041A": "Kcy",
        "\u045C": "kjcy",
        "\u040C": "KJcy",
        "\u043B": "lcy",
        "\u041B": "Lcy",
        "\u0459": "ljcy",
        "\u0409": "LJcy",
        "\u043C": "mcy",
        "\u041C": "Mcy",
        "\u043D": "ncy",
        "\u041D": "Ncy",
        "\u045A": "njcy",
        "\u040A": "NJcy",
        "\u043E": "ocy",
        "\u041E": "Ocy",
        "\u043F": "pcy",
        "\u041F": "Pcy",
        "\u0440": "rcy",
        "\u0420": "Rcy",
        "\u0441": "scy",
        "\u0421": "Scy",
        "\u0442": "tcy",
        "\u0422": "Tcy",
        "\u045B": "tshcy",
        "\u040B": "TSHcy",
        "\u0443": "ucy",
        "\u0423": "Ucy",
        "\u045E": "ubrcy",
        "\u040E": "Ubrcy",
        "\u0444": "fcy",
        "\u0424": "Fcy",
        "\u0445": "khcy",
        "\u0425": "KHcy",
        "\u0446": "tscy",
        "\u0426": "TScy",
        "\u0447": "chcy",
        "\u0427": "CHcy",
        "\u045F": "dzcy",
        "\u040F": "DZcy",
        "\u0448": "shcy",
        "\u0428": "SHcy",
        "\u0449": "shchcy",
        "\u0429": "SHCHcy",
        "\u044A": "hardcy",
        "\u042A": "HARDcy",
        "\u044B": "ycy",
        "\u042B": "Ycy",
        "\u044C": "softcy",
        "\u042C": "SOFTcy",
        "\u044D": "ecy",
        "\u042D": "Ecy",
        "\u044E": "yucy",
        "\u042E": "YUcy",
        "\u044F": "yacy",
        "\u042F": "YAcy",
        "\u2135": "aleph",
        "\u2136": "beth",
        "\u2137": "gimel",
        "\u2138": "daleth",
      };
      var regexEscape = /["&'<>`]/g;
      var escapeMap = {
        '"': "&quot;",
        "&": "&amp;",
        "'": "&#x27;",
        "<": "&lt;",
        // See https://mathiasbynens.be/notes/ambiguous-ampersands: in HTML, the
        // following is not strictly necessary unless it’s part of a tag or an
        // unquoted attribute value. We’re only escaping it to support those
        // situations, and for XML support.
        ">": "&gt;",
        // In Internet Explorer ≤ 8, the backtick character can be used
        // to break out of (un)quoted attribute values or HTML comments.
        // See http://html5sec.org/#102, http://html5sec.org/#108, and
        // http://html5sec.org/#133.
        "`": "&#x60;",
      };
      var regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;
      var regexInvalidRawCodePoint =
        /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
      var regexDecode =
        /&(CounterClockwiseContourIntegral|DoubleLongLeftRightArrow|ClockwiseContourIntegral|NotNestedGreaterGreater|NotSquareSupersetEqual|DiacriticalDoubleAcute|NotRightTriangleEqual|NotSucceedsSlantEqual|NotPrecedesSlantEqual|CloseCurlyDoubleQuote|NegativeVeryThinSpace|DoubleContourIntegral|FilledVerySmallSquare|CapitalDifferentialD|OpenCurlyDoubleQuote|EmptyVerySmallSquare|NestedGreaterGreater|DoubleLongRightArrow|NotLeftTriangleEqual|NotGreaterSlantEqual|ReverseUpEquilibrium|DoubleLeftRightArrow|NotSquareSubsetEqual|NotDoubleVerticalBar|RightArrowLeftArrow|NotGreaterFullEqual|NotRightTriangleBar|SquareSupersetEqual|DownLeftRightVector|DoubleLongLeftArrow|leftrightsquigarrow|LeftArrowRightArrow|NegativeMediumSpace|blacktriangleright|RightDownVectorBar|PrecedesSlantEqual|RightDoubleBracket|SucceedsSlantEqual|NotLeftTriangleBar|RightTriangleEqual|SquareIntersection|RightDownTeeVector|ReverseEquilibrium|NegativeThickSpace|longleftrightarrow|Longleftrightarrow|LongLeftRightArrow|DownRightTeeVector|DownRightVectorBar|GreaterSlantEqual|SquareSubsetEqual|LeftDownVectorBar|LeftDoubleBracket|VerticalSeparator|rightleftharpoons|NotGreaterGreater|NotSquareSuperset|blacktriangleleft|blacktriangledown|NegativeThinSpace|LeftDownTeeVector|NotLessSlantEqual|leftrightharpoons|DoubleUpDownArrow|DoubleVerticalBar|LeftTriangleEqual|FilledSmallSquare|twoheadrightarrow|NotNestedLessLess|DownLeftTeeVector|DownLeftVectorBar|RightAngleBracket|NotTildeFullEqual|NotReverseElement|RightUpDownVector|DiacriticalTilde|NotSucceedsTilde|circlearrowright|NotPrecedesEqual|rightharpoondown|DoubleRightArrow|NotSucceedsEqual|NonBreakingSpace|NotRightTriangle|LessEqualGreater|RightUpTeeVector|LeftAngleBracket|GreaterFullEqual|DownArrowUpArrow|RightUpVectorBar|twoheadleftarrow|GreaterEqualLess|downharpoonright|RightTriangleBar|ntrianglerighteq|NotSupersetEqual|LeftUpDownVector|DiacriticalAcute|rightrightarrows|vartriangleright|UpArrowDownArrow|DiacriticalGrave|UnderParenthesis|EmptySmallSquare|LeftUpVectorBar|leftrightarrows|DownRightVector|downharpoonleft|trianglerighteq|ShortRightArrow|OverParenthesis|DoubleLeftArrow|DoubleDownArrow|NotSquareSubset|bigtriangledown|ntrianglelefteq|UpperRightArrow|curvearrowright|vartriangleleft|NotLeftTriangle|nleftrightarrow|LowerRightArrow|NotHumpDownHump|NotGreaterTilde|rightthreetimes|LeftUpTeeVector|NotGreaterEqual|straightepsilon|LeftTriangleBar|rightsquigarrow|ContourIntegral|rightleftarrows|CloseCurlyQuote|RightDownVector|LeftRightVector|nLeftrightarrow|leftharpoondown|circlearrowleft|SquareSuperset|OpenCurlyQuote|hookrightarrow|HorizontalLine|DiacriticalDot|NotLessGreater|ntriangleright|DoubleRightTee|InvisibleComma|InvisibleTimes|LowerLeftArrow|DownLeftVector|NotSubsetEqual|curvearrowleft|trianglelefteq|NotVerticalBar|TildeFullEqual|downdownarrows|NotGreaterLess|RightTeeVector|ZeroWidthSpace|looparrowright|LongRightArrow|doublebarwedge|ShortLeftArrow|ShortDownArrow|RightVectorBar|GreaterGreater|ReverseElement|rightharpoonup|LessSlantEqual|leftthreetimes|upharpoonright|rightarrowtail|LeftDownVector|Longrightarrow|NestedLessLess|UpperLeftArrow|nshortparallel|leftleftarrows|leftrightarrow|Leftrightarrow|LeftRightArrow|longrightarrow|upharpoonleft|RightArrowBar|ApplyFunction|LeftTeeVector|leftarrowtail|NotEqualTilde|varsubsetneqq|varsupsetneqq|RightTeeArrow|SucceedsEqual|SucceedsTilde|LeftVectorBar|SupersetEqual|hookleftarrow|DifferentialD|VerticalTilde|VeryThinSpace|blacktriangle|bigtriangleup|LessFullEqual|divideontimes|leftharpoonup|UpEquilibrium|ntriangleleft|RightTriangle|measuredangle|shortparallel|longleftarrow|Longleftarrow|LongLeftArrow|DoubleLeftTee|Poincareplane|PrecedesEqual|triangleright|DoubleUpArrow|RightUpVector|fallingdotseq|looparrowleft|PrecedesTilde|NotTildeEqual|NotTildeTilde|smallsetminus|Proportional|triangleleft|triangledown|UnderBracket|NotHumpEqual|exponentiale|ExponentialE|NotLessTilde|HilbertSpace|RightCeiling|blacklozenge|varsupsetneq|HumpDownHump|GreaterEqual|VerticalLine|LeftTeeArrow|NotLessEqual|DownTeeArrow|LeftTriangle|varsubsetneq|Intersection|NotCongruent|DownArrowBar|LeftUpVector|LeftArrowBar|risingdotseq|GreaterTilde|RoundImplies|SquareSubset|ShortUpArrow|NotSuperset|quaternions|precnapprox|backepsilon|preccurlyeq|OverBracket|blacksquare|MediumSpace|VerticalBar|circledcirc|circleddash|CircleMinus|CircleTimes|LessGreater|curlyeqprec|curlyeqsucc|diamondsuit|UpDownArrow|Updownarrow|RuleDelayed|Rrightarrow|updownarrow|RightVector|nRightarrow|nrightarrow|eqslantless|LeftCeiling|Equilibrium|SmallCircle|expectation|NotSucceeds|thickapprox|GreaterLess|SquareUnion|NotPrecedes|NotLessLess|straightphi|succnapprox|succcurlyeq|SubsetEqual|sqsupseteq|Proportion|Laplacetrf|ImaginaryI|supsetneqq|NotGreater|gtreqqless|NotElement|ThickSpace|TildeEqual|TildeTilde|Fouriertrf|rmoustache|EqualTilde|eqslantgtr|UnderBrace|LeftVector|UpArrowBar|nLeftarrow|nsubseteqq|subsetneqq|nsupseteqq|nleftarrow|succapprox|lessapprox|UpTeeArrow|upuparrows|curlywedge|lesseqqgtr|varepsilon|varnothing|RightFloor|complement|CirclePlus|sqsubseteq|Lleftarrow|circledast|RightArrow|Rightarrow|rightarrow|lmoustache|Bernoullis|precapprox|mapstoleft|mapstodown|longmapsto|dotsquare|downarrow|DoubleDot|nsubseteq|supsetneq|leftarrow|nsupseteq|subsetneq|ThinSpace|ngeqslant|subseteqq|HumpEqual|NotSubset|triangleq|NotCupCap|lesseqgtr|heartsuit|TripleDot|Leftarrow|Coproduct|Congruent|varpropto|complexes|gvertneqq|LeftArrow|LessTilde|supseteqq|MinusPlus|CircleDot|nleqslant|NotExists|gtreqless|nparallel|UnionPlus|LeftFloor|checkmark|CenterDot|centerdot|Mellintrf|gtrapprox|bigotimes|OverBrace|spadesuit|therefore|pitchfork|rationals|PlusMinus|Backslash|Therefore|DownBreve|backsimeq|backprime|DownArrow|nshortmid|Downarrow|lvertneqq|eqvparsl|imagline|imagpart|infintie|integers|Integral|intercal|LessLess|Uarrocir|intlarhk|sqsupset|angmsdaf|sqsubset|llcorner|vartheta|cupbrcap|lnapprox|Superset|SuchThat|succnsim|succneqq|angmsdag|biguplus|curlyvee|trpezium|Succeeds|NotTilde|bigwedge|angmsdah|angrtvbd|triminus|cwconint|fpartint|lrcorner|smeparsl|subseteq|urcorner|lurdshar|laemptyv|DDotrahd|approxeq|ldrushar|awconint|mapstoup|backcong|shortmid|triangle|geqslant|gesdotol|timesbar|circledR|circledS|setminus|multimap|naturals|scpolint|ncongdot|RightTee|boxminus|gnapprox|boxtimes|andslope|thicksim|angmsdaa|varsigma|cirfnint|rtriltri|angmsdab|rppolint|angmsdac|barwedge|drbkarow|clubsuit|thetasym|bsolhsub|capbrcup|dzigrarr|doteqdot|DotEqual|dotminus|UnderBar|NotEqual|realpart|otimesas|ulcorner|hksearow|hkswarow|parallel|PartialD|elinters|emptyset|plusacir|bbrktbrk|angmsdad|pointint|bigoplus|angmsdae|Precedes|bigsqcup|varkappa|notindot|supseteq|precneqq|precnsim|profalar|profline|profsurf|leqslant|lesdotor|raemptyv|subplus|notnivb|notnivc|subrarr|zigrarr|vzigzag|submult|subedot|Element|between|cirscir|larrbfs|larrsim|lotimes|lbrksld|lbrkslu|lozenge|ldrdhar|dbkarow|bigcirc|epsilon|simrarr|simplus|ltquest|Epsilon|luruhar|gtquest|maltese|npolint|eqcolon|npreceq|bigodot|ddagger|gtrless|bnequiv|harrcir|ddotseq|equivDD|backsim|demptyv|nsqsube|nsqsupe|Upsilon|nsubset|upsilon|minusdu|nsucceq|swarrow|nsupset|coloneq|searrow|boxplus|napprox|natural|asympeq|alefsym|congdot|nearrow|bigstar|diamond|supplus|tritime|LeftTee|nvinfin|triplus|NewLine|nvltrie|nvrtrie|nwarrow|nexists|Diamond|ruluhar|Implies|supmult|angzarr|suplarr|suphsub|questeq|because|digamma|Because|olcross|bemptyv|omicron|Omicron|rotimes|NoBreak|intprod|angrtvb|orderof|uwangle|suphsol|lesdoto|orslope|DownTee|realine|cudarrl|rdldhar|OverBar|supedot|lessdot|supdsub|topfork|succsim|rbrkslu|rbrksld|pertenk|cudarrr|isindot|planckh|lessgtr|pluscir|gesdoto|plussim|plustwo|lesssim|cularrp|rarrsim|Cayleys|notinva|notinvb|notinvc|UpArrow|Uparrow|uparrow|NotLess|dwangle|precsim|Product|curarrm|Cconint|dotplus|rarrbfs|ccupssm|Cedilla|cemptyv|notniva|quatint|frac35|frac38|frac45|frac56|frac58|frac78|tridot|xoplus|gacute|gammad|Gammad|lfisht|lfloor|bigcup|sqsupe|gbreve|Gbreve|lharul|sqsube|sqcups|Gcedil|apacir|llhard|lmidot|Lmidot|lmoust|andand|sqcaps|approx|Abreve|spades|circeq|tprime|divide|topcir|Assign|topbot|gesdot|divonx|xuplus|timesd|gesles|atilde|solbar|SOFTcy|loplus|timesb|lowast|lowbar|dlcorn|dlcrop|softcy|dollar|lparlt|thksim|lrhard|Atilde|lsaquo|smashp|bigvee|thinsp|wreath|bkarow|lsquor|lstrok|Lstrok|lthree|ltimes|ltlarr|DotDot|simdot|ltrPar|weierp|xsqcup|angmsd|sigmav|sigmaf|zeetrf|Zcaron|zcaron|mapsto|vsupne|thetav|cirmid|marker|mcomma|Zacute|vsubnE|there4|gtlPar|vsubne|bottom|gtrarr|SHCHcy|shchcy|midast|midcir|middot|minusb|minusd|gtrdot|bowtie|sfrown|mnplus|models|colone|seswar|Colone|mstpos|searhk|gtrsim|nacute|Nacute|boxbox|telrec|hairsp|Tcedil|nbumpe|scnsim|ncaron|Ncaron|ncedil|Ncedil|hamilt|Scedil|nearhk|hardcy|HARDcy|tcedil|Tcaron|commat|nequiv|nesear|tcaron|target|hearts|nexist|varrho|scedil|Scaron|scaron|hellip|Sacute|sacute|hercon|swnwar|compfn|rtimes|rthree|rsquor|rsaquo|zacute|wedgeq|homtht|barvee|barwed|Barwed|rpargt|horbar|conint|swarhk|roplus|nltrie|hslash|hstrok|Hstrok|rmoust|Conint|bprime|hybull|hyphen|iacute|Iacute|supsup|supsub|supsim|varphi|coprod|brvbar|agrave|Supset|supset|igrave|Igrave|notinE|Agrave|iiiint|iinfin|copysr|wedbar|Verbar|vangrt|becaus|incare|verbar|inodot|bullet|drcorn|intcal|drcrop|cularr|vellip|Utilde|bumpeq|cupcap|dstrok|Dstrok|CupCap|cupcup|cupdot|eacute|Eacute|supdot|iquest|easter|ecaron|Ecaron|ecolon|isinsv|utilde|itilde|Itilde|curarr|succeq|Bumpeq|cacute|ulcrop|nparsl|Cacute|nprcue|egrave|Egrave|nrarrc|nrarrw|subsup|subsub|nrtrie|jsercy|nsccue|Jsercy|kappav|kcedil|Kcedil|subsim|ulcorn|nsimeq|egsdot|veebar|kgreen|capand|elsdot|Subset|subset|curren|aacute|lacute|Lacute|emptyv|ntilde|Ntilde|lagran|lambda|Lambda|capcap|Ugrave|langle|subdot|emsp13|numero|emsp14|nvdash|nvDash|nVdash|nVDash|ugrave|ufisht|nvHarr|larrfs|nvlArr|larrhk|larrlp|larrpl|nvrArr|Udblac|nwarhk|larrtl|nwnear|oacute|Oacute|latail|lAtail|sstarf|lbrace|odblac|Odblac|lbrack|udblac|odsold|eparsl|lcaron|Lcaron|ograve|Ograve|lcedil|Lcedil|Aacute|ssmile|ssetmn|squarf|ldquor|capcup|ominus|cylcty|rharul|eqcirc|dagger|rfloor|rfisht|Dagger|daleth|equals|origof|capdot|equest|dcaron|Dcaron|rdquor|oslash|Oslash|otilde|Otilde|otimes|Otimes|urcrop|Ubreve|ubreve|Yacute|Uacute|uacute|Rcedil|rcedil|urcorn|parsim|Rcaron|Vdashl|rcaron|Tstrok|percnt|period|permil|Exists|yacute|rbrack|rbrace|phmmat|ccaron|Ccaron|planck|ccedil|plankv|tstrok|female|plusdo|plusdu|ffilig|plusmn|ffllig|Ccedil|rAtail|dfisht|bernou|ratail|Rarrtl|rarrtl|angsph|rarrpl|rarrlp|rarrhk|xwedge|xotime|forall|ForAll|Vvdash|vsupnE|preceq|bigcap|frac12|frac13|frac14|primes|rarrfs|prnsim|frac15|Square|frac16|square|lesdot|frac18|frac23|propto|prurel|rarrap|rangle|puncsp|frac25|Racute|qprime|racute|lesges|frac34|abreve|AElig|eqsim|utdot|setmn|urtri|Equal|Uring|seArr|uring|searr|dashv|Dashv|mumap|nabla|iogon|Iogon|sdote|sdotb|scsim|napid|napos|equiv|natur|Acirc|dblac|erarr|nbump|iprod|erDot|ucirc|awint|esdot|angrt|ncong|isinE|scnap|Scirc|scirc|ndash|isins|Ubrcy|nearr|neArr|isinv|nedot|ubrcy|acute|Ycirc|iukcy|Iukcy|xutri|nesim|caret|jcirc|Jcirc|caron|twixt|ddarr|sccue|exist|jmath|sbquo|ngeqq|angst|ccaps|lceil|ngsim|UpTee|delta|Delta|rtrif|nharr|nhArr|nhpar|rtrie|jukcy|Jukcy|kappa|rsquo|Kappa|nlarr|nlArr|TSHcy|rrarr|aogon|Aogon|fflig|xrarr|tshcy|ccirc|nleqq|filig|upsih|nless|dharl|nlsim|fjlig|ropar|nltri|dharr|robrk|roarr|fllig|fltns|roang|rnmid|subnE|subne|lAarr|trisb|Ccirc|acirc|ccups|blank|VDash|forkv|Vdash|langd|cedil|blk12|blk14|laquo|strns|diams|notin|vDash|larrb|blk34|block|disin|uplus|vdash|vBarv|aelig|starf|Wedge|check|xrArr|lates|lbarr|lBarr|notni|lbbrk|bcong|frasl|lbrke|frown|vrtri|vprop|vnsup|gamma|Gamma|wedge|xodot|bdquo|srarr|doteq|ldquo|boxdl|boxdL|gcirc|Gcirc|boxDl|boxDL|boxdr|boxdR|boxDr|TRADE|trade|rlhar|boxDR|vnsub|npart|vltri|rlarr|boxhd|boxhD|nprec|gescc|nrarr|nrArr|boxHd|boxHD|boxhu|boxhU|nrtri|boxHu|clubs|boxHU|times|colon|Colon|gimel|xlArr|Tilde|nsime|tilde|nsmid|nspar|THORN|thorn|xlarr|nsube|nsubE|thkap|xhArr|comma|nsucc|boxul|boxuL|nsupe|nsupE|gneqq|gnsim|boxUl|boxUL|grave|boxur|boxuR|boxUr|boxUR|lescc|angle|bepsi|boxvh|varpi|boxvH|numsp|Theta|gsime|gsiml|theta|boxVh|boxVH|boxvl|gtcir|gtdot|boxvL|boxVl|boxVL|crarr|cross|Cross|nvsim|boxvr|nwarr|nwArr|sqsup|dtdot|Uogon|lhard|lharu|dtrif|ocirc|Ocirc|lhblk|duarr|odash|sqsub|Hacek|sqcup|llarr|duhar|oelig|OElig|ofcir|boxvR|uogon|lltri|boxVr|csube|uuarr|ohbar|csupe|ctdot|olarr|olcir|harrw|oline|sqcap|omacr|Omacr|omega|Omega|boxVR|aleph|lneqq|lnsim|loang|loarr|rharu|lobrk|hcirc|operp|oplus|rhard|Hcirc|orarr|Union|order|ecirc|Ecirc|cuepr|szlig|cuesc|breve|reals|eDDot|Breve|hoarr|lopar|utrif|rdquo|Umacr|umacr|efDot|swArr|ultri|alpha|rceil|ovbar|swarr|Wcirc|wcirc|smtes|smile|bsemi|lrarr|aring|parsl|lrhar|bsime|uhblk|lrtri|cupor|Aring|uharr|uharl|slarr|rbrke|bsolb|lsime|rbbrk|RBarr|lsimg|phone|rBarr|rbarr|icirc|lsquo|Icirc|emacr|Emacr|ratio|simne|plusb|simlE|simgE|simeq|pluse|ltcir|ltdot|empty|xharr|xdtri|iexcl|Alpha|ltrie|rarrw|pound|ltrif|xcirc|bumpe|prcue|bumpE|asymp|amacr|cuvee|Sigma|sigma|iiint|udhar|iiota|ijlig|IJlig|supnE|imacr|Imacr|prime|Prime|image|prnap|eogon|Eogon|rarrc|mdash|mDDot|cuwed|imath|supne|imped|Amacr|udarr|prsim|micro|rarrb|cwint|raquo|infin|eplus|range|rangd|Ucirc|radic|minus|amalg|veeeq|rAarr|epsiv|ycirc|quest|sharp|quot|zwnj|Qscr|race|qscr|Qopf|qopf|qint|rang|Rang|Zscr|zscr|Zopf|zopf|rarr|rArr|Rarr|Pscr|pscr|prop|prod|prnE|prec|ZHcy|zhcy|prap|Zeta|zeta|Popf|popf|Zdot|plus|zdot|Yuml|yuml|phiv|YUcy|yucy|Yscr|yscr|perp|Yopf|yopf|part|para|YIcy|Ouml|rcub|yicy|YAcy|rdca|ouml|osol|Oscr|rdsh|yacy|real|oscr|xvee|andd|rect|andv|Xscr|oror|ordm|ordf|xscr|ange|aopf|Aopf|rHar|Xopf|opar|Oopf|xopf|xnis|rhov|oopf|omid|xmap|oint|apid|apos|ogon|ascr|Ascr|odot|odiv|xcup|xcap|ocir|oast|nvlt|nvle|nvgt|nvge|nvap|Wscr|wscr|auml|ntlg|ntgl|nsup|nsub|nsim|Nscr|nscr|nsce|Wopf|ring|npre|wopf|npar|Auml|Barv|bbrk|Nopf|nopf|nmid|nLtv|beta|ropf|Ropf|Beta|beth|nles|rpar|nleq|bnot|bNot|nldr|NJcy|rscr|Rscr|Vscr|vscr|rsqb|njcy|bopf|nisd|Bopf|rtri|Vopf|nGtv|ngtr|vopf|boxh|boxH|boxv|nges|ngeq|boxV|bscr|scap|Bscr|bsim|Vert|vert|bsol|bull|bump|caps|cdot|ncup|scnE|ncap|nbsp|napE|Cdot|cent|sdot|Vbar|nang|vBar|chcy|Mscr|mscr|sect|semi|CHcy|Mopf|mopf|sext|circ|cire|mldr|mlcp|cirE|comp|shcy|SHcy|vArr|varr|cong|copf|Copf|copy|COPY|malt|male|macr|lvnE|cscr|ltri|sime|ltcc|simg|Cscr|siml|csub|Uuml|lsqb|lsim|uuml|csup|Lscr|lscr|utri|smid|lpar|cups|smte|lozf|darr|Lopf|Uscr|solb|lopf|sopf|Sopf|lneq|uscr|spar|dArr|lnap|Darr|dash|Sqrt|LJcy|ljcy|lHar|dHar|Upsi|upsi|diam|lesg|djcy|DJcy|leqq|dopf|Dopf|dscr|Dscr|dscy|ldsh|ldca|squf|DScy|sscr|Sscr|dsol|lcub|late|star|Star|Uopf|Larr|lArr|larr|uopf|dtri|dzcy|sube|subE|Lang|lang|Kscr|kscr|Kopf|kopf|KJcy|kjcy|KHcy|khcy|DZcy|ecir|edot|eDot|Jscr|jscr|succ|Jopf|jopf|Edot|uHar|emsp|ensp|Iuml|iuml|eopf|isin|Iscr|iscr|Eopf|epar|sung|epsi|escr|sup1|sup2|sup3|Iota|iota|supe|supE|Iopf|iopf|IOcy|iocy|Escr|esim|Esim|imof|Uarr|QUOT|uArr|uarr|euml|IEcy|iecy|Idot|Euml|euro|excl|Hscr|hscr|Hopf|hopf|TScy|tscy|Tscr|hbar|tscr|flat|tbrk|fnof|hArr|harr|half|fopf|Fopf|tdot|gvnE|fork|trie|gtcc|fscr|Fscr|gdot|gsim|Gscr|gscr|Gopf|gopf|gneq|Gdot|tosa|gnap|Topf|topf|geqq|toea|GJcy|gjcy|tint|gesl|mid|Sfr|ggg|top|ges|gla|glE|glj|geq|gne|gEl|gel|gnE|Gcy|gcy|gap|Tfr|tfr|Tcy|tcy|Hat|Tau|Ffr|tau|Tab|hfr|Hfr|ffr|Fcy|fcy|icy|Icy|iff|ETH|eth|ifr|Ifr|Eta|eta|int|Int|Sup|sup|ucy|Ucy|Sum|sum|jcy|ENG|ufr|Ufr|eng|Jcy|jfr|els|ell|egs|Efr|efr|Jfr|uml|kcy|Kcy|Ecy|ecy|kfr|Kfr|lap|Sub|sub|lat|lcy|Lcy|leg|Dot|dot|lEg|leq|les|squ|div|die|lfr|Lfr|lgE|Dfr|dfr|Del|deg|Dcy|dcy|lne|lnE|sol|loz|smt|Cup|lrm|cup|lsh|Lsh|sim|shy|map|Map|mcy|Mcy|mfr|Mfr|mho|gfr|Gfr|sfr|cir|Chi|chi|nap|Cfr|vcy|Vcy|cfr|Scy|scy|ncy|Ncy|vee|Vee|Cap|cap|nfr|scE|sce|Nfr|nge|ngE|nGg|vfr|Vfr|ngt|bot|nGt|nis|niv|Rsh|rsh|nle|nlE|bne|Bfr|bfr|nLl|nlt|nLt|Bcy|bcy|not|Not|rlm|wfr|Wfr|npr|nsc|num|ocy|ast|Ocy|ofr|xfr|Xfr|Ofr|ogt|ohm|apE|olt|Rho|ape|rho|Rfr|rfr|ord|REG|ang|reg|orv|And|and|AMP|Rcy|amp|Afr|ycy|Ycy|yen|yfr|Yfr|rcy|par|pcy|Pcy|pfr|Pfr|phi|Phi|afr|Acy|acy|zcy|Zcy|piv|acE|acd|zfr|Zfr|pre|prE|psi|Psi|qfr|Qfr|zwj|Or|ge|Gg|gt|gg|el|oS|lt|Lt|LT|Re|lg|gl|eg|ne|Im|it|le|DD|wp|wr|nu|Nu|dd|lE|Sc|sc|pi|Pi|ee|af|ll|Ll|rx|gE|xi|pm|Xi|ic|pr|Pr|in|ni|mp|mu|ac|Mu|or|ap|Gt|GT|ii);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)(?!;)([=a-zA-Z0-9]?)|&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+)/g;
      var decodeMap = {
        aacute: "\xE1",
        Aacute: "\xC1",
        abreve: "\u0103",
        Abreve: "\u0102",
        ac: "\u223E",
        acd: "\u223F",
        acE: "\u223E\u0333",
        acirc: "\xE2",
        Acirc: "\xC2",
        acute: "\xB4",
        acy: "\u0430",
        Acy: "\u0410",
        aelig: "\xE6",
        AElig: "\xC6",
        af: "\u2061",
        afr: "\u{1D51E}",
        Afr: "\u{1D504}",
        agrave: "\xE0",
        Agrave: "\xC0",
        alefsym: "\u2135",
        aleph: "\u2135",
        alpha: "\u03B1",
        Alpha: "\u0391",
        amacr: "\u0101",
        Amacr: "\u0100",
        amalg: "\u2A3F",
        amp: "&",
        AMP: "&",
        and: "\u2227",
        And: "\u2A53",
        andand: "\u2A55",
        andd: "\u2A5C",
        andslope: "\u2A58",
        andv: "\u2A5A",
        ang: "\u2220",
        ange: "\u29A4",
        angle: "\u2220",
        angmsd: "\u2221",
        angmsdaa: "\u29A8",
        angmsdab: "\u29A9",
        angmsdac: "\u29AA",
        angmsdad: "\u29AB",
        angmsdae: "\u29AC",
        angmsdaf: "\u29AD",
        angmsdag: "\u29AE",
        angmsdah: "\u29AF",
        angrt: "\u221F",
        angrtvb: "\u22BE",
        angrtvbd: "\u299D",
        angsph: "\u2222",
        angst: "\xC5",
        angzarr: "\u237C",
        aogon: "\u0105",
        Aogon: "\u0104",
        aopf: "\u{1D552}",
        Aopf: "\u{1D538}",
        ap: "\u2248",
        apacir: "\u2A6F",
        ape: "\u224A",
        apE: "\u2A70",
        apid: "\u224B",
        apos: "'",
        ApplyFunction: "\u2061",
        approx: "\u2248",
        approxeq: "\u224A",
        aring: "\xE5",
        Aring: "\xC5",
        ascr: "\u{1D4B6}",
        Ascr: "\u{1D49C}",
        Assign: "\u2254",
        ast: "*",
        asymp: "\u2248",
        asympeq: "\u224D",
        atilde: "\xE3",
        Atilde: "\xC3",
        auml: "\xE4",
        Auml: "\xC4",
        awconint: "\u2233",
        awint: "\u2A11",
        backcong: "\u224C",
        backepsilon: "\u03F6",
        backprime: "\u2035",
        backsim: "\u223D",
        backsimeq: "\u22CD",
        Backslash: "\u2216",
        Barv: "\u2AE7",
        barvee: "\u22BD",
        barwed: "\u2305",
        Barwed: "\u2306",
        barwedge: "\u2305",
        bbrk: "\u23B5",
        bbrktbrk: "\u23B6",
        bcong: "\u224C",
        bcy: "\u0431",
        Bcy: "\u0411",
        bdquo: "\u201E",
        becaus: "\u2235",
        because: "\u2235",
        Because: "\u2235",
        bemptyv: "\u29B0",
        bepsi: "\u03F6",
        bernou: "\u212C",
        Bernoullis: "\u212C",
        beta: "\u03B2",
        Beta: "\u0392",
        beth: "\u2136",
        between: "\u226C",
        bfr: "\u{1D51F}",
        Bfr: "\u{1D505}",
        bigcap: "\u22C2",
        bigcirc: "\u25EF",
        bigcup: "\u22C3",
        bigodot: "\u2A00",
        bigoplus: "\u2A01",
        bigotimes: "\u2A02",
        bigsqcup: "\u2A06",
        bigstar: "\u2605",
        bigtriangledown: "\u25BD",
        bigtriangleup: "\u25B3",
        biguplus: "\u2A04",
        bigvee: "\u22C1",
        bigwedge: "\u22C0",
        bkarow: "\u290D",
        blacklozenge: "\u29EB",
        blacksquare: "\u25AA",
        blacktriangle: "\u25B4",
        blacktriangledown: "\u25BE",
        blacktriangleleft: "\u25C2",
        blacktriangleright: "\u25B8",
        blank: "\u2423",
        blk12: "\u2592",
        blk14: "\u2591",
        blk34: "\u2593",
        block: "\u2588",
        bne: "=\u20E5",
        bnequiv: "\u2261\u20E5",
        bnot: "\u2310",
        bNot: "\u2AED",
        bopf: "\u{1D553}",
        Bopf: "\u{1D539}",
        bot: "\u22A5",
        bottom: "\u22A5",
        bowtie: "\u22C8",
        boxbox: "\u29C9",
        boxdl: "\u2510",
        boxdL: "\u2555",
        boxDl: "\u2556",
        boxDL: "\u2557",
        boxdr: "\u250C",
        boxdR: "\u2552",
        boxDr: "\u2553",
        boxDR: "\u2554",
        boxh: "\u2500",
        boxH: "\u2550",
        boxhd: "\u252C",
        boxhD: "\u2565",
        boxHd: "\u2564",
        boxHD: "\u2566",
        boxhu: "\u2534",
        boxhU: "\u2568",
        boxHu: "\u2567",
        boxHU: "\u2569",
        boxminus: "\u229F",
        boxplus: "\u229E",
        boxtimes: "\u22A0",
        boxul: "\u2518",
        boxuL: "\u255B",
        boxUl: "\u255C",
        boxUL: "\u255D",
        boxur: "\u2514",
        boxuR: "\u2558",
        boxUr: "\u2559",
        boxUR: "\u255A",
        boxv: "\u2502",
        boxV: "\u2551",
        boxvh: "\u253C",
        boxvH: "\u256A",
        boxVh: "\u256B",
        boxVH: "\u256C",
        boxvl: "\u2524",
        boxvL: "\u2561",
        boxVl: "\u2562",
        boxVL: "\u2563",
        boxvr: "\u251C",
        boxvR: "\u255E",
        boxVr: "\u255F",
        boxVR: "\u2560",
        bprime: "\u2035",
        breve: "\u02D8",
        Breve: "\u02D8",
        brvbar: "\xA6",
        bscr: "\u{1D4B7}",
        Bscr: "\u212C",
        bsemi: "\u204F",
        bsim: "\u223D",
        bsime: "\u22CD",
        bsol: "\\",
        bsolb: "\u29C5",
        bsolhsub: "\u27C8",
        bull: "\u2022",
        bullet: "\u2022",
        bump: "\u224E",
        bumpe: "\u224F",
        bumpE: "\u2AAE",
        bumpeq: "\u224F",
        Bumpeq: "\u224E",
        cacute: "\u0107",
        Cacute: "\u0106",
        cap: "\u2229",
        Cap: "\u22D2",
        capand: "\u2A44",
        capbrcup: "\u2A49",
        capcap: "\u2A4B",
        capcup: "\u2A47",
        capdot: "\u2A40",
        CapitalDifferentialD: "\u2145",
        caps: "\u2229\uFE00",
        caret: "\u2041",
        caron: "\u02C7",
        Cayleys: "\u212D",
        ccaps: "\u2A4D",
        ccaron: "\u010D",
        Ccaron: "\u010C",
        ccedil: "\xE7",
        Ccedil: "\xC7",
        ccirc: "\u0109",
        Ccirc: "\u0108",
        Cconint: "\u2230",
        ccups: "\u2A4C",
        ccupssm: "\u2A50",
        cdot: "\u010B",
        Cdot: "\u010A",
        cedil: "\xB8",
        Cedilla: "\xB8",
        cemptyv: "\u29B2",
        cent: "\xA2",
        centerdot: "\xB7",
        CenterDot: "\xB7",
        cfr: "\u{1D520}",
        Cfr: "\u212D",
        chcy: "\u0447",
        CHcy: "\u0427",
        check: "\u2713",
        checkmark: "\u2713",
        chi: "\u03C7",
        Chi: "\u03A7",
        cir: "\u25CB",
        circ: "\u02C6",
        circeq: "\u2257",
        circlearrowleft: "\u21BA",
        circlearrowright: "\u21BB",
        circledast: "\u229B",
        circledcirc: "\u229A",
        circleddash: "\u229D",
        CircleDot: "\u2299",
        circledR: "\xAE",
        circledS: "\u24C8",
        CircleMinus: "\u2296",
        CirclePlus: "\u2295",
        CircleTimes: "\u2297",
        cire: "\u2257",
        cirE: "\u29C3",
        cirfnint: "\u2A10",
        cirmid: "\u2AEF",
        cirscir: "\u29C2",
        ClockwiseContourIntegral: "\u2232",
        CloseCurlyDoubleQuote: "\u201D",
        CloseCurlyQuote: "\u2019",
        clubs: "\u2663",
        clubsuit: "\u2663",
        colon: ":",
        Colon: "\u2237",
        colone: "\u2254",
        Colone: "\u2A74",
        coloneq: "\u2254",
        comma: ",",
        commat: "@",
        comp: "\u2201",
        compfn: "\u2218",
        complement: "\u2201",
        complexes: "\u2102",
        cong: "\u2245",
        congdot: "\u2A6D",
        Congruent: "\u2261",
        conint: "\u222E",
        Conint: "\u222F",
        ContourIntegral: "\u222E",
        copf: "\u{1D554}",
        Copf: "\u2102",
        coprod: "\u2210",
        Coproduct: "\u2210",
        copy: "\xA9",
        COPY: "\xA9",
        copysr: "\u2117",
        CounterClockwiseContourIntegral: "\u2233",
        crarr: "\u21B5",
        cross: "\u2717",
        Cross: "\u2A2F",
        cscr: "\u{1D4B8}",
        Cscr: "\u{1D49E}",
        csub: "\u2ACF",
        csube: "\u2AD1",
        csup: "\u2AD0",
        csupe: "\u2AD2",
        ctdot: "\u22EF",
        cudarrl: "\u2938",
        cudarrr: "\u2935",
        cuepr: "\u22DE",
        cuesc: "\u22DF",
        cularr: "\u21B6",
        cularrp: "\u293D",
        cup: "\u222A",
        Cup: "\u22D3",
        cupbrcap: "\u2A48",
        cupcap: "\u2A46",
        CupCap: "\u224D",
        cupcup: "\u2A4A",
        cupdot: "\u228D",
        cupor: "\u2A45",
        cups: "\u222A\uFE00",
        curarr: "\u21B7",
        curarrm: "\u293C",
        curlyeqprec: "\u22DE",
        curlyeqsucc: "\u22DF",
        curlyvee: "\u22CE",
        curlywedge: "\u22CF",
        curren: "\xA4",
        curvearrowleft: "\u21B6",
        curvearrowright: "\u21B7",
        cuvee: "\u22CE",
        cuwed: "\u22CF",
        cwconint: "\u2232",
        cwint: "\u2231",
        cylcty: "\u232D",
        dagger: "\u2020",
        Dagger: "\u2021",
        daleth: "\u2138",
        darr: "\u2193",
        dArr: "\u21D3",
        Darr: "\u21A1",
        dash: "\u2010",
        dashv: "\u22A3",
        Dashv: "\u2AE4",
        dbkarow: "\u290F",
        dblac: "\u02DD",
        dcaron: "\u010F",
        Dcaron: "\u010E",
        dcy: "\u0434",
        Dcy: "\u0414",
        dd: "\u2146",
        DD: "\u2145",
        ddagger: "\u2021",
        ddarr: "\u21CA",
        DDotrahd: "\u2911",
        ddotseq: "\u2A77",
        deg: "\xB0",
        Del: "\u2207",
        delta: "\u03B4",
        Delta: "\u0394",
        demptyv: "\u29B1",
        dfisht: "\u297F",
        dfr: "\u{1D521}",
        Dfr: "\u{1D507}",
        dHar: "\u2965",
        dharl: "\u21C3",
        dharr: "\u21C2",
        DiacriticalAcute: "\xB4",
        DiacriticalDot: "\u02D9",
        DiacriticalDoubleAcute: "\u02DD",
        DiacriticalGrave: "`",
        DiacriticalTilde: "\u02DC",
        diam: "\u22C4",
        diamond: "\u22C4",
        Diamond: "\u22C4",
        diamondsuit: "\u2666",
        diams: "\u2666",
        die: "\xA8",
        DifferentialD: "\u2146",
        digamma: "\u03DD",
        disin: "\u22F2",
        div: "\xF7",
        divide: "\xF7",
        divideontimes: "\u22C7",
        divonx: "\u22C7",
        djcy: "\u0452",
        DJcy: "\u0402",
        dlcorn: "\u231E",
        dlcrop: "\u230D",
        dollar: "$",
        dopf: "\u{1D555}",
        Dopf: "\u{1D53B}",
        dot: "\u02D9",
        Dot: "\xA8",
        DotDot: "\u20DC",
        doteq: "\u2250",
        doteqdot: "\u2251",
        DotEqual: "\u2250",
        dotminus: "\u2238",
        dotplus: "\u2214",
        dotsquare: "\u22A1",
        doublebarwedge: "\u2306",
        DoubleContourIntegral: "\u222F",
        DoubleDot: "\xA8",
        DoubleDownArrow: "\u21D3",
        DoubleLeftArrow: "\u21D0",
        DoubleLeftRightArrow: "\u21D4",
        DoubleLeftTee: "\u2AE4",
        DoubleLongLeftArrow: "\u27F8",
        DoubleLongLeftRightArrow: "\u27FA",
        DoubleLongRightArrow: "\u27F9",
        DoubleRightArrow: "\u21D2",
        DoubleRightTee: "\u22A8",
        DoubleUpArrow: "\u21D1",
        DoubleUpDownArrow: "\u21D5",
        DoubleVerticalBar: "\u2225",
        downarrow: "\u2193",
        Downarrow: "\u21D3",
        DownArrow: "\u2193",
        DownArrowBar: "\u2913",
        DownArrowUpArrow: "\u21F5",
        DownBreve: "\u0311",
        downdownarrows: "\u21CA",
        downharpoonleft: "\u21C3",
        downharpoonright: "\u21C2",
        DownLeftRightVector: "\u2950",
        DownLeftTeeVector: "\u295E",
        DownLeftVector: "\u21BD",
        DownLeftVectorBar: "\u2956",
        DownRightTeeVector: "\u295F",
        DownRightVector: "\u21C1",
        DownRightVectorBar: "\u2957",
        DownTee: "\u22A4",
        DownTeeArrow: "\u21A7",
        drbkarow: "\u2910",
        drcorn: "\u231F",
        drcrop: "\u230C",
        dscr: "\u{1D4B9}",
        Dscr: "\u{1D49F}",
        dscy: "\u0455",
        DScy: "\u0405",
        dsol: "\u29F6",
        dstrok: "\u0111",
        Dstrok: "\u0110",
        dtdot: "\u22F1",
        dtri: "\u25BF",
        dtrif: "\u25BE",
        duarr: "\u21F5",
        duhar: "\u296F",
        dwangle: "\u29A6",
        dzcy: "\u045F",
        DZcy: "\u040F",
        dzigrarr: "\u27FF",
        eacute: "\xE9",
        Eacute: "\xC9",
        easter: "\u2A6E",
        ecaron: "\u011B",
        Ecaron: "\u011A",
        ecir: "\u2256",
        ecirc: "\xEA",
        Ecirc: "\xCA",
        ecolon: "\u2255",
        ecy: "\u044D",
        Ecy: "\u042D",
        eDDot: "\u2A77",
        edot: "\u0117",
        eDot: "\u2251",
        Edot: "\u0116",
        ee: "\u2147",
        efDot: "\u2252",
        efr: "\u{1D522}",
        Efr: "\u{1D508}",
        eg: "\u2A9A",
        egrave: "\xE8",
        Egrave: "\xC8",
        egs: "\u2A96",
        egsdot: "\u2A98",
        el: "\u2A99",
        Element: "\u2208",
        elinters: "\u23E7",
        ell: "\u2113",
        els: "\u2A95",
        elsdot: "\u2A97",
        emacr: "\u0113",
        Emacr: "\u0112",
        empty: "\u2205",
        emptyset: "\u2205",
        EmptySmallSquare: "\u25FB",
        emptyv: "\u2205",
        EmptyVerySmallSquare: "\u25AB",
        emsp: "\u2003",
        emsp13: "\u2004",
        emsp14: "\u2005",
        eng: "\u014B",
        ENG: "\u014A",
        ensp: "\u2002",
        eogon: "\u0119",
        Eogon: "\u0118",
        eopf: "\u{1D556}",
        Eopf: "\u{1D53C}",
        epar: "\u22D5",
        eparsl: "\u29E3",
        eplus: "\u2A71",
        epsi: "\u03B5",
        epsilon: "\u03B5",
        Epsilon: "\u0395",
        epsiv: "\u03F5",
        eqcirc: "\u2256",
        eqcolon: "\u2255",
        eqsim: "\u2242",
        eqslantgtr: "\u2A96",
        eqslantless: "\u2A95",
        Equal: "\u2A75",
        equals: "=",
        EqualTilde: "\u2242",
        equest: "\u225F",
        Equilibrium: "\u21CC",
        equiv: "\u2261",
        equivDD: "\u2A78",
        eqvparsl: "\u29E5",
        erarr: "\u2971",
        erDot: "\u2253",
        escr: "\u212F",
        Escr: "\u2130",
        esdot: "\u2250",
        esim: "\u2242",
        Esim: "\u2A73",
        eta: "\u03B7",
        Eta: "\u0397",
        eth: "\xF0",
        ETH: "\xD0",
        euml: "\xEB",
        Euml: "\xCB",
        euro: "\u20AC",
        excl: "!",
        exist: "\u2203",
        Exists: "\u2203",
        expectation: "\u2130",
        exponentiale: "\u2147",
        ExponentialE: "\u2147",
        fallingdotseq: "\u2252",
        fcy: "\u0444",
        Fcy: "\u0424",
        female: "\u2640",
        ffilig: "\uFB03",
        fflig: "\uFB00",
        ffllig: "\uFB04",
        ffr: "\u{1D523}",
        Ffr: "\u{1D509}",
        filig: "\uFB01",
        FilledSmallSquare: "\u25FC",
        FilledVerySmallSquare: "\u25AA",
        fjlig: "fj",
        flat: "\u266D",
        fllig: "\uFB02",
        fltns: "\u25B1",
        fnof: "\u0192",
        fopf: "\u{1D557}",
        Fopf: "\u{1D53D}",
        forall: "\u2200",
        ForAll: "\u2200",
        fork: "\u22D4",
        forkv: "\u2AD9",
        Fouriertrf: "\u2131",
        fpartint: "\u2A0D",
        frac12: "\xBD",
        frac13: "\u2153",
        frac14: "\xBC",
        frac15: "\u2155",
        frac16: "\u2159",
        frac18: "\u215B",
        frac23: "\u2154",
        frac25: "\u2156",
        frac34: "\xBE",
        frac35: "\u2157",
        frac38: "\u215C",
        frac45: "\u2158",
        frac56: "\u215A",
        frac58: "\u215D",
        frac78: "\u215E",
        frasl: "\u2044",
        frown: "\u2322",
        fscr: "\u{1D4BB}",
        Fscr: "\u2131",
        gacute: "\u01F5",
        gamma: "\u03B3",
        Gamma: "\u0393",
        gammad: "\u03DD",
        Gammad: "\u03DC",
        gap: "\u2A86",
        gbreve: "\u011F",
        Gbreve: "\u011E",
        Gcedil: "\u0122",
        gcirc: "\u011D",
        Gcirc: "\u011C",
        gcy: "\u0433",
        Gcy: "\u0413",
        gdot: "\u0121",
        Gdot: "\u0120",
        ge: "\u2265",
        gE: "\u2267",
        gel: "\u22DB",
        gEl: "\u2A8C",
        geq: "\u2265",
        geqq: "\u2267",
        geqslant: "\u2A7E",
        ges: "\u2A7E",
        gescc: "\u2AA9",
        gesdot: "\u2A80",
        gesdoto: "\u2A82",
        gesdotol: "\u2A84",
        gesl: "\u22DB\uFE00",
        gesles: "\u2A94",
        gfr: "\u{1D524}",
        Gfr: "\u{1D50A}",
        gg: "\u226B",
        Gg: "\u22D9",
        ggg: "\u22D9",
        gimel: "\u2137",
        gjcy: "\u0453",
        GJcy: "\u0403",
        gl: "\u2277",
        gla: "\u2AA5",
        glE: "\u2A92",
        glj: "\u2AA4",
        gnap: "\u2A8A",
        gnapprox: "\u2A8A",
        gne: "\u2A88",
        gnE: "\u2269",
        gneq: "\u2A88",
        gneqq: "\u2269",
        gnsim: "\u22E7",
        gopf: "\u{1D558}",
        Gopf: "\u{1D53E}",
        grave: "`",
        GreaterEqual: "\u2265",
        GreaterEqualLess: "\u22DB",
        GreaterFullEqual: "\u2267",
        GreaterGreater: "\u2AA2",
        GreaterLess: "\u2277",
        GreaterSlantEqual: "\u2A7E",
        GreaterTilde: "\u2273",
        gscr: "\u210A",
        Gscr: "\u{1D4A2}",
        gsim: "\u2273",
        gsime: "\u2A8E",
        gsiml: "\u2A90",
        gt: ">",
        Gt: "\u226B",
        GT: ">",
        gtcc: "\u2AA7",
        gtcir: "\u2A7A",
        gtdot: "\u22D7",
        gtlPar: "\u2995",
        gtquest: "\u2A7C",
        gtrapprox: "\u2A86",
        gtrarr: "\u2978",
        gtrdot: "\u22D7",
        gtreqless: "\u22DB",
        gtreqqless: "\u2A8C",
        gtrless: "\u2277",
        gtrsim: "\u2273",
        gvertneqq: "\u2269\uFE00",
        gvnE: "\u2269\uFE00",
        Hacek: "\u02C7",
        hairsp: "\u200A",
        half: "\xBD",
        hamilt: "\u210B",
        hardcy: "\u044A",
        HARDcy: "\u042A",
        harr: "\u2194",
        hArr: "\u21D4",
        harrcir: "\u2948",
        harrw: "\u21AD",
        Hat: "^",
        hbar: "\u210F",
        hcirc: "\u0125",
        Hcirc: "\u0124",
        hearts: "\u2665",
        heartsuit: "\u2665",
        hellip: "\u2026",
        hercon: "\u22B9",
        hfr: "\u{1D525}",
        Hfr: "\u210C",
        HilbertSpace: "\u210B",
        hksearow: "\u2925",
        hkswarow: "\u2926",
        hoarr: "\u21FF",
        homtht: "\u223B",
        hookleftarrow: "\u21A9",
        hookrightarrow: "\u21AA",
        hopf: "\u{1D559}",
        Hopf: "\u210D",
        horbar: "\u2015",
        HorizontalLine: "\u2500",
        hscr: "\u{1D4BD}",
        Hscr: "\u210B",
        hslash: "\u210F",
        hstrok: "\u0127",
        Hstrok: "\u0126",
        HumpDownHump: "\u224E",
        HumpEqual: "\u224F",
        hybull: "\u2043",
        hyphen: "\u2010",
        iacute: "\xED",
        Iacute: "\xCD",
        ic: "\u2063",
        icirc: "\xEE",
        Icirc: "\xCE",
        icy: "\u0438",
        Icy: "\u0418",
        Idot: "\u0130",
        iecy: "\u0435",
        IEcy: "\u0415",
        iexcl: "\xA1",
        iff: "\u21D4",
        ifr: "\u{1D526}",
        Ifr: "\u2111",
        igrave: "\xEC",
        Igrave: "\xCC",
        ii: "\u2148",
        iiiint: "\u2A0C",
        iiint: "\u222D",
        iinfin: "\u29DC",
        iiota: "\u2129",
        ijlig: "\u0133",
        IJlig: "\u0132",
        Im: "\u2111",
        imacr: "\u012B",
        Imacr: "\u012A",
        image: "\u2111",
        ImaginaryI: "\u2148",
        imagline: "\u2110",
        imagpart: "\u2111",
        imath: "\u0131",
        imof: "\u22B7",
        imped: "\u01B5",
        Implies: "\u21D2",
        in: "\u2208",
        incare: "\u2105",
        infin: "\u221E",
        infintie: "\u29DD",
        inodot: "\u0131",
        int: "\u222B",
        Int: "\u222C",
        intcal: "\u22BA",
        integers: "\u2124",
        Integral: "\u222B",
        intercal: "\u22BA",
        Intersection: "\u22C2",
        intlarhk: "\u2A17",
        intprod: "\u2A3C",
        InvisibleComma: "\u2063",
        InvisibleTimes: "\u2062",
        iocy: "\u0451",
        IOcy: "\u0401",
        iogon: "\u012F",
        Iogon: "\u012E",
        iopf: "\u{1D55A}",
        Iopf: "\u{1D540}",
        iota: "\u03B9",
        Iota: "\u0399",
        iprod: "\u2A3C",
        iquest: "\xBF",
        iscr: "\u{1D4BE}",
        Iscr: "\u2110",
        isin: "\u2208",
        isindot: "\u22F5",
        isinE: "\u22F9",
        isins: "\u22F4",
        isinsv: "\u22F3",
        isinv: "\u2208",
        it: "\u2062",
        itilde: "\u0129",
        Itilde: "\u0128",
        iukcy: "\u0456",
        Iukcy: "\u0406",
        iuml: "\xEF",
        Iuml: "\xCF",
        jcirc: "\u0135",
        Jcirc: "\u0134",
        jcy: "\u0439",
        Jcy: "\u0419",
        jfr: "\u{1D527}",
        Jfr: "\u{1D50D}",
        jmath: "\u0237",
        jopf: "\u{1D55B}",
        Jopf: "\u{1D541}",
        jscr: "\u{1D4BF}",
        Jscr: "\u{1D4A5}",
        jsercy: "\u0458",
        Jsercy: "\u0408",
        jukcy: "\u0454",
        Jukcy: "\u0404",
        kappa: "\u03BA",
        Kappa: "\u039A",
        kappav: "\u03F0",
        kcedil: "\u0137",
        Kcedil: "\u0136",
        kcy: "\u043A",
        Kcy: "\u041A",
        kfr: "\u{1D528}",
        Kfr: "\u{1D50E}",
        kgreen: "\u0138",
        khcy: "\u0445",
        KHcy: "\u0425",
        kjcy: "\u045C",
        KJcy: "\u040C",
        kopf: "\u{1D55C}",
        Kopf: "\u{1D542}",
        kscr: "\u{1D4C0}",
        Kscr: "\u{1D4A6}",
        lAarr: "\u21DA",
        lacute: "\u013A",
        Lacute: "\u0139",
        laemptyv: "\u29B4",
        lagran: "\u2112",
        lambda: "\u03BB",
        Lambda: "\u039B",
        lang: "\u27E8",
        Lang: "\u27EA",
        langd: "\u2991",
        langle: "\u27E8",
        lap: "\u2A85",
        Laplacetrf: "\u2112",
        laquo: "\xAB",
        larr: "\u2190",
        lArr: "\u21D0",
        Larr: "\u219E",
        larrb: "\u21E4",
        larrbfs: "\u291F",
        larrfs: "\u291D",
        larrhk: "\u21A9",
        larrlp: "\u21AB",
        larrpl: "\u2939",
        larrsim: "\u2973",
        larrtl: "\u21A2",
        lat: "\u2AAB",
        latail: "\u2919",
        lAtail: "\u291B",
        late: "\u2AAD",
        lates: "\u2AAD\uFE00",
        lbarr: "\u290C",
        lBarr: "\u290E",
        lbbrk: "\u2772",
        lbrace: "{",
        lbrack: "[",
        lbrke: "\u298B",
        lbrksld: "\u298F",
        lbrkslu: "\u298D",
        lcaron: "\u013E",
        Lcaron: "\u013D",
        lcedil: "\u013C",
        Lcedil: "\u013B",
        lceil: "\u2308",
        lcub: "{",
        lcy: "\u043B",
        Lcy: "\u041B",
        ldca: "\u2936",
        ldquo: "\u201C",
        ldquor: "\u201E",
        ldrdhar: "\u2967",
        ldrushar: "\u294B",
        ldsh: "\u21B2",
        le: "\u2264",
        lE: "\u2266",
        LeftAngleBracket: "\u27E8",
        leftarrow: "\u2190",
        Leftarrow: "\u21D0",
        LeftArrow: "\u2190",
        LeftArrowBar: "\u21E4",
        LeftArrowRightArrow: "\u21C6",
        leftarrowtail: "\u21A2",
        LeftCeiling: "\u2308",
        LeftDoubleBracket: "\u27E6",
        LeftDownTeeVector: "\u2961",
        LeftDownVector: "\u21C3",
        LeftDownVectorBar: "\u2959",
        LeftFloor: "\u230A",
        leftharpoondown: "\u21BD",
        leftharpoonup: "\u21BC",
        leftleftarrows: "\u21C7",
        leftrightarrow: "\u2194",
        Leftrightarrow: "\u21D4",
        LeftRightArrow: "\u2194",
        leftrightarrows: "\u21C6",
        leftrightharpoons: "\u21CB",
        leftrightsquigarrow: "\u21AD",
        LeftRightVector: "\u294E",
        LeftTee: "\u22A3",
        LeftTeeArrow: "\u21A4",
        LeftTeeVector: "\u295A",
        leftthreetimes: "\u22CB",
        LeftTriangle: "\u22B2",
        LeftTriangleBar: "\u29CF",
        LeftTriangleEqual: "\u22B4",
        LeftUpDownVector: "\u2951",
        LeftUpTeeVector: "\u2960",
        LeftUpVector: "\u21BF",
        LeftUpVectorBar: "\u2958",
        LeftVector: "\u21BC",
        LeftVectorBar: "\u2952",
        leg: "\u22DA",
        lEg: "\u2A8B",
        leq: "\u2264",
        leqq: "\u2266",
        leqslant: "\u2A7D",
        les: "\u2A7D",
        lescc: "\u2AA8",
        lesdot: "\u2A7F",
        lesdoto: "\u2A81",
        lesdotor: "\u2A83",
        lesg: "\u22DA\uFE00",
        lesges: "\u2A93",
        lessapprox: "\u2A85",
        lessdot: "\u22D6",
        lesseqgtr: "\u22DA",
        lesseqqgtr: "\u2A8B",
        LessEqualGreater: "\u22DA",
        LessFullEqual: "\u2266",
        LessGreater: "\u2276",
        lessgtr: "\u2276",
        LessLess: "\u2AA1",
        lesssim: "\u2272",
        LessSlantEqual: "\u2A7D",
        LessTilde: "\u2272",
        lfisht: "\u297C",
        lfloor: "\u230A",
        lfr: "\u{1D529}",
        Lfr: "\u{1D50F}",
        lg: "\u2276",
        lgE: "\u2A91",
        lHar: "\u2962",
        lhard: "\u21BD",
        lharu: "\u21BC",
        lharul: "\u296A",
        lhblk: "\u2584",
        ljcy: "\u0459",
        LJcy: "\u0409",
        ll: "\u226A",
        Ll: "\u22D8",
        llarr: "\u21C7",
        llcorner: "\u231E",
        Lleftarrow: "\u21DA",
        llhard: "\u296B",
        lltri: "\u25FA",
        lmidot: "\u0140",
        Lmidot: "\u013F",
        lmoust: "\u23B0",
        lmoustache: "\u23B0",
        lnap: "\u2A89",
        lnapprox: "\u2A89",
        lne: "\u2A87",
        lnE: "\u2268",
        lneq: "\u2A87",
        lneqq: "\u2268",
        lnsim: "\u22E6",
        loang: "\u27EC",
        loarr: "\u21FD",
        lobrk: "\u27E6",
        longleftarrow: "\u27F5",
        Longleftarrow: "\u27F8",
        LongLeftArrow: "\u27F5",
        longleftrightarrow: "\u27F7",
        Longleftrightarrow: "\u27FA",
        LongLeftRightArrow: "\u27F7",
        longmapsto: "\u27FC",
        longrightarrow: "\u27F6",
        Longrightarrow: "\u27F9",
        LongRightArrow: "\u27F6",
        looparrowleft: "\u21AB",
        looparrowright: "\u21AC",
        lopar: "\u2985",
        lopf: "\u{1D55D}",
        Lopf: "\u{1D543}",
        loplus: "\u2A2D",
        lotimes: "\u2A34",
        lowast: "\u2217",
        lowbar: "_",
        LowerLeftArrow: "\u2199",
        LowerRightArrow: "\u2198",
        loz: "\u25CA",
        lozenge: "\u25CA",
        lozf: "\u29EB",
        lpar: "(",
        lparlt: "\u2993",
        lrarr: "\u21C6",
        lrcorner: "\u231F",
        lrhar: "\u21CB",
        lrhard: "\u296D",
        lrm: "\u200E",
        lrtri: "\u22BF",
        lsaquo: "\u2039",
        lscr: "\u{1D4C1}",
        Lscr: "\u2112",
        lsh: "\u21B0",
        Lsh: "\u21B0",
        lsim: "\u2272",
        lsime: "\u2A8D",
        lsimg: "\u2A8F",
        lsqb: "[",
        lsquo: "\u2018",
        lsquor: "\u201A",
        lstrok: "\u0142",
        Lstrok: "\u0141",
        lt: "<",
        Lt: "\u226A",
        LT: "<",
        ltcc: "\u2AA6",
        ltcir: "\u2A79",
        ltdot: "\u22D6",
        lthree: "\u22CB",
        ltimes: "\u22C9",
        ltlarr: "\u2976",
        ltquest: "\u2A7B",
        ltri: "\u25C3",
        ltrie: "\u22B4",
        ltrif: "\u25C2",
        ltrPar: "\u2996",
        lurdshar: "\u294A",
        luruhar: "\u2966",
        lvertneqq: "\u2268\uFE00",
        lvnE: "\u2268\uFE00",
        macr: "\xAF",
        male: "\u2642",
        malt: "\u2720",
        maltese: "\u2720",
        map: "\u21A6",
        Map: "\u2905",
        mapsto: "\u21A6",
        mapstodown: "\u21A7",
        mapstoleft: "\u21A4",
        mapstoup: "\u21A5",
        marker: "\u25AE",
        mcomma: "\u2A29",
        mcy: "\u043C",
        Mcy: "\u041C",
        mdash: "\u2014",
        mDDot: "\u223A",
        measuredangle: "\u2221",
        MediumSpace: "\u205F",
        Mellintrf: "\u2133",
        mfr: "\u{1D52A}",
        Mfr: "\u{1D510}",
        mho: "\u2127",
        micro: "\xB5",
        mid: "\u2223",
        midast: "*",
        midcir: "\u2AF0",
        middot: "\xB7",
        minus: "\u2212",
        minusb: "\u229F",
        minusd: "\u2238",
        minusdu: "\u2A2A",
        MinusPlus: "\u2213",
        mlcp: "\u2ADB",
        mldr: "\u2026",
        mnplus: "\u2213",
        models: "\u22A7",
        mopf: "\u{1D55E}",
        Mopf: "\u{1D544}",
        mp: "\u2213",
        mscr: "\u{1D4C2}",
        Mscr: "\u2133",
        mstpos: "\u223E",
        mu: "\u03BC",
        Mu: "\u039C",
        multimap: "\u22B8",
        mumap: "\u22B8",
        nabla: "\u2207",
        nacute: "\u0144",
        Nacute: "\u0143",
        nang: "\u2220\u20D2",
        nap: "\u2249",
        napE: "\u2A70\u0338",
        napid: "\u224B\u0338",
        napos: "\u0149",
        napprox: "\u2249",
        natur: "\u266E",
        natural: "\u266E",
        naturals: "\u2115",
        nbsp: "\xA0",
        nbump: "\u224E\u0338",
        nbumpe: "\u224F\u0338",
        ncap: "\u2A43",
        ncaron: "\u0148",
        Ncaron: "\u0147",
        ncedil: "\u0146",
        Ncedil: "\u0145",
        ncong: "\u2247",
        ncongdot: "\u2A6D\u0338",
        ncup: "\u2A42",
        ncy: "\u043D",
        Ncy: "\u041D",
        ndash: "\u2013",
        ne: "\u2260",
        nearhk: "\u2924",
        nearr: "\u2197",
        neArr: "\u21D7",
        nearrow: "\u2197",
        nedot: "\u2250\u0338",
        NegativeMediumSpace: "\u200B",
        NegativeThickSpace: "\u200B",
        NegativeThinSpace: "\u200B",
        NegativeVeryThinSpace: "\u200B",
        nequiv: "\u2262",
        nesear: "\u2928",
        nesim: "\u2242\u0338",
        NestedGreaterGreater: "\u226B",
        NestedLessLess: "\u226A",
        NewLine: "\n",
        nexist: "\u2204",
        nexists: "\u2204",
        nfr: "\u{1D52B}",
        Nfr: "\u{1D511}",
        nge: "\u2271",
        ngE: "\u2267\u0338",
        ngeq: "\u2271",
        ngeqq: "\u2267\u0338",
        ngeqslant: "\u2A7E\u0338",
        nges: "\u2A7E\u0338",
        nGg: "\u22D9\u0338",
        ngsim: "\u2275",
        ngt: "\u226F",
        nGt: "\u226B\u20D2",
        ngtr: "\u226F",
        nGtv: "\u226B\u0338",
        nharr: "\u21AE",
        nhArr: "\u21CE",
        nhpar: "\u2AF2",
        ni: "\u220B",
        nis: "\u22FC",
        nisd: "\u22FA",
        niv: "\u220B",
        njcy: "\u045A",
        NJcy: "\u040A",
        nlarr: "\u219A",
        nlArr: "\u21CD",
        nldr: "\u2025",
        nle: "\u2270",
        nlE: "\u2266\u0338",
        nleftarrow: "\u219A",
        nLeftarrow: "\u21CD",
        nleftrightarrow: "\u21AE",
        nLeftrightarrow: "\u21CE",
        nleq: "\u2270",
        nleqq: "\u2266\u0338",
        nleqslant: "\u2A7D\u0338",
        nles: "\u2A7D\u0338",
        nless: "\u226E",
        nLl: "\u22D8\u0338",
        nlsim: "\u2274",
        nlt: "\u226E",
        nLt: "\u226A\u20D2",
        nltri: "\u22EA",
        nltrie: "\u22EC",
        nLtv: "\u226A\u0338",
        nmid: "\u2224",
        NoBreak: "\u2060",
        NonBreakingSpace: "\xA0",
        nopf: "\u{1D55F}",
        Nopf: "\u2115",
        not: "\xAC",
        Not: "\u2AEC",
        NotCongruent: "\u2262",
        NotCupCap: "\u226D",
        NotDoubleVerticalBar: "\u2226",
        NotElement: "\u2209",
        NotEqual: "\u2260",
        NotEqualTilde: "\u2242\u0338",
        NotExists: "\u2204",
        NotGreater: "\u226F",
        NotGreaterEqual: "\u2271",
        NotGreaterFullEqual: "\u2267\u0338",
        NotGreaterGreater: "\u226B\u0338",
        NotGreaterLess: "\u2279",
        NotGreaterSlantEqual: "\u2A7E\u0338",
        NotGreaterTilde: "\u2275",
        NotHumpDownHump: "\u224E\u0338",
        NotHumpEqual: "\u224F\u0338",
        notin: "\u2209",
        notindot: "\u22F5\u0338",
        notinE: "\u22F9\u0338",
        notinva: "\u2209",
        notinvb: "\u22F7",
        notinvc: "\u22F6",
        NotLeftTriangle: "\u22EA",
        NotLeftTriangleBar: "\u29CF\u0338",
        NotLeftTriangleEqual: "\u22EC",
        NotLess: "\u226E",
        NotLessEqual: "\u2270",
        NotLessGreater: "\u2278",
        NotLessLess: "\u226A\u0338",
        NotLessSlantEqual: "\u2A7D\u0338",
        NotLessTilde: "\u2274",
        NotNestedGreaterGreater: "\u2AA2\u0338",
        NotNestedLessLess: "\u2AA1\u0338",
        notni: "\u220C",
        notniva: "\u220C",
        notnivb: "\u22FE",
        notnivc: "\u22FD",
        NotPrecedes: "\u2280",
        NotPrecedesEqual: "\u2AAF\u0338",
        NotPrecedesSlantEqual: "\u22E0",
        NotReverseElement: "\u220C",
        NotRightTriangle: "\u22EB",
        NotRightTriangleBar: "\u29D0\u0338",
        NotRightTriangleEqual: "\u22ED",
        NotSquareSubset: "\u228F\u0338",
        NotSquareSubsetEqual: "\u22E2",
        NotSquareSuperset: "\u2290\u0338",
        NotSquareSupersetEqual: "\u22E3",
        NotSubset: "\u2282\u20D2",
        NotSubsetEqual: "\u2288",
        NotSucceeds: "\u2281",
        NotSucceedsEqual: "\u2AB0\u0338",
        NotSucceedsSlantEqual: "\u22E1",
        NotSucceedsTilde: "\u227F\u0338",
        NotSuperset: "\u2283\u20D2",
        NotSupersetEqual: "\u2289",
        NotTilde: "\u2241",
        NotTildeEqual: "\u2244",
        NotTildeFullEqual: "\u2247",
        NotTildeTilde: "\u2249",
        NotVerticalBar: "\u2224",
        npar: "\u2226",
        nparallel: "\u2226",
        nparsl: "\u2AFD\u20E5",
        npart: "\u2202\u0338",
        npolint: "\u2A14",
        npr: "\u2280",
        nprcue: "\u22E0",
        npre: "\u2AAF\u0338",
        nprec: "\u2280",
        npreceq: "\u2AAF\u0338",
        nrarr: "\u219B",
        nrArr: "\u21CF",
        nrarrc: "\u2933\u0338",
        nrarrw: "\u219D\u0338",
        nrightarrow: "\u219B",
        nRightarrow: "\u21CF",
        nrtri: "\u22EB",
        nrtrie: "\u22ED",
        nsc: "\u2281",
        nsccue: "\u22E1",
        nsce: "\u2AB0\u0338",
        nscr: "\u{1D4C3}",
        Nscr: "\u{1D4A9}",
        nshortmid: "\u2224",
        nshortparallel: "\u2226",
        nsim: "\u2241",
        nsime: "\u2244",
        nsimeq: "\u2244",
        nsmid: "\u2224",
        nspar: "\u2226",
        nsqsube: "\u22E2",
        nsqsupe: "\u22E3",
        nsub: "\u2284",
        nsube: "\u2288",
        nsubE: "\u2AC5\u0338",
        nsubset: "\u2282\u20D2",
        nsubseteq: "\u2288",
        nsubseteqq: "\u2AC5\u0338",
        nsucc: "\u2281",
        nsucceq: "\u2AB0\u0338",
        nsup: "\u2285",
        nsupe: "\u2289",
        nsupE: "\u2AC6\u0338",
        nsupset: "\u2283\u20D2",
        nsupseteq: "\u2289",
        nsupseteqq: "\u2AC6\u0338",
        ntgl: "\u2279",
        ntilde: "\xF1",
        Ntilde: "\xD1",
        ntlg: "\u2278",
        ntriangleleft: "\u22EA",
        ntrianglelefteq: "\u22EC",
        ntriangleright: "\u22EB",
        ntrianglerighteq: "\u22ED",
        nu: "\u03BD",
        Nu: "\u039D",
        num: "#",
        numero: "\u2116",
        numsp: "\u2007",
        nvap: "\u224D\u20D2",
        nvdash: "\u22AC",
        nvDash: "\u22AD",
        nVdash: "\u22AE",
        nVDash: "\u22AF",
        nvge: "\u2265\u20D2",
        nvgt: ">\u20D2",
        nvHarr: "\u2904",
        nvinfin: "\u29DE",
        nvlArr: "\u2902",
        nvle: "\u2264\u20D2",
        nvlt: "<\u20D2",
        nvltrie: "\u22B4\u20D2",
        nvrArr: "\u2903",
        nvrtrie: "\u22B5\u20D2",
        nvsim: "\u223C\u20D2",
        nwarhk: "\u2923",
        nwarr: "\u2196",
        nwArr: "\u21D6",
        nwarrow: "\u2196",
        nwnear: "\u2927",
        oacute: "\xF3",
        Oacute: "\xD3",
        oast: "\u229B",
        ocir: "\u229A",
        ocirc: "\xF4",
        Ocirc: "\xD4",
        ocy: "\u043E",
        Ocy: "\u041E",
        odash: "\u229D",
        odblac: "\u0151",
        Odblac: "\u0150",
        odiv: "\u2A38",
        odot: "\u2299",
        odsold: "\u29BC",
        oelig: "\u0153",
        OElig: "\u0152",
        ofcir: "\u29BF",
        ofr: "\u{1D52C}",
        Ofr: "\u{1D512}",
        ogon: "\u02DB",
        ograve: "\xF2",
        Ograve: "\xD2",
        ogt: "\u29C1",
        ohbar: "\u29B5",
        ohm: "\u03A9",
        oint: "\u222E",
        olarr: "\u21BA",
        olcir: "\u29BE",
        olcross: "\u29BB",
        oline: "\u203E",
        olt: "\u29C0",
        omacr: "\u014D",
        Omacr: "\u014C",
        omega: "\u03C9",
        Omega: "\u03A9",
        omicron: "\u03BF",
        Omicron: "\u039F",
        omid: "\u29B6",
        ominus: "\u2296",
        oopf: "\u{1D560}",
        Oopf: "\u{1D546}",
        opar: "\u29B7",
        OpenCurlyDoubleQuote: "\u201C",
        OpenCurlyQuote: "\u2018",
        operp: "\u29B9",
        oplus: "\u2295",
        or: "\u2228",
        Or: "\u2A54",
        orarr: "\u21BB",
        ord: "\u2A5D",
        order: "\u2134",
        orderof: "\u2134",
        ordf: "\xAA",
        ordm: "\xBA",
        origof: "\u22B6",
        oror: "\u2A56",
        orslope: "\u2A57",
        orv: "\u2A5B",
        oS: "\u24C8",
        oscr: "\u2134",
        Oscr: "\u{1D4AA}",
        oslash: "\xF8",
        Oslash: "\xD8",
        osol: "\u2298",
        otilde: "\xF5",
        Otilde: "\xD5",
        otimes: "\u2297",
        Otimes: "\u2A37",
        otimesas: "\u2A36",
        ouml: "\xF6",
        Ouml: "\xD6",
        ovbar: "\u233D",
        OverBar: "\u203E",
        OverBrace: "\u23DE",
        OverBracket: "\u23B4",
        OverParenthesis: "\u23DC",
        par: "\u2225",
        para: "\xB6",
        parallel: "\u2225",
        parsim: "\u2AF3",
        parsl: "\u2AFD",
        part: "\u2202",
        PartialD: "\u2202",
        pcy: "\u043F",
        Pcy: "\u041F",
        percnt: "%",
        period: ".",
        permil: "\u2030",
        perp: "\u22A5",
        pertenk: "\u2031",
        pfr: "\u{1D52D}",
        Pfr: "\u{1D513}",
        phi: "\u03C6",
        Phi: "\u03A6",
        phiv: "\u03D5",
        phmmat: "\u2133",
        phone: "\u260E",
        pi: "\u03C0",
        Pi: "\u03A0",
        pitchfork: "\u22D4",
        piv: "\u03D6",
        planck: "\u210F",
        planckh: "\u210E",
        plankv: "\u210F",
        plus: "+",
        plusacir: "\u2A23",
        plusb: "\u229E",
        pluscir: "\u2A22",
        plusdo: "\u2214",
        plusdu: "\u2A25",
        pluse: "\u2A72",
        PlusMinus: "\xB1",
        plusmn: "\xB1",
        plussim: "\u2A26",
        plustwo: "\u2A27",
        pm: "\xB1",
        Poincareplane: "\u210C",
        pointint: "\u2A15",
        popf: "\u{1D561}",
        Popf: "\u2119",
        pound: "\xA3",
        pr: "\u227A",
        Pr: "\u2ABB",
        prap: "\u2AB7",
        prcue: "\u227C",
        pre: "\u2AAF",
        prE: "\u2AB3",
        prec: "\u227A",
        precapprox: "\u2AB7",
        preccurlyeq: "\u227C",
        Precedes: "\u227A",
        PrecedesEqual: "\u2AAF",
        PrecedesSlantEqual: "\u227C",
        PrecedesTilde: "\u227E",
        preceq: "\u2AAF",
        precnapprox: "\u2AB9",
        precneqq: "\u2AB5",
        precnsim: "\u22E8",
        precsim: "\u227E",
        prime: "\u2032",
        Prime: "\u2033",
        primes: "\u2119",
        prnap: "\u2AB9",
        prnE: "\u2AB5",
        prnsim: "\u22E8",
        prod: "\u220F",
        Product: "\u220F",
        profalar: "\u232E",
        profline: "\u2312",
        profsurf: "\u2313",
        prop: "\u221D",
        Proportion: "\u2237",
        Proportional: "\u221D",
        propto: "\u221D",
        prsim: "\u227E",
        prurel: "\u22B0",
        pscr: "\u{1D4C5}",
        Pscr: "\u{1D4AB}",
        psi: "\u03C8",
        Psi: "\u03A8",
        puncsp: "\u2008",
        qfr: "\u{1D52E}",
        Qfr: "\u{1D514}",
        qint: "\u2A0C",
        qopf: "\u{1D562}",
        Qopf: "\u211A",
        qprime: "\u2057",
        qscr: "\u{1D4C6}",
        Qscr: "\u{1D4AC}",
        quaternions: "\u210D",
        quatint: "\u2A16",
        quest: "?",
        questeq: "\u225F",
        quot: '"',
        QUOT: '"',
        rAarr: "\u21DB",
        race: "\u223D\u0331",
        racute: "\u0155",
        Racute: "\u0154",
        radic: "\u221A",
        raemptyv: "\u29B3",
        rang: "\u27E9",
        Rang: "\u27EB",
        rangd: "\u2992",
        range: "\u29A5",
        rangle: "\u27E9",
        raquo: "\xBB",
        rarr: "\u2192",
        rArr: "\u21D2",
        Rarr: "\u21A0",
        rarrap: "\u2975",
        rarrb: "\u21E5",
        rarrbfs: "\u2920",
        rarrc: "\u2933",
        rarrfs: "\u291E",
        rarrhk: "\u21AA",
        rarrlp: "\u21AC",
        rarrpl: "\u2945",
        rarrsim: "\u2974",
        rarrtl: "\u21A3",
        Rarrtl: "\u2916",
        rarrw: "\u219D",
        ratail: "\u291A",
        rAtail: "\u291C",
        ratio: "\u2236",
        rationals: "\u211A",
        rbarr: "\u290D",
        rBarr: "\u290F",
        RBarr: "\u2910",
        rbbrk: "\u2773",
        rbrace: "}",
        rbrack: "]",
        rbrke: "\u298C",
        rbrksld: "\u298E",
        rbrkslu: "\u2990",
        rcaron: "\u0159",
        Rcaron: "\u0158",
        rcedil: "\u0157",
        Rcedil: "\u0156",
        rceil: "\u2309",
        rcub: "}",
        rcy: "\u0440",
        Rcy: "\u0420",
        rdca: "\u2937",
        rdldhar: "\u2969",
        rdquo: "\u201D",
        rdquor: "\u201D",
        rdsh: "\u21B3",
        Re: "\u211C",
        real: "\u211C",
        realine: "\u211B",
        realpart: "\u211C",
        reals: "\u211D",
        rect: "\u25AD",
        reg: "\xAE",
        REG: "\xAE",
        ReverseElement: "\u220B",
        ReverseEquilibrium: "\u21CB",
        ReverseUpEquilibrium: "\u296F",
        rfisht: "\u297D",
        rfloor: "\u230B",
        rfr: "\u{1D52F}",
        Rfr: "\u211C",
        rHar: "\u2964",
        rhard: "\u21C1",
        rharu: "\u21C0",
        rharul: "\u296C",
        rho: "\u03C1",
        Rho: "\u03A1",
        rhov: "\u03F1",
        RightAngleBracket: "\u27E9",
        rightarrow: "\u2192",
        Rightarrow: "\u21D2",
        RightArrow: "\u2192",
        RightArrowBar: "\u21E5",
        RightArrowLeftArrow: "\u21C4",
        rightarrowtail: "\u21A3",
        RightCeiling: "\u2309",
        RightDoubleBracket: "\u27E7",
        RightDownTeeVector: "\u295D",
        RightDownVector: "\u21C2",
        RightDownVectorBar: "\u2955",
        RightFloor: "\u230B",
        rightharpoondown: "\u21C1",
        rightharpoonup: "\u21C0",
        rightleftarrows: "\u21C4",
        rightleftharpoons: "\u21CC",
        rightrightarrows: "\u21C9",
        rightsquigarrow: "\u219D",
        RightTee: "\u22A2",
        RightTeeArrow: "\u21A6",
        RightTeeVector: "\u295B",
        rightthreetimes: "\u22CC",
        RightTriangle: "\u22B3",
        RightTriangleBar: "\u29D0",
        RightTriangleEqual: "\u22B5",
        RightUpDownVector: "\u294F",
        RightUpTeeVector: "\u295C",
        RightUpVector: "\u21BE",
        RightUpVectorBar: "\u2954",
        RightVector: "\u21C0",
        RightVectorBar: "\u2953",
        ring: "\u02DA",
        risingdotseq: "\u2253",
        rlarr: "\u21C4",
        rlhar: "\u21CC",
        rlm: "\u200F",
        rmoust: "\u23B1",
        rmoustache: "\u23B1",
        rnmid: "\u2AEE",
        roang: "\u27ED",
        roarr: "\u21FE",
        robrk: "\u27E7",
        ropar: "\u2986",
        ropf: "\u{1D563}",
        Ropf: "\u211D",
        roplus: "\u2A2E",
        rotimes: "\u2A35",
        RoundImplies: "\u2970",
        rpar: ")",
        rpargt: "\u2994",
        rppolint: "\u2A12",
        rrarr: "\u21C9",
        Rrightarrow: "\u21DB",
        rsaquo: "\u203A",
        rscr: "\u{1D4C7}",
        Rscr: "\u211B",
        rsh: "\u21B1",
        Rsh: "\u21B1",
        rsqb: "]",
        rsquo: "\u2019",
        rsquor: "\u2019",
        rthree: "\u22CC",
        rtimes: "\u22CA",
        rtri: "\u25B9",
        rtrie: "\u22B5",
        rtrif: "\u25B8",
        rtriltri: "\u29CE",
        RuleDelayed: "\u29F4",
        ruluhar: "\u2968",
        rx: "\u211E",
        sacute: "\u015B",
        Sacute: "\u015A",
        sbquo: "\u201A",
        sc: "\u227B",
        Sc: "\u2ABC",
        scap: "\u2AB8",
        scaron: "\u0161",
        Scaron: "\u0160",
        sccue: "\u227D",
        sce: "\u2AB0",
        scE: "\u2AB4",
        scedil: "\u015F",
        Scedil: "\u015E",
        scirc: "\u015D",
        Scirc: "\u015C",
        scnap: "\u2ABA",
        scnE: "\u2AB6",
        scnsim: "\u22E9",
        scpolint: "\u2A13",
        scsim: "\u227F",
        scy: "\u0441",
        Scy: "\u0421",
        sdot: "\u22C5",
        sdotb: "\u22A1",
        sdote: "\u2A66",
        searhk: "\u2925",
        searr: "\u2198",
        seArr: "\u21D8",
        searrow: "\u2198",
        sect: "\xA7",
        semi: ";",
        seswar: "\u2929",
        setminus: "\u2216",
        setmn: "\u2216",
        sext: "\u2736",
        sfr: "\u{1D530}",
        Sfr: "\u{1D516}",
        sfrown: "\u2322",
        sharp: "\u266F",
        shchcy: "\u0449",
        SHCHcy: "\u0429",
        shcy: "\u0448",
        SHcy: "\u0428",
        ShortDownArrow: "\u2193",
        ShortLeftArrow: "\u2190",
        shortmid: "\u2223",
        shortparallel: "\u2225",
        ShortRightArrow: "\u2192",
        ShortUpArrow: "\u2191",
        shy: "\xAD",
        sigma: "\u03C3",
        Sigma: "\u03A3",
        sigmaf: "\u03C2",
        sigmav: "\u03C2",
        sim: "\u223C",
        simdot: "\u2A6A",
        sime: "\u2243",
        simeq: "\u2243",
        simg: "\u2A9E",
        simgE: "\u2AA0",
        siml: "\u2A9D",
        simlE: "\u2A9F",
        simne: "\u2246",
        simplus: "\u2A24",
        simrarr: "\u2972",
        slarr: "\u2190",
        SmallCircle: "\u2218",
        smallsetminus: "\u2216",
        smashp: "\u2A33",
        smeparsl: "\u29E4",
        smid: "\u2223",
        smile: "\u2323",
        smt: "\u2AAA",
        smte: "\u2AAC",
        smtes: "\u2AAC\uFE00",
        softcy: "\u044C",
        SOFTcy: "\u042C",
        sol: "/",
        solb: "\u29C4",
        solbar: "\u233F",
        sopf: "\u{1D564}",
        Sopf: "\u{1D54A}",
        spades: "\u2660",
        spadesuit: "\u2660",
        spar: "\u2225",
        sqcap: "\u2293",
        sqcaps: "\u2293\uFE00",
        sqcup: "\u2294",
        sqcups: "\u2294\uFE00",
        Sqrt: "\u221A",
        sqsub: "\u228F",
        sqsube: "\u2291",
        sqsubset: "\u228F",
        sqsubseteq: "\u2291",
        sqsup: "\u2290",
        sqsupe: "\u2292",
        sqsupset: "\u2290",
        sqsupseteq: "\u2292",
        squ: "\u25A1",
        square: "\u25A1",
        Square: "\u25A1",
        SquareIntersection: "\u2293",
        SquareSubset: "\u228F",
        SquareSubsetEqual: "\u2291",
        SquareSuperset: "\u2290",
        SquareSupersetEqual: "\u2292",
        SquareUnion: "\u2294",
        squarf: "\u25AA",
        squf: "\u25AA",
        srarr: "\u2192",
        sscr: "\u{1D4C8}",
        Sscr: "\u{1D4AE}",
        ssetmn: "\u2216",
        ssmile: "\u2323",
        sstarf: "\u22C6",
        star: "\u2606",
        Star: "\u22C6",
        starf: "\u2605",
        straightepsilon: "\u03F5",
        straightphi: "\u03D5",
        strns: "\xAF",
        sub: "\u2282",
        Sub: "\u22D0",
        subdot: "\u2ABD",
        sube: "\u2286",
        subE: "\u2AC5",
        subedot: "\u2AC3",
        submult: "\u2AC1",
        subne: "\u228A",
        subnE: "\u2ACB",
        subplus: "\u2ABF",
        subrarr: "\u2979",
        subset: "\u2282",
        Subset: "\u22D0",
        subseteq: "\u2286",
        subseteqq: "\u2AC5",
        SubsetEqual: "\u2286",
        subsetneq: "\u228A",
        subsetneqq: "\u2ACB",
        subsim: "\u2AC7",
        subsub: "\u2AD5",
        subsup: "\u2AD3",
        succ: "\u227B",
        succapprox: "\u2AB8",
        succcurlyeq: "\u227D",
        Succeeds: "\u227B",
        SucceedsEqual: "\u2AB0",
        SucceedsSlantEqual: "\u227D",
        SucceedsTilde: "\u227F",
        succeq: "\u2AB0",
        succnapprox: "\u2ABA",
        succneqq: "\u2AB6",
        succnsim: "\u22E9",
        succsim: "\u227F",
        SuchThat: "\u220B",
        sum: "\u2211",
        Sum: "\u2211",
        sung: "\u266A",
        sup: "\u2283",
        Sup: "\u22D1",
        sup1: "\xB9",
        sup2: "\xB2",
        sup3: "\xB3",
        supdot: "\u2ABE",
        supdsub: "\u2AD8",
        supe: "\u2287",
        supE: "\u2AC6",
        supedot: "\u2AC4",
        Superset: "\u2283",
        SupersetEqual: "\u2287",
        suphsol: "\u27C9",
        suphsub: "\u2AD7",
        suplarr: "\u297B",
        supmult: "\u2AC2",
        supne: "\u228B",
        supnE: "\u2ACC",
        supplus: "\u2AC0",
        supset: "\u2283",
        Supset: "\u22D1",
        supseteq: "\u2287",
        supseteqq: "\u2AC6",
        supsetneq: "\u228B",
        supsetneqq: "\u2ACC",
        supsim: "\u2AC8",
        supsub: "\u2AD4",
        supsup: "\u2AD6",
        swarhk: "\u2926",
        swarr: "\u2199",
        swArr: "\u21D9",
        swarrow: "\u2199",
        swnwar: "\u292A",
        szlig: "\xDF",
        Tab: "	",
        target: "\u2316",
        tau: "\u03C4",
        Tau: "\u03A4",
        tbrk: "\u23B4",
        tcaron: "\u0165",
        Tcaron: "\u0164",
        tcedil: "\u0163",
        Tcedil: "\u0162",
        tcy: "\u0442",
        Tcy: "\u0422",
        tdot: "\u20DB",
        telrec: "\u2315",
        tfr: "\u{1D531}",
        Tfr: "\u{1D517}",
        there4: "\u2234",
        therefore: "\u2234",
        Therefore: "\u2234",
        theta: "\u03B8",
        Theta: "\u0398",
        thetasym: "\u03D1",
        thetav: "\u03D1",
        thickapprox: "\u2248",
        thicksim: "\u223C",
        ThickSpace: "\u205F\u200A",
        thinsp: "\u2009",
        ThinSpace: "\u2009",
        thkap: "\u2248",
        thksim: "\u223C",
        thorn: "\xFE",
        THORN: "\xDE",
        tilde: "\u02DC",
        Tilde: "\u223C",
        TildeEqual: "\u2243",
        TildeFullEqual: "\u2245",
        TildeTilde: "\u2248",
        times: "\xD7",
        timesb: "\u22A0",
        timesbar: "\u2A31",
        timesd: "\u2A30",
        tint: "\u222D",
        toea: "\u2928",
        top: "\u22A4",
        topbot: "\u2336",
        topcir: "\u2AF1",
        topf: "\u{1D565}",
        Topf: "\u{1D54B}",
        topfork: "\u2ADA",
        tosa: "\u2929",
        tprime: "\u2034",
        trade: "\u2122",
        TRADE: "\u2122",
        triangle: "\u25B5",
        triangledown: "\u25BF",
        triangleleft: "\u25C3",
        trianglelefteq: "\u22B4",
        triangleq: "\u225C",
        triangleright: "\u25B9",
        trianglerighteq: "\u22B5",
        tridot: "\u25EC",
        trie: "\u225C",
        triminus: "\u2A3A",
        TripleDot: "\u20DB",
        triplus: "\u2A39",
        trisb: "\u29CD",
        tritime: "\u2A3B",
        trpezium: "\u23E2",
        tscr: "\u{1D4C9}",
        Tscr: "\u{1D4AF}",
        tscy: "\u0446",
        TScy: "\u0426",
        tshcy: "\u045B",
        TSHcy: "\u040B",
        tstrok: "\u0167",
        Tstrok: "\u0166",
        twixt: "\u226C",
        twoheadleftarrow: "\u219E",
        twoheadrightarrow: "\u21A0",
        uacute: "\xFA",
        Uacute: "\xDA",
        uarr: "\u2191",
        uArr: "\u21D1",
        Uarr: "\u219F",
        Uarrocir: "\u2949",
        ubrcy: "\u045E",
        Ubrcy: "\u040E",
        ubreve: "\u016D",
        Ubreve: "\u016C",
        ucirc: "\xFB",
        Ucirc: "\xDB",
        ucy: "\u0443",
        Ucy: "\u0423",
        udarr: "\u21C5",
        udblac: "\u0171",
        Udblac: "\u0170",
        udhar: "\u296E",
        ufisht: "\u297E",
        ufr: "\u{1D532}",
        Ufr: "\u{1D518}",
        ugrave: "\xF9",
        Ugrave: "\xD9",
        uHar: "\u2963",
        uharl: "\u21BF",
        uharr: "\u21BE",
        uhblk: "\u2580",
        ulcorn: "\u231C",
        ulcorner: "\u231C",
        ulcrop: "\u230F",
        ultri: "\u25F8",
        umacr: "\u016B",
        Umacr: "\u016A",
        uml: "\xA8",
        UnderBar: "_",
        UnderBrace: "\u23DF",
        UnderBracket: "\u23B5",
        UnderParenthesis: "\u23DD",
        Union: "\u22C3",
        UnionPlus: "\u228E",
        uogon: "\u0173",
        Uogon: "\u0172",
        uopf: "\u{1D566}",
        Uopf: "\u{1D54C}",
        uparrow: "\u2191",
        Uparrow: "\u21D1",
        UpArrow: "\u2191",
        UpArrowBar: "\u2912",
        UpArrowDownArrow: "\u21C5",
        updownarrow: "\u2195",
        Updownarrow: "\u21D5",
        UpDownArrow: "\u2195",
        UpEquilibrium: "\u296E",
        upharpoonleft: "\u21BF",
        upharpoonright: "\u21BE",
        uplus: "\u228E",
        UpperLeftArrow: "\u2196",
        UpperRightArrow: "\u2197",
        upsi: "\u03C5",
        Upsi: "\u03D2",
        upsih: "\u03D2",
        upsilon: "\u03C5",
        Upsilon: "\u03A5",
        UpTee: "\u22A5",
        UpTeeArrow: "\u21A5",
        upuparrows: "\u21C8",
        urcorn: "\u231D",
        urcorner: "\u231D",
        urcrop: "\u230E",
        uring: "\u016F",
        Uring: "\u016E",
        urtri: "\u25F9",
        uscr: "\u{1D4CA}",
        Uscr: "\u{1D4B0}",
        utdot: "\u22F0",
        utilde: "\u0169",
        Utilde: "\u0168",
        utri: "\u25B5",
        utrif: "\u25B4",
        uuarr: "\u21C8",
        uuml: "\xFC",
        Uuml: "\xDC",
        uwangle: "\u29A7",
        vangrt: "\u299C",
        varepsilon: "\u03F5",
        varkappa: "\u03F0",
        varnothing: "\u2205",
        varphi: "\u03D5",
        varpi: "\u03D6",
        varpropto: "\u221D",
        varr: "\u2195",
        vArr: "\u21D5",
        varrho: "\u03F1",
        varsigma: "\u03C2",
        varsubsetneq: "\u228A\uFE00",
        varsubsetneqq: "\u2ACB\uFE00",
        varsupsetneq: "\u228B\uFE00",
        varsupsetneqq: "\u2ACC\uFE00",
        vartheta: "\u03D1",
        vartriangleleft: "\u22B2",
        vartriangleright: "\u22B3",
        vBar: "\u2AE8",
        Vbar: "\u2AEB",
        vBarv: "\u2AE9",
        vcy: "\u0432",
        Vcy: "\u0412",
        vdash: "\u22A2",
        vDash: "\u22A8",
        Vdash: "\u22A9",
        VDash: "\u22AB",
        Vdashl: "\u2AE6",
        vee: "\u2228",
        Vee: "\u22C1",
        veebar: "\u22BB",
        veeeq: "\u225A",
        vellip: "\u22EE",
        verbar: "|",
        Verbar: "\u2016",
        vert: "|",
        Vert: "\u2016",
        VerticalBar: "\u2223",
        VerticalLine: "|",
        VerticalSeparator: "\u2758",
        VerticalTilde: "\u2240",
        VeryThinSpace: "\u200A",
        vfr: "\u{1D533}",
        Vfr: "\u{1D519}",
        vltri: "\u22B2",
        vnsub: "\u2282\u20D2",
        vnsup: "\u2283\u20D2",
        vopf: "\u{1D567}",
        Vopf: "\u{1D54D}",
        vprop: "\u221D",
        vrtri: "\u22B3",
        vscr: "\u{1D4CB}",
        Vscr: "\u{1D4B1}",
        vsubne: "\u228A\uFE00",
        vsubnE: "\u2ACB\uFE00",
        vsupne: "\u228B\uFE00",
        vsupnE: "\u2ACC\uFE00",
        Vvdash: "\u22AA",
        vzigzag: "\u299A",
        wcirc: "\u0175",
        Wcirc: "\u0174",
        wedbar: "\u2A5F",
        wedge: "\u2227",
        Wedge: "\u22C0",
        wedgeq: "\u2259",
        weierp: "\u2118",
        wfr: "\u{1D534}",
        Wfr: "\u{1D51A}",
        wopf: "\u{1D568}",
        Wopf: "\u{1D54E}",
        wp: "\u2118",
        wr: "\u2240",
        wreath: "\u2240",
        wscr: "\u{1D4CC}",
        Wscr: "\u{1D4B2}",
        xcap: "\u22C2",
        xcirc: "\u25EF",
        xcup: "\u22C3",
        xdtri: "\u25BD",
        xfr: "\u{1D535}",
        Xfr: "\u{1D51B}",
        xharr: "\u27F7",
        xhArr: "\u27FA",
        xi: "\u03BE",
        Xi: "\u039E",
        xlarr: "\u27F5",
        xlArr: "\u27F8",
        xmap: "\u27FC",
        xnis: "\u22FB",
        xodot: "\u2A00",
        xopf: "\u{1D569}",
        Xopf: "\u{1D54F}",
        xoplus: "\u2A01",
        xotime: "\u2A02",
        xrarr: "\u27F6",
        xrArr: "\u27F9",
        xscr: "\u{1D4CD}",
        Xscr: "\u{1D4B3}",
        xsqcup: "\u2A06",
        xuplus: "\u2A04",
        xutri: "\u25B3",
        xvee: "\u22C1",
        xwedge: "\u22C0",
        yacute: "\xFD",
        Yacute: "\xDD",
        yacy: "\u044F",
        YAcy: "\u042F",
        ycirc: "\u0177",
        Ycirc: "\u0176",
        ycy: "\u044B",
        Ycy: "\u042B",
        yen: "\xA5",
        yfr: "\u{1D536}",
        Yfr: "\u{1D51C}",
        yicy: "\u0457",
        YIcy: "\u0407",
        yopf: "\u{1D56A}",
        Yopf: "\u{1D550}",
        yscr: "\u{1D4CE}",
        Yscr: "\u{1D4B4}",
        yucy: "\u044E",
        YUcy: "\u042E",
        yuml: "\xFF",
        Yuml: "\u0178",
        zacute: "\u017A",
        Zacute: "\u0179",
        zcaron: "\u017E",
        Zcaron: "\u017D",
        zcy: "\u0437",
        Zcy: "\u0417",
        zdot: "\u017C",
        Zdot: "\u017B",
        zeetrf: "\u2128",
        ZeroWidthSpace: "\u200B",
        zeta: "\u03B6",
        Zeta: "\u0396",
        zfr: "\u{1D537}",
        Zfr: "\u2128",
        zhcy: "\u0436",
        ZHcy: "\u0416",
        zigrarr: "\u21DD",
        zopf: "\u{1D56B}",
        Zopf: "\u2124",
        zscr: "\u{1D4CF}",
        Zscr: "\u{1D4B5}",
        zwj: "\u200D",
        zwnj: "\u200C",
      };
      var decodeMapLegacy = {
        aacute: "\xE1",
        Aacute: "\xC1",
        acirc: "\xE2",
        Acirc: "\xC2",
        acute: "\xB4",
        aelig: "\xE6",
        AElig: "\xC6",
        agrave: "\xE0",
        Agrave: "\xC0",
        amp: "&",
        AMP: "&",
        aring: "\xE5",
        Aring: "\xC5",
        atilde: "\xE3",
        Atilde: "\xC3",
        auml: "\xE4",
        Auml: "\xC4",
        brvbar: "\xA6",
        ccedil: "\xE7",
        Ccedil: "\xC7",
        cedil: "\xB8",
        cent: "\xA2",
        copy: "\xA9",
        COPY: "\xA9",
        curren: "\xA4",
        deg: "\xB0",
        divide: "\xF7",
        eacute: "\xE9",
        Eacute: "\xC9",
        ecirc: "\xEA",
        Ecirc: "\xCA",
        egrave: "\xE8",
        Egrave: "\xC8",
        eth: "\xF0",
        ETH: "\xD0",
        euml: "\xEB",
        Euml: "\xCB",
        frac12: "\xBD",
        frac14: "\xBC",
        frac34: "\xBE",
        gt: ">",
        GT: ">",
        iacute: "\xED",
        Iacute: "\xCD",
        icirc: "\xEE",
        Icirc: "\xCE",
        iexcl: "\xA1",
        igrave: "\xEC",
        Igrave: "\xCC",
        iquest: "\xBF",
        iuml: "\xEF",
        Iuml: "\xCF",
        laquo: "\xAB",
        lt: "<",
        LT: "<",
        macr: "\xAF",
        micro: "\xB5",
        middot: "\xB7",
        nbsp: "\xA0",
        not: "\xAC",
        ntilde: "\xF1",
        Ntilde: "\xD1",
        oacute: "\xF3",
        Oacute: "\xD3",
        ocirc: "\xF4",
        Ocirc: "\xD4",
        ograve: "\xF2",
        Ograve: "\xD2",
        ordf: "\xAA",
        ordm: "\xBA",
        oslash: "\xF8",
        Oslash: "\xD8",
        otilde: "\xF5",
        Otilde: "\xD5",
        ouml: "\xF6",
        Ouml: "\xD6",
        para: "\xB6",
        plusmn: "\xB1",
        pound: "\xA3",
        quot: '"',
        QUOT: '"',
        raquo: "\xBB",
        reg: "\xAE",
        REG: "\xAE",
        sect: "\xA7",
        shy: "\xAD",
        sup1: "\xB9",
        sup2: "\xB2",
        sup3: "\xB3",
        szlig: "\xDF",
        thorn: "\xFE",
        THORN: "\xDE",
        times: "\xD7",
        uacute: "\xFA",
        Uacute: "\xDA",
        ucirc: "\xFB",
        Ucirc: "\xDB",
        ugrave: "\xF9",
        Ugrave: "\xD9",
        uml: "\xA8",
        uuml: "\xFC",
        Uuml: "\xDC",
        yacute: "\xFD",
        Yacute: "\xDD",
        yen: "\xA5",
        yuml: "\xFF",
      };
      var decodeMapNumeric = {
        0: "\uFFFD",
        128: "\u20AC",
        130: "\u201A",
        131: "\u0192",
        132: "\u201E",
        133: "\u2026",
        134: "\u2020",
        135: "\u2021",
        136: "\u02C6",
        137: "\u2030",
        138: "\u0160",
        139: "\u2039",
        140: "\u0152",
        142: "\u017D",
        145: "\u2018",
        146: "\u2019",
        147: "\u201C",
        148: "\u201D",
        149: "\u2022",
        150: "\u2013",
        151: "\u2014",
        152: "\u02DC",
        153: "\u2122",
        154: "\u0161",
        155: "\u203A",
        156: "\u0153",
        158: "\u017E",
        159: "\u0178",
      };
      var invalidReferenceCodePoints = [
        1, 2, 3, 4, 5, 6, 7, 8, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
        24, 25, 26, 27, 28, 29, 30, 31, 127, 128, 129, 130, 131, 132, 133, 134,
        135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,
        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 64976, 64977,
        64978, 64979, 64980, 64981, 64982, 64983, 64984, 64985, 64986, 64987,
        64988, 64989, 64990, 64991, 64992, 64993, 64994, 64995, 64996, 64997,
        64998, 64999, 65e3, 65001, 65002, 65003, 65004, 65005, 65006, 65007,
        65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678,
        327679, 393214, 393215, 458750, 458751, 524286, 524287, 589822, 589823,
        655358, 655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502,
        917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111,
      ];
      var stringFromCharCode = String.fromCharCode;
      var object4 = {};
      var hasOwnProperty = object4.hasOwnProperty;
      var has = function (object5, propertyName) {
        return hasOwnProperty.call(object5, propertyName);
      };
      var contains = function (array3, value) {
        var index = -1;
        var length = array3.length;
        while (++index < length) {
          if (array3[index] == value) {
            return true;
          }
        }
        return false;
      };
      var merge4 = function (options, defaults) {
        if (!options) {
          return defaults;
        }
        var result = {};
        var key2;
        for (key2 in defaults) {
          result[key2] = has(options, key2) ? options[key2] : defaults[key2];
        }
        return result;
      };
      var codePointToSymbol = function (codePoint, strict) {
        var output = "";
        if ((codePoint >= 55296 && codePoint <= 57343) || codePoint > 1114111) {
          if (strict) {
            parseError(
              "character reference outside the permissible Unicode range",
            );
          }
          return "\uFFFD";
        }
        if (has(decodeMapNumeric, codePoint)) {
          if (strict) {
            parseError("disallowed character reference");
          }
          return decodeMapNumeric[codePoint];
        }
        if (strict && contains(invalidReferenceCodePoints, codePoint)) {
          parseError("disallowed character reference");
        }
        if (codePoint > 65535) {
          codePoint -= 65536;
          output += stringFromCharCode(((codePoint >>> 10) & 1023) | 55296);
          codePoint = 56320 | (codePoint & 1023);
        }
        output += stringFromCharCode(codePoint);
        return output;
      };
      var hexEscape = function (codePoint) {
        return "&#x" + codePoint.toString(16).toUpperCase() + ";";
      };
      var decEscape = function (codePoint) {
        return "&#" + codePoint + ";";
      };
      var parseError = function (message) {
        throw Error("Parse error: " + message);
      };
      var encode4 = function (string5, options) {
        options = merge4(options, encode4.options);
        var strict = options.strict;
        if (strict && regexInvalidRawCodePoint.test(string5)) {
          parseError("forbidden code point");
        }
        var encodeEverything = options.encodeEverything;
        var useNamedReferences = options.useNamedReferences;
        var allowUnsafeSymbols = options.allowUnsafeSymbols;
        var escapeCodePoint = options.decimal ? decEscape : hexEscape;
        var escapeBmpSymbol = function (symbol19) {
          return escapeCodePoint(symbol19.charCodeAt(0));
        };
        if (encodeEverything) {
          string5 = string5.replace(regexAsciiWhitelist, function (symbol19) {
            if (useNamedReferences && has(encodeMap, symbol19)) {
              return "&" + encodeMap[symbol19] + ";";
            }
            return escapeBmpSymbol(symbol19);
          });
          if (useNamedReferences) {
            string5 = string5
              .replace(/&gt;\u20D2/g, "&nvgt;")
              .replace(/&lt;\u20D2/g, "&nvlt;")
              .replace(/&#x66;&#x6A;/g, "&fjlig;");
          }
          if (useNamedReferences) {
            string5 = string5.replace(regexEncodeNonAscii, function (string6) {
              return "&" + encodeMap[string6] + ";";
            });
          }
        } else if (useNamedReferences) {
          if (!allowUnsafeSymbols) {
            string5 = string5.replace(regexEscape, function (string6) {
              return "&" + encodeMap[string6] + ";";
            });
          }
          string5 = string5
            .replace(/&gt;\u20D2/g, "&nvgt;")
            .replace(/&lt;\u20D2/g, "&nvlt;");
          string5 = string5.replace(regexEncodeNonAscii, function (string6) {
            return "&" + encodeMap[string6] + ";";
          });
        } else if (!allowUnsafeSymbols) {
          string5 = string5.replace(regexEscape, escapeBmpSymbol);
        }
        return string5
          .replace(regexAstralSymbols, function ($0) {
            var high = $0.charCodeAt(0);
            var low = $0.charCodeAt(1);
            var codePoint = (high - 55296) * 1024 + low - 56320 + 65536;
            return escapeCodePoint(codePoint);
          })
          .replace(regexBmpWhitelist, escapeBmpSymbol);
      };
      encode4.options = {
        allowUnsafeSymbols: false,
        encodeEverything: false,
        strict: false,
        useNamedReferences: false,
        decimal: false,
      };
      var decode4 = function (html, options) {
        options = merge4(options, decode4.options);
        var strict = options.strict;
        if (strict && regexInvalidEntity.test(html)) {
          parseError("malformed character reference");
        }
        return html.replace(
          regexDecode,
          function ($0, $1, $2, $3, $4, $5, $6, $7, $8) {
            var codePoint;
            var semicolon;
            var decDigits;
            var hexDigits;
            var reference;
            var next;
            if ($1) {
              reference = $1;
              return decodeMap[reference];
            }
            if ($2) {
              reference = $2;
              next = $3;
              if (next && options.isAttributeValue) {
                if (strict && next == "=") {
                  parseError("`&` did not start a character reference");
                }
                return $0;
              } else {
                if (strict) {
                  parseError(
                    "named character reference was not terminated by a semicolon",
                  );
                }
                return decodeMapLegacy[reference] + (next || "");
              }
            }
            if ($4) {
              decDigits = $4;
              semicolon = $5;
              if (strict && !semicolon) {
                parseError(
                  "character reference was not terminated by a semicolon",
                );
              }
              codePoint = parseInt(decDigits, 10);
              return codePointToSymbol(codePoint, strict);
            }
            if ($6) {
              hexDigits = $6;
              semicolon = $7;
              if (strict && !semicolon) {
                parseError(
                  "character reference was not terminated by a semicolon",
                );
              }
              codePoint = parseInt(hexDigits, 16);
              return codePointToSymbol(codePoint, strict);
            }
            if (strict) {
              parseError(
                "named character reference was not terminated by a semicolon",
              );
            }
            return $0;
          },
        );
      };
      decode4.options = {
        isAttributeValue: false,
        strict: false,
      };
      var escape = function (string5) {
        return string5.replace(regexEscape, function ($0) {
          return escapeMap[$0];
        });
      };
      var he = {
        version: "1.2.0",
        encode: encode4,
        decode: decode4,
        escape: escape,
        unescape: decode4,
      };
      if (
        typeof define == "function" &&
        typeof define.amd == "object" &&
        define.amd
      ) {
        define(function () {
          return he;
        });
      } else if (freeExports && !freeExports.nodeType) {
        if (freeModule) {
          freeModule.exports = he;
        } else {
          for (var key in he) {
            has(he, key) && (freeExports[key] = he[key]);
          }
        }
      } else {
        root.he = he;
      }
    })(exports);
  },
});

// node_modules/node-html-parser/dist/nodes/node.js
var require_node = __commonJS({
  "node_modules/node-html-parser/dist/nodes/node.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var he_1 = require_he();
    var Node =
      /** @class */
      (function () {
        function Node2(parentNode, range) {
          if (parentNode === void 0) {
            parentNode = null;
          }
          this.parentNode = parentNode;
          this.childNodes = [];
          Object.defineProperty(this, "range", {
            enumerable: false,
            writable: true,
            configurable: true,
            value: range !== null && range !== void 0 ? range : [-1, -1],
          });
        }
        Node2.prototype.remove = function () {
          var _this = this;
          if (this.parentNode) {
            var children = this.parentNode.childNodes;
            this.parentNode.childNodes = children.filter(function (child) {
              return _this !== child;
            });
            this.parentNode = null;
          }
          return this;
        };
        Object.defineProperty(Node2.prototype, "innerText", {
          get: function () {
            return this.rawText;
          },
          enumerable: false,
          configurable: true,
        });
        Object.defineProperty(Node2.prototype, "textContent", {
          get: function () {
            return (0, he_1.decode)(this.rawText);
          },
          set: function (val) {
            this.rawText = (0, he_1.encode)(val);
          },
          enumerable: false,
          configurable: true,
        });
        return Node2;
      })();
    exports.default = Node;
  },
});

// node_modules/node-html-parser/dist/nodes/type.js
var require_type = __commonJS({
  "node_modules/node-html-parser/dist/nodes/type.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var NodeType;
    (function (NodeType2) {
      NodeType2[(NodeType2["ELEMENT_NODE"] = 1)] = "ELEMENT_NODE";
      NodeType2[(NodeType2["TEXT_NODE"] = 3)] = "TEXT_NODE";
      NodeType2[(NodeType2["COMMENT_NODE"] = 8)] = "COMMENT_NODE";
    })(NodeType || (NodeType = {}));
    exports.default = NodeType;
  },
});

// node_modules/node-html-parser/dist/nodes/comment.js
var require_comment = __commonJS({
  "node_modules/node-html-parser/dist/nodes/comment.js"(exports) {
    "use strict";
    var __extends =
      (exports && exports.__extends) ||
      /* @__PURE__ */ (function () {
        var extendStatics = function (d2, b2) {
          extendStatics =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (d3, b3) {
                d3.__proto__ = b3;
              }) ||
            function (d3, b3) {
              for (var p2 in b3)
                if (Object.prototype.hasOwnProperty.call(b3, p2))
                  d3[p2] = b3[p2];
            };
          return extendStatics(d2, b2);
        };
        return function (d2, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError(
              "Class extends value " +
                String(b2) +
                " is not a constructor or null",
            );
          extendStatics(d2, b2);
          function __() {
            this.constructor = d2;
          }
          d2.prototype =
            b2 === null
              ? Object.create(b2)
              : ((__.prototype = b2.prototype), new __());
        };
      })();
    var __importDefault =
      (exports && exports.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports, "__esModule", { value: true });
    var node_1 = __importDefault(require_node());
    var type_1 = __importDefault(require_type());
    var CommentNode =
      /** @class */
      (function (_super) {
        __extends(CommentNode2, _super);
        function CommentNode2(rawText, parentNode, range, rawTagName) {
          if (parentNode === void 0) {
            parentNode = null;
          }
          if (rawTagName === void 0) {
            rawTagName = "!--";
          }
          var _this = _super.call(this, parentNode, range) || this;
          _this.rawText = rawText;
          _this.rawTagName = rawTagName;
          _this.nodeType = type_1.default.COMMENT_NODE;
          return _this;
        }
        CommentNode2.prototype.clone = function () {
          return new CommentNode2(this.rawText, null, void 0, this.rawTagName);
        };
        Object.defineProperty(CommentNode2.prototype, "text", {
          /**
           * Get unescaped text value of current node and its children.
           * @return {string} text content
           */
          get: function () {
            return this.rawText;
          },
          enumerable: false,
          configurable: true,
        });
        CommentNode2.prototype.toString = function () {
          return "<!--".concat(this.rawText, "-->");
        };
        return CommentNode2;
      })(node_1.default);
    exports.default = CommentNode;
  },
});

// node_modules/domelementtype/lib/index.js
var require_lib = __commonJS({
  "node_modules/domelementtype/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Doctype =
      exports.CDATA =
      exports.Tag =
      exports.Style =
      exports.Script =
      exports.Comment =
      exports.Directive =
      exports.Text =
      exports.Root =
      exports.isTag =
      exports.ElementType =
        void 0;
    var ElementType;
    (function (ElementType2) {
      ElementType2["Root"] = "root";
      ElementType2["Text"] = "text";
      ElementType2["Directive"] = "directive";
      ElementType2["Comment"] = "comment";
      ElementType2["Script"] = "script";
      ElementType2["Style"] = "style";
      ElementType2["Tag"] = "tag";
      ElementType2["CDATA"] = "cdata";
      ElementType2["Doctype"] = "doctype";
    })((ElementType = exports.ElementType || (exports.ElementType = {})));
    function isTag(elem) {
      return (
        elem.type === ElementType.Tag ||
        elem.type === ElementType.Script ||
        elem.type === ElementType.Style
      );
    }
    exports.isTag = isTag;
    exports.Root = ElementType.Root;
    exports.Text = ElementType.Text;
    exports.Directive = ElementType.Directive;
    exports.Comment = ElementType.Comment;
    exports.Script = ElementType.Script;
    exports.Style = ElementType.Style;
    exports.Tag = ElementType.Tag;
    exports.CDATA = ElementType.CDATA;
    exports.Doctype = ElementType.Doctype;
  },
});

// node_modules/domhandler/lib/node.js
var require_node2 = __commonJS({
  "node_modules/domhandler/lib/node.js"(exports) {
    "use strict";
    var __extends =
      (exports && exports.__extends) ||
      /* @__PURE__ */ (function () {
        var extendStatics = function (d2, b2) {
          extendStatics =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (d3, b3) {
                d3.__proto__ = b3;
              }) ||
            function (d3, b3) {
              for (var p2 in b3)
                if (Object.prototype.hasOwnProperty.call(b3, p2))
                  d3[p2] = b3[p2];
            };
          return extendStatics(d2, b2);
        };
        return function (d2, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError(
              "Class extends value " +
                String(b2) +
                " is not a constructor or null",
            );
          extendStatics(d2, b2);
          function __() {
            this.constructor = d2;
          }
          d2.prototype =
            b2 === null
              ? Object.create(b2)
              : ((__.prototype = b2.prototype), new __());
        };
      })();
    var __assign =
      (exports && exports.__assign) ||
      function () {
        __assign =
          Object.assign ||
          function (t2) {
            for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {
              s2 = arguments[i2];
              for (var p2 in s2)
                if (Object.prototype.hasOwnProperty.call(s2, p2))
                  t2[p2] = s2[p2];
            }
            return t2;
          };
        return __assign.apply(this, arguments);
      };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.cloneNode =
      exports.hasChildren =
      exports.isDocument =
      exports.isDirective =
      exports.isComment =
      exports.isText =
      exports.isCDATA =
      exports.isTag =
      exports.Element =
      exports.Document =
      exports.CDATA =
      exports.NodeWithChildren =
      exports.ProcessingInstruction =
      exports.Comment =
      exports.Text =
      exports.DataNode =
      exports.Node =
        void 0;
    var domelementtype_1 = require_lib();
    var Node =
      /** @class */
      (function () {
        function Node2() {
          this.parent = null;
          this.prev = null;
          this.next = null;
          this.startIndex = null;
          this.endIndex = null;
        }
        Object.defineProperty(Node2.prototype, "parentNode", {
          // Read-write aliases for properties
          /**
           * Same as {@link parent}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function () {
            return this.parent;
          },
          set: function (parent) {
            this.parent = parent;
          },
          enumerable: false,
          configurable: true,
        });
        Object.defineProperty(Node2.prototype, "previousSibling", {
          /**
           * Same as {@link prev}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function () {
            return this.prev;
          },
          set: function (prev) {
            this.prev = prev;
          },
          enumerable: false,
          configurable: true,
        });
        Object.defineProperty(Node2.prototype, "nextSibling", {
          /**
           * Same as {@link next}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function () {
            return this.next;
          },
          set: function (next) {
            this.next = next;
          },
          enumerable: false,
          configurable: true,
        });
        Node2.prototype.cloneNode = function (recursive) {
          if (recursive === void 0) {
            recursive = false;
          }
          return cloneNode(this, recursive);
        };
        return Node2;
      })();
    exports.Node = Node;
    var DataNode =
      /** @class */
      (function (_super) {
        __extends(DataNode2, _super);
        function DataNode2(data) {
          var _this = _super.call(this) || this;
          _this.data = data;
          return _this;
        }
        Object.defineProperty(DataNode2.prototype, "nodeValue", {
          /**
           * Same as {@link data}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function () {
            return this.data;
          },
          set: function (data) {
            this.data = data;
          },
          enumerable: false,
          configurable: true,
        });
        return DataNode2;
      })(Node);
    exports.DataNode = DataNode;
    var Text =
      /** @class */
      (function (_super) {
        __extends(Text2, _super);
        function Text2() {
          var _this =
            (_super !== null && _super.apply(this, arguments)) || this;
          _this.type = domelementtype_1.ElementType.Text;
          return _this;
        }
        Object.defineProperty(Text2.prototype, "nodeType", {
          get: function () {
            return 3;
          },
          enumerable: false,
          configurable: true,
        });
        return Text2;
      })(DataNode);
    exports.Text = Text;
    var Comment =
      /** @class */
      (function (_super) {
        __extends(Comment2, _super);
        function Comment2() {
          var _this =
            (_super !== null && _super.apply(this, arguments)) || this;
          _this.type = domelementtype_1.ElementType.Comment;
          return _this;
        }
        Object.defineProperty(Comment2.prototype, "nodeType", {
          get: function () {
            return 8;
          },
          enumerable: false,
          configurable: true,
        });
        return Comment2;
      })(DataNode);
    exports.Comment = Comment;
    var ProcessingInstruction =
      /** @class */
      (function (_super) {
        __extends(ProcessingInstruction2, _super);
        function ProcessingInstruction2(name18, data) {
          var _this = _super.call(this, data) || this;
          _this.name = name18;
          _this.type = domelementtype_1.ElementType.Directive;
          return _this;
        }
        Object.defineProperty(ProcessingInstruction2.prototype, "nodeType", {
          get: function () {
            return 1;
          },
          enumerable: false,
          configurable: true,
        });
        return ProcessingInstruction2;
      })(DataNode);
    exports.ProcessingInstruction = ProcessingInstruction;
    var NodeWithChildren =
      /** @class */
      (function (_super) {
        __extends(NodeWithChildren2, _super);
        function NodeWithChildren2(children) {
          var _this = _super.call(this) || this;
          _this.children = children;
          return _this;
        }
        Object.defineProperty(NodeWithChildren2.prototype, "firstChild", {
          // Aliases
          /** First child of the node. */
          get: function () {
            var _a19;
            return (_a19 = this.children[0]) !== null && _a19 !== void 0
              ? _a19
              : null;
          },
          enumerable: false,
          configurable: true,
        });
        Object.defineProperty(NodeWithChildren2.prototype, "lastChild", {
          /** Last child of the node. */
          get: function () {
            return this.children.length > 0
              ? this.children[this.children.length - 1]
              : null;
          },
          enumerable: false,
          configurable: true,
        });
        Object.defineProperty(NodeWithChildren2.prototype, "childNodes", {
          /**
           * Same as {@link children}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function () {
            return this.children;
          },
          set: function (children) {
            this.children = children;
          },
          enumerable: false,
          configurable: true,
        });
        return NodeWithChildren2;
      })(Node);
    exports.NodeWithChildren = NodeWithChildren;
    var CDATA =
      /** @class */
      (function (_super) {
        __extends(CDATA2, _super);
        function CDATA2() {
          var _this =
            (_super !== null && _super.apply(this, arguments)) || this;
          _this.type = domelementtype_1.ElementType.CDATA;
          return _this;
        }
        Object.defineProperty(CDATA2.prototype, "nodeType", {
          get: function () {
            return 4;
          },
          enumerable: false,
          configurable: true,
        });
        return CDATA2;
      })(NodeWithChildren);
    exports.CDATA = CDATA;
    var Document =
      /** @class */
      (function (_super) {
        __extends(Document2, _super);
        function Document2() {
          var _this =
            (_super !== null && _super.apply(this, arguments)) || this;
          _this.type = domelementtype_1.ElementType.Root;
          return _this;
        }
        Object.defineProperty(Document2.prototype, "nodeType", {
          get: function () {
            return 9;
          },
          enumerable: false,
          configurable: true,
        });
        return Document2;
      })(NodeWithChildren);
    exports.Document = Document;
    var Element =
      /** @class */
      (function (_super) {
        __extends(Element2, _super);
        function Element2(name18, attribs, children, type) {
          if (children === void 0) {
            children = [];
          }
          if (type === void 0) {
            type =
              name18 === "script"
                ? domelementtype_1.ElementType.Script
                : name18 === "style"
                  ? domelementtype_1.ElementType.Style
                  : domelementtype_1.ElementType.Tag;
          }
          var _this = _super.call(this, children) || this;
          _this.name = name18;
          _this.attribs = attribs;
          _this.type = type;
          return _this;
        }
        Object.defineProperty(Element2.prototype, "nodeType", {
          get: function () {
            return 1;
          },
          enumerable: false,
          configurable: true,
        });
        Object.defineProperty(Element2.prototype, "tagName", {
          // DOM Level 1 aliases
          /**
           * Same as {@link name}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function () {
            return this.name;
          },
          set: function (name18) {
            this.name = name18;
          },
          enumerable: false,
          configurable: true,
        });
        Object.defineProperty(Element2.prototype, "attributes", {
          get: function () {
            var _this = this;
            return Object.keys(this.attribs).map(function (name18) {
              var _a19, _b9;
              return {
                name: name18,
                value: _this.attribs[name18],
                namespace:
                  (_a19 = _this["x-attribsNamespace"]) === null ||
                  _a19 === void 0
                    ? void 0
                    : _a19[name18],
                prefix:
                  (_b9 = _this["x-attribsPrefix"]) === null || _b9 === void 0
                    ? void 0
                    : _b9[name18],
              };
            });
          },
          enumerable: false,
          configurable: true,
        });
        return Element2;
      })(NodeWithChildren);
    exports.Element = Element;
    function isTag(node) {
      return (0, domelementtype_1.isTag)(node);
    }
    exports.isTag = isTag;
    function isCDATA(node) {
      return node.type === domelementtype_1.ElementType.CDATA;
    }
    exports.isCDATA = isCDATA;
    function isText(node) {
      return node.type === domelementtype_1.ElementType.Text;
    }
    exports.isText = isText;
    function isComment(node) {
      return node.type === domelementtype_1.ElementType.Comment;
    }
    exports.isComment = isComment;
    function isDirective(node) {
      return node.type === domelementtype_1.ElementType.Directive;
    }
    exports.isDirective = isDirective;
    function isDocument(node) {
      return node.type === domelementtype_1.ElementType.Root;
    }
    exports.isDocument = isDocument;
    function hasChildren(node) {
      return Object.prototype.hasOwnProperty.call(node, "children");
    }
    exports.hasChildren = hasChildren;
    function cloneNode(node, recursive) {
      if (recursive === void 0) {
        recursive = false;
      }
      var result;
      if (isText(node)) {
        result = new Text(node.data);
      } else if (isComment(node)) {
        result = new Comment(node.data);
      } else if (isTag(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_1 = new Element(
          node.name,
          __assign({}, node.attribs),
          children,
        );
        children.forEach(function (child) {
          return (child.parent = clone_1);
        });
        if (node.namespace != null) {
          clone_1.namespace = node.namespace;
        }
        if (node["x-attribsNamespace"]) {
          clone_1["x-attribsNamespace"] = __assign(
            {},
            node["x-attribsNamespace"],
          );
        }
        if (node["x-attribsPrefix"]) {
          clone_1["x-attribsPrefix"] = __assign({}, node["x-attribsPrefix"]);
        }
        result = clone_1;
      } else if (isCDATA(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_2 = new CDATA(children);
        children.forEach(function (child) {
          return (child.parent = clone_2);
        });
        result = clone_2;
      } else if (isDocument(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_3 = new Document(children);
        children.forEach(function (child) {
          return (child.parent = clone_3);
        });
        if (node["x-mode"]) {
          clone_3["x-mode"] = node["x-mode"];
        }
        result = clone_3;
      } else if (isDirective(node)) {
        var instruction = new ProcessingInstruction(node.name, node.data);
        if (node["x-name"] != null) {
          instruction["x-name"] = node["x-name"];
          instruction["x-publicId"] = node["x-publicId"];
          instruction["x-systemId"] = node["x-systemId"];
        }
        result = instruction;
      } else {
        throw new Error("Not implemented yet: ".concat(node.type));
      }
      result.startIndex = node.startIndex;
      result.endIndex = node.endIndex;
      if (node.sourceCodeLocation != null) {
        result.sourceCodeLocation = node.sourceCodeLocation;
      }
      return result;
    }
    exports.cloneNode = cloneNode;
    function cloneChildren(childs) {
      var children = childs.map(function (child) {
        return cloneNode(child, true);
      });
      for (var i2 = 1; i2 < children.length; i2++) {
        children[i2].prev = children[i2 - 1];
        children[i2 - 1].next = children[i2];
      }
      return children;
    }
  },
});

// node_modules/domhandler/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/domhandler/lib/index.js"(exports) {
    "use strict";
    var __createBinding =
      (exports && exports.__createBinding) ||
      (Object.create
        ? function (o2, m2, k, k2) {
            if (k2 === void 0) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m2, k);
            if (
              !desc ||
              ("get" in desc
                ? !m2.__esModule
                : desc.writable || desc.configurable)
            ) {
              desc = {
                enumerable: true,
                get: function () {
                  return m2[k];
                },
              };
            }
            Object.defineProperty(o2, k2, desc);
          }
        : function (o2, m2, k, k2) {
            if (k2 === void 0) k2 = k;
            o2[k2] = m2[k];
          });
    var __exportStar =
      (exports && exports.__exportStar) ||
      function (m2, exports2) {
        for (var p2 in m2)
          if (
            p2 !== "default" &&
            !Object.prototype.hasOwnProperty.call(exports2, p2)
          )
            __createBinding(exports2, m2, p2);
      };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DomHandler = void 0;
    var domelementtype_1 = require_lib();
    var node_js_1 = require_node2();
    __exportStar(require_node2(), exports);
    var defaultOpts = {
      withStartIndices: false,
      withEndIndices: false,
      xmlMode: false,
    };
    var DomHandler =
      /** @class */
      (function () {
        function DomHandler2(callback, options, elementCB) {
          this.dom = [];
          this.root = new node_js_1.Document(this.dom);
          this.done = false;
          this.tagStack = [this.root];
          this.lastNode = null;
          this.parser = null;
          if (typeof options === "function") {
            elementCB = options;
            options = defaultOpts;
          }
          if (typeof callback === "object") {
            options = callback;
            callback = void 0;
          }
          this.callback =
            callback !== null && callback !== void 0 ? callback : null;
          this.options =
            options !== null && options !== void 0 ? options : defaultOpts;
          this.elementCB =
            elementCB !== null && elementCB !== void 0 ? elementCB : null;
        }
        DomHandler2.prototype.onparserinit = function (parser) {
          this.parser = parser;
        };
        DomHandler2.prototype.onreset = function () {
          this.dom = [];
          this.root = new node_js_1.Document(this.dom);
          this.done = false;
          this.tagStack = [this.root];
          this.lastNode = null;
          this.parser = null;
        };
        DomHandler2.prototype.onend = function () {
          if (this.done) return;
          this.done = true;
          this.parser = null;
          this.handleCallback(null);
        };
        DomHandler2.prototype.onerror = function (error45) {
          this.handleCallback(error45);
        };
        DomHandler2.prototype.onclosetag = function () {
          this.lastNode = null;
          var elem = this.tagStack.pop();
          if (this.options.withEndIndices) {
            elem.endIndex = this.parser.endIndex;
          }
          if (this.elementCB) this.elementCB(elem);
        };
        DomHandler2.prototype.onopentag = function (name18, attribs) {
          var type = this.options.xmlMode
            ? domelementtype_1.ElementType.Tag
            : void 0;
          var element = new node_js_1.Element(name18, attribs, void 0, type);
          this.addNode(element);
          this.tagStack.push(element);
        };
        DomHandler2.prototype.ontext = function (data) {
          var lastNode = this.lastNode;
          if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
            lastNode.data += data;
            if (this.options.withEndIndices) {
              lastNode.endIndex = this.parser.endIndex;
            }
          } else {
            var node = new node_js_1.Text(data);
            this.addNode(node);
            this.lastNode = node;
          }
        };
        DomHandler2.prototype.oncomment = function (data) {
          if (
            this.lastNode &&
            this.lastNode.type === domelementtype_1.ElementType.Comment
          ) {
            this.lastNode.data += data;
            return;
          }
          var node = new node_js_1.Comment(data);
          this.addNode(node);
          this.lastNode = node;
        };
        DomHandler2.prototype.oncommentend = function () {
          this.lastNode = null;
        };
        DomHandler2.prototype.oncdatastart = function () {
          var text2 = new node_js_1.Text("");
          var node = new node_js_1.CDATA([text2]);
          this.addNode(node);
          text2.parent = node;
          this.lastNode = text2;
        };
        DomHandler2.prototype.oncdataend = function () {
          this.lastNode = null;
        };
        DomHandler2.prototype.onprocessinginstruction = function (
          name18,
          data,
        ) {
          var node = new node_js_1.ProcessingInstruction(name18, data);
          this.addNode(node);
        };
        DomHandler2.prototype.handleCallback = function (error45) {
          if (typeof this.callback === "function") {
            this.callback(error45, this.dom);
          } else if (error45) {
            throw error45;
          }
        };
        DomHandler2.prototype.addNode = function (node) {
          var parent = this.tagStack[this.tagStack.length - 1];
          var previousSibling = parent.children[parent.children.length - 1];
          if (this.options.withStartIndices) {
            node.startIndex = this.parser.startIndex;
          }
          if (this.options.withEndIndices) {
            node.endIndex = this.parser.endIndex;
          }
          parent.children.push(node);
          if (previousSibling) {
            node.prev = previousSibling;
            previousSibling.next = node;
          }
          node.parent = parent;
          this.lastNode = null;
        };
        return DomHandler2;
      })();
    exports.DomHandler = DomHandler;
    exports.default = DomHandler;
  },
});

// node_modules/entities/lib/generated/decode-data-html.js
var require_decode_data_html = __commonJS({
  "node_modules/entities/lib/generated/decode-data-html.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = new Uint16Array(
      // prettier-ignore
      '\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map(function(c2) {
        return c2.charCodeAt(0);
      }),
    );
  },
});

// node_modules/entities/lib/generated/decode-data-xml.js
var require_decode_data_xml = __commonJS({
  "node_modules/entities/lib/generated/decode-data-xml.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = new Uint16Array(
      // prettier-ignore
      "\u0200aglq	\x1B\u026D\0\0p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map(function(c2) {
        return c2.charCodeAt(0);
      }),
    );
  },
});

// node_modules/entities/lib/decode_codepoint.js
var require_decode_codepoint = __commonJS({
  "node_modules/entities/lib/decode_codepoint.js"(exports) {
    "use strict";
    var _a19;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.replaceCodePoint = exports.fromCodePoint = void 0;
    var decodeMap = /* @__PURE__ */ new Map([
      [0, 65533],
      // C1 Unicode control character reference replacements
      [128, 8364],
      [130, 8218],
      [131, 402],
      [132, 8222],
      [133, 8230],
      [134, 8224],
      [135, 8225],
      [136, 710],
      [137, 8240],
      [138, 352],
      [139, 8249],
      [140, 338],
      [142, 381],
      [145, 8216],
      [146, 8217],
      [147, 8220],
      [148, 8221],
      [149, 8226],
      [150, 8211],
      [151, 8212],
      [152, 732],
      [153, 8482],
      [154, 353],
      [155, 8250],
      [156, 339],
      [158, 382],
      [159, 376],
    ]);
    exports.fromCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
      (_a19 = String.fromCodePoint) !== null && _a19 !== void 0
        ? _a19
        : function (codePoint) {
            var output = "";
            if (codePoint > 65535) {
              codePoint -= 65536;
              output += String.fromCharCode(
                ((codePoint >>> 10) & 1023) | 55296,
              );
              codePoint = 56320 | (codePoint & 1023);
            }
            output += String.fromCharCode(codePoint);
            return output;
          };
    function replaceCodePoint(codePoint) {
      var _a20;
      if ((codePoint >= 55296 && codePoint <= 57343) || codePoint > 1114111) {
        return 65533;
      }
      return (_a20 = decodeMap.get(codePoint)) !== null && _a20 !== void 0
        ? _a20
        : codePoint;
    }
    exports.replaceCodePoint = replaceCodePoint;
    function decodeCodePoint(codePoint) {
      return (0, exports.fromCodePoint)(replaceCodePoint(codePoint));
    }
    exports.default = decodeCodePoint;
  },
});

// node_modules/entities/lib/decode.js
var require_decode = __commonJS({
  "node_modules/entities/lib/decode.js"(exports) {
    "use strict";
    var __createBinding =
      (exports && exports.__createBinding) ||
      (Object.create
        ? function (o2, m2, k, k2) {
            if (k2 === void 0) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m2, k);
            if (
              !desc ||
              ("get" in desc
                ? !m2.__esModule
                : desc.writable || desc.configurable)
            ) {
              desc = {
                enumerable: true,
                get: function () {
                  return m2[k];
                },
              };
            }
            Object.defineProperty(o2, k2, desc);
          }
        : function (o2, m2, k, k2) {
            if (k2 === void 0) k2 = k;
            o2[k2] = m2[k];
          });
    var __setModuleDefault =
      (exports && exports.__setModuleDefault) ||
      (Object.create
        ? function (o2, v2) {
            Object.defineProperty(o2, "default", {
              enumerable: true,
              value: v2,
            });
          }
        : function (o2, v2) {
            o2["default"] = v2;
          });
    var __importStar =
      (exports && exports.__importStar) ||
      function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    var __importDefault =
      (exports && exports.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeXML =
      exports.decodeHTMLStrict =
      exports.decodeHTMLAttribute =
      exports.decodeHTML =
      exports.determineBranch =
      exports.EntityDecoder =
      exports.DecodingMode =
      exports.BinTrieFlags =
      exports.fromCodePoint =
      exports.replaceCodePoint =
      exports.decodeCodePoint =
      exports.xmlDecodeTree =
      exports.htmlDecodeTree =
        void 0;
    var decode_data_html_js_1 = __importDefault(require_decode_data_html());
    exports.htmlDecodeTree = decode_data_html_js_1.default;
    var decode_data_xml_js_1 = __importDefault(require_decode_data_xml());
    exports.xmlDecodeTree = decode_data_xml_js_1.default;
    var decode_codepoint_js_1 = __importStar(require_decode_codepoint());
    exports.decodeCodePoint = decode_codepoint_js_1.default;
    var decode_codepoint_js_2 = require_decode_codepoint();
    Object.defineProperty(exports, "replaceCodePoint", {
      enumerable: true,
      get: function () {
        return decode_codepoint_js_2.replaceCodePoint;
      },
    });
    Object.defineProperty(exports, "fromCodePoint", {
      enumerable: true,
      get: function () {
        return decode_codepoint_js_2.fromCodePoint;
      },
    });
    var CharCodes;
    (function (CharCodes2) {
      CharCodes2[(CharCodes2["NUM"] = 35)] = "NUM";
      CharCodes2[(CharCodes2["SEMI"] = 59)] = "SEMI";
      CharCodes2[(CharCodes2["EQUALS"] = 61)] = "EQUALS";
      CharCodes2[(CharCodes2["ZERO"] = 48)] = "ZERO";
      CharCodes2[(CharCodes2["NINE"] = 57)] = "NINE";
      CharCodes2[(CharCodes2["LOWER_A"] = 97)] = "LOWER_A";
      CharCodes2[(CharCodes2["LOWER_F"] = 102)] = "LOWER_F";
      CharCodes2[(CharCodes2["LOWER_X"] = 120)] = "LOWER_X";
      CharCodes2[(CharCodes2["LOWER_Z"] = 122)] = "LOWER_Z";
      CharCodes2[(CharCodes2["UPPER_A"] = 65)] = "UPPER_A";
      CharCodes2[(CharCodes2["UPPER_F"] = 70)] = "UPPER_F";
      CharCodes2[(CharCodes2["UPPER_Z"] = 90)] = "UPPER_Z";
    })(CharCodes || (CharCodes = {}));
    var TO_LOWER_BIT = 32;
    var BinTrieFlags;
    (function (BinTrieFlags2) {
      BinTrieFlags2[(BinTrieFlags2["VALUE_LENGTH"] = 49152)] = "VALUE_LENGTH";
      BinTrieFlags2[(BinTrieFlags2["BRANCH_LENGTH"] = 16256)] = "BRANCH_LENGTH";
      BinTrieFlags2[(BinTrieFlags2["JUMP_TABLE"] = 127)] = "JUMP_TABLE";
    })((BinTrieFlags = exports.BinTrieFlags || (exports.BinTrieFlags = {})));
    function isNumber(code) {
      return code >= CharCodes.ZERO && code <= CharCodes.NINE;
    }
    function isHexadecimalCharacter(code) {
      return (
        (code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F) ||
        (code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F)
      );
    }
    function isAsciiAlphaNumeric(code) {
      return (
        (code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z) ||
        (code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z) ||
        isNumber(code)
      );
    }
    function isEntityInAttributeInvalidEnd(code) {
      return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
    }
    var EntityDecoderState;
    (function (EntityDecoderState2) {
      EntityDecoderState2[(EntityDecoderState2["EntityStart"] = 0)] =
        "EntityStart";
      EntityDecoderState2[(EntityDecoderState2["NumericStart"] = 1)] =
        "NumericStart";
      EntityDecoderState2[(EntityDecoderState2["NumericDecimal"] = 2)] =
        "NumericDecimal";
      EntityDecoderState2[(EntityDecoderState2["NumericHex"] = 3)] =
        "NumericHex";
      EntityDecoderState2[(EntityDecoderState2["NamedEntity"] = 4)] =
        "NamedEntity";
    })(EntityDecoderState || (EntityDecoderState = {}));
    var DecodingMode;
    (function (DecodingMode2) {
      DecodingMode2[(DecodingMode2["Legacy"] = 0)] = "Legacy";
      DecodingMode2[(DecodingMode2["Strict"] = 1)] = "Strict";
      DecodingMode2[(DecodingMode2["Attribute"] = 2)] = "Attribute";
    })((DecodingMode = exports.DecodingMode || (exports.DecodingMode = {})));
    var EntityDecoder =
      /** @class */
      (function () {
        function EntityDecoder2(decodeTree, emitCodePoint, errors) {
          this.decodeTree = decodeTree;
          this.emitCodePoint = emitCodePoint;
          this.errors = errors;
          this.state = EntityDecoderState.EntityStart;
          this.consumed = 1;
          this.result = 0;
          this.treeIndex = 0;
          this.excess = 1;
          this.decodeMode = DecodingMode.Strict;
        }
        EntityDecoder2.prototype.startEntity = function (decodeMode) {
          this.decodeMode = decodeMode;
          this.state = EntityDecoderState.EntityStart;
          this.result = 0;
          this.treeIndex = 0;
          this.excess = 1;
          this.consumed = 1;
        };
        EntityDecoder2.prototype.write = function (str, offset) {
          switch (this.state) {
            case EntityDecoderState.EntityStart: {
              if (str.charCodeAt(offset) === CharCodes.NUM) {
                this.state = EntityDecoderState.NumericStart;
                this.consumed += 1;
                return this.stateNumericStart(str, offset + 1);
              }
              this.state = EntityDecoderState.NamedEntity;
              return this.stateNamedEntity(str, offset);
            }
            case EntityDecoderState.NumericStart: {
              return this.stateNumericStart(str, offset);
            }
            case EntityDecoderState.NumericDecimal: {
              return this.stateNumericDecimal(str, offset);
            }
            case EntityDecoderState.NumericHex: {
              return this.stateNumericHex(str, offset);
            }
            case EntityDecoderState.NamedEntity: {
              return this.stateNamedEntity(str, offset);
            }
          }
        };
        EntityDecoder2.prototype.stateNumericStart = function (str, offset) {
          if (offset >= str.length) {
            return -1;
          }
          if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
            this.state = EntityDecoderState.NumericHex;
            this.consumed += 1;
            return this.stateNumericHex(str, offset + 1);
          }
          this.state = EntityDecoderState.NumericDecimal;
          return this.stateNumericDecimal(str, offset);
        };
        EntityDecoder2.prototype.addToNumericResult = function (
          str,
          start,
          end,
          base,
        ) {
          if (start !== end) {
            var digitCount = end - start;
            this.result =
              this.result * Math.pow(base, digitCount) +
              parseInt(str.substr(start, digitCount), base);
            this.consumed += digitCount;
          }
        };
        EntityDecoder2.prototype.stateNumericHex = function (str, offset) {
          var startIdx = offset;
          while (offset < str.length) {
            var char = str.charCodeAt(offset);
            if (isNumber(char) || isHexadecimalCharacter(char)) {
              offset += 1;
            } else {
              this.addToNumericResult(str, startIdx, offset, 16);
              return this.emitNumericEntity(char, 3);
            }
          }
          this.addToNumericResult(str, startIdx, offset, 16);
          return -1;
        };
        EntityDecoder2.prototype.stateNumericDecimal = function (str, offset) {
          var startIdx = offset;
          while (offset < str.length) {
            var char = str.charCodeAt(offset);
            if (isNumber(char)) {
              offset += 1;
            } else {
              this.addToNumericResult(str, startIdx, offset, 10);
              return this.emitNumericEntity(char, 2);
            }
          }
          this.addToNumericResult(str, startIdx, offset, 10);
          return -1;
        };
        EntityDecoder2.prototype.emitNumericEntity = function (
          lastCp,
          expectedLength,
        ) {
          var _a19;
          if (this.consumed <= expectedLength) {
            (_a19 = this.errors) === null || _a19 === void 0
              ? void 0
              : _a19.absenceOfDigitsInNumericCharacterReference(this.consumed);
            return 0;
          }
          if (lastCp === CharCodes.SEMI) {
            this.consumed += 1;
          } else if (this.decodeMode === DecodingMode.Strict) {
            return 0;
          }
          this.emitCodePoint(
            (0, decode_codepoint_js_1.replaceCodePoint)(this.result),
            this.consumed,
          );
          if (this.errors) {
            if (lastCp !== CharCodes.SEMI) {
              this.errors.missingSemicolonAfterCharacterReference();
            }
            this.errors.validateNumericCharacterReference(this.result);
          }
          return this.consumed;
        };
        EntityDecoder2.prototype.stateNamedEntity = function (str, offset) {
          var decodeTree = this.decodeTree;
          var current = decodeTree[this.treeIndex];
          var valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
          for (; offset < str.length; offset++, this.excess++) {
            var char = str.charCodeAt(offset);
            this.treeIndex = determineBranch(
              decodeTree,
              current,
              this.treeIndex + Math.max(1, valueLength),
              char,
            );
            if (this.treeIndex < 0) {
              return this.result === 0 || // If we are parsing an attribute
                (this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
                  (valueLength === 0 || // And there should be no invalid characters.
                    isEntityInAttributeInvalidEnd(char)))
                ? 0
                : this.emitNotTerminatedNamedEntity();
            }
            current = decodeTree[this.treeIndex];
            valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
            if (valueLength !== 0) {
              if (char === CharCodes.SEMI) {
                return this.emitNamedEntityData(
                  this.treeIndex,
                  valueLength,
                  this.consumed + this.excess,
                );
              }
              if (this.decodeMode !== DecodingMode.Strict) {
                this.result = this.treeIndex;
                this.consumed += this.excess;
                this.excess = 0;
              }
            }
          }
          return -1;
        };
        EntityDecoder2.prototype.emitNotTerminatedNamedEntity = function () {
          var _a19;
          var _b9 = this,
            result = _b9.result,
            decodeTree = _b9.decodeTree;
          var valueLength =
            (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
          this.emitNamedEntityData(result, valueLength, this.consumed);
          (_a19 = this.errors) === null || _a19 === void 0
            ? void 0
            : _a19.missingSemicolonAfterCharacterReference();
          return this.consumed;
        };
        EntityDecoder2.prototype.emitNamedEntityData = function (
          result,
          valueLength,
          consumed,
        ) {
          var decodeTree = this.decodeTree;
          this.emitCodePoint(
            valueLength === 1
              ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH
              : decodeTree[result + 1],
            consumed,
          );
          if (valueLength === 3) {
            this.emitCodePoint(decodeTree[result + 2], consumed);
          }
          return consumed;
        };
        EntityDecoder2.prototype.end = function () {
          var _a19;
          switch (this.state) {
            case EntityDecoderState.NamedEntity: {
              return this.result !== 0 &&
                (this.decodeMode !== DecodingMode.Attribute ||
                  this.result === this.treeIndex)
                ? this.emitNotTerminatedNamedEntity()
                : 0;
            }
            // Otherwise, emit a numeric entity if we have one.
            case EntityDecoderState.NumericDecimal: {
              return this.emitNumericEntity(0, 2);
            }
            case EntityDecoderState.NumericHex: {
              return this.emitNumericEntity(0, 3);
            }
            case EntityDecoderState.NumericStart: {
              (_a19 = this.errors) === null || _a19 === void 0
                ? void 0
                : _a19.absenceOfDigitsInNumericCharacterReference(
                    this.consumed,
                  );
              return 0;
            }
            case EntityDecoderState.EntityStart: {
              return 0;
            }
          }
        };
        return EntityDecoder2;
      })();
    exports.EntityDecoder = EntityDecoder;
    function getDecoder(decodeTree) {
      var ret = "";
      var decoder = new EntityDecoder(decodeTree, function (str) {
        return (ret += (0, decode_codepoint_js_1.fromCodePoint)(str));
      });
      return function decodeWithTrie(str, decodeMode) {
        var lastIndex = 0;
        var offset = 0;
        while ((offset = str.indexOf("&", offset)) >= 0) {
          ret += str.slice(lastIndex, offset);
          decoder.startEntity(decodeMode);
          var len = decoder.write(
            str,
            // Skip the "&"
            offset + 1,
          );
          if (len < 0) {
            lastIndex = offset + decoder.end();
            break;
          }
          lastIndex = offset + len;
          offset = len === 0 ? lastIndex + 1 : lastIndex;
        }
        var result = ret + str.slice(lastIndex);
        ret = "";
        return result;
      };
    }
    function determineBranch(decodeTree, current, nodeIdx, char) {
      var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
      var jumpOffset = current & BinTrieFlags.JUMP_TABLE;
      if (branchCount === 0) {
        return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
      }
      if (jumpOffset) {
        var value = char - jumpOffset;
        return value < 0 || value >= branchCount
          ? -1
          : decodeTree[nodeIdx + value] - 1;
      }
      var lo = nodeIdx;
      var hi = lo + branchCount - 1;
      while (lo <= hi) {
        var mid = (lo + hi) >>> 1;
        var midVal = decodeTree[mid];
        if (midVal < char) {
          lo = mid + 1;
        } else if (midVal > char) {
          hi = mid - 1;
        } else {
          return decodeTree[mid + branchCount];
        }
      }
      return -1;
    }
    exports.determineBranch = determineBranch;
    var htmlDecoder = getDecoder(decode_data_html_js_1.default);
    var xmlDecoder = getDecoder(decode_data_xml_js_1.default);
    function decodeHTML(str, mode) {
      if (mode === void 0) {
        mode = DecodingMode.Legacy;
      }
      return htmlDecoder(str, mode);
    }
    exports.decodeHTML = decodeHTML;
    function decodeHTMLAttribute(str) {
      return htmlDecoder(str, DecodingMode.Attribute);
    }
    exports.decodeHTMLAttribute = decodeHTMLAttribute;
    function decodeHTMLStrict(str) {
      return htmlDecoder(str, DecodingMode.Strict);
    }
    exports.decodeHTMLStrict = decodeHTMLStrict;
    function decodeXML(str) {
      return xmlDecoder(str, DecodingMode.Strict);
    }
    exports.decodeXML = decodeXML;
  },
});

// node_modules/entities/lib/generated/encode-html.js
var require_encode_html = __commonJS({
  "node_modules/entities/lib/generated/encode-html.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function restoreDiff(arr) {
      for (var i2 = 1; i2 < arr.length; i2++) {
        arr[i2][0] += arr[i2 - 1][0] + 1;
      }
      return arr;
    }
    exports.default = new Map(
      /* @__PURE__ */ restoreDiff([
        [9, "&Tab;"],
        [0, "&NewLine;"],
        [22, "&excl;"],
        [0, "&quot;"],
        [0, "&num;"],
        [0, "&dollar;"],
        [0, "&percnt;"],
        [0, "&amp;"],
        [0, "&apos;"],
        [0, "&lpar;"],
        [0, "&rpar;"],
        [0, "&ast;"],
        [0, "&plus;"],
        [0, "&comma;"],
        [1, "&period;"],
        [0, "&sol;"],
        [10, "&colon;"],
        [0, "&semi;"],
        [0, { v: "&lt;", n: 8402, o: "&nvlt;" }],
        [0, { v: "&equals;", n: 8421, o: "&bne;" }],
        [0, { v: "&gt;", n: 8402, o: "&nvgt;" }],
        [0, "&quest;"],
        [0, "&commat;"],
        [26, "&lbrack;"],
        [0, "&bsol;"],
        [0, "&rbrack;"],
        [0, "&Hat;"],
        [0, "&lowbar;"],
        [0, "&DiacriticalGrave;"],
        [5, { n: 106, o: "&fjlig;" }],
        [20, "&lbrace;"],
        [0, "&verbar;"],
        [0, "&rbrace;"],
        [34, "&nbsp;"],
        [0, "&iexcl;"],
        [0, "&cent;"],
        [0, "&pound;"],
        [0, "&curren;"],
        [0, "&yen;"],
        [0, "&brvbar;"],
        [0, "&sect;"],
        [0, "&die;"],
        [0, "&copy;"],
        [0, "&ordf;"],
        [0, "&laquo;"],
        [0, "&not;"],
        [0, "&shy;"],
        [0, "&circledR;"],
        [0, "&macr;"],
        [0, "&deg;"],
        [0, "&PlusMinus;"],
        [0, "&sup2;"],
        [0, "&sup3;"],
        [0, "&acute;"],
        [0, "&micro;"],
        [0, "&para;"],
        [0, "&centerdot;"],
        [0, "&cedil;"],
        [0, "&sup1;"],
        [0, "&ordm;"],
        [0, "&raquo;"],
        [0, "&frac14;"],
        [0, "&frac12;"],
        [0, "&frac34;"],
        [0, "&iquest;"],
        [0, "&Agrave;"],
        [0, "&Aacute;"],
        [0, "&Acirc;"],
        [0, "&Atilde;"],
        [0, "&Auml;"],
        [0, "&angst;"],
        [0, "&AElig;"],
        [0, "&Ccedil;"],
        [0, "&Egrave;"],
        [0, "&Eacute;"],
        [0, "&Ecirc;"],
        [0, "&Euml;"],
        [0, "&Igrave;"],
        [0, "&Iacute;"],
        [0, "&Icirc;"],
        [0, "&Iuml;"],
        [0, "&ETH;"],
        [0, "&Ntilde;"],
        [0, "&Ograve;"],
        [0, "&Oacute;"],
        [0, "&Ocirc;"],
        [0, "&Otilde;"],
        [0, "&Ouml;"],
        [0, "&times;"],
        [0, "&Oslash;"],
        [0, "&Ugrave;"],
        [0, "&Uacute;"],
        [0, "&Ucirc;"],
        [0, "&Uuml;"],
        [0, "&Yacute;"],
        [0, "&THORN;"],
        [0, "&szlig;"],
        [0, "&agrave;"],
        [0, "&aacute;"],
        [0, "&acirc;"],
        [0, "&atilde;"],
        [0, "&auml;"],
        [0, "&aring;"],
        [0, "&aelig;"],
        [0, "&ccedil;"],
        [0, "&egrave;"],
        [0, "&eacute;"],
        [0, "&ecirc;"],
        [0, "&euml;"],
        [0, "&igrave;"],
        [0, "&iacute;"],
        [0, "&icirc;"],
        [0, "&iuml;"],
        [0, "&eth;"],
        [0, "&ntilde;"],
        [0, "&ograve;"],
        [0, "&oacute;"],
        [0, "&ocirc;"],
        [0, "&otilde;"],
        [0, "&ouml;"],
        [0, "&div;"],
        [0, "&oslash;"],
        [0, "&ugrave;"],
        [0, "&uacute;"],
        [0, "&ucirc;"],
        [0, "&uuml;"],
        [0, "&yacute;"],
        [0, "&thorn;"],
        [0, "&yuml;"],
        [0, "&Amacr;"],
        [0, "&amacr;"],
        [0, "&Abreve;"],
        [0, "&abreve;"],
        [0, "&Aogon;"],
        [0, "&aogon;"],
        [0, "&Cacute;"],
        [0, "&cacute;"],
        [0, "&Ccirc;"],
        [0, "&ccirc;"],
        [0, "&Cdot;"],
        [0, "&cdot;"],
        [0, "&Ccaron;"],
        [0, "&ccaron;"],
        [0, "&Dcaron;"],
        [0, "&dcaron;"],
        [0, "&Dstrok;"],
        [0, "&dstrok;"],
        [0, "&Emacr;"],
        [0, "&emacr;"],
        [2, "&Edot;"],
        [0, "&edot;"],
        [0, "&Eogon;"],
        [0, "&eogon;"],
        [0, "&Ecaron;"],
        [0, "&ecaron;"],
        [0, "&Gcirc;"],
        [0, "&gcirc;"],
        [0, "&Gbreve;"],
        [0, "&gbreve;"],
        [0, "&Gdot;"],
        [0, "&gdot;"],
        [0, "&Gcedil;"],
        [1, "&Hcirc;"],
        [0, "&hcirc;"],
        [0, "&Hstrok;"],
        [0, "&hstrok;"],
        [0, "&Itilde;"],
        [0, "&itilde;"],
        [0, "&Imacr;"],
        [0, "&imacr;"],
        [2, "&Iogon;"],
        [0, "&iogon;"],
        [0, "&Idot;"],
        [0, "&imath;"],
        [0, "&IJlig;"],
        [0, "&ijlig;"],
        [0, "&Jcirc;"],
        [0, "&jcirc;"],
        [0, "&Kcedil;"],
        [0, "&kcedil;"],
        [0, "&kgreen;"],
        [0, "&Lacute;"],
        [0, "&lacute;"],
        [0, "&Lcedil;"],
        [0, "&lcedil;"],
        [0, "&Lcaron;"],
        [0, "&lcaron;"],
        [0, "&Lmidot;"],
        [0, "&lmidot;"],
        [0, "&Lstrok;"],
        [0, "&lstrok;"],
        [0, "&Nacute;"],
        [0, "&nacute;"],
        [0, "&Ncedil;"],
        [0, "&ncedil;"],
        [0, "&Ncaron;"],
        [0, "&ncaron;"],
        [0, "&napos;"],
        [0, "&ENG;"],
        [0, "&eng;"],
        [0, "&Omacr;"],
        [0, "&omacr;"],
        [2, "&Odblac;"],
        [0, "&odblac;"],
        [0, "&OElig;"],
        [0, "&oelig;"],
        [0, "&Racute;"],
        [0, "&racute;"],
        [0, "&Rcedil;"],
        [0, "&rcedil;"],
        [0, "&Rcaron;"],
        [0, "&rcaron;"],
        [0, "&Sacute;"],
        [0, "&sacute;"],
        [0, "&Scirc;"],
        [0, "&scirc;"],
        [0, "&Scedil;"],
        [0, "&scedil;"],
        [0, "&Scaron;"],
        [0, "&scaron;"],
        [0, "&Tcedil;"],
        [0, "&tcedil;"],
        [0, "&Tcaron;"],
        [0, "&tcaron;"],
        [0, "&Tstrok;"],
        [0, "&tstrok;"],
        [0, "&Utilde;"],
        [0, "&utilde;"],
        [0, "&Umacr;"],
        [0, "&umacr;"],
        [0, "&Ubreve;"],
        [0, "&ubreve;"],
        [0, "&Uring;"],
        [0, "&uring;"],
        [0, "&Udblac;"],
        [0, "&udblac;"],
        [0, "&Uogon;"],
        [0, "&uogon;"],
        [0, "&Wcirc;"],
        [0, "&wcirc;"],
        [0, "&Ycirc;"],
        [0, "&ycirc;"],
        [0, "&Yuml;"],
        [0, "&Zacute;"],
        [0, "&zacute;"],
        [0, "&Zdot;"],
        [0, "&zdot;"],
        [0, "&Zcaron;"],
        [0, "&zcaron;"],
        [19, "&fnof;"],
        [34, "&imped;"],
        [63, "&gacute;"],
        [65, "&jmath;"],
        [142, "&circ;"],
        [0, "&caron;"],
        [16, "&breve;"],
        [0, "&DiacriticalDot;"],
        [0, "&ring;"],
        [0, "&ogon;"],
        [0, "&DiacriticalTilde;"],
        [0, "&dblac;"],
        [51, "&DownBreve;"],
        [127, "&Alpha;"],
        [0, "&Beta;"],
        [0, "&Gamma;"],
        [0, "&Delta;"],
        [0, "&Epsilon;"],
        [0, "&Zeta;"],
        [0, "&Eta;"],
        [0, "&Theta;"],
        [0, "&Iota;"],
        [0, "&Kappa;"],
        [0, "&Lambda;"],
        [0, "&Mu;"],
        [0, "&Nu;"],
        [0, "&Xi;"],
        [0, "&Omicron;"],
        [0, "&Pi;"],
        [0, "&Rho;"],
        [1, "&Sigma;"],
        [0, "&Tau;"],
        [0, "&Upsilon;"],
        [0, "&Phi;"],
        [0, "&Chi;"],
        [0, "&Psi;"],
        [0, "&ohm;"],
        [7, "&alpha;"],
        [0, "&beta;"],
        [0, "&gamma;"],
        [0, "&delta;"],
        [0, "&epsi;"],
        [0, "&zeta;"],
        [0, "&eta;"],
        [0, "&theta;"],
        [0, "&iota;"],
        [0, "&kappa;"],
        [0, "&lambda;"],
        [0, "&mu;"],
        [0, "&nu;"],
        [0, "&xi;"],
        [0, "&omicron;"],
        [0, "&pi;"],
        [0, "&rho;"],
        [0, "&sigmaf;"],
        [0, "&sigma;"],
        [0, "&tau;"],
        [0, "&upsi;"],
        [0, "&phi;"],
        [0, "&chi;"],
        [0, "&psi;"],
        [0, "&omega;"],
        [7, "&thetasym;"],
        [0, "&Upsi;"],
        [2, "&phiv;"],
        [0, "&piv;"],
        [5, "&Gammad;"],
        [0, "&digamma;"],
        [18, "&kappav;"],
        [0, "&rhov;"],
        [3, "&epsiv;"],
        [0, "&backepsilon;"],
        [10, "&IOcy;"],
        [0, "&DJcy;"],
        [0, "&GJcy;"],
        [0, "&Jukcy;"],
        [0, "&DScy;"],
        [0, "&Iukcy;"],
        [0, "&YIcy;"],
        [0, "&Jsercy;"],
        [0, "&LJcy;"],
        [0, "&NJcy;"],
        [0, "&TSHcy;"],
        [0, "&KJcy;"],
        [1, "&Ubrcy;"],
        [0, "&DZcy;"],
        [0, "&Acy;"],
        [0, "&Bcy;"],
        [0, "&Vcy;"],
        [0, "&Gcy;"],
        [0, "&Dcy;"],
        [0, "&IEcy;"],
        [0, "&ZHcy;"],
        [0, "&Zcy;"],
        [0, "&Icy;"],
        [0, "&Jcy;"],
        [0, "&Kcy;"],
        [0, "&Lcy;"],
        [0, "&Mcy;"],
        [0, "&Ncy;"],
        [0, "&Ocy;"],
        [0, "&Pcy;"],
        [0, "&Rcy;"],
        [0, "&Scy;"],
        [0, "&Tcy;"],
        [0, "&Ucy;"],
        [0, "&Fcy;"],
        [0, "&KHcy;"],
        [0, "&TScy;"],
        [0, "&CHcy;"],
        [0, "&SHcy;"],
        [0, "&SHCHcy;"],
        [0, "&HARDcy;"],
        [0, "&Ycy;"],
        [0, "&SOFTcy;"],
        [0, "&Ecy;"],
        [0, "&YUcy;"],
        [0, "&YAcy;"],
        [0, "&acy;"],
        [0, "&bcy;"],
        [0, "&vcy;"],
        [0, "&gcy;"],
        [0, "&dcy;"],
        [0, "&iecy;"],
        [0, "&zhcy;"],
        [0, "&zcy;"],
        [0, "&icy;"],
        [0, "&jcy;"],
        [0, "&kcy;"],
        [0, "&lcy;"],
        [0, "&mcy;"],
        [0, "&ncy;"],
        [0, "&ocy;"],
        [0, "&pcy;"],
        [0, "&rcy;"],
        [0, "&scy;"],
        [0, "&tcy;"],
        [0, "&ucy;"],
        [0, "&fcy;"],
        [0, "&khcy;"],
        [0, "&tscy;"],
        [0, "&chcy;"],
        [0, "&shcy;"],
        [0, "&shchcy;"],
        [0, "&hardcy;"],
        [0, "&ycy;"],
        [0, "&softcy;"],
        [0, "&ecy;"],
        [0, "&yucy;"],
        [0, "&yacy;"],
        [1, "&iocy;"],
        [0, "&djcy;"],
        [0, "&gjcy;"],
        [0, "&jukcy;"],
        [0, "&dscy;"],
        [0, "&iukcy;"],
        [0, "&yicy;"],
        [0, "&jsercy;"],
        [0, "&ljcy;"],
        [0, "&njcy;"],
        [0, "&tshcy;"],
        [0, "&kjcy;"],
        [1, "&ubrcy;"],
        [0, "&dzcy;"],
        [7074, "&ensp;"],
        [0, "&emsp;"],
        [0, "&emsp13;"],
        [0, "&emsp14;"],
        [1, "&numsp;"],
        [0, "&puncsp;"],
        [0, "&ThinSpace;"],
        [0, "&hairsp;"],
        [0, "&NegativeMediumSpace;"],
        [0, "&zwnj;"],
        [0, "&zwj;"],
        [0, "&lrm;"],
        [0, "&rlm;"],
        [0, "&dash;"],
        [2, "&ndash;"],
        [0, "&mdash;"],
        [0, "&horbar;"],
        [0, "&Verbar;"],
        [1, "&lsquo;"],
        [0, "&CloseCurlyQuote;"],
        [0, "&lsquor;"],
        [1, "&ldquo;"],
        [0, "&CloseCurlyDoubleQuote;"],
        [0, "&bdquo;"],
        [1, "&dagger;"],
        [0, "&Dagger;"],
        [0, "&bull;"],
        [2, "&nldr;"],
        [0, "&hellip;"],
        [9, "&permil;"],
        [0, "&pertenk;"],
        [0, "&prime;"],
        [0, "&Prime;"],
        [0, "&tprime;"],
        [0, "&backprime;"],
        [3, "&lsaquo;"],
        [0, "&rsaquo;"],
        [3, "&oline;"],
        [2, "&caret;"],
        [1, "&hybull;"],
        [0, "&frasl;"],
        [10, "&bsemi;"],
        [7, "&qprime;"],
        [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }],
        [0, "&NoBreak;"],
        [0, "&af;"],
        [0, "&InvisibleTimes;"],
        [0, "&ic;"],
        [72, "&euro;"],
        [46, "&tdot;"],
        [0, "&DotDot;"],
        [37, "&complexes;"],
        [2, "&incare;"],
        [4, "&gscr;"],
        [0, "&hamilt;"],
        [0, "&Hfr;"],
        [0, "&Hopf;"],
        [0, "&planckh;"],
        [0, "&hbar;"],
        [0, "&imagline;"],
        [0, "&Ifr;"],
        [0, "&lagran;"],
        [0, "&ell;"],
        [1, "&naturals;"],
        [0, "&numero;"],
        [0, "&copysr;"],
        [0, "&weierp;"],
        [0, "&Popf;"],
        [0, "&Qopf;"],
        [0, "&realine;"],
        [0, "&real;"],
        [0, "&reals;"],
        [0, "&rx;"],
        [3, "&trade;"],
        [1, "&integers;"],
        [2, "&mho;"],
        [0, "&zeetrf;"],
        [0, "&iiota;"],
        [2, "&bernou;"],
        [0, "&Cayleys;"],
        [1, "&escr;"],
        [0, "&Escr;"],
        [0, "&Fouriertrf;"],
        [1, "&Mellintrf;"],
        [0, "&order;"],
        [0, "&alefsym;"],
        [0, "&beth;"],
        [0, "&gimel;"],
        [0, "&daleth;"],
        [12, "&CapitalDifferentialD;"],
        [0, "&dd;"],
        [0, "&ee;"],
        [0, "&ii;"],
        [10, "&frac13;"],
        [0, "&frac23;"],
        [0, "&frac15;"],
        [0, "&frac25;"],
        [0, "&frac35;"],
        [0, "&frac45;"],
        [0, "&frac16;"],
        [0, "&frac56;"],
        [0, "&frac18;"],
        [0, "&frac38;"],
        [0, "&frac58;"],
        [0, "&frac78;"],
        [49, "&larr;"],
        [0, "&ShortUpArrow;"],
        [0, "&rarr;"],
        [0, "&darr;"],
        [0, "&harr;"],
        [0, "&updownarrow;"],
        [0, "&nwarr;"],
        [0, "&nearr;"],
        [0, "&LowerRightArrow;"],
        [0, "&LowerLeftArrow;"],
        [0, "&nlarr;"],
        [0, "&nrarr;"],
        [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }],
        [0, "&Larr;"],
        [0, "&Uarr;"],
        [0, "&Rarr;"],
        [0, "&Darr;"],
        [0, "&larrtl;"],
        [0, "&rarrtl;"],
        [0, "&LeftTeeArrow;"],
        [0, "&mapstoup;"],
        [0, "&map;"],
        [0, "&DownTeeArrow;"],
        [1, "&hookleftarrow;"],
        [0, "&hookrightarrow;"],
        [0, "&larrlp;"],
        [0, "&looparrowright;"],
        [0, "&harrw;"],
        [0, "&nharr;"],
        [1, "&lsh;"],
        [0, "&rsh;"],
        [0, "&ldsh;"],
        [0, "&rdsh;"],
        [1, "&crarr;"],
        [0, "&cularr;"],
        [0, "&curarr;"],
        [2, "&circlearrowleft;"],
        [0, "&circlearrowright;"],
        [0, "&leftharpoonup;"],
        [0, "&DownLeftVector;"],
        [0, "&RightUpVector;"],
        [0, "&LeftUpVector;"],
        [0, "&rharu;"],
        [0, "&DownRightVector;"],
        [0, "&dharr;"],
        [0, "&dharl;"],
        [0, "&RightArrowLeftArrow;"],
        [0, "&udarr;"],
        [0, "&LeftArrowRightArrow;"],
        [0, "&leftleftarrows;"],
        [0, "&upuparrows;"],
        [0, "&rightrightarrows;"],
        [0, "&ddarr;"],
        [0, "&leftrightharpoons;"],
        [0, "&Equilibrium;"],
        [0, "&nlArr;"],
        [0, "&nhArr;"],
        [0, "&nrArr;"],
        [0, "&DoubleLeftArrow;"],
        [0, "&DoubleUpArrow;"],
        [0, "&DoubleRightArrow;"],
        [0, "&dArr;"],
        [0, "&DoubleLeftRightArrow;"],
        [0, "&DoubleUpDownArrow;"],
        [0, "&nwArr;"],
        [0, "&neArr;"],
        [0, "&seArr;"],
        [0, "&swArr;"],
        [0, "&lAarr;"],
        [0, "&rAarr;"],
        [1, "&zigrarr;"],
        [6, "&larrb;"],
        [0, "&rarrb;"],
        [15, "&DownArrowUpArrow;"],
        [7, "&loarr;"],
        [0, "&roarr;"],
        [0, "&hoarr;"],
        [0, "&forall;"],
        [0, "&comp;"],
        [0, { v: "&part;", n: 824, o: "&npart;" }],
        [0, "&exist;"],
        [0, "&nexist;"],
        [0, "&empty;"],
        [1, "&Del;"],
        [0, "&Element;"],
        [0, "&NotElement;"],
        [1, "&ni;"],
        [0, "&notni;"],
        [2, "&prod;"],
        [0, "&coprod;"],
        [0, "&sum;"],
        [0, "&minus;"],
        [0, "&MinusPlus;"],
        [0, "&dotplus;"],
        [1, "&Backslash;"],
        [0, "&lowast;"],
        [0, "&compfn;"],
        [1, "&radic;"],
        [2, "&prop;"],
        [0, "&infin;"],
        [0, "&angrt;"],
        [0, { v: "&ang;", n: 8402, o: "&nang;" }],
        [0, "&angmsd;"],
        [0, "&angsph;"],
        [0, "&mid;"],
        [0, "&nmid;"],
        [0, "&DoubleVerticalBar;"],
        [0, "&NotDoubleVerticalBar;"],
        [0, "&and;"],
        [0, "&or;"],
        [0, { v: "&cap;", n: 65024, o: "&caps;" }],
        [0, { v: "&cup;", n: 65024, o: "&cups;" }],
        [0, "&int;"],
        [0, "&Int;"],
        [0, "&iiint;"],
        [0, "&conint;"],
        [0, "&Conint;"],
        [0, "&Cconint;"],
        [0, "&cwint;"],
        [0, "&ClockwiseContourIntegral;"],
        [0, "&awconint;"],
        [0, "&there4;"],
        [0, "&becaus;"],
        [0, "&ratio;"],
        [0, "&Colon;"],
        [0, "&dotminus;"],
        [1, "&mDDot;"],
        [0, "&homtht;"],
        [0, { v: "&sim;", n: 8402, o: "&nvsim;" }],
        [0, { v: "&backsim;", n: 817, o: "&race;" }],
        [0, { v: "&ac;", n: 819, o: "&acE;" }],
        [0, "&acd;"],
        [0, "&VerticalTilde;"],
        [0, "&NotTilde;"],
        [0, { v: "&eqsim;", n: 824, o: "&nesim;" }],
        [0, "&sime;"],
        [0, "&NotTildeEqual;"],
        [0, "&cong;"],
        [0, "&simne;"],
        [0, "&ncong;"],
        [0, "&ap;"],
        [0, "&nap;"],
        [0, "&ape;"],
        [0, { v: "&apid;", n: 824, o: "&napid;" }],
        [0, "&backcong;"],
        [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }],
        [0, { v: "&bump;", n: 824, o: "&nbump;" }],
        [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }],
        [0, { v: "&doteq;", n: 824, o: "&nedot;" }],
        [0, "&doteqdot;"],
        [0, "&efDot;"],
        [0, "&erDot;"],
        [0, "&Assign;"],
        [0, "&ecolon;"],
        [0, "&ecir;"],
        [0, "&circeq;"],
        [1, "&wedgeq;"],
        [0, "&veeeq;"],
        [1, "&triangleq;"],
        [2, "&equest;"],
        [0, "&ne;"],
        [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }],
        [0, "&nequiv;"],
        [1, { v: "&le;", n: 8402, o: "&nvle;" }],
        [0, { v: "&ge;", n: 8402, o: "&nvge;" }],
        [0, { v: "&lE;", n: 824, o: "&nlE;" }],
        [0, { v: "&gE;", n: 824, o: "&ngE;" }],
        [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }],
        [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }],
        [
          0,
          {
            v: "&ll;",
            n: new Map(
              /* @__PURE__ */ restoreDiff([
                [824, "&nLtv;"],
                [7577, "&nLt;"],
              ]),
            ),
          },
        ],
        [
          0,
          {
            v: "&gg;",
            n: new Map(
              /* @__PURE__ */ restoreDiff([
                [824, "&nGtv;"],
                [7577, "&nGt;"],
              ]),
            ),
          },
        ],
        [0, "&between;"],
        [0, "&NotCupCap;"],
        [0, "&nless;"],
        [0, "&ngt;"],
        [0, "&nle;"],
        [0, "&nge;"],
        [0, "&lesssim;"],
        [0, "&GreaterTilde;"],
        [0, "&nlsim;"],
        [0, "&ngsim;"],
        [0, "&LessGreater;"],
        [0, "&gl;"],
        [0, "&NotLessGreater;"],
        [0, "&NotGreaterLess;"],
        [0, "&pr;"],
        [0, "&sc;"],
        [0, "&prcue;"],
        [0, "&sccue;"],
        [0, "&PrecedesTilde;"],
        [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }],
        [0, "&NotPrecedes;"],
        [0, "&NotSucceeds;"],
        [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }],
        [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }],
        [0, "&nsub;"],
        [0, "&nsup;"],
        [0, "&sube;"],
        [0, "&supe;"],
        [0, "&NotSubsetEqual;"],
        [0, "&NotSupersetEqual;"],
        [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }],
        [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }],
        [1, "&cupdot;"],
        [0, "&UnionPlus;"],
        [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }],
        [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }],
        [0, "&sqsube;"],
        [0, "&sqsupe;"],
        [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }],
        [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }],
        [0, "&CirclePlus;"],
        [0, "&CircleMinus;"],
        [0, "&CircleTimes;"],
        [0, "&osol;"],
        [0, "&CircleDot;"],
        [0, "&circledcirc;"],
        [0, "&circledast;"],
        [1, "&circleddash;"],
        [0, "&boxplus;"],
        [0, "&boxminus;"],
        [0, "&boxtimes;"],
        [0, "&dotsquare;"],
        [0, "&RightTee;"],
        [0, "&dashv;"],
        [0, "&DownTee;"],
        [0, "&bot;"],
        [1, "&models;"],
        [0, "&DoubleRightTee;"],
        [0, "&Vdash;"],
        [0, "&Vvdash;"],
        [0, "&VDash;"],
        [0, "&nvdash;"],
        [0, "&nvDash;"],
        [0, "&nVdash;"],
        [0, "&nVDash;"],
        [0, "&prurel;"],
        [1, "&LeftTriangle;"],
        [0, "&RightTriangle;"],
        [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }],
        [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }],
        [0, "&origof;"],
        [0, "&imof;"],
        [0, "&multimap;"],
        [0, "&hercon;"],
        [0, "&intcal;"],
        [0, "&veebar;"],
        [1, "&barvee;"],
        [0, "&angrtvb;"],
        [0, "&lrtri;"],
        [0, "&bigwedge;"],
        [0, "&bigvee;"],
        [0, "&bigcap;"],
        [0, "&bigcup;"],
        [0, "&diam;"],
        [0, "&sdot;"],
        [0, "&sstarf;"],
        [0, "&divideontimes;"],
        [0, "&bowtie;"],
        [0, "&ltimes;"],
        [0, "&rtimes;"],
        [0, "&leftthreetimes;"],
        [0, "&rightthreetimes;"],
        [0, "&backsimeq;"],
        [0, "&curlyvee;"],
        [0, "&curlywedge;"],
        [0, "&Sub;"],
        [0, "&Sup;"],
        [0, "&Cap;"],
        [0, "&Cup;"],
        [0, "&fork;"],
        [0, "&epar;"],
        [0, "&lessdot;"],
        [0, "&gtdot;"],
        [0, { v: "&Ll;", n: 824, o: "&nLl;" }],
        [0, { v: "&Gg;", n: 824, o: "&nGg;" }],
        [0, { v: "&leg;", n: 65024, o: "&lesg;" }],
        [0, { v: "&gel;", n: 65024, o: "&gesl;" }],
        [2, "&cuepr;"],
        [0, "&cuesc;"],
        [0, "&NotPrecedesSlantEqual;"],
        [0, "&NotSucceedsSlantEqual;"],
        [0, "&NotSquareSubsetEqual;"],
        [0, "&NotSquareSupersetEqual;"],
        [2, "&lnsim;"],
        [0, "&gnsim;"],
        [0, "&precnsim;"],
        [0, "&scnsim;"],
        [0, "&nltri;"],
        [0, "&NotRightTriangle;"],
        [0, "&nltrie;"],
        [0, "&NotRightTriangleEqual;"],
        [0, "&vellip;"],
        [0, "&ctdot;"],
        [0, "&utdot;"],
        [0, "&dtdot;"],
        [0, "&disin;"],
        [0, "&isinsv;"],
        [0, "&isins;"],
        [0, { v: "&isindot;", n: 824, o: "&notindot;" }],
        [0, "&notinvc;"],
        [0, "&notinvb;"],
        [1, { v: "&isinE;", n: 824, o: "&notinE;" }],
        [0, "&nisd;"],
        [0, "&xnis;"],
        [0, "&nis;"],
        [0, "&notnivc;"],
        [0, "&notnivb;"],
        [6, "&barwed;"],
        [0, "&Barwed;"],
        [1, "&lceil;"],
        [0, "&rceil;"],
        [0, "&LeftFloor;"],
        [0, "&rfloor;"],
        [0, "&drcrop;"],
        [0, "&dlcrop;"],
        [0, "&urcrop;"],
        [0, "&ulcrop;"],
        [0, "&bnot;"],
        [1, "&profline;"],
        [0, "&profsurf;"],
        [1, "&telrec;"],
        [0, "&target;"],
        [5, "&ulcorn;"],
        [0, "&urcorn;"],
        [0, "&dlcorn;"],
        [0, "&drcorn;"],
        [2, "&frown;"],
        [0, "&smile;"],
        [9, "&cylcty;"],
        [0, "&profalar;"],
        [7, "&topbot;"],
        [6, "&ovbar;"],
        [1, "&solbar;"],
        [60, "&angzarr;"],
        [51, "&lmoustache;"],
        [0, "&rmoustache;"],
        [2, "&OverBracket;"],
        [0, "&bbrk;"],
        [0, "&bbrktbrk;"],
        [37, "&OverParenthesis;"],
        [0, "&UnderParenthesis;"],
        [0, "&OverBrace;"],
        [0, "&UnderBrace;"],
        [2, "&trpezium;"],
        [4, "&elinters;"],
        [59, "&blank;"],
        [164, "&circledS;"],
        [55, "&boxh;"],
        [1, "&boxv;"],
        [9, "&boxdr;"],
        [3, "&boxdl;"],
        [3, "&boxur;"],
        [3, "&boxul;"],
        [3, "&boxvr;"],
        [7, "&boxvl;"],
        [7, "&boxhd;"],
        [7, "&boxhu;"],
        [7, "&boxvh;"],
        [19, "&boxH;"],
        [0, "&boxV;"],
        [0, "&boxdR;"],
        [0, "&boxDr;"],
        [0, "&boxDR;"],
        [0, "&boxdL;"],
        [0, "&boxDl;"],
        [0, "&boxDL;"],
        [0, "&boxuR;"],
        [0, "&boxUr;"],
        [0, "&boxUR;"],
        [0, "&boxuL;"],
        [0, "&boxUl;"],
        [0, "&boxUL;"],
        [0, "&boxvR;"],
        [0, "&boxVr;"],
        [0, "&boxVR;"],
        [0, "&boxvL;"],
        [0, "&boxVl;"],
        [0, "&boxVL;"],
        [0, "&boxHd;"],
        [0, "&boxhD;"],
        [0, "&boxHD;"],
        [0, "&boxHu;"],
        [0, "&boxhU;"],
        [0, "&boxHU;"],
        [0, "&boxvH;"],
        [0, "&boxVh;"],
        [0, "&boxVH;"],
        [19, "&uhblk;"],
        [3, "&lhblk;"],
        [3, "&block;"],
        [8, "&blk14;"],
        [0, "&blk12;"],
        [0, "&blk34;"],
        [13, "&square;"],
        [8, "&blacksquare;"],
        [0, "&EmptyVerySmallSquare;"],
        [1, "&rect;"],
        [0, "&marker;"],
        [2, "&fltns;"],
        [1, "&bigtriangleup;"],
        [0, "&blacktriangle;"],
        [0, "&triangle;"],
        [2, "&blacktriangleright;"],
        [0, "&rtri;"],
        [3, "&bigtriangledown;"],
        [0, "&blacktriangledown;"],
        [0, "&dtri;"],
        [2, "&blacktriangleleft;"],
        [0, "&ltri;"],
        [6, "&loz;"],
        [0, "&cir;"],
        [32, "&tridot;"],
        [2, "&bigcirc;"],
        [8, "&ultri;"],
        [0, "&urtri;"],
        [0, "&lltri;"],
        [0, "&EmptySmallSquare;"],
        [0, "&FilledSmallSquare;"],
        [8, "&bigstar;"],
        [0, "&star;"],
        [7, "&phone;"],
        [49, "&female;"],
        [1, "&male;"],
        [29, "&spades;"],
        [2, "&clubs;"],
        [1, "&hearts;"],
        [0, "&diamondsuit;"],
        [3, "&sung;"],
        [2, "&flat;"],
        [0, "&natural;"],
        [0, "&sharp;"],
        [163, "&check;"],
        [3, "&cross;"],
        [8, "&malt;"],
        [21, "&sext;"],
        [33, "&VerticalSeparator;"],
        [25, "&lbbrk;"],
        [0, "&rbbrk;"],
        [84, "&bsolhsub;"],
        [0, "&suphsol;"],
        [28, "&LeftDoubleBracket;"],
        [0, "&RightDoubleBracket;"],
        [0, "&lang;"],
        [0, "&rang;"],
        [0, "&Lang;"],
        [0, "&Rang;"],
        [0, "&loang;"],
        [0, "&roang;"],
        [7, "&longleftarrow;"],
        [0, "&longrightarrow;"],
        [0, "&longleftrightarrow;"],
        [0, "&DoubleLongLeftArrow;"],
        [0, "&DoubleLongRightArrow;"],
        [0, "&DoubleLongLeftRightArrow;"],
        [1, "&longmapsto;"],
        [2, "&dzigrarr;"],
        [258, "&nvlArr;"],
        [0, "&nvrArr;"],
        [0, "&nvHarr;"],
        [0, "&Map;"],
        [6, "&lbarr;"],
        [0, "&bkarow;"],
        [0, "&lBarr;"],
        [0, "&dbkarow;"],
        [0, "&drbkarow;"],
        [0, "&DDotrahd;"],
        [0, "&UpArrowBar;"],
        [0, "&DownArrowBar;"],
        [2, "&Rarrtl;"],
        [2, "&latail;"],
        [0, "&ratail;"],
        [0, "&lAtail;"],
        [0, "&rAtail;"],
        [0, "&larrfs;"],
        [0, "&rarrfs;"],
        [0, "&larrbfs;"],
        [0, "&rarrbfs;"],
        [2, "&nwarhk;"],
        [0, "&nearhk;"],
        [0, "&hksearow;"],
        [0, "&hkswarow;"],
        [0, "&nwnear;"],
        [0, "&nesear;"],
        [0, "&seswar;"],
        [0, "&swnwar;"],
        [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }],
        [1, "&cudarrr;"],
        [0, "&ldca;"],
        [0, "&rdca;"],
        [0, "&cudarrl;"],
        [0, "&larrpl;"],
        [2, "&curarrm;"],
        [0, "&cularrp;"],
        [7, "&rarrpl;"],
        [2, "&harrcir;"],
        [0, "&Uarrocir;"],
        [0, "&lurdshar;"],
        [0, "&ldrushar;"],
        [2, "&LeftRightVector;"],
        [0, "&RightUpDownVector;"],
        [0, "&DownLeftRightVector;"],
        [0, "&LeftUpDownVector;"],
        [0, "&LeftVectorBar;"],
        [0, "&RightVectorBar;"],
        [0, "&RightUpVectorBar;"],
        [0, "&RightDownVectorBar;"],
        [0, "&DownLeftVectorBar;"],
        [0, "&DownRightVectorBar;"],
        [0, "&LeftUpVectorBar;"],
        [0, "&LeftDownVectorBar;"],
        [0, "&LeftTeeVector;"],
        [0, "&RightTeeVector;"],
        [0, "&RightUpTeeVector;"],
        [0, "&RightDownTeeVector;"],
        [0, "&DownLeftTeeVector;"],
        [0, "&DownRightTeeVector;"],
        [0, "&LeftUpTeeVector;"],
        [0, "&LeftDownTeeVector;"],
        [0, "&lHar;"],
        [0, "&uHar;"],
        [0, "&rHar;"],
        [0, "&dHar;"],
        [0, "&luruhar;"],
        [0, "&ldrdhar;"],
        [0, "&ruluhar;"],
        [0, "&rdldhar;"],
        [0, "&lharul;"],
        [0, "&llhard;"],
        [0, "&rharul;"],
        [0, "&lrhard;"],
        [0, "&udhar;"],
        [0, "&duhar;"],
        [0, "&RoundImplies;"],
        [0, "&erarr;"],
        [0, "&simrarr;"],
        [0, "&larrsim;"],
        [0, "&rarrsim;"],
        [0, "&rarrap;"],
        [0, "&ltlarr;"],
        [1, "&gtrarr;"],
        [0, "&subrarr;"],
        [1, "&suplarr;"],
        [0, "&lfisht;"],
        [0, "&rfisht;"],
        [0, "&ufisht;"],
        [0, "&dfisht;"],
        [5, "&lopar;"],
        [0, "&ropar;"],
        [4, "&lbrke;"],
        [0, "&rbrke;"],
        [0, "&lbrkslu;"],
        [0, "&rbrksld;"],
        [0, "&lbrksld;"],
        [0, "&rbrkslu;"],
        [0, "&langd;"],
        [0, "&rangd;"],
        [0, "&lparlt;"],
        [0, "&rpargt;"],
        [0, "&gtlPar;"],
        [0, "&ltrPar;"],
        [3, "&vzigzag;"],
        [1, "&vangrt;"],
        [0, "&angrtvbd;"],
        [6, "&ange;"],
        [0, "&range;"],
        [0, "&dwangle;"],
        [0, "&uwangle;"],
        [0, "&angmsdaa;"],
        [0, "&angmsdab;"],
        [0, "&angmsdac;"],
        [0, "&angmsdad;"],
        [0, "&angmsdae;"],
        [0, "&angmsdaf;"],
        [0, "&angmsdag;"],
        [0, "&angmsdah;"],
        [0, "&bemptyv;"],
        [0, "&demptyv;"],
        [0, "&cemptyv;"],
        [0, "&raemptyv;"],
        [0, "&laemptyv;"],
        [0, "&ohbar;"],
        [0, "&omid;"],
        [0, "&opar;"],
        [1, "&operp;"],
        [1, "&olcross;"],
        [0, "&odsold;"],
        [1, "&olcir;"],
        [0, "&ofcir;"],
        [0, "&olt;"],
        [0, "&ogt;"],
        [0, "&cirscir;"],
        [0, "&cirE;"],
        [0, "&solb;"],
        [0, "&bsolb;"],
        [3, "&boxbox;"],
        [3, "&trisb;"],
        [0, "&rtriltri;"],
        [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }],
        [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }],
        [11, "&iinfin;"],
        [0, "&infintie;"],
        [0, "&nvinfin;"],
        [4, "&eparsl;"],
        [0, "&smeparsl;"],
        [0, "&eqvparsl;"],
        [5, "&blacklozenge;"],
        [8, "&RuleDelayed;"],
        [1, "&dsol;"],
        [9, "&bigodot;"],
        [0, "&bigoplus;"],
        [0, "&bigotimes;"],
        [1, "&biguplus;"],
        [1, "&bigsqcup;"],
        [5, "&iiiint;"],
        [0, "&fpartint;"],
        [2, "&cirfnint;"],
        [0, "&awint;"],
        [0, "&rppolint;"],
        [0, "&scpolint;"],
        [0, "&npolint;"],
        [0, "&pointint;"],
        [0, "&quatint;"],
        [0, "&intlarhk;"],
        [10, "&pluscir;"],
        [0, "&plusacir;"],
        [0, "&simplus;"],
        [0, "&plusdu;"],
        [0, "&plussim;"],
        [0, "&plustwo;"],
        [1, "&mcomma;"],
        [0, "&minusdu;"],
        [2, "&loplus;"],
        [0, "&roplus;"],
        [0, "&Cross;"],
        [0, "&timesd;"],
        [0, "&timesbar;"],
        [1, "&smashp;"],
        [0, "&lotimes;"],
        [0, "&rotimes;"],
        [0, "&otimesas;"],
        [0, "&Otimes;"],
        [0, "&odiv;"],
        [0, "&triplus;"],
        [0, "&triminus;"],
        [0, "&tritime;"],
        [0, "&intprod;"],
        [2, "&amalg;"],
        [0, "&capdot;"],
        [1, "&ncup;"],
        [0, "&ncap;"],
        [0, "&capand;"],
        [0, "&cupor;"],
        [0, "&cupcap;"],
        [0, "&capcup;"],
        [0, "&cupbrcap;"],
        [0, "&capbrcup;"],
        [0, "&cupcup;"],
        [0, "&capcap;"],
        [0, "&ccups;"],
        [0, "&ccaps;"],
        [2, "&ccupssm;"],
        [2, "&And;"],
        [0, "&Or;"],
        [0, "&andand;"],
        [0, "&oror;"],
        [0, "&orslope;"],
        [0, "&andslope;"],
        [1, "&andv;"],
        [0, "&orv;"],
        [0, "&andd;"],
        [0, "&ord;"],
        [1, "&wedbar;"],
        [6, "&sdote;"],
        [3, "&simdot;"],
        [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }],
        [0, "&easter;"],
        [0, "&apacir;"],
        [0, { v: "&apE;", n: 824, o: "&napE;" }],
        [0, "&eplus;"],
        [0, "&pluse;"],
        [0, "&Esim;"],
        [0, "&Colone;"],
        [0, "&Equal;"],
        [1, "&ddotseq;"],
        [0, "&equivDD;"],
        [0, "&ltcir;"],
        [0, "&gtcir;"],
        [0, "&ltquest;"],
        [0, "&gtquest;"],
        [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }],
        [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }],
        [0, "&lesdot;"],
        [0, "&gesdot;"],
        [0, "&lesdoto;"],
        [0, "&gesdoto;"],
        [0, "&lesdotor;"],
        [0, "&gesdotol;"],
        [0, "&lap;"],
        [0, "&gap;"],
        [0, "&lne;"],
        [0, "&gne;"],
        [0, "&lnap;"],
        [0, "&gnap;"],
        [0, "&lEg;"],
        [0, "&gEl;"],
        [0, "&lsime;"],
        [0, "&gsime;"],
        [0, "&lsimg;"],
        [0, "&gsiml;"],
        [0, "&lgE;"],
        [0, "&glE;"],
        [0, "&lesges;"],
        [0, "&gesles;"],
        [0, "&els;"],
        [0, "&egs;"],
        [0, "&elsdot;"],
        [0, "&egsdot;"],
        [0, "&el;"],
        [0, "&eg;"],
        [2, "&siml;"],
        [0, "&simg;"],
        [0, "&simlE;"],
        [0, "&simgE;"],
        [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }],
        [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }],
        [1, "&glj;"],
        [0, "&gla;"],
        [0, "&ltcc;"],
        [0, "&gtcc;"],
        [0, "&lescc;"],
        [0, "&gescc;"],
        [0, "&smt;"],
        [0, "&lat;"],
        [0, { v: "&smte;", n: 65024, o: "&smtes;" }],
        [0, { v: "&late;", n: 65024, o: "&lates;" }],
        [0, "&bumpE;"],
        [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }],
        [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }],
        [2, "&prE;"],
        [0, "&scE;"],
        [0, "&precneqq;"],
        [0, "&scnE;"],
        [0, "&prap;"],
        [0, "&scap;"],
        [0, "&precnapprox;"],
        [0, "&scnap;"],
        [0, "&Pr;"],
        [0, "&Sc;"],
        [0, "&subdot;"],
        [0, "&supdot;"],
        [0, "&subplus;"],
        [0, "&supplus;"],
        [0, "&submult;"],
        [0, "&supmult;"],
        [0, "&subedot;"],
        [0, "&supedot;"],
        [0, { v: "&subE;", n: 824, o: "&nsubE;" }],
        [0, { v: "&supE;", n: 824, o: "&nsupE;" }],
        [0, "&subsim;"],
        [0, "&supsim;"],
        [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }],
        [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }],
        [2, "&csub;"],
        [0, "&csup;"],
        [0, "&csube;"],
        [0, "&csupe;"],
        [0, "&subsup;"],
        [0, "&supsub;"],
        [0, "&subsub;"],
        [0, "&supsup;"],
        [0, "&suphsub;"],
        [0, "&supdsub;"],
        [0, "&forkv;"],
        [0, "&topfork;"],
        [0, "&mlcp;"],
        [8, "&Dashv;"],
        [1, "&Vdashl;"],
        [0, "&Barv;"],
        [0, "&vBar;"],
        [0, "&vBarv;"],
        [1, "&Vbar;"],
        [0, "&Not;"],
        [0, "&bNot;"],
        [0, "&rnmid;"],
        [0, "&cirmid;"],
        [0, "&midcir;"],
        [0, "&topcir;"],
        [0, "&nhpar;"],
        [0, "&parsim;"],
        [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }],
        [
          44343,
          {
            n: new Map(
              /* @__PURE__ */ restoreDiff([
                [56476, "&Ascr;"],
                [1, "&Cscr;"],
                [0, "&Dscr;"],
                [2, "&Gscr;"],
                [2, "&Jscr;"],
                [0, "&Kscr;"],
                [2, "&Nscr;"],
                [0, "&Oscr;"],
                [0, "&Pscr;"],
                [0, "&Qscr;"],
                [1, "&Sscr;"],
                [0, "&Tscr;"],
                [0, "&Uscr;"],
                [0, "&Vscr;"],
                [0, "&Wscr;"],
                [0, "&Xscr;"],
                [0, "&Yscr;"],
                [0, "&Zscr;"],
                [0, "&ascr;"],
                [0, "&bscr;"],
                [0, "&cscr;"],
                [0, "&dscr;"],
                [1, "&fscr;"],
                [1, "&hscr;"],
                [0, "&iscr;"],
                [0, "&jscr;"],
                [0, "&kscr;"],
                [0, "&lscr;"],
                [0, "&mscr;"],
                [0, "&nscr;"],
                [1, "&pscr;"],
                [0, "&qscr;"],
                [0, "&rscr;"],
                [0, "&sscr;"],
                [0, "&tscr;"],
                [0, "&uscr;"],
                [0, "&vscr;"],
                [0, "&wscr;"],
                [0, "&xscr;"],
                [0, "&yscr;"],
                [0, "&zscr;"],
                [52, "&Afr;"],
                [0, "&Bfr;"],
                [1, "&Dfr;"],
                [0, "&Efr;"],
                [0, "&Ffr;"],
                [0, "&Gfr;"],
                [2, "&Jfr;"],
                [0, "&Kfr;"],
                [0, "&Lfr;"],
                [0, "&Mfr;"],
                [0, "&Nfr;"],
                [0, "&Ofr;"],
                [0, "&Pfr;"],
                [0, "&Qfr;"],
                [1, "&Sfr;"],
                [0, "&Tfr;"],
                [0, "&Ufr;"],
                [0, "&Vfr;"],
                [0, "&Wfr;"],
                [0, "&Xfr;"],
                [0, "&Yfr;"],
                [1, "&afr;"],
                [0, "&bfr;"],
                [0, "&cfr;"],
                [0, "&dfr;"],
                [0, "&efr;"],
                [0, "&ffr;"],
                [0, "&gfr;"],
                [0, "&hfr;"],
                [0, "&ifr;"],
                [0, "&jfr;"],
                [0, "&kfr;"],
                [0, "&lfr;"],
                [0, "&mfr;"],
                [0, "&nfr;"],
                [0, "&ofr;"],
                [0, "&pfr;"],
                [0, "&qfr;"],
                [0, "&rfr;"],
                [0, "&sfr;"],
                [0, "&tfr;"],
                [0, "&ufr;"],
                [0, "&vfr;"],
                [0, "&wfr;"],
                [0, "&xfr;"],
                [0, "&yfr;"],
                [0, "&zfr;"],
                [0, "&Aopf;"],
                [0, "&Bopf;"],
                [1, "&Dopf;"],
                [0, "&Eopf;"],
                [0, "&Fopf;"],
                [0, "&Gopf;"],
                [1, "&Iopf;"],
                [0, "&Jopf;"],
                [0, "&Kopf;"],
                [0, "&Lopf;"],
                [0, "&Mopf;"],
                [1, "&Oopf;"],
                [3, "&Sopf;"],
                [0, "&Topf;"],
                [0, "&Uopf;"],
                [0, "&Vopf;"],
                [0, "&Wopf;"],
                [0, "&Xopf;"],
                [0, "&Yopf;"],
                [1, "&aopf;"],
                [0, "&bopf;"],
                [0, "&copf;"],
                [0, "&dopf;"],
                [0, "&eopf;"],
                [0, "&fopf;"],
                [0, "&gopf;"],
                [0, "&hopf;"],
                [0, "&iopf;"],
                [0, "&jopf;"],
                [0, "&kopf;"],
                [0, "&lopf;"],
                [0, "&mopf;"],
                [0, "&nopf;"],
                [0, "&oopf;"],
                [0, "&popf;"],
                [0, "&qopf;"],
                [0, "&ropf;"],
                [0, "&sopf;"],
                [0, "&topf;"],
                [0, "&uopf;"],
                [0, "&vopf;"],
                [0, "&wopf;"],
                [0, "&xopf;"],
                [0, "&yopf;"],
                [0, "&zopf;"],
              ]),
            ),
          },
        ],
        [8906, "&fflig;"],
        [0, "&filig;"],
        [0, "&fllig;"],
        [0, "&ffilig;"],
        [0, "&ffllig;"],
      ]),
    );
  },
});

// node_modules/entities/lib/escape.js
var require_escape = __commonJS({
  "node_modules/entities/lib/escape.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.escapeText =
      exports.escapeAttribute =
      exports.escapeUTF8 =
      exports.escape =
      exports.encodeXML =
      exports.getCodePoint =
      exports.xmlReplacer =
        void 0;
    exports.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
    var xmlCodeMap = /* @__PURE__ */ new Map([
      [34, "&quot;"],
      [38, "&amp;"],
      [39, "&apos;"],
      [60, "&lt;"],
      [62, "&gt;"],
    ]);
    exports.getCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      String.prototype.codePointAt != null
        ? function (str, index) {
            return str.codePointAt(index);
          }
        : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
          function (c2, index) {
            return (c2.charCodeAt(index) & 64512) === 55296
              ? (c2.charCodeAt(index) - 55296) * 1024 +
                  c2.charCodeAt(index + 1) -
                  56320 +
                  65536
              : c2.charCodeAt(index);
          };
    function encodeXML(str) {
      var ret = "";
      var lastIdx = 0;
      var match;
      while ((match = exports.xmlReplacer.exec(str)) !== null) {
        var i2 = match.index;
        var char = str.charCodeAt(i2);
        var next = xmlCodeMap.get(char);
        if (next !== void 0) {
          ret += str.substring(lastIdx, i2) + next;
          lastIdx = i2 + 1;
        } else {
          ret += ""
            .concat(str.substring(lastIdx, i2), "&#x")
            .concat((0, exports.getCodePoint)(str, i2).toString(16), ";");
          lastIdx = exports.xmlReplacer.lastIndex += Number(
            (char & 64512) === 55296,
          );
        }
      }
      return ret + str.substr(lastIdx);
    }
    exports.encodeXML = encodeXML;
    exports.escape = encodeXML;
    function getEscaper(regex, map2) {
      return function escape(data) {
        var match;
        var lastIdx = 0;
        var result = "";
        while ((match = regex.exec(data))) {
          if (lastIdx !== match.index) {
            result += data.substring(lastIdx, match.index);
          }
          result += map2.get(match[0].charCodeAt(0));
          lastIdx = match.index + 1;
        }
        return result + data.substring(lastIdx);
      };
    }
    exports.escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
    exports.escapeAttribute = getEscaper(
      /["&\u00A0]/g,
      /* @__PURE__ */ new Map([
        [34, "&quot;"],
        [38, "&amp;"],
        [160, "&nbsp;"],
      ]),
    );
    exports.escapeText = getEscaper(
      /[&<>\u00A0]/g,
      /* @__PURE__ */ new Map([
        [38, "&amp;"],
        [60, "&lt;"],
        [62, "&gt;"],
        [160, "&nbsp;"],
      ]),
    );
  },
});

// node_modules/entities/lib/encode.js
var require_encode = __commonJS({
  "node_modules/entities/lib/encode.js"(exports) {
    "use strict";
    var __importDefault =
      (exports && exports.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeNonAsciiHTML = exports.encodeHTML = void 0;
    var encode_html_js_1 = __importDefault(require_encode_html());
    var escape_js_1 = require_escape();
    var htmlReplacer = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
    function encodeHTML(data) {
      return encodeHTMLTrieRe(htmlReplacer, data);
    }
    exports.encodeHTML = encodeHTML;
    function encodeNonAsciiHTML(data) {
      return encodeHTMLTrieRe(escape_js_1.xmlReplacer, data);
    }
    exports.encodeNonAsciiHTML = encodeNonAsciiHTML;
    function encodeHTMLTrieRe(regExp, str) {
      var ret = "";
      var lastIdx = 0;
      var match;
      while ((match = regExp.exec(str)) !== null) {
        var i2 = match.index;
        ret += str.substring(lastIdx, i2);
        var char = str.charCodeAt(i2);
        var next = encode_html_js_1.default.get(char);
        if (typeof next === "object") {
          if (i2 + 1 < str.length) {
            var nextChar = str.charCodeAt(i2 + 1);
            var value =
              typeof next.n === "number"
                ? next.n === nextChar
                  ? next.o
                  : void 0
                : next.n.get(nextChar);
            if (value !== void 0) {
              ret += value;
              lastIdx = regExp.lastIndex += 1;
              continue;
            }
          }
          next = next.v;
        }
        if (next !== void 0) {
          ret += next;
          lastIdx = i2 + 1;
        } else {
          var cp = (0, escape_js_1.getCodePoint)(str, i2);
          ret += "&#x".concat(cp.toString(16), ";");
          lastIdx = regExp.lastIndex += Number(cp !== char);
        }
      }
      return ret + str.substr(lastIdx);
    }
  },
});

// node_modules/entities/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/entities/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeXMLStrict =
      exports.decodeHTML5Strict =
      exports.decodeHTML4Strict =
      exports.decodeHTML5 =
      exports.decodeHTML4 =
      exports.decodeHTMLAttribute =
      exports.decodeHTMLStrict =
      exports.decodeHTML =
      exports.decodeXML =
      exports.DecodingMode =
      exports.EntityDecoder =
      exports.encodeHTML5 =
      exports.encodeHTML4 =
      exports.encodeNonAsciiHTML =
      exports.encodeHTML =
      exports.escapeText =
      exports.escapeAttribute =
      exports.escapeUTF8 =
      exports.escape =
      exports.encodeXML =
      exports.encode =
      exports.decodeStrict =
      exports.decode =
      exports.EncodingMode =
      exports.EntityLevel =
        void 0;
    var decode_js_1 = require_decode();
    var encode_js_1 = require_encode();
    var escape_js_1 = require_escape();
    var EntityLevel;
    (function (EntityLevel2) {
      EntityLevel2[(EntityLevel2["XML"] = 0)] = "XML";
      EntityLevel2[(EntityLevel2["HTML"] = 1)] = "HTML";
    })((EntityLevel = exports.EntityLevel || (exports.EntityLevel = {})));
    var EncodingMode;
    (function (EncodingMode2) {
      EncodingMode2[(EncodingMode2["UTF8"] = 0)] = "UTF8";
      EncodingMode2[(EncodingMode2["ASCII"] = 1)] = "ASCII";
      EncodingMode2[(EncodingMode2["Extensive"] = 2)] = "Extensive";
      EncodingMode2[(EncodingMode2["Attribute"] = 3)] = "Attribute";
      EncodingMode2[(EncodingMode2["Text"] = 4)] = "Text";
    })((EncodingMode = exports.EncodingMode || (exports.EncodingMode = {})));
    function decode4(data, options) {
      if (options === void 0) {
        options = EntityLevel.XML;
      }
      var level = typeof options === "number" ? options : options.level;
      if (level === EntityLevel.HTML) {
        var mode = typeof options === "object" ? options.mode : void 0;
        return (0, decode_js_1.decodeHTML)(data, mode);
      }
      return (0, decode_js_1.decodeXML)(data);
    }
    exports.decode = decode4;
    function decodeStrict(data, options) {
      var _a19;
      if (options === void 0) {
        options = EntityLevel.XML;
      }
      var opts = typeof options === "number" ? { level: options } : options;
      (_a19 = opts.mode) !== null && _a19 !== void 0
        ? _a19
        : (opts.mode = decode_js_1.DecodingMode.Strict);
      return decode4(data, opts);
    }
    exports.decodeStrict = decodeStrict;
    function encode4(data, options) {
      if (options === void 0) {
        options = EntityLevel.XML;
      }
      var opts = typeof options === "number" ? { level: options } : options;
      if (opts.mode === EncodingMode.UTF8)
        return (0, escape_js_1.escapeUTF8)(data);
      if (opts.mode === EncodingMode.Attribute)
        return (0, escape_js_1.escapeAttribute)(data);
      if (opts.mode === EncodingMode.Text)
        return (0, escape_js_1.escapeText)(data);
      if (opts.level === EntityLevel.HTML) {
        if (opts.mode === EncodingMode.ASCII) {
          return (0, encode_js_1.encodeNonAsciiHTML)(data);
        }
        return (0, encode_js_1.encodeHTML)(data);
      }
      return (0, escape_js_1.encodeXML)(data);
    }
    exports.encode = encode4;
    var escape_js_2 = require_escape();
    Object.defineProperty(exports, "encodeXML", {
      enumerable: true,
      get: function () {
        return escape_js_2.encodeXML;
      },
    });
    Object.defineProperty(exports, "escape", {
      enumerable: true,
      get: function () {
        return escape_js_2.escape;
      },
    });
    Object.defineProperty(exports, "escapeUTF8", {
      enumerable: true,
      get: function () {
        return escape_js_2.escapeUTF8;
      },
    });
    Object.defineProperty(exports, "escapeAttribute", {
      enumerable: true,
      get: function () {
        return escape_js_2.escapeAttribute;
      },
    });
    Object.defineProperty(exports, "escapeText", {
      enumerable: true,
      get: function () {
        return escape_js_2.escapeText;
      },
    });
    var encode_js_2 = require_encode();
    Object.defineProperty(exports, "encodeHTML", {
      enumerable: true,
      get: function () {
        return encode_js_2.encodeHTML;
      },
    });
    Object.defineProperty(exports, "encodeNonAsciiHTML", {
      enumerable: true,
      get: function () {
        return encode_js_2.encodeNonAsciiHTML;
      },
    });
    Object.defineProperty(exports, "encodeHTML4", {
      enumerable: true,
      get: function () {
        return encode_js_2.encodeHTML;
      },
    });
    Object.defineProperty(exports, "encodeHTML5", {
      enumerable: true,
      get: function () {
        return encode_js_2.encodeHTML;
      },
    });
    var decode_js_2 = require_decode();
    Object.defineProperty(exports, "EntityDecoder", {
      enumerable: true,
      get: function () {
        return decode_js_2.EntityDecoder;
      },
    });
    Object.defineProperty(exports, "DecodingMode", {
      enumerable: true,
      get: function () {
        return decode_js_2.DecodingMode;
      },
    });
    Object.defineProperty(exports, "decodeXML", {
      enumerable: true,
      get: function () {
        return decode_js_2.decodeXML;
      },
    });
    Object.defineProperty(exports, "decodeHTML", {
      enumerable: true,
      get: function () {
        return decode_js_2.decodeHTML;
      },
    });
    Object.defineProperty(exports, "decodeHTMLStrict", {
      enumerable: true,
      get: function () {
        return decode_js_2.decodeHTMLStrict;
      },
    });
    Object.defineProperty(exports, "decodeHTMLAttribute", {
      enumerable: true,
      get: function () {
        return decode_js_2.decodeHTMLAttribute;
      },
    });
    Object.defineProperty(exports, "decodeHTML4", {
      enumerable: true,
      get: function () {
        return decode_js_2.decodeHTML;
      },
    });
    Object.defineProperty(exports, "decodeHTML5", {
      enumerable: true,
      get: function () {
        return decode_js_2.decodeHTML;
      },
    });
    Object.defineProperty(exports, "decodeHTML4Strict", {
      enumerable: true,
      get: function () {
        return decode_js_2.decodeHTMLStrict;
      },
    });
    Object.defineProperty(exports, "decodeHTML5Strict", {
      enumerable: true,
      get: function () {
        return decode_js_2.decodeHTMLStrict;
      },
    });
    Object.defineProperty(exports, "decodeXMLStrict", {
      enumerable: true,
      get: function () {
        return decode_js_2.decodeXML;
      },
    });
  },
});

// node_modules/dom-serializer/lib/foreignNames.js
var require_foreignNames = __commonJS({
  "node_modules/dom-serializer/lib/foreignNames.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.attributeNames = exports.elementNames = void 0;
    exports.elementNames = new Map(
      [
        "altGlyph",
        "altGlyphDef",
        "altGlyphItem",
        "animateColor",
        "animateMotion",
        "animateTransform",
        "clipPath",
        "feBlend",
        "feColorMatrix",
        "feComponentTransfer",
        "feComposite",
        "feConvolveMatrix",
        "feDiffuseLighting",
        "feDisplacementMap",
        "feDistantLight",
        "feDropShadow",
        "feFlood",
        "feFuncA",
        "feFuncB",
        "feFuncG",
        "feFuncR",
        "feGaussianBlur",
        "feImage",
        "feMerge",
        "feMergeNode",
        "feMorphology",
        "feOffset",
        "fePointLight",
        "feSpecularLighting",
        "feSpotLight",
        "feTile",
        "feTurbulence",
        "foreignObject",
        "glyphRef",
        "linearGradient",
        "radialGradient",
        "textPath",
      ].map(function (val) {
        return [val.toLowerCase(), val];
      }),
    );
    exports.attributeNames = new Map(
      [
        "definitionURL",
        "attributeName",
        "attributeType",
        "baseFrequency",
        "baseProfile",
        "calcMode",
        "clipPathUnits",
        "diffuseConstant",
        "edgeMode",
        "filterUnits",
        "glyphRef",
        "gradientTransform",
        "gradientUnits",
        "kernelMatrix",
        "kernelUnitLength",
        "keyPoints",
        "keySplines",
        "keyTimes",
        "lengthAdjust",
        "limitingConeAngle",
        "markerHeight",
        "markerUnits",
        "markerWidth",
        "maskContentUnits",
        "maskUnits",
        "numOctaves",
        "pathLength",
        "patternContentUnits",
        "patternTransform",
        "patternUnits",
        "pointsAtX",
        "pointsAtY",
        "pointsAtZ",
        "preserveAlpha",
        "preserveAspectRatio",
        "primitiveUnits",
        "refX",
        "refY",
        "repeatCount",
        "repeatDur",
        "requiredExtensions",
        "requiredFeatures",
        "specularConstant",
        "specularExponent",
        "spreadMethod",
        "startOffset",
        "stdDeviation",
        "stitchTiles",
        "surfaceScale",
        "systemLanguage",
        "tableValues",
        "targetX",
        "targetY",
        "textLength",
        "viewBox",
        "viewTarget",
        "xChannelSelector",
        "yChannelSelector",
        "zoomAndPan",
      ].map(function (val) {
        return [val.toLowerCase(), val];
      }),
    );
  },
});

// node_modules/dom-serializer/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/dom-serializer/lib/index.js"(exports) {
    "use strict";
    var __assign =
      (exports && exports.__assign) ||
      function () {
        __assign =
          Object.assign ||
          function (t2) {
            for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {
              s2 = arguments[i2];
              for (var p2 in s2)
                if (Object.prototype.hasOwnProperty.call(s2, p2))
                  t2[p2] = s2[p2];
            }
            return t2;
          };
        return __assign.apply(this, arguments);
      };
    var __createBinding =
      (exports && exports.__createBinding) ||
      (Object.create
        ? function (o2, m2, k, k2) {
            if (k2 === void 0) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m2, k);
            if (
              !desc ||
              ("get" in desc
                ? !m2.__esModule
                : desc.writable || desc.configurable)
            ) {
              desc = {
                enumerable: true,
                get: function () {
                  return m2[k];
                },
              };
            }
            Object.defineProperty(o2, k2, desc);
          }
        : function (o2, m2, k, k2) {
            if (k2 === void 0) k2 = k;
            o2[k2] = m2[k];
          });
    var __setModuleDefault =
      (exports && exports.__setModuleDefault) ||
      (Object.create
        ? function (o2, v2) {
            Object.defineProperty(o2, "default", {
              enumerable: true,
              value: v2,
            });
          }
        : function (o2, v2) {
            o2["default"] = v2;
          });
    var __importStar =
      (exports && exports.__importStar) ||
      function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.render = void 0;
    var ElementType = __importStar(require_lib());
    var entities_1 = require_lib3();
    var foreignNames_js_1 = require_foreignNames();
    var unencodedElements = /* @__PURE__ */ new Set([
      "style",
      "script",
      "xmp",
      "iframe",
      "noembed",
      "noframes",
      "plaintext",
      "noscript",
    ]);
    function replaceQuotes(value) {
      return value.replace(/"/g, "&quot;");
    }
    function formatAttributes(attributes, opts) {
      var _a19;
      if (!attributes) return;
      var encode4 =
        ((_a19 = opts.encodeEntities) !== null && _a19 !== void 0
          ? _a19
          : opts.decodeEntities) === false
          ? replaceQuotes
          : opts.xmlMode || opts.encodeEntities !== "utf8"
            ? entities_1.encodeXML
            : entities_1.escapeAttribute;
      return Object.keys(attributes)
        .map(function (key) {
          var _a20, _b9;
          var value =
            (_a20 = attributes[key]) !== null && _a20 !== void 0 ? _a20 : "";
          if (opts.xmlMode === "foreign") {
            key =
              (_b9 = foreignNames_js_1.attributeNames.get(key)) !== null &&
              _b9 !== void 0
                ? _b9
                : key;
          }
          if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
            return key;
          }
          return "".concat(key, '="').concat(encode4(value), '"');
        })
        .join(" ");
    }
    var singleTag = /* @__PURE__ */ new Set([
      "area",
      "base",
      "basefont",
      "br",
      "col",
      "command",
      "embed",
      "frame",
      "hr",
      "img",
      "input",
      "isindex",
      "keygen",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr",
    ]);
    function render(node, options) {
      if (options === void 0) {
        options = {};
      }
      var nodes = "length" in node ? node : [node];
      var output = "";
      for (var i2 = 0; i2 < nodes.length; i2++) {
        output += renderNode(nodes[i2], options);
      }
      return output;
    }
    exports.render = render;
    exports.default = render;
    function renderNode(node, options) {
      switch (node.type) {
        case ElementType.Root:
          return render(node.children, options);
        // @ts-expect-error We don't use `Doctype` yet
        case ElementType.Doctype:
        case ElementType.Directive:
          return renderDirective(node);
        case ElementType.Comment:
          return renderComment(node);
        case ElementType.CDATA:
          return renderCdata(node);
        case ElementType.Script:
        case ElementType.Style:
        case ElementType.Tag:
          return renderTag(node, options);
        case ElementType.Text:
          return renderText(node, options);
      }
    }
    var foreignModeIntegrationPoints = /* @__PURE__ */ new Set([
      "mi",
      "mo",
      "mn",
      "ms",
      "mtext",
      "annotation-xml",
      "foreignObject",
      "desc",
      "title",
    ]);
    var foreignElements = /* @__PURE__ */ new Set(["svg", "math"]);
    function renderTag(elem, opts) {
      var _a19;
      if (opts.xmlMode === "foreign") {
        elem.name =
          (_a19 = foreignNames_js_1.elementNames.get(elem.name)) !== null &&
          _a19 !== void 0
            ? _a19
            : elem.name;
        if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
          opts = __assign(__assign({}, opts), { xmlMode: false });
        }
      }
      if (!opts.xmlMode && foreignElements.has(elem.name)) {
        opts = __assign(__assign({}, opts), { xmlMode: "foreign" });
      }
      var tag = "<".concat(elem.name);
      var attribs = formatAttributes(elem.attribs, opts);
      if (attribs) {
        tag += " ".concat(attribs);
      }
      if (
        elem.children.length === 0 &&
        (opts.xmlMode
          ? // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
            opts.selfClosingTags !== false
          : // User explicitly asked for self-closing tags, even in HTML mode
            opts.selfClosingTags && singleTag.has(elem.name))
      ) {
        if (!opts.xmlMode) tag += " ";
        tag += "/>";
      } else {
        tag += ">";
        if (elem.children.length > 0) {
          tag += render(elem.children, opts);
        }
        if (opts.xmlMode || !singleTag.has(elem.name)) {
          tag += "</".concat(elem.name, ">");
        }
      }
      return tag;
    }
    function renderDirective(elem) {
      return "<".concat(elem.data, ">");
    }
    function renderText(elem, opts) {
      var _a19;
      var data = elem.data || "";
      if (
        ((_a19 = opts.encodeEntities) !== null && _a19 !== void 0
          ? _a19
          : opts.decodeEntities) !== false &&
        !(
          !opts.xmlMode &&
          elem.parent &&
          unencodedElements.has(elem.parent.name)
        )
      ) {
        data =
          opts.xmlMode || opts.encodeEntities !== "utf8"
            ? (0, entities_1.encodeXML)(data)
            : (0, entities_1.escapeText)(data);
      }
      return data;
    }
    function renderCdata(elem) {
      return "<![CDATA[".concat(elem.children[0].data, "]]>");
    }
    function renderComment(elem) {
      return "<!--".concat(elem.data, "-->");
    }
  },
});

// node_modules/domutils/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/domutils/lib/stringify.js"(exports) {
    "use strict";
    var __importDefault =
      (exports && exports.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getOuterHTML = getOuterHTML;
    exports.getInnerHTML = getInnerHTML;
    exports.getText = getText;
    exports.textContent = textContent;
    exports.innerText = innerText;
    var domhandler_1 = require_lib2();
    var dom_serializer_1 = __importDefault(require_lib4());
    var domelementtype_1 = require_lib();
    function getOuterHTML(node, options) {
      return (0, dom_serializer_1.default)(node, options);
    }
    function getInnerHTML(node, options) {
      return (0, domhandler_1.hasChildren)(node)
        ? node.children
            .map(function (node2) {
              return getOuterHTML(node2, options);
            })
            .join("")
        : "";
    }
    function getText(node) {
      if (Array.isArray(node)) return node.map(getText).join("");
      if ((0, domhandler_1.isTag)(node))
        return node.name === "br" ? "\n" : getText(node.children);
      if ((0, domhandler_1.isCDATA)(node)) return getText(node.children);
      if ((0, domhandler_1.isText)(node)) return node.data;
      return "";
    }
    function textContent(node) {
      if (Array.isArray(node)) return node.map(textContent).join("");
      if (
        (0, domhandler_1.hasChildren)(node) &&
        !(0, domhandler_1.isComment)(node)
      ) {
        return textContent(node.children);
      }
      if ((0, domhandler_1.isText)(node)) return node.data;
      return "";
    }
    function innerText(node) {
      if (Array.isArray(node)) return node.map(innerText).join("");
      if (
        (0, domhandler_1.hasChildren)(node) &&
        (node.type === domelementtype_1.ElementType.Tag ||
          (0, domhandler_1.isCDATA)(node))
      ) {
        return innerText(node.children);
      }
      if ((0, domhandler_1.isText)(node)) return node.data;
      return "";
    }
  },
});

// node_modules/domutils/lib/traversal.js
var require_traversal = __commonJS({
  "node_modules/domutils/lib/traversal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getChildren = getChildren;
    exports.getParent = getParent;
    exports.getSiblings = getSiblings;
    exports.getAttributeValue = getAttributeValue;
    exports.hasAttrib = hasAttrib;
    exports.getName = getName;
    exports.nextElementSibling = nextElementSibling;
    exports.prevElementSibling = prevElementSibling;
    var domhandler_1 = require_lib2();
    function getChildren(elem) {
      return (0, domhandler_1.hasChildren)(elem) ? elem.children : [];
    }
    function getParent(elem) {
      return elem.parent || null;
    }
    function getSiblings(elem) {
      var _a19, _b9;
      var parent = getParent(elem);
      if (parent != null) return getChildren(parent);
      var siblings = [elem];
      var prev = elem.prev,
        next = elem.next;
      while (prev != null) {
        siblings.unshift(prev);
        ((_a19 = prev), (prev = _a19.prev));
      }
      while (next != null) {
        siblings.push(next);
        ((_b9 = next), (next = _b9.next));
      }
      return siblings;
    }
    function getAttributeValue(elem, name18) {
      var _a19;
      return (_a19 = elem.attribs) === null || _a19 === void 0
        ? void 0
        : _a19[name18];
    }
    function hasAttrib(elem, name18) {
      return (
        elem.attribs != null &&
        Object.prototype.hasOwnProperty.call(elem.attribs, name18) &&
        elem.attribs[name18] != null
      );
    }
    function getName(elem) {
      return elem.name;
    }
    function nextElementSibling(elem) {
      var _a19;
      var next = elem.next;
      while (next !== null && !(0, domhandler_1.isTag)(next))
        ((_a19 = next), (next = _a19.next));
      return next;
    }
    function prevElementSibling(elem) {
      var _a19;
      var prev = elem.prev;
      while (prev !== null && !(0, domhandler_1.isTag)(prev))
        ((_a19 = prev), (prev = _a19.prev));
      return prev;
    }
  },
});

// node_modules/domutils/lib/manipulation.js
var require_manipulation = __commonJS({
  "node_modules/domutils/lib/manipulation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.removeElement = removeElement;
    exports.replaceElement = replaceElement;
    exports.appendChild = appendChild;
    exports.append = append;
    exports.prependChild = prependChild;
    exports.prepend = prepend;
    function removeElement(elem) {
      if (elem.prev) elem.prev.next = elem.next;
      if (elem.next) elem.next.prev = elem.prev;
      if (elem.parent) {
        var childs = elem.parent.children;
        var childsIndex = childs.lastIndexOf(elem);
        if (childsIndex >= 0) {
          childs.splice(childsIndex, 1);
        }
      }
      elem.next = null;
      elem.prev = null;
      elem.parent = null;
    }
    function replaceElement(elem, replacement) {
      var prev = (replacement.prev = elem.prev);
      if (prev) {
        prev.next = replacement;
      }
      var next = (replacement.next = elem.next);
      if (next) {
        next.prev = replacement;
      }
      var parent = (replacement.parent = elem.parent);
      if (parent) {
        var childs = parent.children;
        childs[childs.lastIndexOf(elem)] = replacement;
        elem.parent = null;
      }
    }
    function appendChild(parent, child) {
      removeElement(child);
      child.next = null;
      child.parent = parent;
      if (parent.children.push(child) > 1) {
        var sibling = parent.children[parent.children.length - 2];
        sibling.next = child;
        child.prev = sibling;
      } else {
        child.prev = null;
      }
    }
    function append(elem, next) {
      removeElement(next);
      var parent = elem.parent;
      var currNext = elem.next;
      next.next = currNext;
      next.prev = elem;
      elem.next = next;
      next.parent = parent;
      if (currNext) {
        currNext.prev = next;
        if (parent) {
          var childs = parent.children;
          childs.splice(childs.lastIndexOf(currNext), 0, next);
        }
      } else if (parent) {
        parent.children.push(next);
      }
    }
    function prependChild(parent, child) {
      removeElement(child);
      child.parent = parent;
      child.prev = null;
      if (parent.children.unshift(child) !== 1) {
        var sibling = parent.children[1];
        sibling.prev = child;
        child.next = sibling;
      } else {
        child.next = null;
      }
    }
    function prepend(elem, prev) {
      removeElement(prev);
      var parent = elem.parent;
      if (parent) {
        var childs = parent.children;
        childs.splice(childs.indexOf(elem), 0, prev);
      }
      if (elem.prev) {
        elem.prev.next = prev;
      }
      prev.parent = parent;
      prev.prev = elem.prev;
      prev.next = elem;
      elem.prev = prev;
    }
  },
});

// node_modules/domutils/lib/querying.js
var require_querying = __commonJS({
  "node_modules/domutils/lib/querying.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.filter = filter2;
    exports.find = find;
    exports.findOneChild = findOneChild;
    exports.findOne = findOne;
    exports.existsOne = existsOne;
    exports.findAll = findAll;
    var domhandler_1 = require_lib2();
    function filter2(test, node, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      return find(test, Array.isArray(node) ? node : [node], recurse, limit);
    }
    function find(test, nodes, recurse, limit) {
      var result = [];
      var nodeStack = [Array.isArray(nodes) ? nodes : [nodes]];
      var indexStack = [0];
      for (;;) {
        if (indexStack[0] >= nodeStack[0].length) {
          if (indexStack.length === 1) {
            return result;
          }
          nodeStack.shift();
          indexStack.shift();
          continue;
        }
        var elem = nodeStack[0][indexStack[0]++];
        if (test(elem)) {
          result.push(elem);
          if (--limit <= 0) return result;
        }
        if (
          recurse &&
          (0, domhandler_1.hasChildren)(elem) &&
          elem.children.length > 0
        ) {
          indexStack.unshift(0);
          nodeStack.unshift(elem.children);
        }
      }
    }
    function findOneChild(test, nodes) {
      return nodes.find(test);
    }
    function findOne(test, nodes, recurse) {
      if (recurse === void 0) {
        recurse = true;
      }
      var searchedNodes = Array.isArray(nodes) ? nodes : [nodes];
      for (var i2 = 0; i2 < searchedNodes.length; i2++) {
        var node = searchedNodes[i2];
        if ((0, domhandler_1.isTag)(node) && test(node)) {
          return node;
        }
        if (
          recurse &&
          (0, domhandler_1.hasChildren)(node) &&
          node.children.length > 0
        ) {
          var found = findOne(test, node.children, true);
          if (found) return found;
        }
      }
      return null;
    }
    function existsOne(test, nodes) {
      return (Array.isArray(nodes) ? nodes : [nodes]).some(function (node) {
        return (
          ((0, domhandler_1.isTag)(node) && test(node)) ||
          ((0, domhandler_1.hasChildren)(node) &&
            existsOne(test, node.children))
        );
      });
    }
    function findAll(test, nodes) {
      var result = [];
      var nodeStack = [Array.isArray(nodes) ? nodes : [nodes]];
      var indexStack = [0];
      for (;;) {
        if (indexStack[0] >= nodeStack[0].length) {
          if (nodeStack.length === 1) {
            return result;
          }
          nodeStack.shift();
          indexStack.shift();
          continue;
        }
        var elem = nodeStack[0][indexStack[0]++];
        if ((0, domhandler_1.isTag)(elem) && test(elem)) result.push(elem);
        if ((0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {
          indexStack.unshift(0);
          nodeStack.unshift(elem.children);
        }
      }
    }
  },
});

// node_modules/domutils/lib/legacy.js
var require_legacy = __commonJS({
  "node_modules/domutils/lib/legacy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.testElement = testElement;
    exports.getElements = getElements;
    exports.getElementById = getElementById;
    exports.getElementsByTagName = getElementsByTagName;
    exports.getElementsByClassName = getElementsByClassName;
    exports.getElementsByTagType = getElementsByTagType;
    var domhandler_1 = require_lib2();
    var querying_js_1 = require_querying();
    var Checks = {
      tag_name: function (name18) {
        if (typeof name18 === "function") {
          return function (elem) {
            return (0, domhandler_1.isTag)(elem) && name18(elem.name);
          };
        } else if (name18 === "*") {
          return domhandler_1.isTag;
        }
        return function (elem) {
          return (0, domhandler_1.isTag)(elem) && elem.name === name18;
        };
      },
      tag_type: function (type) {
        if (typeof type === "function") {
          return function (elem) {
            return type(elem.type);
          };
        }
        return function (elem) {
          return elem.type === type;
        };
      },
      tag_contains: function (data) {
        if (typeof data === "function") {
          return function (elem) {
            return (0, domhandler_1.isText)(elem) && data(elem.data);
          };
        }
        return function (elem) {
          return (0, domhandler_1.isText)(elem) && elem.data === data;
        };
      },
    };
    function getAttribCheck(attrib, value) {
      if (typeof value === "function") {
        return function (elem) {
          return (0, domhandler_1.isTag)(elem) && value(elem.attribs[attrib]);
        };
      }
      return function (elem) {
        return (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value;
      };
    }
    function combineFuncs(a2, b2) {
      return function (elem) {
        return a2(elem) || b2(elem);
      };
    }
    function compileTest(options) {
      var funcs = Object.keys(options).map(function (key) {
        var value = options[key];
        return Object.prototype.hasOwnProperty.call(Checks, key)
          ? Checks[key](value)
          : getAttribCheck(key, value);
      });
      return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
    }
    function testElement(options, node) {
      var test = compileTest(options);
      return test ? test(node) : true;
    }
    function getElements(options, nodes, recurse, limit) {
      if (limit === void 0) {
        limit = Infinity;
      }
      var test = compileTest(options);
      return test ? (0, querying_js_1.filter)(test, nodes, recurse, limit) : [];
    }
    function getElementById(id, nodes, recurse) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (!Array.isArray(nodes)) nodes = [nodes];
      return (0, querying_js_1.findOne)(
        getAttribCheck("id", id),
        nodes,
        recurse,
      );
    }
    function getElementsByTagName(tagName, nodes, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      return (0, querying_js_1.filter)(
        Checks["tag_name"](tagName),
        nodes,
        recurse,
        limit,
      );
    }
    function getElementsByClassName(className, nodes, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      return (0, querying_js_1.filter)(
        getAttribCheck("class", className),
        nodes,
        recurse,
        limit,
      );
    }
    function getElementsByTagType(type, nodes, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      return (0, querying_js_1.filter)(
        Checks["tag_type"](type),
        nodes,
        recurse,
        limit,
      );
    }
  },
});

// node_modules/domutils/lib/helpers.js
var require_helpers = __commonJS({
  "node_modules/domutils/lib/helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DocumentPosition = void 0;
    exports.removeSubsets = removeSubsets;
    exports.compareDocumentPosition = compareDocumentPosition;
    exports.uniqueSort = uniqueSort;
    var domhandler_1 = require_lib2();
    function removeSubsets(nodes) {
      var idx = nodes.length;
      while (--idx >= 0) {
        var node = nodes[idx];
        if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
          nodes.splice(idx, 1);
          continue;
        }
        for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
          if (nodes.includes(ancestor)) {
            nodes.splice(idx, 1);
            break;
          }
        }
      }
      return nodes;
    }
    var DocumentPosition;
    (function (DocumentPosition2) {
      DocumentPosition2[(DocumentPosition2["DISCONNECTED"] = 1)] =
        "DISCONNECTED";
      DocumentPosition2[(DocumentPosition2["PRECEDING"] = 2)] = "PRECEDING";
      DocumentPosition2[(DocumentPosition2["FOLLOWING"] = 4)] = "FOLLOWING";
      DocumentPosition2[(DocumentPosition2["CONTAINS"] = 8)] = "CONTAINS";
      DocumentPosition2[(DocumentPosition2["CONTAINED_BY"] = 16)] =
        "CONTAINED_BY";
    })(DocumentPosition || (exports.DocumentPosition = DocumentPosition = {}));
    function compareDocumentPosition(nodeA, nodeB) {
      var aParents = [];
      var bParents = [];
      if (nodeA === nodeB) {
        return 0;
      }
      var current = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;
      while (current) {
        aParents.unshift(current);
        current = current.parent;
      }
      current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;
      while (current) {
        bParents.unshift(current);
        current = current.parent;
      }
      var maxIdx = Math.min(aParents.length, bParents.length);
      var idx = 0;
      while (idx < maxIdx && aParents[idx] === bParents[idx]) {
        idx++;
      }
      if (idx === 0) {
        return DocumentPosition.DISCONNECTED;
      }
      var sharedParent = aParents[idx - 1];
      var siblings = sharedParent.children;
      var aSibling = aParents[idx];
      var bSibling = bParents[idx];
      if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
        if (sharedParent === nodeB) {
          return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
        }
        return DocumentPosition.FOLLOWING;
      }
      if (sharedParent === nodeA) {
        return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
      }
      return DocumentPosition.PRECEDING;
    }
    function uniqueSort(nodes) {
      nodes = nodes.filter(function (node, i2, arr) {
        return !arr.includes(node, i2 + 1);
      });
      nodes.sort(function (a2, b2) {
        var relative = compareDocumentPosition(a2, b2);
        if (relative & DocumentPosition.PRECEDING) {
          return -1;
        } else if (relative & DocumentPosition.FOLLOWING) {
          return 1;
        }
        return 0;
      });
      return nodes;
    }
  },
});

// node_modules/domutils/lib/feeds.js
var require_feeds = __commonJS({
  "node_modules/domutils/lib/feeds.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFeed = getFeed;
    var stringify_js_1 = require_stringify();
    var legacy_js_1 = require_legacy();
    function getFeed(doc) {
      var feedRoot = getOneElement(isValidFeed, doc);
      return !feedRoot
        ? null
        : feedRoot.name === "feed"
          ? getAtomFeed(feedRoot)
          : getRssFeed(feedRoot);
    }
    function getAtomFeed(feedRoot) {
      var _a19;
      var childs = feedRoot.children;
      var feed = {
        type: "atom",
        items: (0, legacy_js_1.getElementsByTagName)("entry", childs).map(
          function (item) {
            var _a20;
            var children = item.children;
            var entry = { media: getMediaElements(children) };
            addConditionally(entry, "id", "id", children);
            addConditionally(entry, "title", "title", children);
            var href2 =
              (_a20 = getOneElement("link", children)) === null ||
              _a20 === void 0
                ? void 0
                : _a20.attribs["href"];
            if (href2) {
              entry.link = href2;
            }
            var description =
              fetch2("summary", children) || fetch2("content", children);
            if (description) {
              entry.description = description;
            }
            var pubDate = fetch2("updated", children);
            if (pubDate) {
              entry.pubDate = new Date(pubDate);
            }
            return entry;
          },
        ),
      };
      addConditionally(feed, "id", "id", childs);
      addConditionally(feed, "title", "title", childs);
      var href =
        (_a19 = getOneElement("link", childs)) === null || _a19 === void 0
          ? void 0
          : _a19.attribs["href"];
      if (href) {
        feed.link = href;
      }
      addConditionally(feed, "description", "subtitle", childs);
      var updated = fetch2("updated", childs);
      if (updated) {
        feed.updated = new Date(updated);
      }
      addConditionally(feed, "author", "email", childs, true);
      return feed;
    }
    function getRssFeed(feedRoot) {
      var _a19, _b9;
      var childs =
        (_b9 =
          (_a19 = getOneElement("channel", feedRoot.children)) === null ||
          _a19 === void 0
            ? void 0
            : _a19.children) !== null && _b9 !== void 0
          ? _b9
          : [];
      var feed = {
        type: feedRoot.name.substr(0, 3),
        id: "",
        items: (0, legacy_js_1.getElementsByTagName)(
          "item",
          feedRoot.children,
        ).map(function (item) {
          var children = item.children;
          var entry = { media: getMediaElements(children) };
          addConditionally(entry, "id", "guid", children);
          addConditionally(entry, "title", "title", children);
          addConditionally(entry, "link", "link", children);
          addConditionally(entry, "description", "description", children);
          var pubDate =
            fetch2("pubDate", children) || fetch2("dc:date", children);
          if (pubDate) entry.pubDate = new Date(pubDate);
          return entry;
        }),
      };
      addConditionally(feed, "title", "title", childs);
      addConditionally(feed, "link", "link", childs);
      addConditionally(feed, "description", "description", childs);
      var updated = fetch2("lastBuildDate", childs);
      if (updated) {
        feed.updated = new Date(updated);
      }
      addConditionally(feed, "author", "managingEditor", childs, true);
      return feed;
    }
    var MEDIA_KEYS_STRING = ["url", "type", "lang"];
    var MEDIA_KEYS_INT = [
      "fileSize",
      "bitrate",
      "framerate",
      "samplingrate",
      "channels",
      "duration",
      "height",
      "width",
    ];
    function getMediaElements(where) {
      return (0, legacy_js_1.getElementsByTagName)("media:content", where).map(
        function (elem) {
          var attribs = elem.attribs;
          var media = {
            medium: attribs["medium"],
            isDefault: !!attribs["isDefault"],
          };
          for (
            var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING;
            _i < MEDIA_KEYS_STRING_1.length;
            _i++
          ) {
            var attrib = MEDIA_KEYS_STRING_1[_i];
            if (attribs[attrib]) {
              media[attrib] = attribs[attrib];
            }
          }
          for (
            var _a19 = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT;
            _a19 < MEDIA_KEYS_INT_1.length;
            _a19++
          ) {
            var attrib = MEDIA_KEYS_INT_1[_a19];
            if (attribs[attrib]) {
              media[attrib] = parseInt(attribs[attrib], 10);
            }
          }
          if (attribs["expression"]) {
            media.expression = attribs["expression"];
          }
          return media;
        },
      );
    }
    function getOneElement(tagName, node) {
      return (0, legacy_js_1.getElementsByTagName)(tagName, node, true, 1)[0];
    }
    function fetch2(tagName, where, recurse) {
      if (recurse === void 0) {
        recurse = false;
      }
      return (0, stringify_js_1.textContent)(
        (0, legacy_js_1.getElementsByTagName)(tagName, where, recurse, 1),
      ).trim();
    }
    function addConditionally(obj, prop, tagName, where, recurse) {
      if (recurse === void 0) {
        recurse = false;
      }
      var val = fetch2(tagName, where, recurse);
      if (val) obj[prop] = val;
    }
    function isValidFeed(value) {
      return value === "rss" || value === "feed" || value === "rdf:RDF";
    }
  },
});

// node_modules/domutils/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/domutils/lib/index.js"(exports) {
    "use strict";
    var __createBinding =
      (exports && exports.__createBinding) ||
      (Object.create
        ? function (o2, m2, k, k2) {
            if (k2 === void 0) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m2, k);
            if (
              !desc ||
              ("get" in desc
                ? !m2.__esModule
                : desc.writable || desc.configurable)
            ) {
              desc = {
                enumerable: true,
                get: function () {
                  return m2[k];
                },
              };
            }
            Object.defineProperty(o2, k2, desc);
          }
        : function (o2, m2, k, k2) {
            if (k2 === void 0) k2 = k;
            o2[k2] = m2[k];
          });
    var __exportStar =
      (exports && exports.__exportStar) ||
      function (m2, exports2) {
        for (var p2 in m2)
          if (
            p2 !== "default" &&
            !Object.prototype.hasOwnProperty.call(exports2, p2)
          )
            __createBinding(exports2, m2, p2);
      };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hasChildren =
      exports.isDocument =
      exports.isComment =
      exports.isText =
      exports.isCDATA =
      exports.isTag =
        void 0;
    __exportStar(require_stringify(), exports);
    __exportStar(require_traversal(), exports);
    __exportStar(require_manipulation(), exports);
    __exportStar(require_querying(), exports);
    __exportStar(require_legacy(), exports);
    __exportStar(require_helpers(), exports);
    __exportStar(require_feeds(), exports);
    var domhandler_1 = require_lib2();
    Object.defineProperty(exports, "isTag", {
      enumerable: true,
      get: function () {
        return domhandler_1.isTag;
      },
    });
    Object.defineProperty(exports, "isCDATA", {
      enumerable: true,
      get: function () {
        return domhandler_1.isCDATA;
      },
    });
    Object.defineProperty(exports, "isText", {
      enumerable: true,
      get: function () {
        return domhandler_1.isText;
      },
    });
    Object.defineProperty(exports, "isComment", {
      enumerable: true,
      get: function () {
        return domhandler_1.isComment;
      },
    });
    Object.defineProperty(exports, "isDocument", {
      enumerable: true,
      get: function () {
        return domhandler_1.isDocument;
      },
    });
    Object.defineProperty(exports, "hasChildren", {
      enumerable: true,
      get: function () {
        return domhandler_1.hasChildren;
      },
    });
  },
});

// node_modules/boolbase/index.js
var require_boolbase = __commonJS({
  "node_modules/boolbase/index.js"(exports, module) {
    module.exports = {
      trueFunc: function trueFunc() {
        return true;
      },
      falseFunc: function falseFunc() {
        return false;
      },
    };
  },
});

// node_modules/css-what/lib/es/types.js
var SelectorType, IgnoreCaseMode, AttributeAction;
var init_types = __esm({
  "node_modules/css-what/lib/es/types.js"() {
    (function (SelectorType2) {
      SelectorType2["Attribute"] = "attribute";
      SelectorType2["Pseudo"] = "pseudo";
      SelectorType2["PseudoElement"] = "pseudo-element";
      SelectorType2["Tag"] = "tag";
      SelectorType2["Universal"] = "universal";
      SelectorType2["Adjacent"] = "adjacent";
      SelectorType2["Child"] = "child";
      SelectorType2["Descendant"] = "descendant";
      SelectorType2["Parent"] = "parent";
      SelectorType2["Sibling"] = "sibling";
      SelectorType2["ColumnCombinator"] = "column-combinator";
    })(SelectorType || (SelectorType = {}));
    IgnoreCaseMode = {
      Unknown: null,
      QuirksMode: "quirks",
      IgnoreCase: true,
      CaseSensitive: false,
    };
    (function (AttributeAction2) {
      AttributeAction2["Any"] = "any";
      AttributeAction2["Element"] = "element";
      AttributeAction2["End"] = "end";
      AttributeAction2["Equals"] = "equals";
      AttributeAction2["Exists"] = "exists";
      AttributeAction2["Hyphen"] = "hyphen";
      AttributeAction2["Not"] = "not";
      AttributeAction2["Start"] = "start";
    })(AttributeAction || (AttributeAction = {}));
  },
});

// node_modules/css-what/lib/es/parse.js
function isTraversal(selector) {
  switch (selector.type) {
    case SelectorType.Adjacent:
    case SelectorType.Child:
    case SelectorType.Descendant:
    case SelectorType.Parent:
    case SelectorType.Sibling:
    case SelectorType.ColumnCombinator:
      return true;
    default:
      return false;
  }
}
function funescape(_2, escaped, escapedWhitespace) {
  const high = parseInt(escaped, 16) - 65536;
  return high !== high || escapedWhitespace
    ? escaped
    : high < 0
      ? // BMP codepoint
        String.fromCharCode(high + 65536)
      : // Supplemental Plane codepoint (surrogate pair)
        String.fromCharCode((high >> 10) | 55296, (high & 1023) | 56320);
}
function unescapeCSS(str) {
  return str.replace(reEscape, funescape);
}
function isQuote(c2) {
  return c2 === 39 || c2 === 34;
}
function isWhitespace(c2) {
  return c2 === 32 || c2 === 9 || c2 === 10 || c2 === 12 || c2 === 13;
}
function parse3(selector) {
  const subselects = [];
  const endIndex = parseSelector(subselects, `${selector}`, 0);
  if (endIndex < selector.length) {
    throw new Error(`Unmatched selector: ${selector.slice(endIndex)}`);
  }
  return subselects;
}
function parseSelector(subselects, selector, selectorIndex) {
  let tokens = [];
  function getName(offset) {
    const match = selector.slice(selectorIndex + offset).match(reName);
    if (!match) {
      throw new Error(`Expected name, found ${selector.slice(selectorIndex)}`);
    }
    const [name18] = match;
    selectorIndex += offset + name18.length;
    return unescapeCSS(name18);
  }
  function stripWhitespace(offset) {
    selectorIndex += offset;
    while (
      selectorIndex < selector.length &&
      isWhitespace(selector.charCodeAt(selectorIndex))
    ) {
      selectorIndex++;
    }
  }
  function readValueWithParenthesis() {
    selectorIndex += 1;
    const start = selectorIndex;
    let counter = 1;
    for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {
      if (
        selector.charCodeAt(selectorIndex) === 40 &&
        !isEscaped(selectorIndex)
      ) {
        counter++;
      } else if (
        selector.charCodeAt(selectorIndex) === 41 &&
        !isEscaped(selectorIndex)
      ) {
        counter--;
      }
    }
    if (counter) {
      throw new Error("Parenthesis not matched");
    }
    return unescapeCSS(selector.slice(start, selectorIndex - 1));
  }
  function isEscaped(pos) {
    let slashCount = 0;
    while (selector.charCodeAt(--pos) === 92) slashCount++;
    return (slashCount & 1) === 1;
  }
  function ensureNotTraversal() {
    if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1])) {
      throw new Error("Did not expect successive traversals.");
    }
  }
  function addTraversal(type) {
    if (
      tokens.length > 0 &&
      tokens[tokens.length - 1].type === SelectorType.Descendant
    ) {
      tokens[tokens.length - 1].type = type;
      return;
    }
    ensureNotTraversal();
    tokens.push({ type });
  }
  function addSpecialAttribute(name18, action) {
    tokens.push({
      type: SelectorType.Attribute,
      name: name18,
      action,
      value: getName(1),
      namespace: null,
      ignoreCase: "quirks",
    });
  }
  function finalizeSubselector() {
    if (
      tokens.length &&
      tokens[tokens.length - 1].type === SelectorType.Descendant
    ) {
      tokens.pop();
    }
    if (tokens.length === 0) {
      throw new Error("Empty sub-selector");
    }
    subselects.push(tokens);
  }
  stripWhitespace(0);
  if (selector.length === selectorIndex) {
    return selectorIndex;
  }
  loop: while (selectorIndex < selector.length) {
    const firstChar = selector.charCodeAt(selectorIndex);
    switch (firstChar) {
      // Whitespace
      case 32:
      case 9:
      case 10:
      case 12:
      case 13: {
        if (tokens.length === 0 || tokens[0].type !== SelectorType.Descendant) {
          ensureNotTraversal();
          tokens.push({ type: SelectorType.Descendant });
        }
        stripWhitespace(1);
        break;
      }
      // Traversals
      case 62: {
        addTraversal(SelectorType.Child);
        stripWhitespace(1);
        break;
      }
      case 60: {
        addTraversal(SelectorType.Parent);
        stripWhitespace(1);
        break;
      }
      case 126: {
        addTraversal(SelectorType.Sibling);
        stripWhitespace(1);
        break;
      }
      case 43: {
        addTraversal(SelectorType.Adjacent);
        stripWhitespace(1);
        break;
      }
      // Special attribute selectors: .class, #id
      case 46: {
        addSpecialAttribute("class", AttributeAction.Element);
        break;
      }
      case 35: {
        addSpecialAttribute("id", AttributeAction.Equals);
        break;
      }
      case 91: {
        stripWhitespace(1);
        let name18;
        let namespace = null;
        if (selector.charCodeAt(selectorIndex) === 124) {
          name18 = getName(1);
        } else if (selector.startsWith("*|", selectorIndex)) {
          namespace = "*";
          name18 = getName(2);
        } else {
          name18 = getName(0);
          if (
            selector.charCodeAt(selectorIndex) === 124 &&
            selector.charCodeAt(selectorIndex + 1) !== 61
          ) {
            namespace = name18;
            name18 = getName(1);
          }
        }
        stripWhitespace(0);
        let action = AttributeAction.Exists;
        const possibleAction = actionTypes.get(
          selector.charCodeAt(selectorIndex),
        );
        if (possibleAction) {
          action = possibleAction;
          if (selector.charCodeAt(selectorIndex + 1) !== 61) {
            throw new Error("Expected `=`");
          }
          stripWhitespace(2);
        } else if (selector.charCodeAt(selectorIndex) === 61) {
          action = AttributeAction.Equals;
          stripWhitespace(1);
        }
        let value = "";
        let ignoreCase = null;
        if (action !== "exists") {
          if (isQuote(selector.charCodeAt(selectorIndex))) {
            const quote = selector.charCodeAt(selectorIndex);
            let sectionEnd = selectorIndex + 1;
            while (
              sectionEnd < selector.length &&
              (selector.charCodeAt(sectionEnd) !== quote ||
                isEscaped(sectionEnd))
            ) {
              sectionEnd += 1;
            }
            if (selector.charCodeAt(sectionEnd) !== quote) {
              throw new Error("Attribute value didn't end");
            }
            value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));
            selectorIndex = sectionEnd + 1;
          } else {
            const valueStart = selectorIndex;
            while (
              selectorIndex < selector.length &&
              ((!isWhitespace(selector.charCodeAt(selectorIndex)) &&
                selector.charCodeAt(selectorIndex) !== 93) ||
                isEscaped(selectorIndex))
            ) {
              selectorIndex += 1;
            }
            value = unescapeCSS(selector.slice(valueStart, selectorIndex));
          }
          stripWhitespace(0);
          const forceIgnore = selector.charCodeAt(selectorIndex) | 32;
          if (forceIgnore === 115) {
            ignoreCase = false;
            stripWhitespace(1);
          } else if (forceIgnore === 105) {
            ignoreCase = true;
            stripWhitespace(1);
          }
        }
        if (selector.charCodeAt(selectorIndex) !== 93) {
          throw new Error("Attribute selector didn't terminate");
        }
        selectorIndex += 1;
        const attributeSelector = {
          type: SelectorType.Attribute,
          name: name18,
          action,
          value,
          namespace,
          ignoreCase,
        };
        tokens.push(attributeSelector);
        break;
      }
      case 58: {
        if (selector.charCodeAt(selectorIndex + 1) === 58) {
          tokens.push({
            type: SelectorType.PseudoElement,
            name: getName(2).toLowerCase(),
            data:
              selector.charCodeAt(selectorIndex) === 40
                ? readValueWithParenthesis()
                : null,
          });
          continue;
        }
        const name18 = getName(1).toLowerCase();
        let data = null;
        if (selector.charCodeAt(selectorIndex) === 40) {
          if (unpackPseudos.has(name18)) {
            if (isQuote(selector.charCodeAt(selectorIndex + 1))) {
              throw new Error(`Pseudo-selector ${name18} cannot be quoted`);
            }
            data = [];
            selectorIndex = parseSelector(data, selector, selectorIndex + 1);
            if (selector.charCodeAt(selectorIndex) !== 41) {
              throw new Error(
                `Missing closing parenthesis in :${name18} (${selector})`,
              );
            }
            selectorIndex += 1;
          } else {
            data = readValueWithParenthesis();
            if (stripQuotesFromPseudos.has(name18)) {
              const quot = data.charCodeAt(0);
              if (quot === data.charCodeAt(data.length - 1) && isQuote(quot)) {
                data = data.slice(1, -1);
              }
            }
            data = unescapeCSS(data);
          }
        }
        tokens.push({ type: SelectorType.Pseudo, name: name18, data });
        break;
      }
      case 44: {
        finalizeSubselector();
        tokens = [];
        stripWhitespace(1);
        break;
      }
      default: {
        if (selector.startsWith("/*", selectorIndex)) {
          const endIndex = selector.indexOf("*/", selectorIndex + 2);
          if (endIndex < 0) {
            throw new Error("Comment was not terminated");
          }
          selectorIndex = endIndex + 2;
          if (tokens.length === 0) {
            stripWhitespace(0);
          }
          break;
        }
        let namespace = null;
        let name18;
        if (firstChar === 42) {
          selectorIndex += 1;
          name18 = "*";
        } else if (firstChar === 124) {
          name18 = "";
          if (selector.charCodeAt(selectorIndex + 1) === 124) {
            addTraversal(SelectorType.ColumnCombinator);
            stripWhitespace(2);
            break;
          }
        } else if (reName.test(selector.slice(selectorIndex))) {
          name18 = getName(0);
        } else {
          break loop;
        }
        if (
          selector.charCodeAt(selectorIndex) === 124 &&
          selector.charCodeAt(selectorIndex + 1) !== 124
        ) {
          namespace = name18;
          if (selector.charCodeAt(selectorIndex + 1) === 42) {
            name18 = "*";
            selectorIndex += 2;
          } else {
            name18 = getName(1);
          }
        }
        tokens.push(
          name18 === "*"
            ? { type: SelectorType.Universal, namespace }
            : { type: SelectorType.Tag, name: name18, namespace },
        );
      }
    }
  }
  finalizeSubselector();
  return selectorIndex;
}
var reName, reEscape, actionTypes, unpackPseudos, stripQuotesFromPseudos;
var init_parse = __esm({
  "node_modules/css-what/lib/es/parse.js"() {
    init_types();
    reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
    reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
    actionTypes = /* @__PURE__ */ new Map([
      [126, AttributeAction.Element],
      [94, AttributeAction.Start],
      [36, AttributeAction.End],
      [42, AttributeAction.Any],
      [33, AttributeAction.Not],
      [124, AttributeAction.Hyphen],
    ]);
    unpackPseudos = /* @__PURE__ */ new Set([
      "has",
      "not",
      "matches",
      "is",
      "where",
      "host",
      "host-context",
    ]);
    stripQuotesFromPseudos = /* @__PURE__ */ new Set(["contains", "icontains"]);
  },
});

// node_modules/css-what/lib/es/stringify.js
function stringify(selector) {
  return selector.map((token) => token.map(stringifyToken).join("")).join(", ");
}
function stringifyToken(token, index, arr) {
  switch (token.type) {
    // Simple types
    case SelectorType.Child:
      return index === 0 ? "> " : " > ";
    case SelectorType.Parent:
      return index === 0 ? "< " : " < ";
    case SelectorType.Sibling:
      return index === 0 ? "~ " : " ~ ";
    case SelectorType.Adjacent:
      return index === 0 ? "+ " : " + ";
    case SelectorType.Descendant:
      return " ";
    case SelectorType.ColumnCombinator:
      return index === 0 ? "|| " : " || ";
    case SelectorType.Universal:
      return token.namespace === "*" &&
        index + 1 < arr.length &&
        "name" in arr[index + 1]
        ? ""
        : `${getNamespace(token.namespace)}*`;
    case SelectorType.Tag:
      return getNamespacedName(token);
    case SelectorType.PseudoElement:
      return `::${escapeName(token.name, charsToEscapeInName)}${token.data === null ? "" : `(${escapeName(token.data, charsToEscapeInPseudoValue)})`}`;
    case SelectorType.Pseudo:
      return `:${escapeName(token.name, charsToEscapeInName)}${token.data === null ? "" : `(${typeof token.data === "string" ? escapeName(token.data, charsToEscapeInPseudoValue) : stringify(token.data)})`}`;
    case SelectorType.Attribute: {
      if (
        token.name === "id" &&
        token.action === AttributeAction.Equals &&
        token.ignoreCase === "quirks" &&
        !token.namespace
      ) {
        return `#${escapeName(token.value, charsToEscapeInName)}`;
      }
      if (
        token.name === "class" &&
        token.action === AttributeAction.Element &&
        token.ignoreCase === "quirks" &&
        !token.namespace
      ) {
        return `.${escapeName(token.value, charsToEscapeInName)}`;
      }
      const name18 = getNamespacedName(token);
      if (token.action === AttributeAction.Exists) {
        return `[${name18}]`;
      }
      return `[${name18}${getActionValue(token.action)}="${escapeName(token.value, charsToEscapeInAttributeValue)}"${token.ignoreCase === null ? "" : token.ignoreCase ? " i" : " s"}]`;
    }
  }
}
function getActionValue(action) {
  switch (action) {
    case AttributeAction.Equals:
      return "";
    case AttributeAction.Element:
      return "~";
    case AttributeAction.Start:
      return "^";
    case AttributeAction.End:
      return "$";
    case AttributeAction.Any:
      return "*";
    case AttributeAction.Not:
      return "!";
    case AttributeAction.Hyphen:
      return "|";
    case AttributeAction.Exists:
      throw new Error("Shouldn't be here");
  }
}
function getNamespacedName(token) {
  return `${getNamespace(token.namespace)}${escapeName(token.name, charsToEscapeInName)}`;
}
function getNamespace(namespace) {
  return namespace !== null
    ? `${namespace === "*" ? "*" : escapeName(namespace, charsToEscapeInName)}|`
    : "";
}
function escapeName(str, charsToEscape) {
  let lastIdx = 0;
  let ret = "";
  for (let i2 = 0; i2 < str.length; i2++) {
    if (charsToEscape.has(str.charCodeAt(i2))) {
      ret += `${str.slice(lastIdx, i2)}\\${str.charAt(i2)}`;
      lastIdx = i2 + 1;
    }
  }
  return ret.length > 0 ? ret + str.slice(lastIdx) : str;
}
var attribValChars,
  pseudoValChars,
  charsToEscapeInAttributeValue,
  charsToEscapeInPseudoValue,
  charsToEscapeInName;
var init_stringify = __esm({
  "node_modules/css-what/lib/es/stringify.js"() {
    init_types();
    attribValChars = ["\\", '"'];
    pseudoValChars = [...attribValChars, "(", ")"];
    charsToEscapeInAttributeValue = new Set(
      attribValChars.map((c2) => c2.charCodeAt(0)),
    );
    charsToEscapeInPseudoValue = new Set(
      pseudoValChars.map((c2) => c2.charCodeAt(0)),
    );
    charsToEscapeInName = new Set(
      [
        ...pseudoValChars,
        "~",
        "^",
        "$",
        "*",
        "+",
        "!",
        "|",
        ":",
        "[",
        "]",
        " ",
        ".",
      ].map((c2) => c2.charCodeAt(0)),
    );
  },
});

// node_modules/css-what/lib/es/index.js
var es_exports = {};
__export(es_exports, {
  AttributeAction: () => AttributeAction,
  IgnoreCaseMode: () => IgnoreCaseMode,
  SelectorType: () => SelectorType,
  isTraversal: () => isTraversal,
  parse: () => parse3,
  stringify: () => stringify,
});
var init_es = __esm({
  "node_modules/css-what/lib/es/index.js"() {
    init_types();
    init_parse();
    init_stringify();
  },
});

// node_modules/css-select/lib/sort.js
var require_sort = __commonJS({
  "node_modules/css-select/lib/sort.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isTraversal = void 0;
    var css_what_1 = (init_es(), __toCommonJS(es_exports));
    var procedure = /* @__PURE__ */ new Map([
      [css_what_1.SelectorType.Universal, 50],
      [css_what_1.SelectorType.Tag, 30],
      [css_what_1.SelectorType.Attribute, 1],
      [css_what_1.SelectorType.Pseudo, 0],
    ]);
    function isTraversal2(token) {
      return !procedure.has(token.type);
    }
    exports.isTraversal = isTraversal2;
    var attributes = /* @__PURE__ */ new Map([
      [css_what_1.AttributeAction.Exists, 10],
      [css_what_1.AttributeAction.Equals, 8],
      [css_what_1.AttributeAction.Not, 7],
      [css_what_1.AttributeAction.Start, 6],
      [css_what_1.AttributeAction.End, 6],
      [css_what_1.AttributeAction.Any, 5],
    ]);
    function sortByProcedure(arr) {
      var procs = arr.map(getProcedure);
      for (var i2 = 1; i2 < arr.length; i2++) {
        var procNew = procs[i2];
        if (procNew < 0) continue;
        for (var j = i2 - 1; j >= 0 && procNew < procs[j]; j--) {
          var token = arr[j + 1];
          arr[j + 1] = arr[j];
          arr[j] = token;
          procs[j + 1] = procs[j];
          procs[j] = procNew;
        }
      }
    }
    exports.default = sortByProcedure;
    function getProcedure(token) {
      var _a19, _b9;
      var proc =
        (_a19 = procedure.get(token.type)) !== null && _a19 !== void 0
          ? _a19
          : -1;
      if (token.type === css_what_1.SelectorType.Attribute) {
        proc =
          (_b9 = attributes.get(token.action)) !== null && _b9 !== void 0
            ? _b9
            : 4;
        if (
          token.action === css_what_1.AttributeAction.Equals &&
          token.name === "id"
        ) {
          proc = 9;
        }
        if (token.ignoreCase) {
          proc >>= 1;
        }
      } else if (token.type === css_what_1.SelectorType.Pseudo) {
        if (!token.data) {
          proc = 3;
        } else if (token.name === "has" || token.name === "contains") {
          proc = 0;
        } else if (Array.isArray(token.data)) {
          proc = Math.min.apply(
            Math,
            token.data.map(function (d2) {
              return Math.min.apply(Math, d2.map(getProcedure));
            }),
          );
          if (proc < 0) {
            proc = 0;
          }
        } else {
          proc = 2;
        }
      }
      return proc;
    }
  },
});

// node_modules/css-select/lib/attributes.js
var require_attributes = __commonJS({
  "node_modules/css-select/lib/attributes.js"(exports) {
    "use strict";
    var __importDefault =
      (exports && exports.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.attributeRules = void 0;
    var boolbase_1 = __importDefault(require_boolbase());
    var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
    function escapeRegex3(value) {
      return value.replace(reChars, "\\$&");
    }
    var caseInsensitiveAttributes = /* @__PURE__ */ new Set([
      "accept",
      "accept-charset",
      "align",
      "alink",
      "axis",
      "bgcolor",
      "charset",
      "checked",
      "clear",
      "codetype",
      "color",
      "compact",
      "declare",
      "defer",
      "dir",
      "direction",
      "disabled",
      "enctype",
      "face",
      "frame",
      "hreflang",
      "http-equiv",
      "lang",
      "language",
      "link",
      "media",
      "method",
      "multiple",
      "nohref",
      "noresize",
      "noshade",
      "nowrap",
      "readonly",
      "rel",
      "rev",
      "rules",
      "scope",
      "scrolling",
      "selected",
      "shape",
      "target",
      "text",
      "type",
      "valign",
      "valuetype",
      "vlink",
    ]);
    function shouldIgnoreCase(selector, options) {
      return typeof selector.ignoreCase === "boolean"
        ? selector.ignoreCase
        : selector.ignoreCase === "quirks"
          ? !!options.quirksMode
          : !options.xmlMode && caseInsensitiveAttributes.has(selector.name);
    }
    exports.attributeRules = {
      equals: function (next, data, options) {
        var adapter = options.adapter;
        var name18 = data.name;
        var value = data.value;
        if (shouldIgnoreCase(data, options)) {
          value = value.toLowerCase();
          return function (elem) {
            var attr = adapter.getAttributeValue(elem, name18);
            return (
              attr != null &&
              attr.length === value.length &&
              attr.toLowerCase() === value &&
              next(elem)
            );
          };
        }
        return function (elem) {
          return (
            adapter.getAttributeValue(elem, name18) === value && next(elem)
          );
        };
      },
      hyphen: function (next, data, options) {
        var adapter = options.adapter;
        var name18 = data.name;
        var value = data.value;
        var len = value.length;
        if (shouldIgnoreCase(data, options)) {
          value = value.toLowerCase();
          return function hyphenIC(elem) {
            var attr = adapter.getAttributeValue(elem, name18);
            return (
              attr != null &&
              (attr.length === len || attr.charAt(len) === "-") &&
              attr.substr(0, len).toLowerCase() === value &&
              next(elem)
            );
          };
        }
        return function hyphen(elem) {
          var attr = adapter.getAttributeValue(elem, name18);
          return (
            attr != null &&
            (attr.length === len || attr.charAt(len) === "-") &&
            attr.substr(0, len) === value &&
            next(elem)
          );
        };
      },
      element: function (next, data, options) {
        var adapter = options.adapter;
        var name18 = data.name,
          value = data.value;
        if (/\s/.test(value)) {
          return boolbase_1.default.falseFunc;
        }
        var regex = new RegExp(
          "(?:^|\\s)".concat(escapeRegex3(value), "(?:$|\\s)"),
          shouldIgnoreCase(data, options) ? "i" : "",
        );
        return function element(elem) {
          var attr = adapter.getAttributeValue(elem, name18);
          return (
            attr != null &&
            attr.length >= value.length &&
            regex.test(attr) &&
            next(elem)
          );
        };
      },
      exists: function (next, _a19, _b9) {
        var name18 = _a19.name;
        var adapter = _b9.adapter;
        return function (elem) {
          return adapter.hasAttrib(elem, name18) && next(elem);
        };
      },
      start: function (next, data, options) {
        var adapter = options.adapter;
        var name18 = data.name;
        var value = data.value;
        var len = value.length;
        if (len === 0) {
          return boolbase_1.default.falseFunc;
        }
        if (shouldIgnoreCase(data, options)) {
          value = value.toLowerCase();
          return function (elem) {
            var attr = adapter.getAttributeValue(elem, name18);
            return (
              attr != null &&
              attr.length >= len &&
              attr.substr(0, len).toLowerCase() === value &&
              next(elem)
            );
          };
        }
        return function (elem) {
          var _a19;
          return (
            !!((_a19 = adapter.getAttributeValue(elem, name18)) === null ||
            _a19 === void 0
              ? void 0
              : _a19.startsWith(value)) && next(elem)
          );
        };
      },
      end: function (next, data, options) {
        var adapter = options.adapter;
        var name18 = data.name;
        var value = data.value;
        var len = -value.length;
        if (len === 0) {
          return boolbase_1.default.falseFunc;
        }
        if (shouldIgnoreCase(data, options)) {
          value = value.toLowerCase();
          return function (elem) {
            var _a19;
            return (
              ((_a19 = adapter.getAttributeValue(elem, name18)) === null ||
              _a19 === void 0
                ? void 0
                : _a19.substr(len).toLowerCase()) === value && next(elem)
            );
          };
        }
        return function (elem) {
          var _a19;
          return (
            !!((_a19 = adapter.getAttributeValue(elem, name18)) === null ||
            _a19 === void 0
              ? void 0
              : _a19.endsWith(value)) && next(elem)
          );
        };
      },
      any: function (next, data, options) {
        var adapter = options.adapter;
        var name18 = data.name,
          value = data.value;
        if (value === "") {
          return boolbase_1.default.falseFunc;
        }
        if (shouldIgnoreCase(data, options)) {
          var regex_1 = new RegExp(escapeRegex3(value), "i");
          return function anyIC(elem) {
            var attr = adapter.getAttributeValue(elem, name18);
            return (
              attr != null &&
              attr.length >= value.length &&
              regex_1.test(attr) &&
              next(elem)
            );
          };
        }
        return function (elem) {
          var _a19;
          return (
            !!((_a19 = adapter.getAttributeValue(elem, name18)) === null ||
            _a19 === void 0
              ? void 0
              : _a19.includes(value)) && next(elem)
          );
        };
      },
      not: function (next, data, options) {
        var adapter = options.adapter;
        var name18 = data.name;
        var value = data.value;
        if (value === "") {
          return function (elem) {
            return !!adapter.getAttributeValue(elem, name18) && next(elem);
          };
        } else if (shouldIgnoreCase(data, options)) {
          value = value.toLowerCase();
          return function (elem) {
            var attr = adapter.getAttributeValue(elem, name18);
            return (
              (attr == null ||
                attr.length !== value.length ||
                attr.toLowerCase() !== value) &&
              next(elem)
            );
          };
        }
        return function (elem) {
          return (
            adapter.getAttributeValue(elem, name18) !== value && next(elem)
          );
        };
      },
    };
  },
});

// node_modules/nth-check/lib/parse.js
var require_parse = __commonJS({
  "node_modules/nth-check/lib/parse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parse = void 0;
    var whitespace = /* @__PURE__ */ new Set([9, 10, 12, 13, 32]);
    var ZERO = "0".charCodeAt(0);
    var NINE = "9".charCodeAt(0);
    function parse7(formula) {
      formula = formula.trim().toLowerCase();
      if (formula === "even") {
        return [2, 0];
      } else if (formula === "odd") {
        return [2, 1];
      }
      var idx = 0;
      var a2 = 0;
      var sign = readSign();
      var number4 = readNumber();
      if (idx < formula.length && formula.charAt(idx) === "n") {
        idx++;
        a2 = sign * (number4 !== null && number4 !== void 0 ? number4 : 1);
        skipWhitespace();
        if (idx < formula.length) {
          sign = readSign();
          skipWhitespace();
          number4 = readNumber();
        } else {
          sign = number4 = 0;
        }
      }
      if (number4 === null || idx < formula.length) {
        throw new Error(
          "n-th rule couldn't be parsed ('".concat(formula, "')"),
        );
      }
      return [a2, sign * number4];
      function readSign() {
        if (formula.charAt(idx) === "-") {
          idx++;
          return -1;
        }
        if (formula.charAt(idx) === "+") {
          idx++;
        }
        return 1;
      }
      function readNumber() {
        var start = idx;
        var value = 0;
        while (
          idx < formula.length &&
          formula.charCodeAt(idx) >= ZERO &&
          formula.charCodeAt(idx) <= NINE
        ) {
          value = value * 10 + (formula.charCodeAt(idx) - ZERO);
          idx++;
        }
        return idx === start ? null : value;
      }
      function skipWhitespace() {
        while (
          idx < formula.length &&
          whitespace.has(formula.charCodeAt(idx))
        ) {
          idx++;
        }
      }
    }
    exports.parse = parse7;
  },
});

// node_modules/nth-check/lib/compile.js
var require_compile = __commonJS({
  "node_modules/nth-check/lib/compile.js"(exports) {
    "use strict";
    var __importDefault =
      (exports && exports.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generate = exports.compile = void 0;
    var boolbase_1 = __importDefault(require_boolbase());
    function compile(parsed) {
      var a2 = parsed[0];
      var b2 = parsed[1] - 1;
      if (b2 < 0 && a2 <= 0) return boolbase_1.default.falseFunc;
      if (a2 === -1)
        return function (index) {
          return index <= b2;
        };
      if (a2 === 0)
        return function (index) {
          return index === b2;
        };
      if (a2 === 1)
        return b2 < 0
          ? boolbase_1.default.trueFunc
          : function (index) {
              return index >= b2;
            };
      var absA = Math.abs(a2);
      var bMod = ((b2 % absA) + absA) % absA;
      return a2 > 1
        ? function (index) {
            return index >= b2 && index % absA === bMod;
          }
        : function (index) {
            return index <= b2 && index % absA === bMod;
          };
    }
    exports.compile = compile;
    function generate(parsed) {
      var a2 = parsed[0];
      var b2 = parsed[1] - 1;
      var n = 0;
      if (a2 < 0) {
        var aPos_1 = -a2;
        var minValue_1 = ((b2 % aPos_1) + aPos_1) % aPos_1;
        return function () {
          var val = minValue_1 + aPos_1 * n++;
          return val > b2 ? null : val;
        };
      }
      if (a2 === 0)
        return b2 < 0
          ? // There are no result — always return `null`
            function () {
              return null;
            }
          : // Return `b` exactly once
            function () {
              return n++ === 0 ? b2 : null;
            };
      if (b2 < 0) {
        b2 += a2 * Math.ceil(-b2 / a2);
      }
      return function () {
        return a2 * n++ + b2;
      };
    }
    exports.generate = generate;
  },
});

// node_modules/nth-check/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/nth-check/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sequence =
      exports.generate =
      exports.compile =
      exports.parse =
        void 0;
    var parse_js_1 = require_parse();
    Object.defineProperty(exports, "parse", {
      enumerable: true,
      get: function () {
        return parse_js_1.parse;
      },
    });
    var compile_js_1 = require_compile();
    Object.defineProperty(exports, "compile", {
      enumerable: true,
      get: function () {
        return compile_js_1.compile;
      },
    });
    Object.defineProperty(exports, "generate", {
      enumerable: true,
      get: function () {
        return compile_js_1.generate;
      },
    });
    function nthCheck(formula) {
      return (0, compile_js_1.compile)((0, parse_js_1.parse)(formula));
    }
    exports.default = nthCheck;
    function sequence(formula) {
      return (0, compile_js_1.generate)((0, parse_js_1.parse)(formula));
    }
    exports.sequence = sequence;
  },
});

// node_modules/css-select/lib/pseudo-selectors/filters.js
var require_filters = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/filters.js"(exports) {
    "use strict";
    var __importDefault =
      (exports && exports.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.filters = void 0;
    var nth_check_1 = __importDefault(require_lib6());
    var boolbase_1 = __importDefault(require_boolbase());
    function getChildFunc(next, adapter) {
      return function (elem) {
        var parent = adapter.getParent(elem);
        return parent != null && adapter.isTag(parent) && next(elem);
      };
    }
    exports.filters = {
      contains: function (next, text2, _a19) {
        var adapter = _a19.adapter;
        return function contains(elem) {
          return next(elem) && adapter.getText(elem).includes(text2);
        };
      },
      icontains: function (next, text2, _a19) {
        var adapter = _a19.adapter;
        var itext = text2.toLowerCase();
        return function icontains(elem) {
          return (
            next(elem) && adapter.getText(elem).toLowerCase().includes(itext)
          );
        };
      },
      // Location specific methods
      "nth-child": function (next, rule, _a19) {
        var adapter = _a19.adapter,
          equals = _a19.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.default.falseFunc)
          return boolbase_1.default.falseFunc;
        if (func === boolbase_1.default.trueFunc)
          return getChildFunc(next, adapter);
        return function nthChild(elem) {
          var siblings = adapter.getSiblings(elem);
          var pos = 0;
          for (var i2 = 0; i2 < siblings.length; i2++) {
            if (equals(elem, siblings[i2])) break;
            if (adapter.isTag(siblings[i2])) {
              pos++;
            }
          }
          return func(pos) && next(elem);
        };
      },
      "nth-last-child": function (next, rule, _a19) {
        var adapter = _a19.adapter,
          equals = _a19.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.default.falseFunc)
          return boolbase_1.default.falseFunc;
        if (func === boolbase_1.default.trueFunc)
          return getChildFunc(next, adapter);
        return function nthLastChild(elem) {
          var siblings = adapter.getSiblings(elem);
          var pos = 0;
          for (var i2 = siblings.length - 1; i2 >= 0; i2--) {
            if (equals(elem, siblings[i2])) break;
            if (adapter.isTag(siblings[i2])) {
              pos++;
            }
          }
          return func(pos) && next(elem);
        };
      },
      "nth-of-type": function (next, rule, _a19) {
        var adapter = _a19.adapter,
          equals = _a19.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.default.falseFunc)
          return boolbase_1.default.falseFunc;
        if (func === boolbase_1.default.trueFunc)
          return getChildFunc(next, adapter);
        return function nthOfType(elem) {
          var siblings = adapter.getSiblings(elem);
          var pos = 0;
          for (var i2 = 0; i2 < siblings.length; i2++) {
            var currentSibling = siblings[i2];
            if (equals(elem, currentSibling)) break;
            if (
              adapter.isTag(currentSibling) &&
              adapter.getName(currentSibling) === adapter.getName(elem)
            ) {
              pos++;
            }
          }
          return func(pos) && next(elem);
        };
      },
      "nth-last-of-type": function (next, rule, _a19) {
        var adapter = _a19.adapter,
          equals = _a19.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.default.falseFunc)
          return boolbase_1.default.falseFunc;
        if (func === boolbase_1.default.trueFunc)
          return getChildFunc(next, adapter);
        return function nthLastOfType(elem) {
          var siblings = adapter.getSiblings(elem);
          var pos = 0;
          for (var i2 = siblings.length - 1; i2 >= 0; i2--) {
            var currentSibling = siblings[i2];
            if (equals(elem, currentSibling)) break;
            if (
              adapter.isTag(currentSibling) &&
              adapter.getName(currentSibling) === adapter.getName(elem)
            ) {
              pos++;
            }
          }
          return func(pos) && next(elem);
        };
      },
      // TODO determine the actual root element
      root: function (next, _rule, _a19) {
        var adapter = _a19.adapter;
        return function (elem) {
          var parent = adapter.getParent(elem);
          return (parent == null || !adapter.isTag(parent)) && next(elem);
        };
      },
      scope: function (next, rule, options, context) {
        var equals = options.equals;
        if (!context || context.length === 0) {
          return exports.filters["root"](next, rule, options);
        }
        if (context.length === 1) {
          return function (elem) {
            return equals(context[0], elem) && next(elem);
          };
        }
        return function (elem) {
          return context.includes(elem) && next(elem);
        };
      },
      hover: dynamicStatePseudo("isHovered"),
      visited: dynamicStatePseudo("isVisited"),
      active: dynamicStatePseudo("isActive"),
    };
    function dynamicStatePseudo(name18) {
      return function dynamicPseudo(next, _rule, _a19) {
        var adapter = _a19.adapter;
        var func = adapter[name18];
        if (typeof func !== "function") {
          return boolbase_1.default.falseFunc;
        }
        return function active(elem) {
          return func(elem) && next(elem);
        };
      };
    }
  },
});

// node_modules/css-select/lib/pseudo-selectors/pseudos.js
var require_pseudos = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/pseudos.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verifyPseudoArgs = exports.pseudos = void 0;
    exports.pseudos = {
      empty: function (elem, _a19) {
        var adapter = _a19.adapter;
        return !adapter.getChildren(elem).some(function (elem2) {
          return adapter.isTag(elem2) || adapter.getText(elem2) !== "";
        });
      },
      "first-child": function (elem, _a19) {
        var adapter = _a19.adapter,
          equals = _a19.equals;
        if (adapter.prevElementSibling) {
          return adapter.prevElementSibling(elem) == null;
        }
        var firstChild = adapter.getSiblings(elem).find(function (elem2) {
          return adapter.isTag(elem2);
        });
        return firstChild != null && equals(elem, firstChild);
      },
      "last-child": function (elem, _a19) {
        var adapter = _a19.adapter,
          equals = _a19.equals;
        var siblings = adapter.getSiblings(elem);
        for (var i2 = siblings.length - 1; i2 >= 0; i2--) {
          if (equals(elem, siblings[i2])) return true;
          if (adapter.isTag(siblings[i2])) break;
        }
        return false;
      },
      "first-of-type": function (elem, _a19) {
        var adapter = _a19.adapter,
          equals = _a19.equals;
        var siblings = adapter.getSiblings(elem);
        var elemName = adapter.getName(elem);
        for (var i2 = 0; i2 < siblings.length; i2++) {
          var currentSibling = siblings[i2];
          if (equals(elem, currentSibling)) return true;
          if (
            adapter.isTag(currentSibling) &&
            adapter.getName(currentSibling) === elemName
          ) {
            break;
          }
        }
        return false;
      },
      "last-of-type": function (elem, _a19) {
        var adapter = _a19.adapter,
          equals = _a19.equals;
        var siblings = adapter.getSiblings(elem);
        var elemName = adapter.getName(elem);
        for (var i2 = siblings.length - 1; i2 >= 0; i2--) {
          var currentSibling = siblings[i2];
          if (equals(elem, currentSibling)) return true;
          if (
            adapter.isTag(currentSibling) &&
            adapter.getName(currentSibling) === elemName
          ) {
            break;
          }
        }
        return false;
      },
      "only-of-type": function (elem, _a19) {
        var adapter = _a19.adapter,
          equals = _a19.equals;
        var elemName = adapter.getName(elem);
        return adapter.getSiblings(elem).every(function (sibling) {
          return (
            equals(elem, sibling) ||
            !adapter.isTag(sibling) ||
            adapter.getName(sibling) !== elemName
          );
        });
      },
      "only-child": function (elem, _a19) {
        var adapter = _a19.adapter,
          equals = _a19.equals;
        return adapter.getSiblings(elem).every(function (sibling) {
          return equals(elem, sibling) || !adapter.isTag(sibling);
        });
      },
    };
    function verifyPseudoArgs(func, name18, subselect, argIndex) {
      if (subselect === null) {
        if (func.length > argIndex) {
          throw new Error(
            "Pseudo-class :".concat(name18, " requires an argument"),
          );
        }
      } else if (func.length === argIndex) {
        throw new Error(
          "Pseudo-class :".concat(name18, " doesn't have any arguments"),
        );
      }
    }
    exports.verifyPseudoArgs = verifyPseudoArgs;
  },
});

// node_modules/css-select/lib/pseudo-selectors/aliases.js
var require_aliases = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/aliases.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.aliases = void 0;
    exports.aliases = {
      // Links
      "any-link": ":is(a, area, link)[href]",
      link: ":any-link:not(:visited)",
      // Forms
      // https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
      disabled:
        ":is(\n        :is(button, input, select, textarea, optgroup, option)[disabled],\n        optgroup[disabled] > option,\n        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)\n    )",
      enabled: ":not(:disabled)",
      checked:
        ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
      required: ":is(input, select, textarea)[required]",
      optional: ":is(input, select, textarea):not([required])",
      // JQuery extensions
      // https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-selectedness
      selected:
        "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
      checkbox: "[type=checkbox]",
      file: "[type=file]",
      password: "[type=password]",
      radio: "[type=radio]",
      reset: "[type=reset]",
      image: "[type=image]",
      submit: "[type=submit]",
      parent: ":not(:empty)",
      header: ":is(h1, h2, h3, h4, h5, h6)",
      button: ":is(button, input[type=button])",
      input: ":is(input, textarea, select, button)",
      text: "input:is(:not([type!='']), [type=text])",
    };
  },
});

// node_modules/css-select/lib/pseudo-selectors/subselects.js
var require_subselects = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/subselects.js"(exports) {
    "use strict";
    var __spreadArray5 =
      (exports && exports.__spreadArray) ||
      function (to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
            if (ar || !(i2 in from)) {
              if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
              ar[i2] = from[i2];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
    var __importDefault =
      (exports && exports.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.subselects =
      exports.getNextSiblings =
      exports.ensureIsTag =
      exports.PLACEHOLDER_ELEMENT =
        void 0;
    var boolbase_1 = __importDefault(require_boolbase());
    var sort_js_1 = require_sort();
    exports.PLACEHOLDER_ELEMENT = {};
    function ensureIsTag(next, adapter) {
      if (next === boolbase_1.default.falseFunc)
        return boolbase_1.default.falseFunc;
      return function (elem) {
        return adapter.isTag(elem) && next(elem);
      };
    }
    exports.ensureIsTag = ensureIsTag;
    function getNextSiblings(elem, adapter) {
      var siblings = adapter.getSiblings(elem);
      if (siblings.length <= 1) return [];
      var elemIndex = siblings.indexOf(elem);
      if (elemIndex < 0 || elemIndex === siblings.length - 1) return [];
      return siblings.slice(elemIndex + 1).filter(adapter.isTag);
    }
    exports.getNextSiblings = getNextSiblings;
    function copyOptions(options) {
      return {
        xmlMode: !!options.xmlMode,
        lowerCaseAttributeNames: !!options.lowerCaseAttributeNames,
        lowerCaseTags: !!options.lowerCaseTags,
        quirksMode: !!options.quirksMode,
        cacheResults: !!options.cacheResults,
        pseudos: options.pseudos,
        adapter: options.adapter,
        equals: options.equals,
      };
    }
    var is = function (next, token, options, context, compileToken) {
      var func = compileToken(token, copyOptions(options), context);
      return func === boolbase_1.default.trueFunc
        ? next
        : func === boolbase_1.default.falseFunc
          ? boolbase_1.default.falseFunc
          : function (elem) {
              return func(elem) && next(elem);
            };
    };
    exports.subselects = {
      is,
      /**
       * `:matches` and `:where` are aliases for `:is`.
       */
      matches: is,
      where: is,
      not: function (next, token, options, context, compileToken) {
        var func = compileToken(token, copyOptions(options), context);
        return func === boolbase_1.default.falseFunc
          ? next
          : func === boolbase_1.default.trueFunc
            ? boolbase_1.default.falseFunc
            : function (elem) {
                return !func(elem) && next(elem);
              };
      },
      has: function (next, subselect, options, _context, compileToken) {
        var adapter = options.adapter;
        var opts = copyOptions(options);
        opts.relativeSelector = true;
        var context = subselect.some(function (s2) {
          return s2.some(sort_js_1.isTraversal);
        })
          ? // Used as a placeholder. Will be replaced with the actual element.
            [exports.PLACEHOLDER_ELEMENT]
          : void 0;
        var compiled = compileToken(subselect, opts, context);
        if (compiled === boolbase_1.default.falseFunc)
          return boolbase_1.default.falseFunc;
        var hasElement = ensureIsTag(compiled, adapter);
        if (context && compiled !== boolbase_1.default.trueFunc) {
          var _a19 = compiled.shouldTestNextSiblings,
            shouldTestNextSiblings_1 = _a19 === void 0 ? false : _a19;
          return function (elem) {
            if (!next(elem)) return false;
            context[0] = elem;
            var childs = adapter.getChildren(elem);
            var nextElements = shouldTestNextSiblings_1
              ? __spreadArray5(
                  __spreadArray5([], childs, true),
                  getNextSiblings(elem, adapter),
                  true,
                )
              : childs;
            return adapter.existsOne(hasElement, nextElements);
          };
        }
        return function (elem) {
          return (
            next(elem) &&
            adapter.existsOne(hasElement, adapter.getChildren(elem))
          );
        };
      },
    };
  },
});

// node_modules/css-select/lib/pseudo-selectors/index.js
var require_pseudo_selectors = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compilePseudoSelector =
      exports.aliases =
      exports.pseudos =
      exports.filters =
        void 0;
    var css_what_1 = (init_es(), __toCommonJS(es_exports));
    var filters_js_1 = require_filters();
    Object.defineProperty(exports, "filters", {
      enumerable: true,
      get: function () {
        return filters_js_1.filters;
      },
    });
    var pseudos_js_1 = require_pseudos();
    Object.defineProperty(exports, "pseudos", {
      enumerable: true,
      get: function () {
        return pseudos_js_1.pseudos;
      },
    });
    var aliases_js_1 = require_aliases();
    Object.defineProperty(exports, "aliases", {
      enumerable: true,
      get: function () {
        return aliases_js_1.aliases;
      },
    });
    var subselects_js_1 = require_subselects();
    function compilePseudoSelector(
      next,
      selector,
      options,
      context,
      compileToken,
    ) {
      var _a19;
      var name18 = selector.name,
        data = selector.data;
      if (Array.isArray(data)) {
        if (!(name18 in subselects_js_1.subselects)) {
          throw new Error(
            "Unknown pseudo-class :".concat(name18, "(").concat(data, ")"),
          );
        }
        return subselects_js_1.subselects[name18](
          next,
          data,
          options,
          context,
          compileToken,
        );
      }
      var userPseudo =
        (_a19 = options.pseudos) === null || _a19 === void 0
          ? void 0
          : _a19[name18];
      var stringPseudo =
        typeof userPseudo === "string"
          ? userPseudo
          : aliases_js_1.aliases[name18];
      if (typeof stringPseudo === "string") {
        if (data != null) {
          throw new Error(
            "Pseudo ".concat(name18, " doesn't have any arguments"),
          );
        }
        var alias = (0, css_what_1.parse)(stringPseudo);
        return subselects_js_1.subselects["is"](
          next,
          alias,
          options,
          context,
          compileToken,
        );
      }
      if (typeof userPseudo === "function") {
        (0, pseudos_js_1.verifyPseudoArgs)(userPseudo, name18, data, 1);
        return function (elem) {
          return userPseudo(elem, data) && next(elem);
        };
      }
      if (name18 in filters_js_1.filters) {
        return filters_js_1.filters[name18](next, data, options, context);
      }
      if (name18 in pseudos_js_1.pseudos) {
        var pseudo_1 = pseudos_js_1.pseudos[name18];
        (0, pseudos_js_1.verifyPseudoArgs)(pseudo_1, name18, data, 2);
        return function (elem) {
          return pseudo_1(elem, options, data) && next(elem);
        };
      }
      throw new Error("Unknown pseudo-class :".concat(name18));
    }
    exports.compilePseudoSelector = compilePseudoSelector;
  },
});

// node_modules/css-select/lib/general.js
var require_general = __commonJS({
  "node_modules/css-select/lib/general.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compileGeneralSelector = void 0;
    var attributes_js_1 = require_attributes();
    var index_js_1 = require_pseudo_selectors();
    var css_what_1 = (init_es(), __toCommonJS(es_exports));
    function getElementParent(node, adapter) {
      var parent = adapter.getParent(node);
      if (parent && adapter.isTag(parent)) {
        return parent;
      }
      return null;
    }
    function compileGeneralSelector(
      next,
      selector,
      options,
      context,
      compileToken,
    ) {
      var adapter = options.adapter,
        equals = options.equals;
      switch (selector.type) {
        case css_what_1.SelectorType.PseudoElement: {
          throw new Error("Pseudo-elements are not supported by css-select");
        }
        case css_what_1.SelectorType.ColumnCombinator: {
          throw new Error(
            "Column combinators are not yet supported by css-select",
          );
        }
        case css_what_1.SelectorType.Attribute: {
          if (selector.namespace != null) {
            throw new Error(
              "Namespaced attributes are not yet supported by css-select",
            );
          }
          if (!options.xmlMode || options.lowerCaseAttributeNames) {
            selector.name = selector.name.toLowerCase();
          }
          return attributes_js_1.attributeRules[selector.action](
            next,
            selector,
            options,
          );
        }
        case css_what_1.SelectorType.Pseudo: {
          return (0, index_js_1.compilePseudoSelector)(
            next,
            selector,
            options,
            context,
            compileToken,
          );
        }
        // Tags
        case css_what_1.SelectorType.Tag: {
          if (selector.namespace != null) {
            throw new Error(
              "Namespaced tag names are not yet supported by css-select",
            );
          }
          var name_1 = selector.name;
          if (!options.xmlMode || options.lowerCaseTags) {
            name_1 = name_1.toLowerCase();
          }
          return function tag(elem) {
            return adapter.getName(elem) === name_1 && next(elem);
          };
        }
        // Traversal
        case css_what_1.SelectorType.Descendant: {
          if (
            options.cacheResults === false ||
            typeof WeakSet === "undefined"
          ) {
            return function descendant(elem) {
              var current = elem;
              while ((current = getElementParent(current, adapter))) {
                if (next(current)) {
                  return true;
                }
              }
              return false;
            };
          }
          var isFalseCache_1 = /* @__PURE__ */ new WeakSet();
          return function cachedDescendant(elem) {
            var current = elem;
            while ((current = getElementParent(current, adapter))) {
              if (!isFalseCache_1.has(current)) {
                if (adapter.isTag(current) && next(current)) {
                  return true;
                }
                isFalseCache_1.add(current);
              }
            }
            return false;
          };
        }
        case "_flexibleDescendant": {
          return function flexibleDescendant(elem) {
            var current = elem;
            do {
              if (next(current)) return true;
            } while ((current = getElementParent(current, adapter)));
            return false;
          };
        }
        case css_what_1.SelectorType.Parent: {
          return function parent(elem) {
            return adapter.getChildren(elem).some(function (elem2) {
              return adapter.isTag(elem2) && next(elem2);
            });
          };
        }
        case css_what_1.SelectorType.Child: {
          return function child(elem) {
            var parent = adapter.getParent(elem);
            return parent != null && adapter.isTag(parent) && next(parent);
          };
        }
        case css_what_1.SelectorType.Sibling: {
          return function sibling(elem) {
            var siblings = adapter.getSiblings(elem);
            for (var i2 = 0; i2 < siblings.length; i2++) {
              var currentSibling = siblings[i2];
              if (equals(elem, currentSibling)) break;
              if (adapter.isTag(currentSibling) && next(currentSibling)) {
                return true;
              }
            }
            return false;
          };
        }
        case css_what_1.SelectorType.Adjacent: {
          if (adapter.prevElementSibling) {
            return function adjacent(elem) {
              var previous = adapter.prevElementSibling(elem);
              return previous != null && next(previous);
            };
          }
          return function adjacent(elem) {
            var siblings = adapter.getSiblings(elem);
            var lastElement;
            for (var i2 = 0; i2 < siblings.length; i2++) {
              var currentSibling = siblings[i2];
              if (equals(elem, currentSibling)) break;
              if (adapter.isTag(currentSibling)) {
                lastElement = currentSibling;
              }
            }
            return !!lastElement && next(lastElement);
          };
        }
        case css_what_1.SelectorType.Universal: {
          if (selector.namespace != null && selector.namespace !== "*") {
            throw new Error(
              "Namespaced universal selectors are not yet supported by css-select",
            );
          }
          return next;
        }
      }
    }
    exports.compileGeneralSelector = compileGeneralSelector;
  },
});

// node_modules/css-select/lib/compile.js
var require_compile2 = __commonJS({
  "node_modules/css-select/lib/compile.js"(exports) {
    "use strict";
    var __createBinding =
      (exports && exports.__createBinding) ||
      (Object.create
        ? function (o2, m2, k, k2) {
            if (k2 === void 0) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m2, k);
            if (
              !desc ||
              ("get" in desc
                ? !m2.__esModule
                : desc.writable || desc.configurable)
            ) {
              desc = {
                enumerable: true,
                get: function () {
                  return m2[k];
                },
              };
            }
            Object.defineProperty(o2, k2, desc);
          }
        : function (o2, m2, k, k2) {
            if (k2 === void 0) k2 = k;
            o2[k2] = m2[k];
          });
    var __setModuleDefault =
      (exports && exports.__setModuleDefault) ||
      (Object.create
        ? function (o2, v2) {
            Object.defineProperty(o2, "default", {
              enumerable: true,
              value: v2,
            });
          }
        : function (o2, v2) {
            o2["default"] = v2;
          });
    var __importStar =
      (exports && exports.__importStar) ||
      function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    var __importDefault =
      (exports && exports.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compileToken = exports.compileUnsafe = exports.compile = void 0;
    var css_what_1 = (init_es(), __toCommonJS(es_exports));
    var boolbase_1 = __importDefault(require_boolbase());
    var sort_js_1 = __importStar(require_sort());
    var general_js_1 = require_general();
    var subselects_js_1 = require_subselects();
    function compile(selector, options, context) {
      var next = compileUnsafe(selector, options, context);
      return (0, subselects_js_1.ensureIsTag)(next, options.adapter);
    }
    exports.compile = compile;
    function compileUnsafe(selector, options, context) {
      var token =
        typeof selector === "string"
          ? (0, css_what_1.parse)(selector)
          : selector;
      return compileToken(token, options, context);
    }
    exports.compileUnsafe = compileUnsafe;
    function includesScopePseudo(t2) {
      return (
        t2.type === css_what_1.SelectorType.Pseudo &&
        (t2.name === "scope" ||
          (Array.isArray(t2.data) &&
            t2.data.some(function (data) {
              return data.some(includesScopePseudo);
            })))
      );
    }
    var DESCENDANT_TOKEN = { type: css_what_1.SelectorType.Descendant };
    var FLEXIBLE_DESCENDANT_TOKEN = {
      type: "_flexibleDescendant",
    };
    var SCOPE_TOKEN = {
      type: css_what_1.SelectorType.Pseudo,
      name: "scope",
      data: null,
    };
    function absolutize(token, _a19, context) {
      var adapter = _a19.adapter;
      var hasContext = !!(context === null || context === void 0
        ? void 0
        : context.every(function (e2) {
            var parent = adapter.isTag(e2) && adapter.getParent(e2);
            return (
              e2 === subselects_js_1.PLACEHOLDER_ELEMENT ||
              (parent && adapter.isTag(parent))
            );
          }));
      for (var _i = 0, token_1 = token; _i < token_1.length; _i++) {
        var t2 = token_1[_i];
        if (
          t2.length > 0 &&
          (0, sort_js_1.isTraversal)(t2[0]) &&
          t2[0].type !== css_what_1.SelectorType.Descendant
        ) {
        } else if (hasContext && !t2.some(includesScopePseudo)) {
          t2.unshift(DESCENDANT_TOKEN);
        } else {
          continue;
        }
        t2.unshift(SCOPE_TOKEN);
      }
    }
    function compileToken(token, options, context) {
      var _a19;
      token.forEach(sort_js_1.default);
      context =
        (_a19 = options.context) !== null && _a19 !== void 0 ? _a19 : context;
      var isArrayContext = Array.isArray(context);
      var finalContext =
        context && (Array.isArray(context) ? context : [context]);
      if (options.relativeSelector !== false) {
        absolutize(token, options, finalContext);
      } else if (
        token.some(function (t2) {
          return t2.length > 0 && (0, sort_js_1.isTraversal)(t2[0]);
        })
      ) {
        throw new Error(
          "Relative selectors are not allowed when the `relativeSelector` option is disabled",
        );
      }
      var shouldTestNextSiblings = false;
      var query = token
        .map(function (rules) {
          if (rules.length >= 2) {
            var first = rules[0],
              second = rules[1];
            if (
              first.type !== css_what_1.SelectorType.Pseudo ||
              first.name !== "scope"
            ) {
            } else if (
              isArrayContext &&
              second.type === css_what_1.SelectorType.Descendant
            ) {
              rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
            } else if (
              second.type === css_what_1.SelectorType.Adjacent ||
              second.type === css_what_1.SelectorType.Sibling
            ) {
              shouldTestNextSiblings = true;
            }
          }
          return compileRules(rules, options, finalContext);
        })
        .reduce(reduceRules, boolbase_1.default.falseFunc);
      query.shouldTestNextSiblings = shouldTestNextSiblings;
      return query;
    }
    exports.compileToken = compileToken;
    function compileRules(rules, options, context) {
      var _a19;
      return rules.reduce(
        function (previous, rule) {
          return previous === boolbase_1.default.falseFunc
            ? boolbase_1.default.falseFunc
            : (0, general_js_1.compileGeneralSelector)(
                previous,
                rule,
                options,
                context,
                compileToken,
              );
        },
        (_a19 = options.rootFunc) !== null && _a19 !== void 0
          ? _a19
          : boolbase_1.default.trueFunc,
      );
    }
    function reduceRules(a2, b2) {
      if (
        b2 === boolbase_1.default.falseFunc ||
        a2 === boolbase_1.default.trueFunc
      ) {
        return a2;
      }
      if (
        a2 === boolbase_1.default.falseFunc ||
        b2 === boolbase_1.default.trueFunc
      ) {
        return b2;
      }
      return function combine(elem) {
        return a2(elem) || b2(elem);
      };
    }
  },
});

// node_modules/css-select/lib/index.js
var require_lib7 = __commonJS({
  "node_modules/css-select/lib/index.js"(exports) {
    "use strict";
    var __createBinding =
      (exports && exports.__createBinding) ||
      (Object.create
        ? function (o2, m2, k, k2) {
            if (k2 === void 0) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m2, k);
            if (
              !desc ||
              ("get" in desc
                ? !m2.__esModule
                : desc.writable || desc.configurable)
            ) {
              desc = {
                enumerable: true,
                get: function () {
                  return m2[k];
                },
              };
            }
            Object.defineProperty(o2, k2, desc);
          }
        : function (o2, m2, k, k2) {
            if (k2 === void 0) k2 = k;
            o2[k2] = m2[k];
          });
    var __setModuleDefault =
      (exports && exports.__setModuleDefault) ||
      (Object.create
        ? function (o2, v2) {
            Object.defineProperty(o2, "default", {
              enumerable: true,
              value: v2,
            });
          }
        : function (o2, v2) {
            o2["default"] = v2;
          });
    var __importStar =
      (exports && exports.__importStar) ||
      function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    var __importDefault =
      (exports && exports.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.aliases =
      exports.pseudos =
      exports.filters =
      exports.is =
      exports.selectOne =
      exports.selectAll =
      exports.prepareContext =
      exports._compileToken =
      exports._compileUnsafe =
      exports.compile =
        void 0;
    var DomUtils = __importStar(require_lib5());
    var boolbase_1 = __importDefault(require_boolbase());
    var compile_js_1 = require_compile2();
    var subselects_js_1 = require_subselects();
    var defaultEquals = function (a2, b2) {
      return a2 === b2;
    };
    var defaultOptions3 = {
      adapter: DomUtils,
      equals: defaultEquals,
    };
    function convertOptionFormats(options) {
      var _a19, _b9, _c, _d;
      var opts =
        options !== null && options !== void 0 ? options : defaultOptions3;
      (_a19 = opts.adapter) !== null && _a19 !== void 0
        ? _a19
        : (opts.adapter = DomUtils);
      (_b9 = opts.equals) !== null && _b9 !== void 0
        ? _b9
        : (opts.equals =
            (_d =
              (_c = opts.adapter) === null || _c === void 0
                ? void 0
                : _c.equals) !== null && _d !== void 0
              ? _d
              : defaultEquals);
      return opts;
    }
    function wrapCompile(func) {
      return function addAdapter(selector, options, context) {
        var opts = convertOptionFormats(options);
        return func(selector, opts, context);
      };
    }
    exports.compile = wrapCompile(compile_js_1.compile);
    exports._compileUnsafe = wrapCompile(compile_js_1.compileUnsafe);
    exports._compileToken = wrapCompile(compile_js_1.compileToken);
    function getSelectorFunc(searchFunc) {
      return function select(query, elements, options) {
        var opts = convertOptionFormats(options);
        if (typeof query !== "function") {
          query = (0, compile_js_1.compileUnsafe)(query, opts, elements);
        }
        var filteredElements = prepareContext(
          elements,
          opts.adapter,
          query.shouldTestNextSiblings,
        );
        return searchFunc(query, filteredElements, opts);
      };
    }
    function prepareContext(elems, adapter, shouldTestNextSiblings) {
      if (shouldTestNextSiblings === void 0) {
        shouldTestNextSiblings = false;
      }
      if (shouldTestNextSiblings) {
        elems = appendNextSiblings(elems, adapter);
      }
      return Array.isArray(elems)
        ? adapter.removeSubsets(elems)
        : adapter.getChildren(elems);
    }
    exports.prepareContext = prepareContext;
    function appendNextSiblings(elem, adapter) {
      var elems = Array.isArray(elem) ? elem.slice(0) : [elem];
      var elemsLength = elems.length;
      for (var i2 = 0; i2 < elemsLength; i2++) {
        var nextSiblings = (0, subselects_js_1.getNextSiblings)(
          elems[i2],
          adapter,
        );
        elems.push.apply(elems, nextSiblings);
      }
      return elems;
    }
    exports.selectAll = getSelectorFunc(function (query, elems, options) {
      return query === boolbase_1.default.falseFunc ||
        !elems ||
        elems.length === 0
        ? []
        : options.adapter.findAll(query, elems);
    });
    exports.selectOne = getSelectorFunc(function (query, elems, options) {
      return query === boolbase_1.default.falseFunc ||
        !elems ||
        elems.length === 0
        ? null
        : options.adapter.findOne(query, elems);
    });
    function is(elem, query, options) {
      var opts = convertOptionFormats(options);
      return (
        typeof query === "function"
          ? query
          : (0, compile_js_1.compile)(query, opts)
      )(elem);
    }
    exports.is = is;
    exports.default = exports.selectAll;
    var index_js_1 = require_pseudo_selectors();
    Object.defineProperty(exports, "filters", {
      enumerable: true,
      get: function () {
        return index_js_1.filters;
      },
    });
    Object.defineProperty(exports, "pseudos", {
      enumerable: true,
      get: function () {
        return index_js_1.pseudos;
      },
    });
    Object.defineProperty(exports, "aliases", {
      enumerable: true,
      get: function () {
        return index_js_1.aliases;
      },
    });
  },
});

// node_modules/node-html-parser/dist/back.js
var require_back = __commonJS({
  "node_modules/node-html-parser/dist/back.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function arr_back(arr) {
      return arr[arr.length - 1];
    }
    exports.default = arr_back;
  },
});

// node_modules/node-html-parser/dist/matcher.js
var require_matcher = __commonJS({
  "node_modules/node-html-parser/dist/matcher.js"(exports) {
    "use strict";
    var __importDefault =
      (exports && exports.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports, "__esModule", { value: true });
    var type_1 = __importDefault(require_type());
    function isTag(node) {
      return node && node.nodeType === type_1.default.ELEMENT_NODE;
    }
    function getAttributeValue(elem, name18) {
      return isTag(elem) ? elem.getAttribute(name18) : void 0;
    }
    function getName(elem) {
      return ((elem && elem.rawTagName) || "").toLowerCase();
    }
    function getChildren(node) {
      return node && node.childNodes;
    }
    function getParent(node) {
      return node ? node.parentNode : null;
    }
    function getText(node) {
      return node.text;
    }
    function removeSubsets(nodes) {
      var idx = nodes.length;
      var node;
      var ancestor;
      var replace;
      while (--idx > -1) {
        node = ancestor = nodes[idx];
        nodes[idx] = null;
        replace = true;
        while (ancestor) {
          if (nodes.indexOf(ancestor) > -1) {
            replace = false;
            nodes.splice(idx, 1);
            break;
          }
          ancestor = getParent(ancestor);
        }
        if (replace) {
          nodes[idx] = node;
        }
      }
      return nodes;
    }
    function existsOne(test, elems) {
      return elems.some(function (elem) {
        return isTag(elem)
          ? test(elem) || existsOne(test, getChildren(elem))
          : false;
      });
    }
    function getSiblings(node) {
      var parent = getParent(node);
      return parent ? getChildren(parent) : [];
    }
    function hasAttrib(elem, name18) {
      return getAttributeValue(elem, name18) !== void 0;
    }
    function findOne(test, elems) {
      var elem = null;
      for (
        var i2 = 0,
          l2 = elems === null || elems === void 0 ? void 0 : elems.length;
        i2 < l2 && !elem;
        i2++
      ) {
        var el = elems[i2];
        if (test(el)) {
          elem = el;
        } else {
          var childs = getChildren(el);
          if (childs && childs.length > 0) {
            elem = findOne(test, childs);
          }
        }
      }
      return elem;
    }
    function findAll(test, nodes) {
      var result = [];
      for (var i2 = 0, j = nodes.length; i2 < j; i2++) {
        if (!isTag(nodes[i2])) continue;
        if (test(nodes[i2])) result.push(nodes[i2]);
        var childs = getChildren(nodes[i2]);
        if (childs) result = result.concat(findAll(test, childs));
      }
      return result;
    }
    exports.default = {
      isTag,
      getAttributeValue,
      getName,
      getChildren,
      getParent,
      getText,
      removeSubsets,
      existsOne,
      getSiblings,
      hasAttrib,
      findOne,
      findAll,
    };
  },
});

// node_modules/node-html-parser/dist/void-tag.js
var require_void_tag = __commonJS({
  "node_modules/node-html-parser/dist/void-tag.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var VoidTag =
      /** @class */
      (function () {
        function VoidTag2(addClosingSlash, tags) {
          if (addClosingSlash === void 0) {
            addClosingSlash = false;
          }
          this.addClosingSlash = addClosingSlash;
          if (Array.isArray(tags)) {
            this.voidTags = tags.reduce(function (set2, tag) {
              return set2
                .add(tag.toLowerCase())
                .add(tag.toUpperCase())
                .add(tag);
            }, /* @__PURE__ */ new Set());
          } else {
            this.voidTags = [
              "area",
              "base",
              "br",
              "col",
              "embed",
              "hr",
              "img",
              "input",
              "link",
              "meta",
              "param",
              "source",
              "track",
              "wbr",
            ].reduce(function (set2, tag) {
              return set2
                .add(tag.toLowerCase())
                .add(tag.toUpperCase())
                .add(tag);
            }, /* @__PURE__ */ new Set());
          }
        }
        VoidTag2.prototype.formatNode = function (tag, attrs, innerHTML) {
          var addClosingSlash = this.addClosingSlash;
          var closingSpace =
            addClosingSlash && attrs && !attrs.endsWith(" ") ? " " : "";
          var closingSlash = addClosingSlash
            ? "".concat(closingSpace, "/")
            : "";
          return this.isVoidElement(tag.toLowerCase())
            ? "<".concat(tag).concat(attrs).concat(closingSlash, ">")
            : "<"
                .concat(tag)
                .concat(attrs, ">")
                .concat(innerHTML, "</")
                .concat(tag, ">");
        };
        VoidTag2.prototype.isVoidElement = function (tag) {
          return this.voidTags.has(tag);
        };
        return VoidTag2;
      })();
    exports.default = VoidTag;
  },
});

// node_modules/node-html-parser/dist/nodes/text.js
var require_text = __commonJS({
  "node_modules/node-html-parser/dist/nodes/text.js"(exports) {
    "use strict";
    var __extends =
      (exports && exports.__extends) ||
      /* @__PURE__ */ (function () {
        var extendStatics = function (d2, b2) {
          extendStatics =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (d3, b3) {
                d3.__proto__ = b3;
              }) ||
            function (d3, b3) {
              for (var p2 in b3)
                if (Object.prototype.hasOwnProperty.call(b3, p2))
                  d3[p2] = b3[p2];
            };
          return extendStatics(d2, b2);
        };
        return function (d2, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError(
              "Class extends value " +
                String(b2) +
                " is not a constructor or null",
            );
          extendStatics(d2, b2);
          function __() {
            this.constructor = d2;
          }
          d2.prototype =
            b2 === null
              ? Object.create(b2)
              : ((__.prototype = b2.prototype), new __());
        };
      })();
    var __importDefault =
      (exports && exports.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports, "__esModule", { value: true });
    var he_1 = require_he();
    var node_1 = __importDefault(require_node());
    var type_1 = __importDefault(require_type());
    var TextNode =
      /** @class */
      (function (_super) {
        __extends(TextNode2, _super);
        function TextNode2(rawText, parentNode, range) {
          if (parentNode === void 0) {
            parentNode = null;
          }
          var _this = _super.call(this, parentNode, range) || this;
          _this.nodeType = type_1.default.TEXT_NODE;
          _this.rawTagName = "";
          _this._rawText = rawText;
          return _this;
        }
        TextNode2.prototype.clone = function () {
          return new TextNode2(this._rawText, null);
        };
        Object.defineProperty(TextNode2.prototype, "rawText", {
          get: function () {
            return this._rawText;
          },
          /**
           * Set rawText and invalidate trimmed caches
           */
          set: function (text2) {
            this._rawText = text2;
            this._trimmedRawText = void 0;
            this._trimmedText = void 0;
          },
          enumerable: false,
          configurable: true,
        });
        Object.defineProperty(TextNode2.prototype, "trimmedRawText", {
          /**
           * Returns raw text with all whitespace trimmed except single leading/trailing non-breaking space
           */
          get: function () {
            if (this._trimmedRawText !== void 0) return this._trimmedRawText;
            this._trimmedRawText = trimText(this.rawText);
            return this._trimmedRawText;
          },
          enumerable: false,
          configurable: true,
        });
        Object.defineProperty(TextNode2.prototype, "trimmedText", {
          /**
           * Returns text with all whitespace trimmed except single leading/trailing non-breaking space
           */
          get: function () {
            if (this._trimmedText !== void 0) return this._trimmedText;
            this._trimmedText = trimText(this.text);
            return this._trimmedText;
          },
          enumerable: false,
          configurable: true,
        });
        Object.defineProperty(TextNode2.prototype, "text", {
          /**
           * Get unescaped text value of current node and its children.
           * @return {string} text content
           */
          get: function () {
            return (0, he_1.decode)(this.rawText);
          },
          enumerable: false,
          configurable: true,
        });
        Object.defineProperty(TextNode2.prototype, "isWhitespace", {
          /**
           * Detect if the node contains only white space.
           * @return {boolean}
           */
          get: function () {
            return /^(\s|&nbsp;)*$/.test(this.rawText);
          },
          enumerable: false,
          configurable: true,
        });
        TextNode2.prototype.toString = function () {
          return this.rawText;
        };
        return TextNode2;
      })(node_1.default);
    exports.default = TextNode;
    function trimText(text2) {
      var i2 = 0;
      var startPos;
      var endPos;
      while (i2 >= 0 && i2 < text2.length) {
        if (/\S/.test(text2[i2])) {
          if (startPos === void 0) {
            startPos = i2;
            i2 = text2.length;
          } else {
            endPos = i2;
            i2 = void 0;
          }
        }
        if (startPos === void 0) i2++;
        else i2--;
      }
      if (startPos === void 0) startPos = 0;
      if (endPos === void 0) endPos = text2.length - 1;
      var hasLeadingSpace =
        startPos > 0 && /[^\S\r\n]/.test(text2[startPos - 1]);
      var hasTrailingSpace =
        endPos < text2.length - 1 && /[^\S\r\n]/.test(text2[endPos + 1]);
      return (
        (hasLeadingSpace ? " " : "") +
        text2.slice(startPos, endPos + 1) +
        (hasTrailingSpace ? " " : "")
      );
    }
  },
});

// node_modules/node-html-parser/dist/nodes/html.js
var require_html = __commonJS({
  "node_modules/node-html-parser/dist/nodes/html.js"(exports) {
    "use strict";
    var __extends =
      (exports && exports.__extends) ||
      /* @__PURE__ */ (function () {
        var extendStatics = function (d2, b2) {
          extendStatics =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (d3, b3) {
                d3.__proto__ = b3;
              }) ||
            function (d3, b3) {
              for (var p2 in b3)
                if (Object.prototype.hasOwnProperty.call(b3, p2))
                  d3[p2] = b3[p2];
            };
          return extendStatics(d2, b2);
        };
        return function (d2, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError(
              "Class extends value " +
                String(b2) +
                " is not a constructor or null",
            );
          extendStatics(d2, b2);
          function __() {
            this.constructor = d2;
          }
          d2.prototype =
            b2 === null
              ? Object.create(b2)
              : ((__.prototype = b2.prototype), new __());
        };
      })();
    var __assign =
      (exports && exports.__assign) ||
      function () {
        __assign =
          Object.assign ||
          function (t2) {
            for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {
              s2 = arguments[i2];
              for (var p2 in s2)
                if (Object.prototype.hasOwnProperty.call(s2, p2))
                  t2[p2] = s2[p2];
            }
            return t2;
          };
        return __assign.apply(this, arguments);
      };
    var __spreadArray5 =
      (exports && exports.__spreadArray) ||
      function (to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
            if (ar || !(i2 in from)) {
              if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
              ar[i2] = from[i2];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
    var __importDefault =
      (exports && exports.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parse = exports.base_parse = void 0;
    var css_select_1 = require_lib7();
    var he_1 = __importDefault(require_he());
    var back_1 = __importDefault(require_back());
    var matcher_1 = __importDefault(require_matcher());
    var void_tag_1 = __importDefault(require_void_tag());
    var comment_1 = __importDefault(require_comment());
    var node_1 = __importDefault(require_node());
    var text_1 = __importDefault(require_text());
    var type_1 = __importDefault(require_type());
    function decode4(val) {
      return JSON.parse(JSON.stringify(he_1.default.decode(val)));
    }
    var Htags = ["h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup"];
    var Dtags = ["details", "dialog", "dd", "div", "dt"];
    var Ftags = ["fieldset", "figcaption", "figure", "footer", "form"];
    var tableTags = ["table", "td", "tr"];
    var htmlTags = [
      "address",
      "article",
      "aside",
      "blockquote",
      "br",
      "hr",
      "li",
      "main",
      "nav",
      "ol",
      "p",
      "pre",
      "section",
      "ul",
    ];
    var kBlockElements = /* @__PURE__ */ new Set();
    function addToKBlockElement() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var addToSet = function (array3) {
        for (var index = 0; index < array3.length; index++) {
          var element = array3[index];
          kBlockElements.add(element);
          kBlockElements.add(element.toUpperCase());
        }
      };
      for (var _a19 = 0, args_1 = args; _a19 < args_1.length; _a19++) {
        var arg = args_1[_a19];
        addToSet(arg);
      }
    }
    addToKBlockElement(Htags, Dtags, Ftags, tableTags, htmlTags);
    var DOMTokenList =
      /** @class */
      (function () {
        function DOMTokenList2(valuesInit, afterUpdate) {
          if (valuesInit === void 0) {
            valuesInit = [];
          }
          if (afterUpdate === void 0) {
            afterUpdate = function () {
              return null;
            };
          }
          this._set = new Set(valuesInit);
          this._afterUpdate = afterUpdate;
        }
        DOMTokenList2.prototype._validate = function (c2) {
          if (/\s/.test(c2)) {
            throw new Error(
              "DOMException in DOMTokenList.add: The token '".concat(
                c2,
                "' contains HTML space characters, which are not valid in tokens.",
              ),
            );
          }
        };
        DOMTokenList2.prototype.add = function (c2) {
          this._validate(c2);
          this._set.add(c2);
          this._afterUpdate(this);
        };
        DOMTokenList2.prototype.replace = function (c1, c2) {
          this._validate(c2);
          this._set.delete(c1);
          this._set.add(c2);
          this._afterUpdate(this);
        };
        DOMTokenList2.prototype.remove = function (c2) {
          this._set.delete(c2) && this._afterUpdate(this);
        };
        DOMTokenList2.prototype.toggle = function (c2) {
          this._validate(c2);
          if (this._set.has(c2)) this._set.delete(c2);
          else this._set.add(c2);
          this._afterUpdate(this);
        };
        DOMTokenList2.prototype.contains = function (c2) {
          return this._set.has(c2);
        };
        Object.defineProperty(DOMTokenList2.prototype, "length", {
          get: function () {
            return this._set.size;
          },
          enumerable: false,
          configurable: true,
        });
        DOMTokenList2.prototype.values = function () {
          return this._set.values();
        };
        Object.defineProperty(DOMTokenList2.prototype, "value", {
          get: function () {
            return Array.from(this._set.values());
          },
          enumerable: false,
          configurable: true,
        });
        DOMTokenList2.prototype.toString = function () {
          return Array.from(this._set.values()).join(" ");
        };
        return DOMTokenList2;
      })();
    var HTMLElement =
      /** @class */
      (function (_super) {
        __extends(HTMLElement2, _super);
        function HTMLElement2(
          tagName,
          keyAttrs,
          rawAttrs,
          parentNode,
          range,
          voidTag,
          _parseOptions,
        ) {
          if (rawAttrs === void 0) {
            rawAttrs = "";
          }
          if (parentNode === void 0) {
            parentNode = null;
          }
          if (voidTag === void 0) {
            voidTag = new void_tag_1.default();
          }
          if (_parseOptions === void 0) {
            _parseOptions = {};
          }
          var _this = _super.call(this, parentNode, range) || this;
          _this.rawAttrs = rawAttrs;
          _this.voidTag = voidTag;
          _this.nodeType = type_1.default.ELEMENT_NODE;
          _this.rawTagName = tagName;
          _this.rawAttrs = rawAttrs || "";
          _this.id = keyAttrs.id || "";
          _this.childNodes = [];
          _this._parseOptions = _parseOptions;
          _this.classList = new DOMTokenList(
            keyAttrs.class ? keyAttrs.class.split(/\s+/) : [],
            function (classList) {
              return _this.setAttribute("class", classList.toString());
            },
            // eslint-disable-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call
          );
          if (keyAttrs.id) {
            if (!rawAttrs) {
              _this.rawAttrs = 'id="'.concat(keyAttrs.id, '"');
            }
          }
          if (keyAttrs.class) {
            if (!rawAttrs) {
              var cls = 'class="'.concat(_this.classList.toString(), '"');
              if (_this.rawAttrs) {
                _this.rawAttrs += " ".concat(cls);
              } else {
                _this.rawAttrs = cls;
              }
            }
          }
          return _this;
        }
        HTMLElement2.prototype.quoteAttribute = function (attr) {
          if (attr == null) {
            return "null";
          }
          return JSON.stringify(attr.replace(/"/g, "&quot;"))
            .replace(/\\t/g, "	")
            .replace(/\\n/g, "\n")
            .replace(/\\r/g, "\r")
            .replace(/\\/g, "");
        };
        HTMLElement2.prototype.removeChild = function (node) {
          this.childNodes = this.childNodes.filter(function (child) {
            return child !== node;
          });
          return this;
        };
        HTMLElement2.prototype.exchangeChild = function (oldNode, newNode) {
          var children = this.childNodes;
          this.childNodes = children.map(function (child) {
            if (child === oldNode) {
              return newNode;
            }
            return child;
          });
          return this;
        };
        Object.defineProperty(HTMLElement2.prototype, "tagName", {
          get: function () {
            return this.rawTagName
              ? this.rawTagName.toUpperCase()
              : this.rawTagName;
          },
          set: function (newname) {
            this.rawTagName = newname.toLowerCase();
          },
          enumerable: false,
          configurable: true,
        });
        Object.defineProperty(HTMLElement2.prototype, "localName", {
          get: function () {
            return this.rawTagName.toLowerCase();
          },
          enumerable: false,
          configurable: true,
        });
        Object.defineProperty(HTMLElement2.prototype, "isVoidElement", {
          get: function () {
            return this.voidTag.isVoidElement(this.localName);
          },
          enumerable: false,
          configurable: true,
        });
        Object.defineProperty(HTMLElement2.prototype, "rawText", {
          /**
           * Get escpaed (as-it) text value of current node and its children.
           * @return {string} text content
           */
          get: function () {
            if (/^br$/i.test(this.rawTagName)) {
              return "\n";
            }
            return this.childNodes.reduce(function (pre, cur) {
              return (pre += cur.rawText);
            }, "");
          },
          enumerable: false,
          configurable: true,
        });
        Object.defineProperty(HTMLElement2.prototype, "textContent", {
          get: function () {
            return decode4(this.rawText);
          },
          set: function (val) {
            var content = [new text_1.default(val, this)];
            this.childNodes = content;
          },
          enumerable: false,
          configurable: true,
        });
        Object.defineProperty(HTMLElement2.prototype, "text", {
          /**
           * Get unescaped text value of current node and its children.
           * @return {string} text content
           */
          get: function () {
            return decode4(this.rawText);
          },
          enumerable: false,
          configurable: true,
        });
        Object.defineProperty(HTMLElement2.prototype, "structuredText", {
          /**
           * Get structured Text (with '\n' etc.)
           * @return {string} structured text
           */
          get: function () {
            var currentBlock = [];
            var blocks = [currentBlock];
            function dfs(node) {
              if (node.nodeType === type_1.default.ELEMENT_NODE) {
                if (kBlockElements.has(node.rawTagName)) {
                  if (currentBlock.length > 0) {
                    blocks.push((currentBlock = []));
                  }
                  node.childNodes.forEach(dfs);
                  if (currentBlock.length > 0) {
                    blocks.push((currentBlock = []));
                  }
                } else {
                  node.childNodes.forEach(dfs);
                }
              } else if (node.nodeType === type_1.default.TEXT_NODE) {
                if (node.isWhitespace) {
                  currentBlock.prependWhitespace = true;
                } else {
                  var text2 = node.trimmedText;
                  if (currentBlock.prependWhitespace) {
                    text2 = " ".concat(text2);
                    currentBlock.prependWhitespace = false;
                  }
                  currentBlock.push(text2);
                }
              }
            }
            dfs(this);
            return blocks
              .map(function (block) {
                return block.join("").replace(/\s{2,}/g, " ");
              })
              .join("\n")
              .replace(/\s+$/, "");
          },
          enumerable: false,
          configurable: true,
        });
        HTMLElement2.prototype.toString = function () {
          var tag = this.rawTagName;
          if (tag) {
            var attrs = this.rawAttrs ? " ".concat(this.rawAttrs) : "";
            return this.voidTag.formatNode(tag, attrs, this.innerHTML);
          }
          return this.innerHTML;
        };
        Object.defineProperty(HTMLElement2.prototype, "innerHTML", {
          get: function () {
            return this.childNodes
              .map(function (child) {
                return child.toString();
              })
              .join("");
          },
          set: function (content) {
            var r2 = parse7(content, this._parseOptions);
            var nodes = r2.childNodes.length
              ? r2.childNodes
              : [new text_1.default(content, this)];
            resetParent(nodes, this);
            resetParent(this.childNodes, null);
            this.childNodes = nodes;
          },
          enumerable: false,
          configurable: true,
        });
        HTMLElement2.prototype.set_content = function (content, options) {
          if (options === void 0) {
            options = {};
          }
          if (content instanceof node_1.default) {
            content = [content];
          } else if (typeof content == "string") {
            options = __assign(__assign({}, this._parseOptions), options);
            var r2 = parse7(content, options);
            content = r2.childNodes.length
              ? r2.childNodes
              : [new text_1.default(r2.innerHTML, this)];
          }
          resetParent(this.childNodes, null);
          resetParent(content, this);
          this.childNodes = content;
          return this;
        };
        HTMLElement2.prototype.replaceWith = function () {
          var _this = this;
          var nodes = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
          }
          var parent = this.parentNode;
          var content = nodes
            .map(function (node) {
              if (node instanceof node_1.default) {
                return [node];
              } else if (typeof node == "string") {
                var r2 = parse7(node, _this._parseOptions);
                return r2.childNodes.length
                  ? r2.childNodes
                  : [new text_1.default(node, _this)];
              }
              return [];
            })
            .flat();
          var idx = parent.childNodes.findIndex(function (child) {
            return child === _this;
          });
          resetParent([this], null);
          parent.childNodes = __spreadArray5(
            __spreadArray5(
              __spreadArray5([], parent.childNodes.slice(0, idx), true),
              resetParent(content, parent),
              true,
            ),
            parent.childNodes.slice(idx + 1),
            true,
          );
          return this;
        };
        Object.defineProperty(HTMLElement2.prototype, "outerHTML", {
          get: function () {
            return this.toString();
          },
          enumerable: false,
          configurable: true,
        });
        HTMLElement2.prototype.trimRight = function (pattern) {
          for (var i2 = 0; i2 < this.childNodes.length; i2++) {
            var childNode = this.childNodes[i2];
            if (childNode.nodeType === type_1.default.ELEMENT_NODE) {
              childNode.trimRight(pattern);
            } else {
              var index = childNode.rawText.search(pattern);
              if (index > -1) {
                childNode.rawText = childNode.rawText.substr(0, index);
                this.childNodes.length = i2 + 1;
              }
            }
          }
          return this;
        };
        Object.defineProperty(HTMLElement2.prototype, "structure", {
          /**
           * Get DOM structure
           * @return {string} structure
           */
          get: function () {
            var res = [];
            var indention = 0;
            function write(str) {
              res.push("  ".repeat(indention) + str);
            }
            function dfs(node) {
              var idStr = node.id ? "#".concat(node.id) : "";
              var classStr = node.classList.length
                ? ".".concat(node.classList.value.join("."))
                : "";
              write("".concat(node.rawTagName).concat(idStr).concat(classStr));
              indention++;
              node.childNodes.forEach(function (childNode) {
                if (childNode.nodeType === type_1.default.ELEMENT_NODE) {
                  dfs(childNode);
                } else if (childNode.nodeType === type_1.default.TEXT_NODE) {
                  if (!childNode.isWhitespace) {
                    write("#text");
                  }
                }
              });
              indention--;
            }
            dfs(this);
            return res.join("\n");
          },
          enumerable: false,
          configurable: true,
        });
        HTMLElement2.prototype.removeWhitespace = function () {
          var _this = this;
          var o2 = 0;
          this.childNodes.forEach(function (node) {
            if (node.nodeType === type_1.default.TEXT_NODE) {
              if (node.isWhitespace) {
                return;
              }
              node.rawText = node.trimmedRawText;
            } else if (node.nodeType === type_1.default.ELEMENT_NODE) {
              node.removeWhitespace();
            }
            _this.childNodes[o2++] = node;
          });
          this.childNodes.length = o2;
          return this;
        };
        HTMLElement2.prototype.querySelectorAll = function (selector) {
          return (0, css_select_1.selectAll)(selector, this, {
            xmlMode: true,
            adapter: matcher_1.default,
          });
        };
        HTMLElement2.prototype.querySelector = function (selector) {
          return (0, css_select_1.selectOne)(selector, this, {
            xmlMode: true,
            adapter: matcher_1.default,
          });
        };
        HTMLElement2.prototype.getElementsByTagName = function (tagName) {
          var upperCasedTagName = tagName.toUpperCase();
          var re2 = [];
          var stack = [];
          var currentNodeReference = this;
          var index = 0;
          while (index !== void 0) {
            var child = void 0;
            do {
              child = currentNodeReference.childNodes[index++];
            } while (
              index < currentNodeReference.childNodes.length &&
              child === void 0
            );
            if (child === void 0) {
              currentNodeReference = currentNodeReference.parentNode;
              index = stack.pop();
              continue;
            }
            if (child.nodeType === type_1.default.ELEMENT_NODE) {
              if (tagName === "*" || child.tagName === upperCasedTagName)
                re2.push(child);
              if (child.childNodes.length > 0) {
                stack.push(index);
                currentNodeReference = child;
                index = 0;
              }
            }
          }
          return re2;
        };
        HTMLElement2.prototype.getElementById = function (id) {
          var stack = [];
          var currentNodeReference = this;
          var index = 0;
          while (index !== void 0) {
            var child = void 0;
            do {
              child = currentNodeReference.childNodes[index++];
            } while (
              index < currentNodeReference.childNodes.length &&
              child === void 0
            );
            if (child === void 0) {
              currentNodeReference = currentNodeReference.parentNode;
              index = stack.pop();
              continue;
            }
            if (child.nodeType === type_1.default.ELEMENT_NODE) {
              if (child.id === id) {
                return child;
              }
              if (child.childNodes.length > 0) {
                stack.push(index);
                currentNodeReference = child;
                index = 0;
              }
            }
          }
          return null;
        };
        HTMLElement2.prototype.closest = function (selector) {
          var mapChild = /* @__PURE__ */ new Map();
          var el = this;
          var old = null;
          function findOne(test, elems) {
            var elem = null;
            for (var i2 = 0, l2 = elems.length; i2 < l2 && !elem; i2++) {
              var el_1 = elems[i2];
              if (test(el_1)) {
                elem = el_1;
              } else {
                var child = mapChild.get(el_1);
                if (child) {
                  elem = findOne(test, [child]);
                }
              }
            }
            return elem;
          }
          while (el) {
            mapChild.set(el, old);
            old = el;
            el = el.parentNode;
          }
          el = this;
          while (el) {
            var e2 = (0, css_select_1.selectOne)(selector, el, {
              xmlMode: true,
              adapter: __assign(__assign({}, matcher_1.default), {
                getChildren: function (node) {
                  var child = mapChild.get(node);
                  return child && [child];
                },
                getSiblings: function (node) {
                  return [node];
                },
                findOne,
                findAll: function () {
                  return [];
                },
              }),
            });
            if (e2) {
              return e2;
            }
            el = el.parentNode;
          }
          return null;
        };
        HTMLElement2.prototype.appendChild = function (node) {
          node.remove();
          this.childNodes.push(node);
          node.parentNode = this;
          return node;
        };
        Object.defineProperty(HTMLElement2.prototype, "firstChild", {
          /**
           * Get first child node
           * @return {Node | undefined} first child node; or undefined if none
           */
          get: function () {
            return this.childNodes[0];
          },
          enumerable: false,
          configurable: true,
        });
        Object.defineProperty(HTMLElement2.prototype, "lastChild", {
          /**
           * Get last child node
           * @return {Node | undefined} last child node; or undefined if none
           */
          get: function () {
            return (0, back_1.default)(this.childNodes);
          },
          enumerable: false,
          configurable: true,
        });
        Object.defineProperty(HTMLElement2.prototype, "attrs", {
          /**
           * Get attributes
           * @access private
           * @return {Object} parsed and unescaped attributes
           */
          get: function () {
            if (this._attrs) {
              return this._attrs;
            }
            this._attrs = {};
            var attrs = this.rawAttributes;
            for (var key in attrs) {
              var val = attrs[key] || "";
              this._attrs[key.toLowerCase()] = decode4(val);
            }
            return this._attrs;
          },
          enumerable: false,
          configurable: true,
        });
        Object.defineProperty(HTMLElement2.prototype, "attributes", {
          get: function () {
            var ret_attrs = {};
            var attrs = this.rawAttributes;
            for (var key in attrs) {
              var val = attrs[key] || "";
              ret_attrs[key] = decode4(val);
            }
            return ret_attrs;
          },
          enumerable: false,
          configurable: true,
        });
        Object.defineProperty(HTMLElement2.prototype, "rawAttributes", {
          /**
           * Get escaped (as-is) attributes
           * @return {Object} parsed attributes
           */
          get: function () {
            if (this._rawAttrs) {
              return this._rawAttrs;
            }
            var attrs = {};
            if (this.rawAttrs) {
              var re2 =
                /([a-zA-Z()[\]#@$.?:][a-zA-Z0-9-_:()[\]#]*)(?:\s*=\s*((?:'[^']*')|(?:"[^"]*")|\S+))?/g;
              var match = void 0;
              while ((match = re2.exec(this.rawAttrs))) {
                var key = match[1];
                var val = match[2] || null;
                if (val && (val[0] === "'" || val[0] === '"'))
                  val = val.slice(1, val.length - 1);
                attrs[key] = attrs[key] || val;
              }
            }
            this._rawAttrs = attrs;
            return attrs;
          },
          enumerable: false,
          configurable: true,
        });
        HTMLElement2.prototype.removeAttribute = function (key) {
          var _this = this;
          var attrs = this.rawAttributes;
          delete attrs[key];
          if (this._attrs) {
            delete this._attrs[key];
          }
          this.rawAttrs = Object.keys(attrs)
            .map(function (name18) {
              var val = _this.quoteAttribute(attrs[name18]);
              if (val === "null" || val === '""') return name18;
              return "".concat(name18, "=").concat(val);
            })
            .join(" ");
          if (key === "id") {
            this.id = "";
          }
          return this;
        };
        HTMLElement2.prototype.hasAttribute = function (key) {
          return key.toLowerCase() in this.attrs;
        };
        HTMLElement2.prototype.getAttribute = function (key) {
          return this.attrs[key.toLowerCase()];
        };
        HTMLElement2.prototype.setAttribute = function (key, value) {
          var _this = this;
          if (arguments.length < 2) {
            throw new Error("Failed to execute 'setAttribute' on 'Element'");
          }
          var k2 = key.toLowerCase();
          var attrs = this.rawAttributes;
          for (var k in attrs) {
            if (k.toLowerCase() === k2) {
              key = k;
              break;
            }
          }
          attrs[key] = String(value);
          if (this._attrs) {
            this._attrs[k2] = decode4(attrs[key]);
          }
          this.rawAttrs = Object.keys(attrs)
            .map(function (name18) {
              var val = _this.quoteAttribute(attrs[name18]);
              if (val === "null" || val === '""') return name18;
              return "".concat(name18, "=").concat(val);
            })
            .join(" ");
          if (key === "id") {
            this.id = value;
          }
          return this;
        };
        HTMLElement2.prototype.setAttributes = function (attributes) {
          var _this = this;
          if (this._attrs) {
            delete this._attrs;
          }
          if (this._rawAttrs) {
            delete this._rawAttrs;
          }
          this.rawAttrs = Object.keys(attributes)
            .map(function (name18) {
              var val = attributes[name18];
              if (val === "null" || val === '""') return name18;
              return ""
                .concat(name18, "=")
                .concat(_this.quoteAttribute(String(val)));
            })
            .join(" ");
          return this;
        };
        HTMLElement2.prototype.insertAdjacentHTML = function (where, html) {
          var _a19, _b9, _c;
          var _this = this;
          if (arguments.length < 2) {
            throw new Error("2 arguments required");
          }
          var p2 = parse7(html, this._parseOptions);
          if (where === "afterend") {
            var idx = this.parentNode.childNodes.findIndex(function (child) {
              return child === _this;
            });
            resetParent(p2.childNodes, this.parentNode);
            (_a19 = this.parentNode.childNodes).splice.apply(
              _a19,
              __spreadArray5([idx + 1, 0], p2.childNodes, false),
            );
          } else if (where === "afterbegin") {
            resetParent(p2.childNodes, this);
            (_b9 = this.childNodes).unshift.apply(_b9, p2.childNodes);
          } else if (where === "beforeend") {
            p2.childNodes.forEach(function (n) {
              _this.appendChild(n);
            });
          } else if (where === "beforebegin") {
            var idx = this.parentNode.childNodes.findIndex(function (child) {
              return child === _this;
            });
            resetParent(p2.childNodes, this.parentNode);
            (_c = this.parentNode.childNodes).splice.apply(
              _c,
              __spreadArray5([idx, 0], p2.childNodes, false),
            );
          } else {
            throw new Error(
              "The value provided ('".concat(
                where,
                "') is not one of 'beforebegin', 'afterbegin', 'beforeend', or 'afterend'",
              ),
            );
          }
          return this;
        };
        Object.defineProperty(HTMLElement2.prototype, "nextSibling", {
          get: function () {
            if (this.parentNode) {
              var children = this.parentNode.childNodes;
              var i2 = 0;
              while (i2 < children.length) {
                var child = children[i2++];
                if (this === child) return children[i2] || null;
              }
              return null;
            }
          },
          enumerable: false,
          configurable: true,
        });
        Object.defineProperty(HTMLElement2.prototype, "nextElementSibling", {
          get: function () {
            if (this.parentNode) {
              var children = this.parentNode.childNodes;
              var i2 = 0;
              var find = false;
              while (i2 < children.length) {
                var child = children[i2++];
                if (find) {
                  if (child instanceof HTMLElement2) {
                    return child || null;
                  }
                } else if (this === child) {
                  find = true;
                }
              }
              return null;
            }
          },
          enumerable: false,
          configurable: true,
        });
        Object.defineProperty(HTMLElement2.prototype, "previousSibling", {
          get: function () {
            if (this.parentNode) {
              var children = this.parentNode.childNodes;
              var i2 = children.length;
              while (i2 > 0) {
                var child = children[--i2];
                if (this === child) return children[i2 - 1] || null;
              }
              return null;
            }
          },
          enumerable: false,
          configurable: true,
        });
        Object.defineProperty(
          HTMLElement2.prototype,
          "previousElementSibling",
          {
            get: function () {
              if (this.parentNode) {
                var children = this.parentNode.childNodes;
                var i2 = children.length;
                var find = false;
                while (i2 > 0) {
                  var child = children[--i2];
                  if (find) {
                    if (child instanceof HTMLElement2) {
                      return child || null;
                    }
                  } else if (this === child) {
                    find = true;
                  }
                }
                return null;
              }
            },
            enumerable: false,
            configurable: true,
          },
        );
        Object.defineProperty(HTMLElement2.prototype, "classNames", {
          get: function () {
            return this.classList.toString();
          },
          enumerable: false,
          configurable: true,
        });
        HTMLElement2.prototype.clone = function () {
          return parse7(this.toString(), this._parseOptions).firstChild;
        };
        return HTMLElement2;
      })(node_1.default);
    exports.default = HTMLElement;
    var kMarkupPattern =
      /<!--[\s\S]*?-->|<(\/?)([a-zA-Z][-.:0-9_a-zA-Z]*)((?:\s+[^>]*?(?:(?:'[^']*')|(?:"[^"]*"))?)*)\s*(\/?)>/g;
    var kAttributePattern =
      /(?:^|\s)(id|class)\s*=\s*((?:'[^']*')|(?:"[^"]*")|\S+)/gi;
    var kElementsClosedByOpening = {
      li: { li: true, LI: true },
      LI: { li: true, LI: true },
      p: { p: true, div: true, P: true, DIV: true },
      P: { p: true, div: true, P: true, DIV: true },
      b: { div: true, DIV: true },
      B: { div: true, DIV: true },
      td: { td: true, th: true, TD: true, TH: true },
      TD: { td: true, th: true, TD: true, TH: true },
      th: { td: true, th: true, TD: true, TH: true },
      TH: { td: true, th: true, TD: true, TH: true },
      h1: { h1: true, H1: true },
      H1: { h1: true, H1: true },
      h2: { h2: true, H2: true },
      H2: { h2: true, H2: true },
      h3: { h3: true, H3: true },
      H3: { h3: true, H3: true },
      h4: { h4: true, H4: true },
      H4: { h4: true, H4: true },
      h5: { h5: true, H5: true },
      H5: { h5: true, H5: true },
      h6: { h6: true, H6: true },
      H6: { h6: true, H6: true },
    };
    var kElementsClosedByClosing = {
      li: { ul: true, ol: true, UL: true, OL: true },
      LI: { ul: true, ol: true, UL: true, OL: true },
      a: { div: true, DIV: true },
      A: { div: true, DIV: true },
      b: { div: true, DIV: true },
      B: { div: true, DIV: true },
      i: { div: true, DIV: true },
      I: { div: true, DIV: true },
      p: { div: true, DIV: true },
      P: { div: true, DIV: true },
      td: { tr: true, table: true, TR: true, TABLE: true },
      TD: { tr: true, table: true, TR: true, TABLE: true },
      th: { tr: true, table: true, TR: true, TABLE: true },
      TH: { tr: true, table: true, TR: true, TABLE: true },
    };
    var frameflag = "documentfragmentcontainer";
    function base_parse(data, options) {
      var _a19, _b9;
      if (options === void 0) {
        options = {};
      }
      var voidTag = new void_tag_1.default(
        (_a19 =
          options === null || options === void 0 ? void 0 : options.voidTag) ===
          null || _a19 === void 0
          ? void 0
          : _a19.closingSlash,
        (_b9 =
          options === null || options === void 0 ? void 0 : options.voidTag) ===
          null || _b9 === void 0
          ? void 0
          : _b9.tags,
      );
      var elements = options.blockTextElements || {
        script: true,
        noscript: true,
        style: true,
        pre: true,
      };
      var element_names = Object.keys(elements);
      var kBlockTextElements = element_names.map(function (it) {
        return new RegExp("^".concat(it, "$"), "i");
      });
      var kIgnoreElements = element_names
        .filter(function (it) {
          return Boolean(elements[it]);
        })
        .map(function (it) {
          return new RegExp("^".concat(it, "$"), "i");
        });
      function element_should_be_ignore(tag) {
        return kIgnoreElements.some(function (it) {
          return it.test(tag);
        });
      }
      function is_block_text_element(tag) {
        return kBlockTextElements.some(function (it) {
          return it.test(tag);
        });
      }
      var createRange = function (startPos, endPos) {
        return [startPos - frameFlagOffset, endPos - frameFlagOffset];
      };
      var root = new HTMLElement(
        null,
        {},
        "",
        null,
        [0, data.length],
        voidTag,
        options,
      );
      var currentParent = root;
      var stack = [root];
      var lastTextPos = -1;
      var noNestedTagIndex = void 0;
      var match;
      data = "<"
        .concat(frameflag, ">")
        .concat(data, "</")
        .concat(frameflag, ">");
      var lowerCaseTagName = options.lowerCaseTagName,
        fixNestedATags = options.fixNestedATags;
      var dataEndPos = data.length - (frameflag.length + 2);
      var frameFlagOffset = frameflag.length + 2;
      while ((match = kMarkupPattern.exec(data))) {
        var matchText = match[0],
          leadingSlash = match[1],
          tagName = match[2],
          attributes = match[3],
          closingSlash = match[4];
        var matchLength = matchText.length;
        var tagStartPos = kMarkupPattern.lastIndex - matchLength;
        var tagEndPos = kMarkupPattern.lastIndex;
        if (lastTextPos > -1) {
          if (lastTextPos + matchLength < tagEndPos) {
            var text2 = data.substring(lastTextPos, tagStartPos);
            currentParent.appendChild(
              new text_1.default(
                text2,
                currentParent,
                createRange(lastTextPos, tagStartPos),
              ),
            );
          }
        }
        lastTextPos = kMarkupPattern.lastIndex;
        if (tagName === frameflag) continue;
        if (matchText[1] === "!") {
          if (options.comment) {
            var text2 = data.substring(tagStartPos + 4, tagEndPos - 3);
            currentParent.appendChild(
              new comment_1.default(
                text2,
                currentParent,
                createRange(tagStartPos, tagEndPos),
              ),
            );
          }
          continue;
        }
        if (lowerCaseTagName) tagName = tagName.toLowerCase();
        if (!leadingSlash) {
          var attrs = {};
          for (
            var attMatch = void 0;
            (attMatch = kAttributePattern.exec(attributes));

          ) {
            var key = attMatch[1],
              val = attMatch[2];
            var isQuoted = val[0] === "'" || val[0] === '"';
            attrs[key.toLowerCase()] = isQuoted
              ? val.slice(1, val.length - 1)
              : val;
          }
          var parentTagName = currentParent.rawTagName;
          if (!closingSlash && kElementsClosedByOpening[parentTagName]) {
            if (kElementsClosedByOpening[parentTagName][tagName]) {
              stack.pop();
              currentParent = (0, back_1.default)(stack);
            }
          }
          if (fixNestedATags && (tagName === "a" || tagName === "A")) {
            if (noNestedTagIndex !== void 0) {
              stack.splice(noNestedTagIndex);
              currentParent = (0, back_1.default)(stack);
            }
            noNestedTagIndex = stack.length;
          }
          var tagEndPos_1 = kMarkupPattern.lastIndex;
          var tagStartPos_1 = tagEndPos_1 - matchLength;
          currentParent = currentParent.appendChild(
            // Initialize range (end position updated later for closed tags)
            new HTMLElement(
              tagName,
              attrs,
              attributes.slice(1),
              null,
              createRange(tagStartPos_1, tagEndPos_1),
              voidTag,
              options,
            ),
          );
          stack.push(currentParent);
          if (is_block_text_element(tagName)) {
            var closeMarkup = "</".concat(tagName, ">");
            var closeIndex = lowerCaseTagName
              ? data
                  .toLocaleLowerCase()
                  .indexOf(closeMarkup, kMarkupPattern.lastIndex)
              : data.indexOf(closeMarkup, kMarkupPattern.lastIndex);
            var textEndPos = closeIndex === -1 ? dataEndPos : closeIndex;
            if (element_should_be_ignore(tagName)) {
              var text2 = data.substring(tagEndPos_1, textEndPos);
              if (text2.length > 0 && /\S/.test(text2)) {
                currentParent.appendChild(
                  new text_1.default(
                    text2,
                    currentParent,
                    createRange(tagEndPos_1, textEndPos),
                  ),
                );
              }
            }
            if (closeIndex === -1) {
              lastTextPos = kMarkupPattern.lastIndex = data.length + 1;
            } else {
              lastTextPos = kMarkupPattern.lastIndex =
                closeIndex + closeMarkup.length;
              leadingSlash = "/";
            }
          }
        }
        if (leadingSlash || closingSlash || voidTag.isVoidElement(tagName)) {
          while (true) {
            if (
              noNestedTagIndex != null &&
              (tagName === "a" || tagName === "A")
            )
              noNestedTagIndex = void 0;
            if (currentParent.rawTagName === tagName) {
              currentParent.range[1] = createRange(
                -1,
                Math.max(lastTextPos, tagEndPos),
              )[1];
              stack.pop();
              currentParent = (0, back_1.default)(stack);
              break;
            } else {
              var parentTagName = currentParent.tagName;
              if (kElementsClosedByClosing[parentTagName]) {
                if (kElementsClosedByClosing[parentTagName][tagName]) {
                  stack.pop();
                  currentParent = (0, back_1.default)(stack);
                  continue;
                }
              }
              break;
            }
          }
        }
      }
      return stack;
    }
    exports.base_parse = base_parse;
    function parse7(data, options) {
      if (options === void 0) {
        options = {};
      }
      var stack = base_parse(data, options);
      var root = stack[0];
      var _loop_1 = function () {
        var last = stack.pop();
        var oneBefore = (0, back_1.default)(stack);
        if (last.parentNode && last.parentNode.parentNode) {
          if (
            last.parentNode === oneBefore &&
            last.tagName === oneBefore.tagName
          ) {
            if (options.parseNoneClosedTags !== true) {
              oneBefore.removeChild(last);
              last.childNodes.forEach(function (child) {
                oneBefore.parentNode.appendChild(child);
              });
              stack.pop();
            }
          } else {
            if (options.parseNoneClosedTags !== true) {
              oneBefore.removeChild(last);
              last.childNodes.forEach(function (child) {
                oneBefore.appendChild(child);
              });
            }
          }
        } else {
        }
      };
      while (stack.length > 1) {
        _loop_1();
      }
      return root;
    }
    exports.parse = parse7;
    function resetParent(nodes, parent) {
      return nodes.map(function (node) {
        node.parentNode = parent;
        return node;
      });
    }
  },
});

// node_modules/node-html-parser/dist/parse.js
var require_parse2 = __commonJS({
  "node_modules/node-html-parser/dist/parse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = void 0;
    var html_1 = require_html();
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function () {
        return html_1.parse;
      },
    });
  },
});

// node_modules/node-html-parser/dist/valid.js
var require_valid = __commonJS({
  "node_modules/node-html-parser/dist/valid.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var html_1 = require_html();
    function valid(data, options) {
      if (options === void 0) {
        options = {};
      }
      var stack = (0, html_1.base_parse)(data, options);
      return Boolean(stack.length === 1);
    }
    exports.default = valid;
  },
});

// node_modules/node-html-parser/dist/index.js
var require_dist = __commonJS({
  "node_modules/node-html-parser/dist/index.js"(exports) {
    "use strict";
    var __importDefault =
      (exports && exports.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NodeType =
      exports.TextNode =
      exports.Node =
      exports.valid =
      exports.CommentNode =
      exports.HTMLElement =
      exports.parse =
        void 0;
    var comment_1 = __importDefault(require_comment());
    exports.CommentNode = comment_1.default;
    var html_1 = __importDefault(require_html());
    exports.HTMLElement = html_1.default;
    var node_1 = __importDefault(require_node());
    exports.Node = node_1.default;
    var text_1 = __importDefault(require_text());
    exports.TextNode = text_1.default;
    var type_1 = __importDefault(require_type());
    exports.NodeType = type_1.default;
    var parse_1 = __importDefault(require_parse2());
    var valid_1 = __importDefault(require_valid());
    exports.valid = valid_1.default;
    function parse7(data, options) {
      if (options === void 0) {
        options = {};
      }
      return (0, parse_1.default)(data, options);
    }
    exports.default = parse7;
    exports.parse = parse7;
    parse7.parse = parse_1.default;
    parse7.HTMLElement = html_1.default;
    parse7.CommentNode = comment_1.default;
    parse7.valid = valid_1.default;
    parse7.Node = node_1.default;
    parse7.TextNode = text_1.default;
    parse7.NodeType = type_1.default;
  },
});

// node_modules/fast-content-type-parse/index.js
var require_fast_content_type_parse = __commonJS({
  "node_modules/fast-content-type-parse/index.js"(exports, module) {
    "use strict";
    var NullObject = function NullObject2() {};
    NullObject.prototype = /* @__PURE__ */ Object.create(null);
    var paramRE =
      /; *([!#$%&'*+.^\w`|~-]+)=("(?:[\v\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\v\u0020-\u00ff])*"|[!#$%&'*+.^\w`|~-]+) */gu;
    var quotedPairRE = /\\([\v\u0020-\u00ff])/gu;
    var mediaTypeRE = /^[!#$%&'*+.^\w|~-]+\/[!#$%&'*+.^\w|~-]+$/u;
    var defaultContentType = { type: "", parameters: new NullObject() };
    Object.freeze(defaultContentType.parameters);
    Object.freeze(defaultContentType);
    function parse7(header) {
      if (typeof header !== "string") {
        throw new TypeError("argument header is required and must be a string");
      }
      let index = header.indexOf(";");
      const type = index !== -1 ? header.slice(0, index).trim() : header.trim();
      if (mediaTypeRE.test(type) === false) {
        throw new TypeError("invalid media type");
      }
      const result = {
        type: type.toLowerCase(),
        parameters: new NullObject(),
      };
      if (index === -1) {
        return result;
      }
      let key;
      let match;
      let value;
      paramRE.lastIndex = index;
      while ((match = paramRE.exec(header))) {
        if (match.index !== index) {
          throw new TypeError("invalid parameter format");
        }
        index += match[0].length;
        key = match[1].toLowerCase();
        value = match[2];
        if (value[0] === '"') {
          value = value.slice(1, value.length - 1);
          quotedPairRE.test(value) &&
            (value = value.replace(quotedPairRE, "$1"));
        }
        result.parameters[key] = value;
      }
      if (index !== header.length) {
        throw new TypeError("invalid parameter format");
      }
      return result;
    }
    function safeParse5(header) {
      if (typeof header !== "string") {
        return defaultContentType;
      }
      let index = header.indexOf(";");
      const type = index !== -1 ? header.slice(0, index).trim() : header.trim();
      if (mediaTypeRE.test(type) === false) {
        return defaultContentType;
      }
      const result = {
        type: type.toLowerCase(),
        parameters: new NullObject(),
      };
      if (index === -1) {
        return result;
      }
      let key;
      let match;
      let value;
      paramRE.lastIndex = index;
      while ((match = paramRE.exec(header))) {
        if (match.index !== index) {
          return defaultContentType;
        }
        index += match[0].length;
        key = match[1].toLowerCase();
        value = match[2];
        if (value[0] === '"') {
          value = value.slice(1, value.length - 1);
          quotedPairRE.test(value) &&
            (value = value.replace(quotedPairRE, "$1"));
        }
        result.parameters[key] = value;
      }
      if (index !== header.length) {
        return defaultContentType;
      }
      return result;
    }
    module.exports.default = { parse: parse7, safeParse: safeParse5 };
    module.exports.parse = parse7;
    module.exports.safeParse = safeParse5;
    module.exports.defaultContentType = defaultContentType;
  },
});

// node_modules/slack-web-api-client/dist/block-kit/block-elements.js
var require_block_elements = __commonJS({
  "node_modules/slack-web-api-client/dist/block-kit/block-elements.js"(
    exports,
  ) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-web-api-client/dist/block-kit/blocks.js
var require_blocks = __commonJS({
  "node_modules/slack-web-api-client/dist/block-kit/blocks.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-web-api-client/dist/block-kit/confirm.js
var require_confirm = __commonJS({
  "node_modules/slack-web-api-client/dist/block-kit/confirm.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-web-api-client/dist/block-kit/link-unfurls.js
var require_link_unfurls = __commonJS({
  "node_modules/slack-web-api-client/dist/block-kit/link-unfurls.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-web-api-client/dist/block-kit/message-attachment.js
var require_message_attachment = __commonJS({
  "node_modules/slack-web-api-client/dist/block-kit/message-attachment.js"(
    exports,
  ) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-web-api-client/dist/block-kit/message-metadata.js
var require_message_metadata = __commonJS({
  "node_modules/slack-web-api-client/dist/block-kit/message-metadata.js"(
    exports,
  ) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-web-api-client/dist/block-kit/options.js
var require_options = __commonJS({
  "node_modules/slack-web-api-client/dist/block-kit/options.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-web-api-client/dist/block-kit/text-fields.js
var require_text_fields = __commonJS({
  "node_modules/slack-web-api-client/dist/block-kit/text-fields.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-web-api-client/dist/block-kit/rich-text-block.js
var require_rich_text_block = __commonJS({
  "node_modules/slack-web-api-client/dist/block-kit/rich-text-block.js"(
    exports,
  ) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-web-api-client/dist/block-kit/views.js
var require_views = __commonJS({
  "node_modules/slack-web-api-client/dist/block-kit/views.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-web-api-client/dist/client/api-client-options.js
var require_api_client_options = __commonJS({
  "node_modules/slack-web-api-client/dist/client/api-client-options.js"(
    exports,
  ) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-web-api-client/dist/errors.js
var require_errors = __commonJS({
  "node_modules/slack-web-api-client/dist/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebhookError =
      exports.TokenRotationError =
      exports.SlackAPIError =
      exports.SlackAPIConnectionError =
        void 0;
    var SlackAPIConnectionError = class extends Error {
      apiName;
      status;
      body;
      headers;
      cause;
      constructor(apiName, status, body, headers, cause) {
        const substring = body
          .replaceAll("\r", "")
          .replaceAll("\n", "")
          .substring(0, 100);
        const bodyToPrint =
          substring.length === 1e3 ? substring + " ..." : substring;
        const message =
          cause !== void 0
            ? `Failed to call ${apiName} (cause: ${cause})`
            : `Failed to call ${apiName} (status: ${status}, body: ${bodyToPrint})`;
        super(message);
        this.name = "SlackAPIConnectionError";
        this.apiName = apiName;
        this.status = status;
        this.body = body;
        this.headers = headers;
        this.cause = cause;
      }
    };
    exports.SlackAPIConnectionError = SlackAPIConnectionError;
    var SlackAPIError = class extends Error {
      apiName;
      error;
      result;
      constructor(apiName, error45, result) {
        const resultToPrint = JSON.stringify(result);
        const message = `Failed to call ${apiName} due to ${error45}: ${resultToPrint}`;
        super(message);
        this.name = "SlackAPIError";
        this.apiName = apiName;
        this.error = error45;
        this.result = result;
      }
    };
    exports.SlackAPIError = SlackAPIError;
    var TokenRotationError = class extends Error {
      cause;
      constructor(message, cause) {
        super(message);
        this.name = "TokenRotationError";
        this.cause = cause;
      }
    };
    exports.TokenRotationError = TokenRotationError;
    var WebhookError = class extends Error {
      status;
      body;
      cause;
      constructor(status, body, cause = void 0) {
        const message = cause
          ? `Failed to send a message using incoming webhook/response_url (cause: ${cause})`
          : `Failed to send a message using incoming webhook/response_url (status: ${status}, body: ${body})`;
        super(message);
        this.name = "WebhookError";
        this.status = status;
        this.body = body;
        this.cause = cause;
      }
    };
    exports.WebhookError = WebhookError;
  },
});

// node_modules/slack-web-api-client/dist/logging/logging-level.js
var require_logging_level = __commonJS({
  "node_modules/slack-web-api-client/dist/logging/logging-level.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-web-api-client/dist/logging/debug-logging.js
var require_debug_logging = __commonJS({
  "node_modules/slack-web-api-client/dist/logging/debug-logging.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isDebugLogEnabled = isDebugLogEnabled;
    exports.prettyPrint = prettyPrint;
    function isDebugLogEnabled(logLevel) {
      return (
        logLevel !== void 0 &&
        logLevel !== null &&
        logLevel.toUpperCase() === "DEBUG"
      );
    }
    function prettyPrint(obj) {
      return JSON.stringify(obj, null, 2);
    }
  },
});

// node_modules/slack-web-api-client/dist/logging/index.js
var require_logging = __commonJS({
  "node_modules/slack-web-api-client/dist/logging/index.js"(exports) {
    "use strict";
    var __createBinding =
      (exports && exports.__createBinding) ||
      (Object.create
        ? function (o2, m2, k, k2) {
            if (k2 === void 0) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m2, k);
            if (
              !desc ||
              ("get" in desc
                ? !m2.__esModule
                : desc.writable || desc.configurable)
            ) {
              desc = {
                enumerable: true,
                get: function () {
                  return m2[k];
                },
              };
            }
            Object.defineProperty(o2, k2, desc);
          }
        : function (o2, m2, k, k2) {
            if (k2 === void 0) k2 = k;
            o2[k2] = m2[k];
          });
    var __exportStar =
      (exports && exports.__exportStar) ||
      function (m2, exports2) {
        for (var p2 in m2)
          if (
            p2 !== "default" &&
            !Object.prototype.hasOwnProperty.call(exports2, p2)
          )
            __createBinding(exports2, m2, p2);
      };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_logging_level(), exports);
    __exportStar(require_debug_logging(), exports);
  },
});

// node_modules/slack-web-api-client/dist/client/retry-handler/retry-handler.js
var require_retry_handler = __commonJS({
  "node_modules/slack-web-api-client/dist/client/retry-handler/retry-handler.js"(
    exports,
  ) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-web-api-client/dist/client/retry-handler/built-in.js
var require_built_in = __commonJS({
  "node_modules/slack-web-api-client/dist/client/retry-handler/built-in.js"(
    exports,
  ) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ServerErrorRetryHandler =
      exports.ConnectionErrorRetryHandler =
      exports.RatelimitRetryHandler =
      exports.DefaultFixedIntervalRetryHandlerOptions =
      exports.DefaultBasicRetryHandlerOptions =
        void 0;
    var errors_1 = require_errors();
    exports.DefaultBasicRetryHandlerOptions = {
      maxAttempts: 1,
    };
    exports.DefaultFixedIntervalRetryHandlerOptions = {
      maxAttempts: 1,
      intervalSeconds: 0.3,
    };
    var RatelimitRetryHandler = class {
      #maxAttempts;
      constructor(options = exports.DefaultBasicRetryHandlerOptions) {
        this.#maxAttempts = options.maxAttempts;
      }
      async shouldRetry({ state, response }) {
        if (state.currentAttempt >= this.#maxAttempts || !response) {
          return false;
        }
        if (response.status !== 429) {
          return false;
        }
        const retryAfter =
          response.headers.get("retry-after") ||
          response.headers.get("Retry-After");
        if (!retryAfter || Number.isNaN(retryAfter)) {
          return false;
        }
        const sleepSeconds = Number.parseFloat(retryAfter);
        await sleep(sleepSeconds);
        return true;
      }
    };
    exports.RatelimitRetryHandler = RatelimitRetryHandler;
    var ConnectionErrorRetryHandler = class {
      #maxAttempts;
      #intervalSeconds;
      constructor(options = exports.DefaultFixedIntervalRetryHandlerOptions) {
        this.#maxAttempts = options.maxAttempts;
        this.#intervalSeconds = options.intervalSeconds;
      }
      async shouldRetry({ state, error: error45 }) {
        if (state.currentAttempt >= this.#maxAttempts || !error45) {
          return false;
        }
        if (error45 instanceof errors_1.SlackAPIConnectionError) {
          await sleep(this.#intervalSeconds);
          return true;
        }
        return false;
      }
    };
    exports.ConnectionErrorRetryHandler = ConnectionErrorRetryHandler;
    var ServerErrorRetryHandler = class {
      #maxAttempts;
      #intervalSeconds;
      constructor(options = exports.DefaultFixedIntervalRetryHandlerOptions) {
        this.#maxAttempts = options.maxAttempts;
        this.#intervalSeconds = options.intervalSeconds;
      }
      async shouldRetry({ state, response }) {
        if (state.currentAttempt >= this.#maxAttempts || !response) {
          return false;
        }
        if (response.status >= 500) {
          await sleep(this.#intervalSeconds);
          return true;
        }
        return false;
      }
    };
    exports.ServerErrorRetryHandler = ServerErrorRetryHandler;
    var sleep = (seconds) => {
      return new Promise((resolve2) => setTimeout(resolve2, seconds * 1e3));
    };
  },
});

// node_modules/slack-web-api-client/dist/client/retry-handler/index.js
var require_retry_handler2 = __commonJS({
  "node_modules/slack-web-api-client/dist/client/retry-handler/index.js"(
    exports,
  ) {
    "use strict";
    var __createBinding =
      (exports && exports.__createBinding) ||
      (Object.create
        ? function (o2, m2, k, k2) {
            if (k2 === void 0) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m2, k);
            if (
              !desc ||
              ("get" in desc
                ? !m2.__esModule
                : desc.writable || desc.configurable)
            ) {
              desc = {
                enumerable: true,
                get: function () {
                  return m2[k];
                },
              };
            }
            Object.defineProperty(o2, k2, desc);
          }
        : function (o2, m2, k, k2) {
            if (k2 === void 0) k2 = k;
            o2[k2] = m2[k];
          });
    var __exportStar =
      (exports && exports.__exportStar) ||
      function (m2, exports2) {
        for (var p2 in m2)
          if (
            p2 !== "default" &&
            !Object.prototype.hasOwnProperty.call(exports2, p2)
          )
            __createBinding(exports2, m2, p2);
      };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_retry_handler(), exports);
    __exportStar(require_built_in(), exports);
  },
});

// node_modules/slack-web-api-client/dist/client/api-client.js
var require_api_client = __commonJS({
  "node_modules/slack-web-api-client/dist/client/api-client.js"(exports) {
    "use strict";
    var _a19;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SlackAPIClient = void 0;
    var errors_1 = require_errors();
    var index_1 = require_logging();
    var index_2 = require_retry_handler2();
    var defaultOptions3 = {
      logLevel: "INFO",
      throwSlackAPIError: true,
      baseUrl: "https://slack.com/api/",
    };
    var SlackAPIClient3 = class {
      #token;
      #options;
      #logLevel;
      #throwSlackAPIError;
      #baseUrl;
      retryHandlers;
      constructor(token = void 0, options = defaultOptions3) {
        this.#token = token;
        this.#options = options;
        this.#logLevel = this.#options.logLevel ?? defaultOptions3.logLevel;
        this.#throwSlackAPIError = this.#options.throwSlackAPIError ?? true;
        this.#baseUrl = this.#options.baseUrl
          ? this.#options.baseUrl.endsWith("/")
            ? this.#options.baseUrl
            : this.#options.baseUrl + "/"
          : defaultOptions3.baseUrl;
        this.retryHandlers = this.#options.retryHandlers ?? [
          new index_2.RatelimitRetryHandler(),
        ];
      }
      // --------------------------------------
      // Internal methods
      // --------------------------------------
      async call(name18, params = {}, retryHandlerState = void 0) {
        const url2 = `${this.#baseUrl}${name18}`;
        const token = params ? (params.token ?? this.#token) : this.#token;
        const _params = {};
        Object.assign(_params, params);
        if (_params && _params.token) {
          delete _params.token;
        }
        for (const [key, value] of Object.entries(_params)) {
          if (typeof value === "object") {
            if (
              Array.isArray(value) &&
              value.length > 0 &&
              typeof value[0] !== "object"
            ) {
              _params[key] = value.map((v2) => v2.toString()).join(",");
            } else {
              _params[key] = JSON.stringify(value);
            }
          }
          if (value === void 0 || value === null) {
            delete _params[key];
          }
        }
        const headers = {
          "Content-Type": "application/x-www-form-urlencoded",
        };
        if (token) {
          headers["Authorization"] = `Bearer ${token}`;
        }
        const body = new URLSearchParams(_params);
        if ((0, index_1.isDebugLogEnabled)(this.#logLevel)) {
          console.log(`Slack API request (${name18}): ${body}`);
        }
        if (retryHandlerState) {
          retryHandlerState.currentAttempt += 1;
        }
        const state = retryHandlerState ?? {
          currentAttempt: 0,
          logLevel: this.#logLevel,
        };
        const request2 = new Request(url2, {
          method: "POST",
          headers,
          body,
        });
        let response;
        try {
          response = await fetch(request2);
          for (const rh of this.retryHandlers) {
            if (await rh.shouldRetry({ state, request: request2, response })) {
              if ((0, index_1.isDebugLogEnabled)(this.#logLevel)) {
                console.log(
                  `Retrying ${name18} API call (params: ${JSON.stringify(params)})`,
                );
              }
              return await this.call(name18, params, state);
            }
          }
        } catch (e2) {
          const error45 = new errors_1.SlackAPIConnectionError(
            name18,
            -1,
            "",
            void 0,
            e2,
          );
          for (const rh of this.retryHandlers) {
            if (
              await rh.shouldRetry({ state, request: request2, error: error45 })
            ) {
              if ((0, index_1.isDebugLogEnabled)(this.#logLevel)) {
                console.log(
                  `Retrying ${name18} API call (params: ${JSON.stringify(params)})`,
                );
              }
              return await this.call(name18, params, state);
            }
          }
          throw error45;
        }
        if (response.status != 200) {
          const body2 = await response.text();
          throw new errors_1.SlackAPIConnectionError(
            name18,
            response.status,
            body2,
            response.headers,
            void 0,
          );
        }
        const responseBody = await response.json();
        const result = {
          ...responseBody,
          headers: response.headers,
        };
        if ((0, index_1.isDebugLogEnabled)(this.#logLevel)) {
          console.log(
            `Slack API response (${name18}): ${JSON.stringify(result)}}`,
          );
        }
        if (this.#throwSlackAPIError && result.error) {
          throw new errors_1.SlackAPIError(name18, result.error, result);
        }
        return result;
      }
      async #sendMultipartData(
        name18,
        params = {},
        retryHandlerState = void 0,
      ) {
        const url2 = `${this.#baseUrl}${name18}`;
        const token = params ? (params.token ?? this.#token) : this.#token;
        const body = new FormData();
        for (const [key, value] of Object.entries(params)) {
          if (value === void 0 || value === null || key === "token") {
            continue;
          }
          if (typeof value === "object") {
            if (value instanceof Blob) {
              body.append(key, value);
            } else {
              body.append(key, new Blob([value]));
            }
          } else {
            body.append(key, value);
          }
        }
        const headers = {};
        if (token) {
          headers["Authorization"] = `Bearer ${token}`;
        }
        if ((0, index_1.isDebugLogEnabled)(this.#logLevel)) {
          const bodyParamNames = Array.from(body.keys()).join(", ");
          console.log(
            `Slack API request (${name18}): Sending ${bodyParamNames}`,
          );
        }
        if (retryHandlerState) {
          retryHandlerState.currentAttempt += 1;
        }
        const state = retryHandlerState ?? {
          currentAttempt: 0,
          logLevel: this.#logLevel,
        };
        const request2 = new Request(url2, {
          method: "POST",
          headers,
          body,
        });
        let response;
        try {
          response = await fetch(request2);
          for (const rh of this.retryHandlers) {
            if (await rh.shouldRetry({ state, request: request2, response })) {
              if ((0, index_1.isDebugLogEnabled)(this.#logLevel)) {
                console.log(`Retrying ${name18} API call`);
              }
              return await this.#sendMultipartData(name18, params, state);
            }
          }
        } catch (e2) {
          const error45 = new errors_1.SlackAPIConnectionError(
            name18,
            -1,
            "",
            void 0,
            e2,
          );
          for (const rh of this.retryHandlers) {
            if (
              await rh.shouldRetry({ state, request: request2, error: error45 })
            ) {
              if ((0, index_1.isDebugLogEnabled)(this.#logLevel)) {
                console.log(`Retrying ${name18} API call`);
              }
              return await this.#sendMultipartData(name18, params, state);
            }
          }
          throw error45;
        }
        if (response.status != 200) {
          const body2 = await response.text();
          throw new errors_1.SlackAPIConnectionError(
            name18,
            response.status,
            body2,
            response.headers,
            void 0,
          );
        }
        const responseBody = await response.json();
        const result = {
          ...responseBody,
          headers: response.headers,
        };
        if ((0, index_1.isDebugLogEnabled)(this.#logLevel)) {
          console.log(
            `Slack API response (${name18}): ${JSON.stringify(result)}}`,
          );
        }
        if (this.#throwSlackAPIError && result.error) {
          throw new errors_1.SlackAPIError(name18, result.error, result);
        }
        return result;
      }
      async #uploadFilesV2(params) {
        const files = "files" in params ? params.files : [{ ...params }];
        const completes = [];
        const uploadErrors = [];
        const client = new _a19(params.token ?? this.#token, {
          logLevel: this.#options.logLevel,
          throwSlackAPIError: true,
          // intentionally set to true for uploadAsync()
        });
        for (const f2 of files) {
          async function uploadAsync() {
            const body = f2.file
              ? new Uint8Array(
                  f2.file instanceof Blob
                    ? await f2.file.arrayBuffer()
                    : f2.file,
                )
              : new TextEncoder().encode(f2.content);
            const getUrl = await client.files.getUploadURLExternal({
              token: params.token,
              filename: f2.filename,
              length: body.length,
              snippet_type: f2.snippet_type,
            });
            const { upload_url, file_id } = getUrl;
            let response;
            try {
              response = await fetch(upload_url, { method: "POST", body });
            } catch (e2) {
              throw new errors_1.SlackAPIConnectionError(
                "files.slack.com",
                -1,
                "",
                void 0,
                e2,
              );
            }
            const uploadBody = await response.text();
            if ((0, index_1.isDebugLogEnabled)(client.#logLevel)) {
              console.log(
                `Slack file upload result: (file ID: ${file_id}, status: ${response.status}, body: ${uploadBody})`,
              );
            }
            if (response.status !== 200) {
              uploadErrors.push(uploadBody);
            }
            if (uploadErrors.length > 0) {
              const errorResponse = {
                ok: false,
                error: "upload_failure",
                uploadErrors,
                headers: response.headers,
              };
              throw new errors_1.SlackAPIError(
                "files.slack.com",
                "upload_error",
                errorResponse,
              );
            }
            return { id: file_id, title: f2.title ?? f2.filename };
          }
          completes.push(uploadAsync());
        }
        try {
          const completion = await this.files.completeUploadExternal({
            token: params.token,
            files: await Promise.all(completes),
            channel_id: params.channel_id,
            initial_comment: params.initial_comment,
            thread_ts: params.thread_ts,
          });
          return {
            ok: true,
            files: completion.files,
            headers: completion.headers,
          };
        } catch (e2) {
          if (
            e2 instanceof errors_1.SlackAPIError &&
            !this.#throwSlackAPIError
          ) {
            return e2.result;
          }
          throw e2;
        }
      }
      #bindApiCall(self, method) {
        return self.call.bind(self, method);
      }
      #bindNoArgAllowedApiCall(self, method) {
        return self.call.bind(self, method);
      }
      #bindMultipartApiCall(self, method) {
        return self.#sendMultipartData.bind(self, method);
      }
      #bindFilesUploadV2(self) {
        return self.#uploadFilesV2.bind(self);
      }
      // --------------------------------------
      // API definition
      // --------------------------------------
      admin = {
        apps: {
          approve: this.#bindNoArgAllowedApiCall(this, "admin.apps.approve"),
          approved: {
            list: this.#bindNoArgAllowedApiCall(
              this,
              "admin.apps.approved.list",
            ),
          },
          clearResolution: this.#bindApiCall(
            this,
            "admin.apps.clearResolution",
          ),
          requests: {
            cancel: this.#bindApiCall(this, "admin.apps.requests.cancel"),
            list: this.#bindNoArgAllowedApiCall(
              this,
              "admin.apps.requests.list",
            ),
          },
          restrict: this.#bindNoArgAllowedApiCall(this, "admin.apps.restrict"),
          restricted: {
            list: this.#bindNoArgAllowedApiCall(
              this,
              "admin.apps.restricted.list",
            ),
          },
          uninstall: this.#bindApiCall(this, "admin.apps.uninstall"),
          activities: {
            list: this.#bindNoArgAllowedApiCall(
              this,
              "admin.apps.activities.list",
            ),
          },
        },
        auth: {
          policy: {
            assignEntities: this.#bindApiCall(
              this,
              "admin.auth.policy.assignEntities",
            ),
            getEntities: this.#bindApiCall(
              this,
              "admin.auth.policy.getEntities",
            ),
            removeEntities: this.#bindApiCall(
              this,
              "admin.auth.policy.removeEntities",
            ),
          },
        },
        barriers: {
          create: this.#bindApiCall(this, "admin.barriers.create"),
          delete: this.#bindApiCall(this, "admin.barriers.delete"),
          list: this.#bindNoArgAllowedApiCall(this, "admin.barriers.list"),
          update: this.#bindApiCall(this, "admin.barriers.update"),
        },
        conversations: {
          archive: this.#bindApiCall(this, "admin.conversations.archive"),
          bulkArchive: this.#bindApiCall(
            this,
            "admin.conversations.bulkArchive",
          ),
          bulkDelete: this.#bindApiCall(this, "admin.conversations.bulkDelete"),
          bulkMove: this.#bindApiCall(this, "admin.conversations.bulkMove"),
          convertToPrivate: this.#bindApiCall(
            this,
            "admin.conversations.convertToPrivate",
          ),
          convertToPublic: this.#bindApiCall(
            this,
            "admin.conversations.convertToPublic",
          ),
          create: this.#bindApiCall(this, "admin.conversations.create"),
          delete: this.#bindApiCall(this, "admin.conversations.delete"),
          disconnectShared: this.#bindApiCall(
            this,
            "admin.conversations.disconnectShared",
          ),
          ekm: {
            listOriginalConnectedChannelInfo: this.#bindNoArgAllowedApiCall(
              this,
              "admin.conversations.ekm.listOriginalConnectedChannelInfo",
            ),
          },
          getConversationPrefs: this.#bindApiCall(
            this,
            "admin.conversations.getConversationPrefs",
          ),
          getTeams: this.#bindApiCall(this, "admin.conversations.getTeams"),
          invite: this.#bindApiCall(this, "admin.conversations.invite"),
          rename: this.#bindApiCall(this, "admin.conversations.rename"),
          restrictAccess: {
            addGroup: this.#bindApiCall(
              this,
              "admin.conversations.restrictAccess.addGroup",
            ),
            listGroups: this.#bindApiCall(
              this,
              "admin.conversations.restrictAccess.listGroups",
            ),
            removeGroup: this.#bindApiCall(
              this,
              "admin.conversations.restrictAccess.removeGroup",
            ),
          },
          requestSharedInvite: {
            approve: this.#bindApiCall(
              this,
              "conversations.requestSharedInvite.approve",
            ),
            deny: this.#bindApiCall(
              this,
              "conversations.requestSharedInvite.deny",
            ),
            list: this.#bindApiCall(
              this,
              "conversations.requestSharedInvite.list",
            ),
          },
          getCustomRetention: this.#bindApiCall(
            this,
            "admin.conversations.getCustomRetention",
          ),
          setCustomRetention: this.#bindApiCall(
            this,
            "admin.conversations.setCustomRetention",
          ),
          removeCustomRetention: this.#bindApiCall(
            this,
            "admin.conversations.removeCustomRetention",
          ),
          lookup: this.#bindApiCall(this, "admin.conversations.lookup"),
          search: this.#bindNoArgAllowedApiCall(
            this,
            "admin.conversations.search",
          ),
          setConversationPrefs: this.#bindApiCall(
            this,
            "admin.conversations.setConversationPrefs",
          ),
          setTeams: this.#bindApiCall(this, "admin.conversations.setTeams"),
          unarchive: this.#bindApiCall(this, "admin.conversations.unarchive"),
        },
        emoji: {
          add: this.#bindApiCall(this, "admin.emoji.add"),
          addAlias: this.#bindApiCall(this, "admin.emoji.addAlias"),
          list: this.#bindApiCall(this, "admin.emoji.list"),
          remove: this.#bindApiCall(this, "admin.emoji.remove"),
          rename: this.#bindApiCall(this, "admin.emoji.rename"),
        },
        functions: {
          list: this.#bindApiCall(this, "admin.functions.list"),
          permissions: {
            lookup: this.#bindApiCall(
              this,
              "admin.functions.permissions.lookup",
            ),
            set: this.#bindApiCall(this, "admin.functions.permissions.set"),
          },
        },
        inviteRequests: {
          approve: this.#bindApiCall(this, "admin.inviteRequests.approve"),
          approved: {
            list: this.#bindApiCall(this, "admin.inviteRequests.approved.list"),
          },
          denied: {
            list: this.#bindApiCall(this, "admin.inviteRequests.denied.list"),
          },
          deny: this.#bindApiCall(this, "admin.inviteRequests.deny"),
          list: this.#bindApiCall(this, "admin.inviteRequests.list"),
        },
        roles: {
          addAssignments: this.#bindApiCall(this, "admin.roles.addAssignments"),
          listAssignments: this.#bindNoArgAllowedApiCall(
            this,
            "admin.roles.listAssignments",
          ),
          removeAssignments: this.#bindApiCall(
            this,
            "admin.roles.removeAssignments",
          ),
        },
        teams: {
          admins: {
            list: this.#bindApiCall(this, "admin.teams.admins.list"),
          },
          create: this.#bindApiCall(this, "admin.teams.create"),
          list: this.#bindNoArgAllowedApiCall(this, "admin.teams.list"),
          owners: {
            list: this.#bindApiCall(this, "admin.teams.owners.list"),
          },
          settings: {
            info: this.#bindApiCall(this, "admin.teams.settings.info"),
            setDefaultChannels: this.#bindApiCall(
              this,
              "admin.teams.settings.setDefaultChannels",
            ),
            setDescription: this.#bindApiCall(
              this,
              "admin.teams.settings.setDescription",
            ),
            setDiscoverability: this.#bindApiCall(
              this,
              "admin.teams.settings.setDiscoverability",
            ),
            setIcon: this.#bindApiCall(this, "admin.teams.settings.setIcon"),
            setName: this.#bindApiCall(this, "admin.teams.settings.setName"),
          },
        },
        usergroups: {
          addChannels: this.#bindApiCall(this, "admin.usergroups.addChannels"),
          addTeams: this.#bindApiCall(this, "admin.usergroups.addTeams"),
          listChannels: this.#bindApiCall(
            this,
            "admin.usergroups.listChannels",
          ),
          removeChannels: this.#bindApiCall(
            this,
            "admin.usergroups.removeChannels",
          ),
        },
        users: {
          assign: this.#bindApiCall(this, "admin.users.assign"),
          invite: this.#bindApiCall(this, "admin.users.invite"),
          list: this.#bindApiCall(this, "admin.users.list"),
          remove: this.#bindApiCall(this, "admin.users.remove"),
          session: {
            list: this.#bindNoArgAllowedApiCall(
              this,
              "admin.users.session.list",
            ),
            reset: this.#bindApiCall(this, "admin.users.session.reset"),
            resetBulk: this.#bindApiCall(this, "admin.users.session.resetBulk"),
            invalidate: this.#bindApiCall(
              this,
              "admin.users.session.invalidate",
            ),
            getSettings: this.#bindApiCall(
              this,
              "admin.users.session.getSettings",
            ),
            setSettings: this.#bindApiCall(
              this,
              "admin.users.session.setSettings",
            ),
            clearSettings: this.#bindApiCall(
              this,
              "admin.users.session.clearSettings",
            ),
          },
          unsupportedVersions: {
            export: this.#bindNoArgAllowedApiCall(
              this,
              "admin.users.unsupportedVersions.export",
            ),
          },
          setAdmin: this.#bindApiCall(this, "admin.users.setAdmin"),
          setExpiration: this.#bindApiCall(this, "admin.users.setExpiration"),
          setOwner: this.#bindApiCall(this, "admin.users.setOwner"),
          setRegular: this.#bindApiCall(this, "admin.users.setRegular"),
        },
        workflows: {
          search: this.#bindNoArgAllowedApiCall(this, "admin.workflows.search"),
          unpublish: this.#bindApiCall(this, "admin.workflows.unpublish"),
          collaborators: {
            add: this.#bindApiCall(this, "admin.workflows.collaborators.add"),
            remove: this.#bindApiCall(
              this,
              "admin.workflows.collaborators.remove",
            ),
          },
          permissions: {
            lookup: this.#bindApiCall(
              this,
              "admin.workflows.permissions.lookup",
            ),
          },
        },
      };
      api = {
        test: this.#bindNoArgAllowedApiCall(this, "api.test"),
      };
      apps = {
        connections: {
          open: this.#bindNoArgAllowedApiCall(this, "apps.connections.open"),
        },
        datastore: {
          put: this.#bindApiCall(this, "apps.datastore.put"),
          update: this.#bindApiCall(this, "apps.datastore.update"),
          get: this.#bindApiCall(this, "apps.datastore.get"),
          query: this.#bindApiCall(this, "apps.datastore.query"),
          delete: this.#bindApiCall(this, "apps.datastore.delete"),
        },
        event: {
          authorizations: {
            list: this.#bindApiCall(this, "apps.event.authorizations.list"),
          },
        },
        manifest: {
          create: this.#bindApiCall(this, "apps.manifest.create"),
          delete: this.#bindApiCall(this, "apps.manifest.delete"),
          update: this.#bindApiCall(this, "apps.manifest.update"),
          export: this.#bindApiCall(this, "apps.manifest.export"),
          validate: this.#bindApiCall(this, "apps.manifest.validate"),
        },
        uninstall: this.#bindApiCall(this, "apps.uninstall"),
      };
      assistant = {
        threads: {
          setStatus: this.#bindApiCall(this, "assistant.threads.setStatus"),
          setSuggestedPrompts: this.#bindApiCall(
            this,
            "assistant.threads.setSuggestedPrompts",
          ),
          setTitle: this.#bindApiCall(this, "assistant.threads.setTitle"),
        },
      };
      auth = {
        revoke: this.#bindNoArgAllowedApiCall(this, "auth.revoke"),
        teams: {
          list: this.#bindNoArgAllowedApiCall(this, "auth.teams.list"),
        },
        test: this.#bindNoArgAllowedApiCall(this, "auth.test"),
      };
      bots = {
        info: this.#bindApiCall(this, "bots.info"),
      };
      bookmarks = {
        add: this.#bindApiCall(this, "bookmarks.add"),
        edit: this.#bindApiCall(this, "bookmarks.edit"),
        list: this.#bindApiCall(this, "bookmarks.list"),
        remove: this.#bindApiCall(this, "bookmarks.remove"),
      };
      canvases = {
        access: {
          delete: this.#bindApiCall(this, "canvases.access.delete"),
          set: this.#bindApiCall(this, "canvases.access.set"),
        },
        create: this.#bindApiCall(this, "canvases.create"),
        edit: this.#bindApiCall(this, "canvases.edit"),
        delete: this.#bindApiCall(this, "canvases.delete"),
        sections: {
          lookup: this.#bindApiCall(this, "canvases.sections.lookup"),
        },
      };
      chat = {
        delete: this.#bindApiCall(this, "chat.delete"),
        deleteScheduledMessage: this.#bindApiCall(
          this,
          "chat.deleteScheduledMessage",
        ),
        getPermalink: this.#bindApiCall(this, "chat.getPermalink"),
        meMessage: this.#bindApiCall(this, "chat.meMessage"),
        postEphemeral: this.#bindApiCall(this, "chat.postEphemeral"),
        postMessage: this.#bindApiCall(this, "chat.postMessage"),
        scheduleMessage: this.#bindApiCall(this, "chat.scheduleMessage"),
        scheduledMessages: {
          list: this.#bindApiCall(this, "chat.scheduledMessages.list"),
        },
        unfurl: this.#bindApiCall(this, "chat.unfurl"),
        update: this.#bindApiCall(this, "chat.update"),
      };
      conversations = {
        acceptSharedInvite: this.#bindApiCall(
          this,
          "conversations.acceptSharedInvite",
        ),
        approveSharedInvite: this.#bindApiCall(
          this,
          "conversations.approveSharedInvite",
        ),
        archive: this.#bindApiCall(this, "conversations.archive"),
        close: this.#bindApiCall(this, "conversations.close"),
        create: this.#bindApiCall(this, "conversations.create"),
        declineSharedInvite: this.#bindApiCall(
          this,
          "conversations.declineSharedInvite",
        ),
        history: this.#bindApiCall(this, "conversations.history"),
        info: this.#bindApiCall(this, "conversations.info"),
        invite: this.#bindApiCall(this, "conversations.invite"),
        inviteShared: this.#bindApiCall(this, "conversations.inviteShared"),
        join: this.#bindApiCall(this, "conversations.join"),
        kick: this.#bindApiCall(this, "conversations.kick"),
        leave: this.#bindApiCall(this, "conversations.leave"),
        list: this.#bindNoArgAllowedApiCall(this, "conversations.list"),
        listConnectInvites: this.#bindNoArgAllowedApiCall(
          this,
          "conversations.listConnectInvites",
        ),
        mark: this.#bindApiCall(this, "conversations.mark"),
        members: this.#bindApiCall(this, "conversations.members"),
        open: this.#bindNoArgAllowedApiCall(this, "conversations.open"),
        rename: this.#bindApiCall(this, "conversations.rename"),
        replies: this.#bindApiCall(this, "conversations.replies"),
        setPurpose: this.#bindApiCall(this, "conversations.setPurpose"),
        setTopic: this.#bindApiCall(this, "conversations.setTopic"),
        unarchive: this.#bindApiCall(this, "conversations.unarchive"),
        canvases: {
          create: this.#bindApiCall(this, "conversations.canvases.create"),
        },
        externalInvitePermissions: {
          set: this.#bindApiCall(
            this,
            "conversations.externalInvitePermissions.set",
          ),
        },
      };
      dnd = {
        endDnd: this.#bindNoArgAllowedApiCall(this, "dnd.endDnd"),
        endSnooze: this.#bindNoArgAllowedApiCall(this, "dnd.endSnooze"),
        info: this.#bindApiCall(this, "dnd.info"),
        setSnooze: this.#bindApiCall(this, "dnd.setSnooze"),
        teamInfo: this.#bindNoArgAllowedApiCall(this, "dnd.teamInfo"),
      };
      emoji = {
        list: this.#bindNoArgAllowedApiCall(this, "emoji.list"),
      };
      files = {
        delete: this.#bindApiCall(this, "files.delete"),
        info: this.#bindApiCall(this, "files.info"),
        list: this.#bindNoArgAllowedApiCall(this, "files.list"),
        revokePublicURL: this.#bindApiCall(this, "files.revokePublicURL"),
        sharedPublicURL: this.#bindApiCall(this, "files.sharedPublicURL"),
        /**
         * @deprecated use files.uploadV2 instead
         */
        upload: this.#bindMultipartApiCall(this, "files.upload"),
        uploadV2: this.#bindFilesUploadV2(this),
        getUploadURLExternal: this.#bindApiCall(
          this,
          "files.getUploadURLExternal",
        ),
        completeUploadExternal: this.#bindApiCall(
          this,
          "files.completeUploadExternal",
        ),
        remote: {
          info: this.#bindNoArgAllowedApiCall(this, "files.remote.info"),
          list: this.#bindNoArgAllowedApiCall(this, "files.remote.list"),
          add: this.#bindApiCall(this, "files.remote.add"),
          update: this.#bindNoArgAllowedApiCall(this, "files.remote.update"),
          remove: this.#bindNoArgAllowedApiCall(this, "files.remote.remove"),
          share: this.#bindApiCall(this, "files.remote.share"),
        },
      };
      functions = {
        completeSuccess: this.#bindApiCall(this, "functions.completeSuccess"),
        completeError: this.#bindApiCall(this, "functions.completeError"),
      };
      migration = {
        exchange: this.#bindApiCall(this, "migration.exchange"),
      };
      oauth = {
        v2: {
          access: this.#bindApiCall(this, "oauth.v2.access"),
          exchange: this.#bindApiCall(this, "oauth.v2.exchange"),
        },
      };
      openid = {
        connect: {
          token: this.#bindApiCall(this, "openid.connect.token"),
          userInfo: this.#bindNoArgAllowedApiCall(
            this,
            "openid.connect.userInfo",
          ),
        },
      };
      pins = {
        add: this.#bindApiCall(this, "pins.add"),
        list: this.#bindApiCall(this, "pins.list"),
        remove: this.#bindApiCall(this, "pins.remove"),
      };
      reactions = {
        add: this.#bindNoArgAllowedApiCall(this, "reactions.add"),
        get: this.#bindNoArgAllowedApiCall(this, "reactions.get"),
        list: this.#bindNoArgAllowedApiCall(this, "reactions.list"),
        remove: this.#bindApiCall(this, "reactions.remove"),
      };
      reminders = {
        add: this.#bindApiCall(this, "reminders.add"),
        complete: this.#bindApiCall(this, "reminders.complete"),
        delete: this.#bindApiCall(this, "reminders.delete"),
        info: this.#bindApiCall(this, "reminders.info"),
        list: this.#bindApiCall(this, "reminders.list"),
      };
      search = {
        all: this.#bindApiCall(this, "search.all"),
        files: this.#bindApiCall(this, "search.files"),
        messages: this.#bindApiCall(this, "search.messages"),
      };
      stars = {
        add: this.#bindNoArgAllowedApiCall(this, "stars.add"),
        list: this.#bindNoArgAllowedApiCall(this, "stars.list"),
        remove: this.#bindNoArgAllowedApiCall(this, "stars.remove"),
      };
      team = {
        accessLogs: this.#bindNoArgAllowedApiCall(this, "team.accessLogs"),
        billableInfo: this.#bindNoArgAllowedApiCall(this, "team.billableInfo"),
        billing: {
          info: this.#bindNoArgAllowedApiCall(this, "team.billing.info"),
        },
        info: this.#bindNoArgAllowedApiCall(this, "team.info"),
        integrationLogs: this.#bindNoArgAllowedApiCall(
          this,
          "team.integrationLogs",
        ),
        preferences: {
          list: this.#bindNoArgAllowedApiCall(this, "team.preferences.list"),
        },
        profile: {
          get: this.#bindNoArgAllowedApiCall(this, "team.profile.get"),
        },
        externalTeams: {
          list: this.#bindApiCall(this, "team.externalTeams.list"),
          disconnect: this.#bindApiCall(this, "team.externalTeams.disconnect"),
        },
      };
      tooling = {
        tokens: {
          rotate: this.#bindApiCall(this, "tooling.tokens.rotate"),
        },
      };
      usergroups = {
        create: this.#bindApiCall(this, "usergroups.create"),
        disable: this.#bindApiCall(this, "usergroups.disable"),
        enable: this.#bindApiCall(this, "usergroups.enable"),
        list: this.#bindNoArgAllowedApiCall(this, "usergroups.list"),
        update: this.#bindApiCall(this, "usergroups.update"),
        users: {
          list: this.#bindApiCall(this, "usergroups.users.list"),
          update: this.#bindApiCall(this, "usergroups.users.update"),
        },
      };
      users = {
        conversations: this.#bindNoArgAllowedApiCall(
          this,
          "users.conversations",
        ),
        deletePhoto: this.#bindNoArgAllowedApiCall(this, "users.deletePhoto"),
        getPresence: this.#bindNoArgAllowedApiCall(this, "users.getPresence"),
        identity: this.#bindNoArgAllowedApiCall(this, "users.identity"),
        info: this.#bindApiCall(this, "users.info"),
        list: this.#bindNoArgAllowedApiCall(this, "users.list"),
        lookupByEmail: this.#bindApiCall(this, "users.lookupByEmail"),
        setPhoto: this.#bindApiCall(this, "users.setPhoto"),
        setPresence: this.#bindApiCall(this, "users.setPresence"),
        profile: {
          get: this.#bindNoArgAllowedApiCall(this, "users.profile.get"),
          set: this.#bindNoArgAllowedApiCall(this, "users.profile.set"),
        },
        discoverableContacts: {
          lookup: this.#bindApiCall(this, "users.discoverableContacts.lookup"),
        },
      };
      views = {
        open: this.#bindApiCall(this, "views.open"),
        publish: this.#bindApiCall(this, "views.publish"),
        push: this.#bindApiCall(this, "views.push"),
        update: this.#bindApiCall(this, "views.update"),
      };
      workflows = {
        triggers: {
          create: this.#bindApiCall(this, "workflows.triggers.create"),
          update: this.#bindApiCall(this, "workflows.triggers.update"),
          delete: this.#bindApiCall(this, "workflows.triggers.delete"),
          list: this.#bindNoArgAllowedApiCall(this, "workflows.triggers.list"),
        },
      };
    };
    exports.SlackAPIClient = SlackAPIClient3;
    _a19 = SlackAPIClient3;
  },
});

// node_modules/slack-web-api-client/dist/client/request.js
var require_request = __commonJS({
  "node_modules/slack-web-api-client/dist/client/request.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-web-api-client/dist/client/response.js
var require_response = __commonJS({
  "node_modules/slack-web-api-client/dist/client/response.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-web-api-client/dist/client/automation-response/index.js
var require_automation_response = __commonJS({
  "node_modules/slack-web-api-client/dist/client/automation-response/index.js"(
    exports,
  ) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-web-api-client/dist/client/generated-response/index.js
var require_generated_response = __commonJS({
  "node_modules/slack-web-api-client/dist/client/generated-response/index.js"(
    exports,
  ) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-web-api-client/dist/client/webhook-client.js
var require_webhook_client = __commonJS({
  "node_modules/slack-web-api-client/dist/client/webhook-client.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ResponseUrlSender = exports.WebhookSender = void 0;
    var errors_1 = require_errors();
    var WebhookSender = class {
      #url;
      constructor(url2) {
        this.#url = url2;
      }
      async call(params) {
        try {
          const response = await fetch(this.#url, {
            method: "POST",
            headers: { "Content-Type": "application/json; charset=utf-8" },
            body: JSON.stringify(params),
          });
          const responseBody = await response.text();
          const body = responseBody.toLowerCase();
          if (
            response.status != 200 ||
            (body !== "ok" && body.toLowerCase() !== '{"ok":true}')
          ) {
            throw new errors_1.WebhookError(response.status, responseBody);
          }
          return response;
        } catch (e2) {
          throw new errors_1.WebhookError(-1, "", e2);
        }
      }
    };
    exports.WebhookSender = WebhookSender;
    exports.ResponseUrlSender = WebhookSender;
  },
});

// node_modules/slack-web-api-client/dist/manifest/manifest-params.js
var require_manifest_params = __commonJS({
  "node_modules/slack-web-api-client/dist/manifest/manifest-params.js"(
    exports,
  ) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-web-api-client/dist/manifest/events.js
var require_events = __commonJS({
  "node_modules/slack-web-api-client/dist/manifest/events.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-web-api-client/dist/manifest/scopes.js
var require_scopes = __commonJS({
  "node_modules/slack-web-api-client/dist/manifest/scopes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-web-api-client/dist/token-rotation/token-refresh-targets.js
var require_token_refresh_targets = __commonJS({
  "node_modules/slack-web-api-client/dist/token-rotation/token-refresh-targets.js"(
    exports,
  ) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-web-api-client/dist/token-rotation/token-refresh-results.js
var require_token_refresh_results = __commonJS({
  "node_modules/slack-web-api-client/dist/token-rotation/token-refresh-results.js"(
    exports,
  ) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-web-api-client/dist/token-rotation/token-rotator-options.js
var require_token_rotator_options = __commonJS({
  "node_modules/slack-web-api-client/dist/token-rotation/token-rotator-options.js"(
    exports,
  ) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-web-api-client/dist/token-rotation/token-rotator.js
var require_token_rotator = __commonJS({
  "node_modules/slack-web-api-client/dist/token-rotation/token-rotator.js"(
    exports,
  ) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TokenRotator = void 0;
    var errors_1 = require_errors();
    var api_client_1 = require_api_client();
    var TokenRotator = class {
      #clientId;
      #clientSecret;
      #client;
      constructor(options) {
        this.#clientId = options.clientId;
        this.#clientSecret = options.clientSecret;
        this.#client = new api_client_1.SlackAPIClient(void 0, options);
      }
      async performRotation(targets) {
        const refreshResults = {};
        const randomSeconds = Math.round(
          crypto.getRandomValues(new Uint16Array(1))[0] / 100,
        );
        const expireAt =
          /* @__PURE__ */ new Date().getTime() / 1e3 + randomSeconds;
        if (targets.bot && targets.bot.token_expires_at < expireAt) {
          try {
            const response = await this.#client.oauth.v2.access({
              client_id: this.#clientId,
              client_secret: this.#clientSecret,
              grant_type: "refresh_token",
              refresh_token: targets.bot.refresh_token,
            });
            if (
              response &&
              response.access_token &&
              response.refresh_token &&
              response.expires_in
            ) {
              refreshResults.bot = {
                access_token: response.access_token,
                refresh_token: response.refresh_token,
                token_expires_at:
                  /* @__PURE__ */ new Date().getTime() / 1e3 +
                  response.expires_in,
              };
            }
          } catch (e2) {
            throw new errors_1.TokenRotationError(
              `Failed to refresh a bot token: ${e2}`,
              e2,
            );
          }
        }
        if (targets.user && targets.user.token_expires_at < expireAt) {
          try {
            const response = await this.#client.oauth.v2.access({
              client_id: this.#clientId,
              client_secret: this.#clientSecret,
              grant_type: "refresh_token",
              refresh_token: targets.user.refresh_token,
            });
            if (
              response &&
              response.access_token &&
              response.refresh_token &&
              response.expires_in
            ) {
              refreshResults.user = {
                access_token: response.access_token,
                refresh_token: response.refresh_token,
                token_expires_at:
                  /* @__PURE__ */ new Date().getTime() / 1e3 +
                  response.expires_in,
              };
            }
          } catch (e2) {
            throw new errors_1.TokenRotationError(
              `Failed to refresh a user token: ${e2}`,
              e2,
            );
          }
        }
        return refreshResults;
      }
    };
    exports.TokenRotator = TokenRotator;
  },
});

// node_modules/slack-web-api-client/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/slack-web-api-client/dist/index.js"(exports) {
    "use strict";
    var __createBinding =
      (exports && exports.__createBinding) ||
      (Object.create
        ? function (o2, m2, k, k2) {
            if (k2 === void 0) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m2, k);
            if (
              !desc ||
              ("get" in desc
                ? !m2.__esModule
                : desc.writable || desc.configurable)
            ) {
              desc = {
                enumerable: true,
                get: function () {
                  return m2[k];
                },
              };
            }
            Object.defineProperty(o2, k2, desc);
          }
        : function (o2, m2, k, k2) {
            if (k2 === void 0) k2 = k;
            o2[k2] = m2[k];
          });
    var __exportStar =
      (exports && exports.__exportStar) ||
      function (m2, exports2) {
        for (var p2 in m2)
          if (
            p2 !== "default" &&
            !Object.prototype.hasOwnProperty.call(exports2, p2)
          )
            __createBinding(exports2, m2, p2);
      };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_block_elements(), exports);
    __exportStar(require_blocks(), exports);
    __exportStar(require_confirm(), exports);
    __exportStar(require_link_unfurls(), exports);
    __exportStar(require_message_attachment(), exports);
    __exportStar(require_message_metadata(), exports);
    __exportStar(require_options(), exports);
    __exportStar(require_text_fields(), exports);
    __exportStar(require_rich_text_block(), exports);
    __exportStar(require_views(), exports);
    __exportStar(require_api_client_options(), exports);
    __exportStar(require_api_client(), exports);
    __exportStar(require_request(), exports);
    __exportStar(require_response(), exports);
    __exportStar(require_retry_handler2(), exports);
    __exportStar(require_automation_response(), exports);
    __exportStar(require_generated_response(), exports);
    __exportStar(require_webhook_client(), exports);
    __exportStar(require_errors(), exports);
    __exportStar(require_logging(), exports);
    __exportStar(require_manifest_params(), exports);
    __exportStar(require_events(), exports);
    __exportStar(require_scopes(), exports);
    __exportStar(require_token_refresh_targets(), exports);
    __exportStar(require_token_refresh_results(), exports);
    __exportStar(require_token_rotator_options(), exports);
    __exportStar(require_token_rotator(), exports);
  },
});

// node_modules/slack-edge/dist/request/payload-types.js
var require_payload_types = __commonJS({
  "node_modules/slack-edge/dist/request/payload-types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PayloadType = void 0;
    var PayloadType;
    (function (PayloadType2) {
      PayloadType2["BlockAction"] = "block_actions";
      PayloadType2["BlockSuggestion"] = "block_suggestion";
      PayloadType2["MessageShortcut"] = "message_action";
      PayloadType2["GlobalShortcut"] = "shortcut";
      PayloadType2["EventsAPI"] = "event_callback";
      PayloadType2["ViewSubmission"] = "view_submission";
      PayloadType2["ViewClosed"] = "view_closed";
      PayloadType2["AppRateLimited"] = "app_rate_limited";
    })(PayloadType || (exports.PayloadType = PayloadType = {}));
  },
});

// node_modules/slack-edge/dist/context/context.js
var require_context = __commonJS({
  "node_modules/slack-edge/dist/context/context.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.builtBaseContext = builtBaseContext;
    exports.extractIsEnterpriseInstall = extractIsEnterpriseInstall;
    exports.extractEnterpriseId = extractEnterpriseId;
    exports.extractTeamId = extractTeamId;
    exports.extractUserId = extractUserId;
    exports.extractActorEnterpriseId = extractActorEnterpriseId;
    exports.extractActorTeamId = extractActorTeamId;
    exports.extractActorUserId = extractActorUserId;
    exports.extractResponseUrl = extractResponseUrl;
    exports.extractChannelId = extractChannelId;
    exports.isAssitantThreadEvent = isAssitantThreadEvent;
    exports.extractThreadTs = extractThreadTs;
    exports.extractTriggerId = extractTriggerId;
    exports.extractFunctionExecutionId = extractFunctionExecutionId;
    exports.extractFunctionBotAccessToken = extractFunctionBotAccessToken;
    var payload_types_1 = require_payload_types();
    function builtBaseContext(body) {
      return {
        isEnterpriseInstall: extractIsEnterpriseInstall(body),
        enterpriseId: extractEnterpriseId(body),
        teamId: extractTeamId(body),
        userId: extractUserId(body),
        actorEnterpriseId: extractActorEnterpriseId(body),
        actorTeamId: extractActorTeamId(body),
        actorUserId: extractActorUserId(body),
        botId: void 0,
        // will be set later
        botUserId: void 0,
        // will be set later
        responseUrl: extractResponseUrl(body),
        channelId: extractChannelId(body),
        threadTs: extractThreadTs(body),
        isAssistantThreadEvent: isAssitantThreadEvent(body),
        triggerId: extractTriggerId(body),
        functionExecutionId: extractFunctionExecutionId(body),
        functionBotAccessToken: extractFunctionBotAccessToken(body),
        custom: {},
      };
    }
    function extractIsEnterpriseInstall(body) {
      if (body.authorizations && body.authorizations.length > 0) {
        return body.authorizations[0].is_enterprise_install;
      } else if (body.is_enterprise_install) {
        if (typeof body.is_enterprise_install === "string") {
          return body.is_enterprise_install === "true";
        }
        return body.is_enterprise_install == true;
      }
      return void 0;
    }
    function extractEnterpriseId(body) {
      if (body.enterprise) {
        if (typeof body.enterprise === "string") {
          return body.enterprise;
        } else if (typeof body.enterprise === "object" && body.enterprise.id) {
          return body.enterprise.id;
        }
      } else if (body.authorizations && body.authorizations.length > 0) {
        return extractEnterpriseId(body.authorizations[0]);
      } else if (body.enterprise_id) {
        return body.enterprise_id;
      } else if (
        body.team &&
        typeof body.team === "object" &&
        body.team.enterprise_id
      ) {
        return body.team.enterprise_id;
      } else if (body.event) {
        return extractEnterpriseId(body.event);
      }
      return void 0;
    }
    function extractTeamId(body) {
      if (body.view && body.view.app_installed_team_id) {
        return body.view.app_installed_team_id;
      } else if (body.team) {
        if (typeof body.team === "string") {
          return body.team;
        } else if (body.team.id) {
          return body.team.id;
        }
      } else if (body.authorizations && body.authorizations.length > 0) {
        return extractTeamId(body.authorizations[0]);
      } else if (body.team_id) {
        return body.team_id;
      } else if (body.user && typeof body.user === "object") {
        return body.user.team_id;
      } else if (body.view && typeof body.view === "object") {
        return body.view.team_id;
      }
      return void 0;
    }
    function extractUserId(body) {
      if (body.user) {
        if (typeof body.user === "string") {
          return body.user;
        }
        if (typeof body.user === "object" && body.user.id) {
          return body.user.id;
        }
      } else if (body.user_id) {
        return body.user_id;
      } else if (body.event) {
        return extractUserId(body.event);
      } else if (body.message) {
        return extractUserId(body.message);
      } else if (body.previous_message) {
        return extractUserId(body.previous_message);
      }
      return void 0;
    }
    function extractActorEnterpriseId(body) {
      if (body.is_ext_shared_channel) {
        if (body.type === "event_callback") {
          const eventTeamId = body.event?.user_team || body.event?.team;
          if (eventTeamId && eventTeamId.startsWith("E")) {
            return eventTeamId;
          } else if (eventTeamId === body.team_id) {
            return body.enterprise_id;
          }
        }
      }
      return extractEnterpriseId(body);
    }
    function extractActorTeamId(body) {
      if (body.is_ext_shared_channel) {
        if (body.type === "event_callback") {
          const eventType = body.event.type;
          if (eventType === "app_mention") {
            const userTeam = body.event.user_team;
            if (!userTeam) {
              return body.event.team;
            } else if (userTeam.startsWith("T")) {
              return userTeam;
            }
            return void 0;
          }
          const eventUserTeam = body.event.user_team;
          if (eventUserTeam) {
            if (eventUserTeam.startsWith("T")) {
              return eventUserTeam;
            } else if (eventUserTeam.startsWith("E")) {
              if (eventUserTeam === body.enterprise_id) {
                return body.team_id;
              } else if (eventUserTeam === body.context_enterprise_id) {
                return body.context_team_id;
              }
            }
          }
          const eventTeam = body.event.team;
          if (eventTeam) {
            if (eventTeam.startsWith("T")) {
              return eventTeam;
            } else if (eventTeam.startsWith("E")) {
              if (eventTeam === body.enterprise_id) {
                return body.team_id;
              } else if (eventTeam === body.context_enterprise_id) {
                return body.context_team_id;
              }
            }
          }
        }
      }
      return extractTeamId(body);
    }
    function extractActorUserId(body) {
      if (body.is_ext_shared_channel) {
        if (body.type === "event_callback") {
          if (body.event) {
            if (extractActorEnterpriseId(body) && extractActorTeamId(body)) {
              return void 0;
            }
            return body.event.user || body.event.user_id;
          } else {
            return void 0;
          }
        }
      }
      return extractUserId(body);
    }
    function extractResponseUrl(body) {
      if (body.response_url) {
        return body.response_url;
      } else if (body.response_urls && body.response_urls.length > 0) {
        return body.response_urls[0].response_url;
      }
      return void 0;
    }
    function extractChannelId(body) {
      if (body.channel) {
        if (typeof body.channel === "string") {
          return body.channel;
        } else if (typeof body.channel === "object" && body.channel.id) {
          return body.channel.id;
        }
      } else if (body.channel_id) {
        return body.channel_id;
      } else if (body.event) {
        return extractChannelId(body.event);
      } else if (body.item) {
        return extractChannelId(body.item);
      } else if (body.assistant_thread) {
        return extractChannelId(body.assistant_thread);
      }
      return void 0;
    }
    function isAssitantThreadEvent(body) {
      return (
        body.type === payload_types_1.PayloadType.EventsAPI &&
        body.event !== void 0 &&
        (body.event.type === "assistant_thread_started" ||
          body.event.type === "assistant_thread_context_changed" ||
          (body.event.type === "message" && body.event.channel_type === "im"))
      );
    }
    function extractThreadTs(body) {
      if (isAssitantThreadEvent(body)) {
        if (
          body.event.assistant_thread !== void 0 &&
          body.event.assistant_thread.thread_ts !== void 0
        ) {
          return body.event.assistant_thread.thread_ts;
        } else if (body.event.channel !== void 0) {
          if (body.event.thread_ts !== void 0) {
            return body.event.thread_ts;
          } else if (
            body.event.message !== void 0 &&
            body.event.message.thread_ts !== void 0
          ) {
            return body.event.message.thread_ts;
          } else if (
            body.event.previous_message !== void 0 &&
            body.event.previous_message.thread_ts !== void 0
          ) {
            return body.event.previous_message.thread_ts;
          }
        }
      }
      return void 0;
    }
    function extractTriggerId(body) {
      if (body.trigger_id) {
        return body.trigger_id;
      }
      if (body.interactivity) {
        return body.interactivity.interactivity_pointer;
      }
      return void 0;
    }
    function extractFunctionExecutionId(body) {
      if (body.event) {
        return extractFunctionExecutionId(body.event);
      }
      if (body.function_execution_id) {
        return body.function_execution_id;
      }
      if (body.function_data) {
        return body.function_data.execution_id;
      }
      return void 0;
    }
    function extractFunctionBotAccessToken(body) {
      if (body.event) {
        return extractFunctionBotAccessToken(body.event);
      }
      if (body.bot_access_token) {
        return body.bot_access_token;
      }
      return void 0;
    }
  },
});

// node_modules/slack-edge/dist/assistant/assistant.js
var require_assistant = __commonJS({
  "node_modules/slack-edge/dist/assistant/assistant.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Assistant = void 0;
    var context_1 = require_context();
    var Assistant = class {
      constructor(options = {}) {
        this.threadContextStore = options.threadContextStore;
        this.threadStartedHandler = async (req) => {
          try {
            if ((0, context_1.isAssitantThreadEvent)(req.body)) {
              const request2 = req;
              if (options.threadStarted) {
                await options.threadStarted(request2);
              } else {
                const { say, setSuggestedPrompts } = request2.context;
                await say({ text: ":wave: Hi, how can I help you today?" });
                await setSuggestedPrompts({
                  title: "New chat",
                  prompts: ["What does SLACK stand for?"],
                });
              }
            }
          } catch (e2) {
            console.error(
              `Failed to execute threadStartedHandler listener: ${e2.stack}`,
            );
          }
        };
        this.threadContextChangedHandler = async (req) => {
          try {
            if ((0, context_1.isAssitantThreadEvent)(req.body)) {
              const request2 = req;
              if (options.threadContextChanged) {
                await options.threadContextChanged(request2);
              } else {
                const { context } = request2;
                await context.saveThreadContextStore({
                  ...request2.payload.assistant_thread.context,
                });
              }
            }
          } catch (e2) {
            console.error(
              `Failed to execute threadContextChangedHandler listener: ${e2.stack}`,
            );
          }
        };
        this.userMessageHandler = async (req) => {
          try {
            if (
              req.payload.subtype === void 0 ||
              req.payload.subtype === "file_share"
            ) {
              if (options.userMessage) {
                await options.userMessage(req);
              } else {
              }
            }
          } catch (e2) {
            console.error(
              `Failed to execute userMessageHandler listener: ${e2.stack}`,
            );
          }
        };
        this.botMessageHandler = async (req) => {
          try {
            if (
              req.payload.subtype === void 0 &&
              req.payload.user === req.context.botUserId
            ) {
              if (options.botMessage) {
                await options.botMessage(req);
              } else {
              }
            }
          } catch (e2) {
            console.error(
              `Failed to execute botMessageHandler listener: ${e2.stack}`,
            );
          }
        };
      }
      threadStarted(handler) {
        this.threadStartedHandler = async (req) => {
          try {
            if ((0, context_1.isAssitantThreadEvent)(req.body)) {
              await handler(req);
            }
          } catch (e2) {
            console.error(
              `Failed to execute threadStartedHandler listener: ${e2.stack}`,
            );
          }
        };
      }
      threadContextChanged(handler) {
        this.threadContextChangedHandler = async (req) => {
          try {
            if ((0, context_1.isAssitantThreadEvent)(req.body)) {
              await handler(req);
            }
          } catch (e2) {
            console.error(
              `Failed to execute threadContextChangedHandler listener: ${e2.stack}`,
            );
          }
        };
      }
      userMessage(handler) {
        this.userMessageHandler = async (req) => {
          try {
            if (
              req.payload.subtype === void 0 ||
              req.payload.subtype === "file_share"
            ) {
              await handler(req);
            }
          } catch (e2) {
            console.error(
              `Failed to execute userMessageHandler listener: ${e2.stack}`,
            );
          }
        };
      }
      botMessage(handler) {
        this.botMessageHandler = async (req) => {
          try {
            if (
              req.payload.subtype === void 0 &&
              req.payload.user === req.context.botUserId
            ) {
              await handler(req);
            }
          } catch (e2) {
            console.error(
              `Failed to execute botMessageHandler listener: ${e2.stack}`,
            );
          }
        };
      }
    };
    exports.Assistant = Assistant;
  },
});

// node_modules/slack-edge/dist/assistant/thread-context-store.js
var require_thread_context_store = __commonJS({
  "node_modules/slack-edge/dist/assistant/thread-context-store.js"(exports) {
    "use strict";
    var __classPrivateFieldSet =
      (exports && exports.__classPrivateFieldSet) ||
      function (receiver, state, value, kind, f2) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f2)
          throw new TypeError("Private accessor was defined without a setter");
        if (
          typeof state === "function"
            ? receiver !== state || !f2
            : !state.has(receiver)
        )
          throw new TypeError(
            "Cannot write private member to an object whose class did not declare it",
          );
        return (
          kind === "a"
            ? f2.call(receiver, value)
            : f2
              ? (f2.value = value)
              : state.set(receiver, value),
          value
        );
      };
    var __classPrivateFieldGet =
      (exports && exports.__classPrivateFieldGet) ||
      function (receiver, state, kind, f2) {
        if (kind === "a" && !f2)
          throw new TypeError("Private accessor was defined without a getter");
        if (
          typeof state === "function"
            ? receiver !== state || !f2
            : !state.has(receiver)
        )
          throw new TypeError(
            "Cannot read private member from an object whose class did not declare it",
          );
        return kind === "m"
          ? f2
          : kind === "a"
            ? f2.call(receiver)
            : f2
              ? f2.value
              : state.get(receiver);
      };
    var _DefaultAssistantThreadContextStore_instances;
    var _DefaultAssistantThreadContextStore_client;
    var _DefaultAssistantThreadContextStore_thisBotUserId;
    var _DefaultAssistantThreadContextStore_findFirstAssistantReply;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DefaultAssistantThreadContextStore = void 0;
    var DefaultAssistantThreadContextStore = class {
      constructor({ client, thisBotUserId }) {
        _DefaultAssistantThreadContextStore_instances.add(this);
        _DefaultAssistantThreadContextStore_client.set(this, void 0);
        _DefaultAssistantThreadContextStore_thisBotUserId.set(this, void 0);
        __classPrivateFieldSet(
          this,
          _DefaultAssistantThreadContextStore_client,
          client,
          "f",
        );
        __classPrivateFieldSet(
          this,
          _DefaultAssistantThreadContextStore_thisBotUserId,
          thisBotUserId,
          "f",
        );
      }
      async save(key, newContext) {
        const reply = await __classPrivateFieldGet(
          this,
          _DefaultAssistantThreadContextStore_instances,
          "m",
          _DefaultAssistantThreadContextStore_findFirstAssistantReply,
        ).call(this, key);
        if (reply) {
          await __classPrivateFieldGet(
            this,
            _DefaultAssistantThreadContextStore_client,
            "f",
          ).chat.update({
            ...reply,
            channel: reply.channel_id,
            metadata: {
              // this must be placed at the bottom
              event_type: "assistant_thread_context",
              event_payload: { ...newContext },
            },
          });
        }
      }
      async find(key) {
        const reply = await __classPrivateFieldGet(
          this,
          _DefaultAssistantThreadContextStore_instances,
          "m",
          _DefaultAssistantThreadContextStore_findFirstAssistantReply,
        ).call(this, key);
        if (reply) {
          return reply.metadata?.event_payload;
        }
        return void 0;
      }
    };
    exports.DefaultAssistantThreadContextStore =
      DefaultAssistantThreadContextStore;
    ((_DefaultAssistantThreadContextStore_client =
      /* @__PURE__ */ new WeakMap()),
      (_DefaultAssistantThreadContextStore_thisBotUserId =
        /* @__PURE__ */ new WeakMap()),
      (_DefaultAssistantThreadContextStore_instances =
        /* @__PURE__ */ new WeakSet()),
      (_DefaultAssistantThreadContextStore_findFirstAssistantReply =
        async function _DefaultAssistantThreadContextStore_findFirstAssistantReply2(
          key,
        ) {
          try {
            const response = await __classPrivateFieldGet(
              this,
              _DefaultAssistantThreadContextStore_client,
              "f",
            ).conversations.replies({
              channel: key.channel_id,
              ts: key.thread_ts,
              oldest: key.thread_ts,
              include_all_metadata: true,
              limit: 4,
            });
            if (response.messages) {
              for (const message of response.messages) {
                if (
                  !("subtype" in message) &&
                  message.user ===
                    __classPrivateFieldGet(
                      this,
                      _DefaultAssistantThreadContextStore_thisBotUserId,
                      "f",
                    )
                ) {
                  return {
                    channel_id: key.channel_id,
                    ts: message.ts,
                    text: message.text,
                    blocks: message.blocks,
                    metadata: message.metadata,
                  };
                }
              }
            }
          } catch (e2) {
            console.log(
              `Failed to fetch conversations.replies API result: ${e2}`,
            );
          }
          return void 0;
        }));
  },
});

// node_modules/slack-edge/dist/authorization/authorize-error-handler.js
var require_authorize_error_handler = __commonJS({
  "node_modules/slack-edge/dist/authorization/authorize-error-handler.js"(
    exports,
  ) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildDefaultAuthorizeErrorHanlder =
      buildDefaultAuthorizeErrorHanlder;
    function buildDefaultAuthorizeErrorHanlder() {
      return async ({ error: error45 }) => {
        return error45;
      };
    }
  },
});

// node_modules/slack-edge/dist/errors.js
var require_errors2 = __commonJS({
  "node_modules/slack-edge/dist/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SocketModeError =
      exports.AuthorizeError =
      exports.ConfigError =
        void 0;
    var ConfigError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "ConfigError";
      }
    };
    exports.ConfigError = ConfigError;
    var AuthorizeError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "AuthorizeError";
      }
    };
    exports.AuthorizeError = AuthorizeError;
    var SocketModeError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "SocketModeError";
      }
    };
    exports.SocketModeError = SocketModeError;
  },
});

// node_modules/slack-edge/dist/authorization/single-team-authorize.js
var require_single_team_authorize = __commonJS({
  "node_modules/slack-edge/dist/authorization/single-team-authorize.js"(
    exports,
  ) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.singleTeamAuthorize = void 0;
    var errors_1 = require_errors2();
    var slack_web_api_client_1 = require_dist2();
    var singleTeamAuthorize = async (req) => {
      const botToken = req.env.SLACK_BOT_TOKEN;
      const client = new slack_web_api_client_1.SlackAPIClient(botToken);
      try {
        const response = await client.auth.test();
        const scopes = response.headers.get("x-oauth-scopes") ?? "";
        return {
          botToken,
          enterpriseId: response.enterprise_id,
          teamId: response.team_id,
          team: response.team,
          url: response.url,
          botId: response.bot_id,
          botUserId: response.user_id,
          userId: response.user_id,
          user: response.user,
          botScopes: scopes.split(","),
          userToken: void 0,
          // As mentioned above, user tokens are not supported in this module
          userScopes: void 0,
          // As mentioned above, user tokens are not supported in this module
        };
      } catch (e2) {
        throw new errors_1.AuthorizeError(
          `Failed to call auth.test API due to ${e2.message}`,
        );
      }
    };
    exports.singleTeamAuthorize = singleTeamAuthorize;
  },
});

// node_modules/slack-edge/dist/execution-context.js
var require_execution_context = __commonJS({
  "node_modules/slack-edge/dist/execution-context.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NoopExecutionContext = void 0;
    var NoopExecutionContext = class {
      // deno-lint-ignore no-explicit-any
      waitUntil(promise2) {
        promise2.catch((reason) => {
          console.error(`Failed to run a lazy listener: ${reason}`);
        });
      }
    };
    exports.NoopExecutionContext = NoopExecutionContext;
  },
});

// node_modules/slack-edge/dist/middleware/built-in-middleware.js
var require_built_in_middleware = __commonJS({
  "node_modules/slack-edge/dist/middleware/built-in-middleware.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.urlVerification = void 0;
    exports.ignoringSelfEvents = ignoringSelfEvents;
    var urlVerification = async (req) => {
      if (req.body.type === "url_verification") {
        return { status: 200, body: req.body.challenge };
      }
    };
    exports.urlVerification = urlVerification;
    var eventTypesToKeep = ["member_joined_channel", "member_left_channel"];
    function ignoringSelfEvents(ignoreSelfAssistantMessageEvents) {
      return async (req) => {
        if (req.body.event) {
          if (eventTypesToKeep.includes(req.body.event.type)) {
            return;
          }
          const auth2 = req.context.authorizeResult;
          const isSelfEvent =
            auth2.botId === req.body.event.bot_id ||
            auth2.botUserId === req.context.userId;
          if (isSelfEvent) {
            if (
              !ignoreSelfAssistantMessageEvents &&
              req.body.event.type === "message" &&
              req.body.event.channel_type === "im"
            ) {
              return;
            }
            return { status: 200, body: "" };
          }
        }
      };
    }
  },
});

// node_modules/slack-edge/dist/request/request-parser.js
var require_request_parser = __commonJS({
  "node_modules/slack-edge/dist/request/request-parser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseRequestBody = parseRequestBody;
    async function parseRequestBody(requestHeaders, requestBody) {
      const contentType = requestHeaders.get("content-type");
      if (
        contentType?.startsWith("application/json") ||
        requestBody.startsWith("{")
      ) {
        return JSON.parse(requestBody);
      }
      const params = new URLSearchParams(requestBody);
      if (params.has("payload")) {
        const payload = params.get("payload");
        return JSON.parse(payload);
      }
      const formBody = {};
      for (const k of params.keys()) {
        formBody[k] = params.get(k);
      }
      return formBody;
    }
  },
});

// node_modules/slack-edge/dist/request/request-verification.js
var require_request_verification = __commonJS({
  "node_modules/slack-edge/dist/request/request-verification.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verifySlackRequest = verifySlackRequest;
    async function verifySlackRequest(
      signingSecret,
      requestHeaders,
      requestBody,
    ) {
      const timestampHeader = requestHeaders.get("x-slack-request-timestamp");
      if (!timestampHeader) {
        console.log("x-slack-request-timestamp header is missing!");
        return false;
      }
      const fiveMinutesAgoSeconds = Math.floor(Date.now() / 1e3) - 60 * 5;
      if (Number.parseInt(timestampHeader) < fiveMinutesAgoSeconds) {
        return false;
      }
      const signatureHeader = requestHeaders.get("x-slack-signature");
      if (!timestampHeader || !signatureHeader) {
        console.log("x-slack-signature header is missing!");
        return false;
      }
      const textEncoder = new TextEncoder();
      return await crypto.subtle.verify(
        "HMAC",
        await crypto.subtle.importKey(
          "raw",
          textEncoder.encode(signingSecret),
          { name: "HMAC", hash: "SHA-256" },
          false,
          ["verify"],
        ),
        fromHexStringToBytes(signatureHeader.substring(3)),
        textEncoder.encode(`v0:${timestampHeader}:${requestBody}`),
      );
    }
    function fromHexStringToBytes(hexString) {
      const bytes = new Uint8Array(hexString.length / 2);
      for (let idx = 0; idx < hexString.length; idx += 2) {
        bytes[idx / 2] = parseInt(hexString.substring(idx, idx + 2), 16);
      }
      return bytes;
    }
  },
});

// node_modules/slack-edge/dist/response/response.js
var require_response2 = __commonJS({
  "node_modules/slack-edge/dist/response/response.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toCompleteResponse = toCompleteResponse;
    function toCompleteResponse(slackResponse) {
      if (!slackResponse) {
        return new Response("", {
          status: 200,
          headers: { "Content-Type": "text/plain" },
        });
      }
      if (typeof slackResponse === "string") {
        return new Response(slackResponse, {
          status: 200,
          headers: { "Content-Type": "text/plain;charset=utf-8" },
        });
      }
      let completeResponse = {};
      if (
        Object.prototype.hasOwnProperty.call(slackResponse, "text") ||
        Object.prototype.hasOwnProperty.call(slackResponse, "blocks")
      ) {
        completeResponse = { status: 200, body: slackResponse };
      } else if (
        Object.prototype.hasOwnProperty.call(slackResponse, "response_action")
      ) {
        completeResponse = { status: 200, body: slackResponse };
      } else if (
        Object.prototype.hasOwnProperty.call(slackResponse, "options") ||
        Object.prototype.hasOwnProperty.call(slackResponse, "option_groups")
      ) {
        completeResponse = { status: 200, body: slackResponse };
      } else {
        completeResponse = slackResponse;
      }
      const status = completeResponse.status ? completeResponse.status : 200;
      let contentType = completeResponse.contentType
        ? completeResponse.contentType
        : "text/plain;charset=utf-8";
      let bodyString = "";
      if (typeof completeResponse.body === "object") {
        contentType = "application/json;charset=utf-8";
        bodyString = JSON.stringify(completeResponse.body);
      } else {
        bodyString = completeResponse.body || "";
      }
      return new Response(bodyString, {
        status,
        headers: { "Content-Type": contentType },
      });
    }
  },
});

// node_modules/slack-edge/dist/socket-mode/payload-handler.js
var require_payload_handler = __commonJS({
  "node_modules/slack-edge/dist/socket-mode/payload-handler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromSocketModeToRequest = fromSocketModeToRequest;
    exports.fromResponseToSocketModePayload = fromResponseToSocketModePayload;
    function fromSocketModeToRequest({
      url: url2,
      body,
      retryNum,
      retryReason,
    }) {
      if (!body) {
        return void 0;
      }
      const payload = JSON.stringify(body);
      const headers = {
        "content-type": "application/json",
      };
      if (retryNum) {
        headers["x-slack-retry-num"] = retryNum;
      }
      if (retryReason) {
        headers["x-slack-retry-reason"] = retryReason;
      }
      const options = {
        method: "POST",
        headers: new Headers(headers),
        body: new Blob([payload]).stream(),
        duplex: "half",
        // required when running on Node.js runtime
      };
      return new Request(url2 ?? "wss://localhost", options);
    }
    async function fromResponseToSocketModePayload({ response }) {
      let message = {};
      if (response.body) {
        const contentType = response.headers.get("Content-Type");
        if (contentType && contentType.startsWith("text/plain")) {
          const text2 = await response.text();
          if (text2) {
            message = { text: text2 };
          }
        } else {
          message = await response.json();
        }
      }
      return message;
    }
  },
});

// node_modules/slack-edge/dist/socket-mode/socket-mode-client.js
var require_socket_mode_client = __commonJS({
  "node_modules/slack-edge/dist/socket-mode/socket-mode-client.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SocketModeClient = void 0;
    var slack_web_api_client_1 = require_dist2();
    var errors_1 = require_errors2();
    var payload_handler_1 = require_payload_handler();
    var SocketModeClient = class {
      constructor(app) {
        if (!app.socketMode) {
          throw new errors_1.ConfigError(
            "socketMode: true must be set for running with Socket Mode",
          );
        }
        if (!app.appLevelToken) {
          throw new errors_1.ConfigError(
            "appLevelToken must be set for running with Socket Mode",
          );
        }
        this.app = app;
        this.appLevelToken = app.appLevelToken;
        console.warn(
          "WARNING: The Socket Mode support provided by slack-edge is still experimental and is not designed to handle reconnections for production-grade applications. It is recommended to use this mode only for local development and testing purposes.",
        );
      }
      async connect() {
        const client = new slack_web_api_client_1.SlackAPIClient(
          this.appLevelToken,
        );
        try {
          const newConnection = await client.apps.connections.open();
          this.ws = new WebSocket(newConnection.url);
        } catch (e2) {
          throw new errors_1.SocketModeError(
            `Failed to establish a new WSS connection: ${e2}`,
          );
        }
        if (this.ws) {
          const ws = this.ws;
          ws.onopen = async (ev) => {
            if (
              (0, slack_web_api_client_1.isDebugLogEnabled)(
                app.env.SLACK_LOGGING_LEVEL,
              )
            ) {
              console.log(
                `Now the Socket Mode client is connected to Slack: ${JSON.stringify(ev)}`,
              );
            }
          };
          ws.onclose = async (ev) => {
            if (
              (0, slack_web_api_client_1.isDebugLogEnabled)(
                app.env.SLACK_LOGGING_LEVEL,
              )
            ) {
              console.log(
                `The Socket Mode client is disconnected from Slack: ${JSON.stringify(ev)}`,
              );
            }
          };
          ws.onerror = async (e2) => {
            console.error(
              `An error was thrown by the Socket Mode connection: ${e2}`,
            );
          };
          const app = this.app;
          ws.onmessage = async (ev) => {
            try {
              if (
                ev.data &&
                typeof ev.data === "string" &&
                ev.data.startsWith("{")
              ) {
                const data = JSON.parse(ev.data);
                if (data.type === "hello") {
                  if (
                    (0, slack_web_api_client_1.isDebugLogEnabled)(
                      app.env.SLACK_LOGGING_LEVEL,
                    )
                  ) {
                    console.log(`*** Received hello data ***
 ${ev.data}`);
                  }
                  return;
                }
                const request2 = (0, payload_handler_1.fromSocketModeToRequest)(
                  {
                    url: ws.url,
                    body: data.payload,
                    retryNum: data.retry_attempt,
                    retryReason: data.retry_reason,
                  },
                );
                if (!request2) {
                  return;
                }
                const response = await app.run(request2);
                const message = {
                  envelope_id: data.envelope_id,
                };
                const payload = await (0,
                payload_handler_1.fromResponseToSocketModePayload)({
                  response,
                });
                if (payload) {
                  message.payload = payload;
                }
                ws.send(JSON.stringify(message));
              } else {
                if (
                  (0, slack_web_api_client_1.isDebugLogEnabled)(
                    app.env.SLACK_LOGGING_LEVEL,
                  )
                ) {
                  console.log(`*** Received non-JSON data ***
 ${ev.data}`);
                }
              }
            } catch (e2) {
              console.error(`Failed to handle a WebSocke message: ${e2}`);
            }
          };
        }
      }
      // deno-lint-ignore require-await
      async disconnect() {
        if (this.ws) {
          this.ws.close();
          this.ws = void 0;
        }
      }
    };
    exports.SocketModeClient = SocketModeClient;
  },
});

// node_modules/slack-edge/dist/utility/function-executed-event.js
var require_function_executed_event = __commonJS({
  "node_modules/slack-edge/dist/utility/function-executed-event.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isFunctionExecutedEvent = void 0;
    var isFunctionExecutedEvent = (event) => {
      return event.type === "function_executed";
    };
    exports.isFunctionExecutedEvent = isFunctionExecutedEvent;
  },
});

// node_modules/slack-edge/dist/utility/message-events.js
var require_message_events = __commonJS({
  "node_modules/slack-edge/dist/utility/message-events.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isPostedMessageEvent = void 0;
    var isPostedMessageEvent = (event) => {
      return (
        event.subtype === void 0 ||
        event.subtype === "bot_message" ||
        event.subtype === "file_share" ||
        event.subtype === "thread_broadcast"
      );
    };
    exports.isPostedMessageEvent = isPostedMessageEvent;
  },
});

// node_modules/slack-edge/dist/app.js
var require_app = __commonJS({
  "node_modules/slack-edge/dist/app.js"(exports) {
    "use strict";
    var __classPrivateFieldSet =
      (exports && exports.__classPrivateFieldSet) ||
      function (receiver, state, value, kind, f2) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f2)
          throw new TypeError("Private accessor was defined without a setter");
        if (
          typeof state === "function"
            ? receiver !== state || !f2
            : !state.has(receiver)
        )
          throw new TypeError(
            "Cannot write private member to an object whose class did not declare it",
          );
        return (
          kind === "a"
            ? f2.call(receiver, value)
            : f2
              ? (f2.value = value)
              : state.set(receiver, value),
          value
        );
      };
    var __classPrivateFieldGet =
      (exports && exports.__classPrivateFieldGet) ||
      function (receiver, state, kind, f2) {
        if (kind === "a" && !f2)
          throw new TypeError("Private accessor was defined without a getter");
        if (
          typeof state === "function"
            ? receiver !== state || !f2
            : !state.has(receiver)
        )
          throw new TypeError(
            "Cannot read private member from an object whose class did not declare it",
          );
        return kind === "m"
          ? f2
          : kind === "a"
            ? f2.call(receiver)
            : f2
              ? f2.value
              : state.get(receiver);
      };
    var _SlackApp_instances;
    var _SlackApp_slashCommands;
    var _SlackApp_events;
    var _SlackApp_globalShorcuts;
    var _SlackApp_messageShorcuts;
    var _SlackApp_blockActions;
    var _SlackApp_blockSuggestions;
    var _SlackApp_viewSubmissions;
    var _SlackApp_viewClosed;
    var _SlackApp_appRateLimited;
    var _SlackApp_assistantEnabled;
    var _SlackApp_assistantEvent;
    var _SlackApp_callAuthorize;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.noopLazyHandler = exports.SlackApp = void 0;
    var slack_web_api_client_1 = require_dist2();
    var assistant_1 = require_assistant();
    var thread_context_store_1 = require_thread_context_store();
    var authorize_error_handler_1 = require_authorize_error_handler();
    var single_team_authorize_1 = require_single_team_authorize();
    var context_1 = require_context();
    var errors_1 = require_errors2();
    var execution_context_1 = require_execution_context();
    var built_in_middleware_1 = require_built_in_middleware();
    var payload_types_1 = require_payload_types();
    var request_parser_1 = require_request_parser();
    var request_verification_1 = require_request_verification();
    var response_1 = require_response2();
    var socket_mode_client_1 = require_socket_mode_client();
    var function_executed_event_1 = require_function_executed_event();
    var message_events_1 = require_message_events();
    var SlackApp2 = class {
      // --------------------------
      constructor(options) {
        _SlackApp_instances.add(this);
        this.preAuthorizeMiddleware = [built_in_middleware_1.urlVerification];
        this.postAuthorizeMiddleware = [];
        this.eventsToSkipAuthorize = ["app_uninstalled", "tokens_revoked"];
        _SlackApp_slashCommands.set(this, []);
        _SlackApp_events.set(this, []);
        _SlackApp_globalShorcuts.set(this, []);
        _SlackApp_messageShorcuts.set(this, []);
        _SlackApp_blockActions.set(this, []);
        _SlackApp_blockSuggestions.set(this, []);
        _SlackApp_viewSubmissions.set(this, []);
        _SlackApp_viewClosed.set(this, []);
        _SlackApp_appRateLimited.set(this, void 0);
        _SlackApp_assistantEnabled.set(this, void 0);
        if (
          options.env.SLACK_BOT_TOKEN === void 0 &&
          (options.authorize === void 0 ||
            options.authorize === single_team_authorize_1.singleTeamAuthorize)
        ) {
          throw new errors_1.ConfigError(
            "When you don't pass env.SLACK_BOT_TOKEN, your own authorize function, which supplies a valid token to use, needs to be passed instead.",
          );
        }
        this.env = options.env;
        this.client = new slack_web_api_client_1.SlackAPIClient(
          options.env.SLACK_BOT_TOKEN,
          {
            logLevel: this.env.SLACK_LOGGING_LEVEL,
          },
        );
        this.appLevelToken = options.env.SLACK_APP_TOKEN;
        this.socketMode = options.socketMode ?? this.appLevelToken !== void 0;
        if (this.socketMode) {
          this.signingSecret = "";
        } else {
          if (!this.env.SLACK_SIGNING_SECRET) {
            throw new errors_1.ConfigError(
              "env.SLACK_SIGNING_SECRET is required to run your app on edge functions!",
            );
          }
          this.signingSecret = this.env.SLACK_SIGNING_SECRET;
        }
        this.startLazyListenerAfterAck =
          options.startLazyListenerAfterAck ?? false;
        this.ignoreSelfEvents = options.ignoreSelfEvents ?? true;
        if (this.ignoreSelfEvents) {
          const middleware = (0, built_in_middleware_1.ignoringSelfEvents)(
            options.ignoreSelfAssistantMessageEvents ?? true,
          );
          this.postAuthorizeMiddleware.push(middleware);
        }
        this.authorize =
          options.authorize ?? single_team_authorize_1.singleTeamAuthorize;
        this.authorizeErrorHandler =
          options.authorizeErrorHandler ??
          (0, authorize_error_handler_1.buildDefaultAuthorizeErrorHanlder)();
        this.routes = { events: options.routes?.events };
        this.assistantThreadContextStore = options.assistantThreadContextStore;
        __classPrivateFieldSet(
          this,
          _SlackApp_assistantEnabled,
          options.assistantThreadContextStore !== void 0,
          "f",
        );
      }
      /**
       * Registers a pre-authorize middleware.
       * @param middleware middleware
       * @returns this instance
       */
      beforeAuthorize(middleware) {
        this.preAuthorizeMiddleware.push(middleware);
        return this;
      }
      /**
       * Registers a post-authorize middleware. This naming is for consistency with bolt-js.
       * @param middleware middleware
       * @returns this instance
       */
      middleware(middleware) {
        return this.afterAuthorize(middleware);
      }
      /**
       * Registers a post-authorize middleware. This naming is for consistency with bolt-js.
       * @param middleware middleware
       * @returns this instance
       */
      use(middleware) {
        return this.afterAuthorize(middleware);
      }
      /**
       * Registers a post-authorize middleware.
       * @param middleware middleware
       * @returns this instance
       */
      afterAuthorize(middleware) {
        this.postAuthorizeMiddleware.push(middleware);
        return this;
      }
      /**
       * Registers a listener that handles slash command executions.
       * @param pattern the pattern to match slash command name
       * @param ack ack function that must complete within 3 seconds
       * @param lazy lazy function that can do anything asynchronously
       * @returns this instance
       */
      command(pattern, ack, lazy2 = exports.noopLazyHandler) {
        const handler = { ack, lazy: lazy2 };
        __classPrivateFieldGet(this, _SlackApp_slashCommands, "f").push(
          (body) => {
            if (body.type || !body.command) {
              return null;
            }
            if (typeof pattern === "string" && body.command === pattern) {
              return handler;
            } else if (
              typeof pattern === "object" &&
              pattern instanceof RegExp &&
              body.command.match(pattern)
            ) {
              return handler;
            }
            return null;
          },
        );
        return this;
      }
      /**
       * Registers a listener that handles custom function calls within Workflow Builder.
       * Please be aware that this feature is still in beta as of April 2024.
       * @param callbackId the pattern to match callback_id in a payload
       * @param lazy lazy function that can do anything asynchronously
       * @returns this instance
       */
      function(callbackId, lazy2) {
        __classPrivateFieldGet(this, _SlackApp_events, "f").push((body) => {
          if (
            body.type !== payload_types_1.PayloadType.EventsAPI ||
            !body.event ||
            body.event.type !== "function_executed"
          ) {
            return null;
          }
          if (
            (0, function_executed_event_1.isFunctionExecutedEvent)(body.event)
          ) {
            let matched = true;
            if (callbackId !== void 0) {
              if (typeof callbackId === "string") {
                matched = body.event.function.callback_id.includes(callbackId);
              }
              if (typeof callbackId === "object") {
                matched =
                  body.event.function.callback_id.match(callbackId) !== null;
              }
            }
            if (matched) {
              return { ack: async (_2) => "", lazy: lazy2 };
            }
          }
          return null;
        });
        return this;
      }
      /**
       * Registers a listener that handles Events API request.
       * @param event the pattern to match event type in a payload
       * @param lazy lazy function that can do anything asynchronously
       * @returns this instance
       */
      event(event, lazy2) {
        __classPrivateFieldGet(this, _SlackApp_events, "f").push((body) => {
          if (
            body.type !== payload_types_1.PayloadType.EventsAPI ||
            !body.event
          ) {
            return null;
          }
          if (body.event.type === event) {
            return { ack: async () => "", lazy: lazy2 };
          }
          return null;
        });
        return this;
      }
      assistant(assistant) {
        __classPrivateFieldGet(
          this,
          _SlackApp_instances,
          "m",
          _SlackApp_assistantEvent,
        ).call(
          this,
          "assistant_thread_started",
          assistant.threadStartedHandler,
        );
        __classPrivateFieldGet(
          this,
          _SlackApp_instances,
          "m",
          _SlackApp_assistantEvent,
        ).call(
          this,
          "assistant_thread_context_changed",
          assistant.threadContextChangedHandler,
        );
        __classPrivateFieldGet(
          this,
          _SlackApp_instances,
          "m",
          _SlackApp_assistantEvent,
        ).call(this, "message", assistant.userMessageHandler, false);
        __classPrivateFieldGet(
          this,
          _SlackApp_instances,
          "m",
          _SlackApp_assistantEvent,
        ).call(this, "message", assistant.botMessageHandler, true);
        if (assistant.threadContextStore) {
          this.assistantThreadContextStore = assistant.threadContextStore;
        }
        return this;
      }
      assistantThreadStarted(lazy2) {
        return __classPrivateFieldGet(
          this,
          _SlackApp_instances,
          "m",
          _SlackApp_assistantEvent,
        ).call(
          this,
          "assistant_thread_started",
          new assistant_1.Assistant({
            threadContextStore: this.assistantThreadContextStore,
            threadStarted: lazy2,
          }).threadStartedHandler,
        );
      }
      assistantThreadContextChanged(lazy2) {
        return __classPrivateFieldGet(
          this,
          _SlackApp_instances,
          "m",
          _SlackApp_assistantEvent,
        ).call(
          this,
          "assistant_thread_context_changed",
          new assistant_1.Assistant({
            threadContextStore: this.assistantThreadContextStore,
            threadContextChanged: lazy2,
          }).threadContextChangedHandler,
        );
      }
      assistantUserMessage(lazy2) {
        return __classPrivateFieldGet(
          this,
          _SlackApp_instances,
          "m",
          _SlackApp_assistantEvent,
        ).call(
          this,
          "message",
          new assistant_1.Assistant({
            threadContextStore: this.assistantThreadContextStore,
            userMessage: lazy2,
          }).userMessageHandler,
          false,
        );
      }
      assistantBotMessage(lazy2) {
        return __classPrivateFieldGet(
          this,
          _SlackApp_instances,
          "m",
          _SlackApp_assistantEvent,
        ).call(
          this,
          "message",
          new assistant_1.Assistant({
            threadContextStore: this.assistantThreadContextStore,
            botMessage: lazy2,
          }).botMessageHandler,
          true,
        );
      }
      /**
       * Registers a listener that handles all newly posted message events.
       * @param lazy lazy function that can do anything asynchronously
       * @returns this instance
       */
      anyMessage(lazy2) {
        return this.message(void 0, lazy2);
      }
      /**
       * Registers a listener that handles newly posted message events that matches the pattern.
       * @param pattern the pattern to match a message event's text
       * @param lazy lazy function that can do anything asynchronously
       * @returns this instance
       */
      message(pattern, lazy2) {
        __classPrivateFieldGet(this, _SlackApp_events, "f").push((body) => {
          if (
            body.type !== payload_types_1.PayloadType.EventsAPI ||
            !body.event ||
            body.event.type !== "message"
          ) {
            return null;
          }
          if ((0, message_events_1.isPostedMessageEvent)(body.event)) {
            let matched = true;
            if (pattern !== void 0) {
              if (typeof pattern === "string") {
                matched = body.event.text.includes(pattern);
              }
              if (typeof pattern === "object") {
                matched = body.event.text.match(pattern) !== null;
              }
            }
            if (matched) {
              return { ack: async (_2) => "", lazy: lazy2 };
            }
          }
          return null;
        });
        return this;
      }
      /**
       * Registers a listener that handles global/message shortcut executions.
       * @param callbackId the pattern to match callback_id in a payload
       * @param ack ack function that must complete within 3 seconds
       * @param lazy lazy function that can do anything asynchronously
       * @returns this instance
       */
      shortcut(callbackId, ack, lazy2 = exports.noopLazyHandler) {
        return this.globalShortcut(callbackId, ack, lazy2).messageShortcut(
          callbackId,
          ack,
          lazy2,
        );
      }
      /**
       * Registers a listener that handles global shortcut executions.
       * @param callbackId the pattern to match callback_id in a payload
       * @param ack ack function that must complete within 3 seconds
       * @param lazy lazy function that can do anything asynchronously
       * @returns this instance
       */
      globalShortcut(callbackId, ack, lazy2 = exports.noopLazyHandler) {
        const handler = { ack, lazy: lazy2 };
        __classPrivateFieldGet(this, _SlackApp_globalShorcuts, "f").push(
          (body) => {
            if (
              body.type !== payload_types_1.PayloadType.GlobalShortcut ||
              !body.callback_id
            ) {
              return null;
            }
            if (
              typeof callbackId === "string" &&
              body.callback_id === callbackId
            ) {
              return handler;
            } else if (
              typeof callbackId === "object" &&
              callbackId instanceof RegExp &&
              body.callback_id.match(callbackId)
            ) {
              return handler;
            }
            return null;
          },
        );
        return this;
      }
      /**
       * Registers a listener that handles message shortcut executions.
       * @param callbackId the pattern to match callback_id in a payload
       * @param ack ack function that must complete within 3 seconds
       * @param lazy lazy function that can do anything asynchronously
       * @returns this instance
       */
      messageShortcut(callbackId, ack, lazy2 = exports.noopLazyHandler) {
        const handler = { ack, lazy: lazy2 };
        __classPrivateFieldGet(this, _SlackApp_messageShorcuts, "f").push(
          (body) => {
            if (
              body.type !== payload_types_1.PayloadType.MessageShortcut ||
              !body.callback_id
            ) {
              return null;
            }
            if (
              typeof callbackId === "string" &&
              body.callback_id === callbackId
            ) {
              return handler;
            } else if (
              typeof callbackId === "object" &&
              callbackId instanceof RegExp &&
              body.callback_id.match(callbackId)
            ) {
              return handler;
            }
            return null;
          },
        );
        return this;
      }
      /**
       * Registers a listener that handles type: "block_actions" requests.
       * @param constraints the constraints to match block_id/action_id in a payload
       * @param ack ack function that must complete within 3 seconds
       * @param lazy lazy function that can do anything asynchronously
       * @returns this instance
       */
      action(constraints, ack, lazy2 = exports.noopLazyHandler) {
        const handler = { ack, lazy: lazy2 };
        __classPrivateFieldGet(this, _SlackApp_blockActions, "f").push(
          (body) => {
            if (
              body.type !== payload_types_1.PayloadType.BlockAction ||
              !body.actions ||
              !body.actions[0]
            ) {
              return null;
            }
            const action = body.actions[0];
            if (
              typeof constraints === "string" &&
              action.action_id === constraints
            ) {
              return handler;
            } else if (typeof constraints === "object") {
              if (constraints instanceof RegExp) {
                if (action.action_id.match(constraints)) {
                  return handler;
                }
              } else if (constraints.type) {
                if (action.type === constraints.type) {
                  if (action.action_id === constraints.action_id) {
                    if (
                      constraints.block_id &&
                      action.block_id !== constraints.block_id
                    ) {
                      return null;
                    }
                    return handler;
                  }
                }
              }
            }
            return null;
          },
        );
        return this;
      }
      /**
       * Registers a listener that handles type: "block_suggestion" requests.
       * Note that your app must return the options/option_groups within 3 seconds,
       * so slack-edge intentionally does not accept lazy here.
       * @param constraints the constraints to match block_id/action_id in a payload
       * @param ack ack function that must complete within 3 seconds
       * @returns this instance
       */
      options(constraints, ack) {
        const handler = { ack };
        __classPrivateFieldGet(this, _SlackApp_blockSuggestions, "f").push(
          (body) => {
            if (
              body.type !== payload_types_1.PayloadType.BlockSuggestion ||
              !body.action_id
            ) {
              return null;
            }
            if (
              typeof constraints === "string" &&
              body.action_id === constraints
            ) {
              return handler;
            } else if (typeof constraints === "object") {
              if (constraints instanceof RegExp) {
                if (body.action_id.match(constraints)) {
                  return handler;
                }
              } else {
                if (body.action_id === constraints.action_id) {
                  if (body.block_id && body.block_id !== constraints.block_id) {
                    return null;
                  }
                  return handler;
                }
              }
            }
            return null;
          },
        );
        return this;
      }
      /**
       * Registers a listener that handles type: "view_submission"/"view_closed" requests.
       * @param callbackId the constraints to match callback_id in a payload
       * @param ack ack function that must complete within 3 seconds
       * @param lazy lazy function that can do anything asynchronously
       * @returns this instance
       */
      view(callbackId, ack, lazy2 = exports.noopLazyHandler) {
        return this.viewSubmission(callbackId, ack, lazy2).viewClosed(
          callbackId,
          ack,
          lazy2,
        );
      }
      /**
       * Registers a listener that handles type: "view_submission" requests.
       * @param callbackId the constraints to match callback_id in a payload
       * @param ack ack function that must complete within 3 seconds
       * @param lazy lazy function that can do anything asynchronously
       * @returns this instance
       */
      viewSubmission(callbackId, ack, lazy2 = exports.noopLazyHandler) {
        const handler = { ack, lazy: lazy2 };
        __classPrivateFieldGet(this, _SlackApp_viewSubmissions, "f").push(
          (body) => {
            if (
              body.type !== payload_types_1.PayloadType.ViewSubmission ||
              !body.view
            ) {
              return null;
            }
            if (
              typeof callbackId === "string" &&
              body.view.callback_id === callbackId
            ) {
              return handler;
            } else if (
              typeof callbackId === "object" &&
              callbackId instanceof RegExp &&
              body.view.callback_id.match(callbackId)
            ) {
              return handler;
            }
            return null;
          },
        );
        return this;
      }
      /**
       * Registers a listener that handles type: "view_closed" requests.
       * @param callbackId the constraints to match callback_id in a payload
       * @param ack ack function that must complete within 3 seconds
       * @param lazy lazy function that can do anything asynchronously
       * @returns this instance
       */
      viewClosed(callbackId, ack, lazy2 = exports.noopLazyHandler) {
        const handler = { ack, lazy: lazy2 };
        __classPrivateFieldGet(this, _SlackApp_viewClosed, "f").push((body) => {
          if (
            body.type !== payload_types_1.PayloadType.ViewClosed ||
            !body.view
          ) {
            return null;
          }
          if (
            typeof callbackId === "string" &&
            body.view.callback_id === callbackId
          ) {
            return handler;
          } else if (
            typeof callbackId === "object" &&
            callbackId instanceof RegExp &&
            body.view.callback_id.match(callbackId)
          ) {
            return handler;
          }
          return null;
        });
        return this;
      }
      /**
       * Registers a single listener that handles type: "app_rate_limited" requests.
       * @param lazy lazy function that can do anything asynchronously
       * @returns this instance
       */
      appRateLimited(lazy2) {
        __classPrivateFieldSet(
          this,
          _SlackApp_appRateLimited,
          (body) => {
            if (body.type !== payload_types_1.PayloadType.AppRateLimited) {
              return null;
            }
            return { ack: async () => "", lazy: lazy2 };
          },
          "f",
        );
        return this;
      }
      /**
       * Handles an http request and returns a response to it.
       * @param request request
       * @param ctx execution context
       * @returns response
       */
      async run(
        request2,
        ctx = new execution_context_1.NoopExecutionContext(),
      ) {
        return await this.handleEventRequest(request2, ctx);
      }
      /**
       * Establishes a WebSocket connection for Socket Mode.
       */
      async connect() {
        if (!this.socketMode) {
          throw new errors_1.ConfigError(
            "Both env.SLACK_APP_TOKEN and socketMode: true are required to start a Socket Mode connection!",
          );
        }
        this.socketModeClient = new socket_mode_client_1.SocketModeClient(this);
        await this.socketModeClient.connect();
      }
      /**
       * Disconnect a WebSocket connection for Socket Mode.
       */
      async disconnect() {
        if (this.socketModeClient) {
          await this.socketModeClient.disconnect();
        }
      }
      /**
       * Handles an HTTP request from Slack's API server and returns a response to it.
       * @param request request
       * @param ctx execution context
       * @returns response
       */
      async handleEventRequest(request2, ctx) {
        if (this.routes.events) {
          const { pathname } = new URL(request2.url);
          if (pathname !== this.routes.events) {
            return new Response("Not found", { status: 404 });
          }
        }
        const blobRequestBody = await request2.blob();
        const rawBody = await blobRequestBody.text();
        if (rawBody.includes("ssl_check=")) {
          const bodyParams = new URLSearchParams(rawBody);
          if (bodyParams.get("ssl_check") === "1" && bodyParams.get("token")) {
            return new Response("", { status: 200 });
          }
        }
        const isRequestSignatureVerified =
          this.socketMode ||
          (await (0, request_verification_1.verifySlackRequest)(
            this.signingSecret,
            request2.headers,
            rawBody,
          ));
        if (isRequestSignatureVerified) {
          const body = await (0, request_parser_1.parseRequestBody)(
            request2.headers,
            rawBody,
          );
          let retryNum = void 0;
          try {
            const retryNumHeader = request2.headers.get("x-slack-retry-num");
            if (retryNumHeader) {
              retryNum = Number.parseInt(retryNumHeader);
            } else if (this.socketMode && body.retry_attempt) {
              retryNum = Number.parseInt(body.retry_attempt);
            }
          } catch (e2) {}
          const retryReason =
            request2.headers.get("x-slack-retry-reason") ?? body.retry_reason;
          const preAuthorizeRequest = {
            body,
            rawBody,
            retryNum,
            retryReason,
            context: (0, context_1.builtBaseContext)(body),
            env: this.env,
            headers: request2.headers,
          };
          if (
            (0, slack_web_api_client_1.isDebugLogEnabled)(
              this.env.SLACK_LOGGING_LEVEL,
            )
          ) {
            console.log(`*** Received request body ***
 ${(0, slack_web_api_client_1.prettyPrint)(body)}`);
          }
          for (const middlware of this.preAuthorizeMiddleware) {
            const response = await middlware(preAuthorizeRequest);
            if (response) {
              return (0, response_1.toCompleteResponse)(response);
            }
          }
          let authorizeResult;
          try {
            authorizeResult = await __classPrivateFieldGet(
              this,
              _SlackApp_instances,
              "m",
              _SlackApp_callAuthorize,
            ).call(this, preAuthorizeRequest);
          } catch (error45) {
            if ("name" in error45 && error45.name === "AuthorizeError") {
              const responseOrError = await this.authorizeErrorHandler({
                request: preAuthorizeRequest,
                error: error45,
              });
              if (
                "name" in responseOrError &&
                responseOrError.name === "AuthorizeError"
              ) {
                throw responseOrError;
              } else {
                return responseOrError;
              }
            } else {
              throw error45;
            }
          }
          const primaryToken =
            preAuthorizeRequest.context.functionBotAccessToken ||
            authorizeResult.botToken;
          const authorizedContext = {
            ...preAuthorizeRequest.context,
            authorizeResult,
            client: new slack_web_api_client_1.SlackAPIClient(primaryToken, {
              logLevel: this.env.SLACK_LOGGING_LEVEL,
            }),
            botToken: authorizeResult.botToken,
            botId: authorizeResult.botId,
            botUserId: authorizeResult.botUserId,
            userToken: authorizeResult.userToken,
          };
          if (authorizedContext.channelId) {
            const context = authorizedContext;
            const primaryToken2 =
              context.functionBotAccessToken || context.botToken;
            const client = new slack_web_api_client_1.SlackAPIClient(
              primaryToken2,
            );
            if (
              __classPrivateFieldGet(this, _SlackApp_assistantEnabled, "f") &&
              authorizedContext.isAssistantThreadEvent
            ) {
              const assistantContext = authorizedContext;
              const { channelId: channel_id, threadTs: thread_ts } =
                assistantContext;
              assistantContext.setStatus = async ({ status }) =>
                await client.assistant.threads.setStatus({
                  channel_id,
                  thread_ts,
                  status,
                });
              assistantContext.setTitle = async ({ title }) =>
                await client.assistant.threads.setTitle({
                  channel_id,
                  thread_ts,
                  title,
                });
              assistantContext.setSuggestedPrompts = async ({
                title,
                prompts,
              }) => {
                const promptsArgs = [];
                for (const p2 of prompts) {
                  if (typeof p2 === "string") {
                    promptsArgs.push({ message: p2, title: p2 });
                  } else {
                    promptsArgs.push(p2);
                  }
                }
                return await client.assistant.threads.setSuggestedPrompts({
                  channel_id,
                  thread_ts,
                  prompts: promptsArgs,
                  title,
                });
              };
              const threadContextStore =
                this.assistantThreadContextStore ??
                new thread_context_store_1.DefaultAssistantThreadContextStore({
                  client,
                  thisBotUserId: context.botUserId,
                });
              assistantContext.threadContextStore = threadContextStore;
              assistantContext.saveThreadContextStore = async (newContext) => {
                await threadContextStore.save(
                  { channel_id, thread_ts },
                  newContext,
                );
              };
              const threadContext =
                (await threadContextStore.find({ channel_id, thread_ts })) ||
                (body.event.assistant_thread?.context &&
                Object.keys(body.event.assistant_thread.context).length > 0
                  ? body.event.assistant_thread?.context
                  : void 0);
              if (threadContext) {
                assistantContext.threadContext = threadContext;
              }
              context.say = async (params) =>
                await client.chat.postMessage({
                  channel: channel_id,
                  thread_ts,
                  metadata: threadContext
                    ? {
                        event_type: "assistant_thread_context",
                        event_payload: { ...threadContext },
                      }
                    : void 0,
                  ...params,
                });
            } else {
              context.say = async (params) =>
                await client.chat.postMessage({
                  channel: context.channelId,
                  thread_ts: context.threadTs,
                  // for assistant apps
                  ...params,
                });
            }
          }
          if (authorizedContext.responseUrl) {
            const responseUrl = authorizedContext.responseUrl;
            authorizedContext.respond = async (params) => {
              return new slack_web_api_client_1.ResponseUrlSender(
                responseUrl,
              ).call(params);
            };
          }
          const baseRequest = {
            ...preAuthorizeRequest,
            context: authorizedContext,
          };
          for (const middlware of this.postAuthorizeMiddleware) {
            const response = await middlware(baseRequest);
            if (response) {
              return (0, response_1.toCompleteResponse)(response);
            }
          }
          const payload = body;
          if (body.type === payload_types_1.PayloadType.EventsAPI) {
            const slackRequest = {
              payload: body.event,
              ...baseRequest,
            };
            for (const matcher of __classPrivateFieldGet(
              this,
              _SlackApp_events,
              "f",
            )) {
              const handler = matcher(payload);
              if (handler) {
                if (!this.startLazyListenerAfterAck) {
                  ctx.waitUntil(handler.lazy(slackRequest));
                }
                const slackResponse = await handler.ack(slackRequest);
                if (
                  (0, slack_web_api_client_1.isDebugLogEnabled)(
                    this.env.SLACK_LOGGING_LEVEL,
                  )
                ) {
                  console.log(`*** Slack response ***
${(0, slack_web_api_client_1.prettyPrint)(slackResponse)}`);
                }
                if (this.startLazyListenerAfterAck) {
                  ctx.waitUntil(handler.lazy(slackRequest));
                }
                return (0, response_1.toCompleteResponse)(slackResponse);
              }
            }
            if (payload.event?.type === "assistant_thread_context_changed") {
              const handler = new assistant_1.Assistant({
                threadContextStore: this.assistantThreadContextStore,
              }).threadContextChangedHandler;
              if (!this.startLazyListenerAfterAck) {
                const req = slackRequest;
                ctx.waitUntil(handler(req));
                return (0, response_1.toCompleteResponse)();
              }
            }
          } else if (!body.type && body.command) {
            const slackRequest = {
              payload: body,
              ...baseRequest,
            };
            for (const matcher of __classPrivateFieldGet(
              this,
              _SlackApp_slashCommands,
              "f",
            )) {
              const handler = matcher(payload);
              if (handler) {
                if (!this.startLazyListenerAfterAck) {
                  ctx.waitUntil(handler.lazy(slackRequest));
                }
                const slackResponse = await handler.ack(slackRequest);
                if (
                  (0, slack_web_api_client_1.isDebugLogEnabled)(
                    this.env.SLACK_LOGGING_LEVEL,
                  )
                ) {
                  console.log(`*** Slack response ***
${(0, slack_web_api_client_1.prettyPrint)(slackResponse)}`);
                }
                if (this.startLazyListenerAfterAck) {
                  ctx.waitUntil(handler.lazy(slackRequest));
                }
                return (0, response_1.toCompleteResponse)(slackResponse);
              }
            }
          } else if (body.type === payload_types_1.PayloadType.GlobalShortcut) {
            const slackRequest = {
              payload: body,
              ...baseRequest,
            };
            for (const matcher of __classPrivateFieldGet(
              this,
              _SlackApp_globalShorcuts,
              "f",
            )) {
              const handler = matcher(payload);
              if (handler) {
                if (!this.startLazyListenerAfterAck) {
                  ctx.waitUntil(handler.lazy(slackRequest));
                }
                const slackResponse = await handler.ack(slackRequest);
                if (
                  (0, slack_web_api_client_1.isDebugLogEnabled)(
                    this.env.SLACK_LOGGING_LEVEL,
                  )
                ) {
                  console.log(`*** Slack response ***
${(0, slack_web_api_client_1.prettyPrint)(slackResponse)}`);
                }
                if (this.startLazyListenerAfterAck) {
                  ctx.waitUntil(handler.lazy(slackRequest));
                }
                return (0, response_1.toCompleteResponse)(slackResponse);
              }
            }
          } else if (
            body.type === payload_types_1.PayloadType.MessageShortcut
          ) {
            const slackRequest = {
              payload: body,
              ...baseRequest,
            };
            for (const matcher of __classPrivateFieldGet(
              this,
              _SlackApp_messageShorcuts,
              "f",
            )) {
              const handler = matcher(payload);
              if (handler) {
                if (!this.startLazyListenerAfterAck) {
                  ctx.waitUntil(handler.lazy(slackRequest));
                }
                const slackResponse = await handler.ack(slackRequest);
                if (
                  (0, slack_web_api_client_1.isDebugLogEnabled)(
                    this.env.SLACK_LOGGING_LEVEL,
                  )
                ) {
                  console.log(`*** Slack response ***
${(0, slack_web_api_client_1.prettyPrint)(slackResponse)}`);
                }
                if (this.startLazyListenerAfterAck) {
                  ctx.waitUntil(handler.lazy(slackRequest));
                }
                return (0, response_1.toCompleteResponse)(slackResponse);
              }
            }
          } else if (body.type === payload_types_1.PayloadType.BlockAction) {
            const slackRequest = {
              // deno-lint-ignore no-explicit-any
              payload: body,
              ...baseRequest,
            };
            for (const matcher of __classPrivateFieldGet(
              this,
              _SlackApp_blockActions,
              "f",
            )) {
              const handler = matcher(payload);
              if (handler) {
                if (!this.startLazyListenerAfterAck) {
                  ctx.waitUntil(handler.lazy(slackRequest));
                }
                const slackResponse = await handler.ack(slackRequest);
                if (
                  (0, slack_web_api_client_1.isDebugLogEnabled)(
                    this.env.SLACK_LOGGING_LEVEL,
                  )
                ) {
                  console.log(`*** Slack response ***
${(0, slack_web_api_client_1.prettyPrint)(slackResponse)}`);
                }
                if (this.startLazyListenerAfterAck) {
                  ctx.waitUntil(handler.lazy(slackRequest));
                }
                return (0, response_1.toCompleteResponse)(slackResponse);
              }
            }
          } else if (
            body.type === payload_types_1.PayloadType.BlockSuggestion
          ) {
            const slackRequest = {
              payload: body,
              ...baseRequest,
            };
            for (const matcher of __classPrivateFieldGet(
              this,
              _SlackApp_blockSuggestions,
              "f",
            )) {
              const handler = matcher(payload);
              if (handler) {
                const slackResponse = await handler.ack(slackRequest);
                if (
                  (0, slack_web_api_client_1.isDebugLogEnabled)(
                    this.env.SLACK_LOGGING_LEVEL,
                  )
                ) {
                  console.log(`*** Slack response ***
${(0, slack_web_api_client_1.prettyPrint)(slackResponse)}`);
                }
                return (0, response_1.toCompleteResponse)(slackResponse);
              }
            }
          } else if (body.type === payload_types_1.PayloadType.ViewSubmission) {
            const slackRequest = {
              payload: body,
              ...baseRequest,
            };
            for (const matcher of __classPrivateFieldGet(
              this,
              _SlackApp_viewSubmissions,
              "f",
            )) {
              const handler = matcher(payload);
              if (handler) {
                if (!this.startLazyListenerAfterAck) {
                  ctx.waitUntil(handler.lazy(slackRequest));
                }
                const slackResponse = await handler.ack(slackRequest);
                if (
                  (0, slack_web_api_client_1.isDebugLogEnabled)(
                    this.env.SLACK_LOGGING_LEVEL,
                  )
                ) {
                  console.log(`*** Slack response ***
${(0, slack_web_api_client_1.prettyPrint)(slackResponse)}`);
                }
                if (this.startLazyListenerAfterAck) {
                  ctx.waitUntil(handler.lazy(slackRequest));
                }
                return (0, response_1.toCompleteResponse)(slackResponse);
              }
            }
          } else if (body.type === payload_types_1.PayloadType.ViewClosed) {
            const slackRequest = {
              payload: body,
              ...baseRequest,
            };
            for (const matcher of __classPrivateFieldGet(
              this,
              _SlackApp_viewClosed,
              "f",
            )) {
              const handler = matcher(payload);
              if (handler) {
                if (!this.startLazyListenerAfterAck) {
                  ctx.waitUntil(handler.lazy(slackRequest));
                }
                const slackResponse = await handler.ack(slackRequest);
                if (
                  (0, slack_web_api_client_1.isDebugLogEnabled)(
                    this.env.SLACK_LOGGING_LEVEL,
                  )
                ) {
                  console.log(`*** Slack response ***
${(0, slack_web_api_client_1.prettyPrint)(slackResponse)}`);
                }
                if (this.startLazyListenerAfterAck) {
                  ctx.waitUntil(handler.lazy(slackRequest));
                }
                return (0, response_1.toCompleteResponse)(slackResponse);
              }
            }
          } else if (body.type === payload_types_1.PayloadType.AppRateLimited) {
            const slackRequest = {
              payload: body,
              ...baseRequest,
            };
            if (__classPrivateFieldGet(this, _SlackApp_appRateLimited, "f")) {
              const handler = __classPrivateFieldGet(
                this,
                _SlackApp_appRateLimited,
                "f",
              ).call(this, payload);
              if (handler) {
                if (!this.startLazyListenerAfterAck) {
                  ctx.waitUntil(handler.lazy(slackRequest));
                }
                const slackResponse = await handler.ack(slackRequest);
                if (
                  (0, slack_web_api_client_1.isDebugLogEnabled)(
                    this.env.SLACK_LOGGING_LEVEL,
                  )
                ) {
                  console.log(`*** Slack response ***
${(0, slack_web_api_client_1.prettyPrint)(slackResponse)}`);
                }
                if (this.startLazyListenerAfterAck) {
                  ctx.waitUntil(handler.lazy(slackRequest));
                }
                return (0, response_1.toCompleteResponse)(slackResponse);
              }
            }
          }
          console.log(`*** No listener found ***
${JSON.stringify(baseRequest.body)}`);
          return new Response("No listener found", { status: 404 });
        }
        return new Response("Invalid signature", { status: 401 });
      }
    };
    exports.SlackApp = SlackApp2;
    ((_SlackApp_slashCommands = /* @__PURE__ */ new WeakMap()),
      (_SlackApp_events = /* @__PURE__ */ new WeakMap()),
      (_SlackApp_globalShorcuts = /* @__PURE__ */ new WeakMap()),
      (_SlackApp_messageShorcuts = /* @__PURE__ */ new WeakMap()),
      (_SlackApp_blockActions = /* @__PURE__ */ new WeakMap()),
      (_SlackApp_blockSuggestions = /* @__PURE__ */ new WeakMap()),
      (_SlackApp_viewSubmissions = /* @__PURE__ */ new WeakMap()),
      (_SlackApp_viewClosed = /* @__PURE__ */ new WeakMap()),
      (_SlackApp_appRateLimited = /* @__PURE__ */ new WeakMap()),
      (_SlackApp_assistantEnabled = /* @__PURE__ */ new WeakMap()),
      (_SlackApp_instances = /* @__PURE__ */ new WeakSet()),
      (_SlackApp_assistantEvent = function _SlackApp_assistantEvent2(
        event,
        lazy2,
        handleSelfBotMessageEvents = false,
      ) {
        __classPrivateFieldSet(this, _SlackApp_assistantEnabled, true, "f");
        __classPrivateFieldGet(this, _SlackApp_events, "f").push((body) => {
          if (
            body.type !== payload_types_1.PayloadType.EventsAPI ||
            !body.event
          ) {
            return null;
          }
          if (
            body.event.type === event &&
            __classPrivateFieldGet(this, _SlackApp_assistantEnabled, "f") &&
            (0, context_1.isAssitantThreadEvent)(body)
          ) {
            if (event === "message" && "bot_profile" in body.event) {
              if (handleSelfBotMessageEvents) {
                return { ack: async () => "", lazy: lazy2 };
              } else {
                return null;
              }
            } else {
              return { ack: async () => "", lazy: lazy2 };
            }
          }
          return null;
        });
        return this;
      }),
      (_SlackApp_callAuthorize = async function _SlackApp_callAuthorize2(
        request2,
      ) {
        const body = request2.body;
        if (
          body.type === payload_types_1.PayloadType.EventsAPI &&
          body.event &&
          this.eventsToSkipAuthorize.includes(body.event.type)
        ) {
          return {
            enterpriseId: request2.context.actorEnterpriseId,
            teamId: request2.context.actorTeamId,
            team: request2.context.actorTeamId,
            botId: request2.context.botId || "N/A",
            botUserId: request2.context.botUserId || "N/A",
            botToken: "N/A",
            botScopes: [],
            userId: request2.context.actorUserId,
            user: request2.context.actorUserId,
            userToken: "N/A",
            userScopes: [],
          };
        }
        return await this.authorize(request2);
      }));
    var noopLazyHandler = async () => {};
    exports.noopLazyHandler = noopLazyHandler;
  },
});

// node_modules/slack-edge/dist/app-env.js
var require_app_env = __commonJS({
  "node_modules/slack-edge/dist/app-env.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-edge/dist/assistant/thread-context.js
var require_thread_context = __commonJS({
  "node_modules/slack-edge/dist/assistant/thread-context.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-edge/dist/oauth/error-codes.js
var require_error_codes = __commonJS({
  "node_modules/slack-edge/dist/oauth/error-codes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OpenIDConnectError =
      exports.CompletionPageError =
      exports.InstallationStoreError =
      exports.InstallationError =
      exports.MissingCode =
      exports.InvalidStateParameter =
        void 0;
    exports.InvalidStateParameter = {
      code: "invalid-state",
      message: "The state parameter is missing or invalid",
    };
    exports.MissingCode = {
      code: "missing-code",
      message: "The code parameter is missing",
    };
    exports.InstallationError = {
      code: "installation-error",
      message: "The installation process failed",
    };
    exports.InstallationStoreError = {
      code: "installation-store-error",
      message: "Saving the installation data failed",
    };
    exports.CompletionPageError = {
      code: "completion-page-failure",
      message: "Rendering the completion page failed",
    };
    exports.OpenIDConnectError = {
      code: "oidc-error",
      message: "The OpenID Connect process failed",
    };
  },
});

// node_modules/slack-edge/dist/handler/handler.js
var require_handler = __commonJS({
  "node_modules/slack-edge/dist/handler/handler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-edge/dist/handler/message-handler.js
var require_message_handler = __commonJS({
  "node_modules/slack-edge/dist/handler/message-handler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-edge/dist/handler/options-handler.js
var require_options_handler = __commonJS({
  "node_modules/slack-edge/dist/handler/options-handler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-edge/dist/handler/view-handler.js
var require_view_handler = __commonJS({
  "node_modules/slack-edge/dist/handler/view-handler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-edge/dist/authorization/authorize.js
var require_authorize = __commonJS({
  "node_modules/slack-edge/dist/authorization/authorize.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-edge/dist/authorization/authorize-result.js
var require_authorize_result = __commonJS({
  "node_modules/slack-edge/dist/authorization/authorize-result.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-edge/dist/middleware/middleware.js
var require_middleware = __commonJS({
  "node_modules/slack-edge/dist/middleware/middleware.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-edge/dist/oauth/state-store.js
var require_state_store = __commonJS({
  "node_modules/slack-edge/dist/oauth/state-store.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NoStorageStateStore = void 0;
    var NoStorageStateStore = class {
      // deno-lint-ignore require-await
      async issueNewState() {
        return crypto.randomUUID();
      }
      // deno-lint-ignore require-await no-unused-vars
      async consume(state) {
        return true;
      }
    };
    exports.NoStorageStateStore = NoStorageStateStore;
  },
});

// node_modules/slack-edge/dist/oauth/authorize-url-generator.js
var require_authorize_url_generator = __commonJS({
  "node_modules/slack-edge/dist/oauth/authorize-url-generator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateAuthorizeUrl = generateAuthorizeUrl;
    function generateAuthorizeUrl(state, env, team = void 0) {
      let url2 = `https://slack.com/oauth/v2/authorize?state=${state}`;
      url2 += `&client_id=${env.SLACK_CLIENT_ID}`;
      url2 += `&scope=${env.SLACK_BOT_SCOPES}`;
      if (env.SLACK_USER_SCOPES) {
        url2 += `&user_scope=${env.SLACK_USER_SCOPES}`;
      }
      if (env.SLACK_REDIRECT_URI) {
        url2 += `&redirect_uri=${env.SLACK_REDIRECT_URI}`;
      }
      if (team) {
        url2 += `&team=${team}`;
      }
      return url2;
    }
  },
});

// node_modules/slack-edge/dist/cookie.js
var require_cookie = __commonJS({
  "node_modules/slack-edge/dist/cookie.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parse = parse7;
    function parse7(str, options = void 0) {
      if (typeof str !== "string") {
        throw new TypeError("argument str must be a string");
      }
      const obj = {};
      const opt = options || {};
      const dec = opt.decode || decode4;
      let index = 0;
      while (index < str.length) {
        const eqIdx = str.indexOf("=", index);
        if (eqIdx === -1) {
          break;
        }
        let endIdx = str.indexOf(";", index);
        if (endIdx === -1) {
          endIdx = str.length;
        } else if (endIdx < eqIdx) {
          index = str.lastIndexOf(";", eqIdx - 1) + 1;
          continue;
        }
        const key = str.slice(index, eqIdx).trim();
        if (void 0 === obj[key]) {
          let val = str.slice(eqIdx + 1, endIdx).trim();
          if (val.charCodeAt(0) === 34) {
            val = val.slice(1, -1);
          }
          obj[key] = tryDecode(val, dec);
        }
        index = endIdx + 1;
      }
      return obj;
    }
    function decode4(str) {
      return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
    }
    function tryDecode(str, decode5) {
      try {
        return decode5(str);
      } catch (e2) {
        return str;
      }
    }
  },
});

// node_modules/slack-edge/dist/oauth/installation.js
var require_installation = __commonJS({
  "node_modules/slack-edge/dist/oauth/installation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toInstallation = toInstallation;
    function toInstallation(oauthAccess) {
      const installation = {
        app_id: oauthAccess.app_id,
        is_enterprise_install: oauthAccess.is_enterprise_install,
        enterprise_id: oauthAccess.enterprise?.id,
        team_id: oauthAccess.team?.id,
        user_id: oauthAccess.authed_user?.id,
        // bot token
        bot_token: oauthAccess.access_token,
        bot_user_id: oauthAccess.bot_user_id,
        bot_scopes: oauthAccess.scope?.split(","),
        bot_refresh_token: oauthAccess.refresh_token,
        bot_token_expires_at: oauthAccess.expires_in
          ? /* @__PURE__ */ new Date().getTime() / 1e3 + oauthAccess.expires_in
          : void 0,
        // user token
        user_token: oauthAccess.authed_user?.access_token,
        user_scopes: oauthAccess.authed_user?.scope?.split(","),
        user_refresh_token: oauthAccess.authed_user?.refresh_token,
        user_token_expires_at: oauthAccess.authed_user?.expires_in
          ? /* @__PURE__ */ new Date().getTime() / 1e3 +
            oauthAccess.authed_user?.expires_in
          : void 0,
        // Only when having incoming-webhooks
        incoming_webhook_url: oauthAccess.incoming_webhook?.url,
        incoming_webhook_channel_id: oauthAccess.incoming_webhook?.channel_id,
        incoming_webhook_configuration_url: oauthAccess.incoming_webhook?.url,
      };
      return installation;
    }
  },
});

// node_modules/slack-edge/dist/oauth/escape-html.js
var require_escape_html = __commonJS({
  "node_modules/slack-edge/dist/oauth/escape-html.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.escapeHtml = escapeHtml;
    function escapeHtml(input) {
      if (input) {
        return input
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#x27;");
      }
      return "";
    }
  },
});

// node_modules/slack-edge/dist/oauth/oauth-page-renderer.js
var require_oauth_page_renderer = __commonJS({
  "node_modules/slack-edge/dist/oauth/oauth-page-renderer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.renderDefaultOAuthStartPage = renderDefaultOAuthStartPage;
    exports.renderSimpleCSSOAuthStartPage = renderSimpleCSSOAuthStartPage;
    exports.renderDefaultOAuthErrorPage = renderDefaultOAuthErrorPage;
    exports.renderSimpleCSSOAuthErrorPage = renderSimpleCSSOAuthErrorPage;
    exports.renderDefaultOAuthCompletionPage = renderDefaultOAuthCompletionPage;
    exports.renderSimpleCSSOAuthCompletionPage =
      renderSimpleCSSOAuthCompletionPage;
    var escape_html_1 = require_escape_html();
    async function renderDefaultOAuthStartPage({
      url: url2,
      immediateRedirect,
    }) {
      const meta = immediateRedirect
        ? `<meta http-equiv="refresh" content="2;url=${(0, escape_html_1.escapeHtml)(url2)}'" />`
        : "";
      return (
        "<html><head>" +
        meta +
        '<title>Redirecting to Slack ...</title></head><body>Redirecting to the Slack OAuth page ... Click <a href="' +
        (0, escape_html_1.escapeHtml)(url2) +
        '">here</a> to continue.</body></html>'
      );
    }
    async function renderSimpleCSSOAuthStartPage({
      url: url2,
      immediateRedirect,
    }) {
      const meta = immediateRedirect
        ? `<meta http-equiv="refresh" content="2;url=${(0, escape_html_1.escapeHtml)(url2)}'" />`
        : "";
      return `<html>
      <head>
      ${meta}
      <title>Redirecting to Slack ...</title>
      <link rel="stylesheet" href="https://cdn.simplecss.org/simple.min.css">
      </head>
      <body>
      <main>
      <h2>Installing Slack App</h2>
      <p>Redirecting to the Slack OAuth page ... Click <a href="${(0, escape_html_1.escapeHtml)(url2)}">here</a> to continue.</p>
      </main>
      </body>
      </html>`;
    }
    async function renderDefaultOAuthErrorPage({ installPath, reason }) {
      return (
        '<html><head><style>body {{ padding: 10px 15px; font-family: verdana; text-align: center; }}</style></head><body><h2>Oops, Something Went Wrong!</h2><p>Please try again from <a href="' +
        (0, escape_html_1.escapeHtml)(installPath) +
        '">here</a> or contact the app owner (reason: ' +
        (0, escape_html_1.escapeHtml)(reason.message) +
        ")</p></body></html>"
      );
    }
    async function renderSimpleCSSOAuthErrorPage({ installPath, reason }) {
      return `<html>
      <head>
      <link rel="stylesheet" href="https://cdn.simplecss.org/simple.min.css">
      </head>
      <body>
      <main>
      <h2>Oops, Something Went Wrong!</h2>
      <p>Please try again from <a href="${(0, escape_html_1.escapeHtml)(installPath)}">here</a> or contact the app owner (reason: ${(0, escape_html_1.escapeHtml)(reason.message)})</p>
      </main>
      </body>
      </html>`;
    }
    async function renderDefaultOAuthCompletionPage({
      appId,
      teamId,
      isEnterpriseInstall,
      enterpriseUrl,
    }) {
      let url2 = `slack://app?team=${teamId}&id=${appId}`;
      if (isEnterpriseInstall && enterpriseUrl !== void 0) {
        url2 = `${enterpriseUrl}manage/organization/apps/profile/${appId}/workspaces/add`;
      }
      const browserUrl = `https://app.slack.com/client/${teamId}`;
      return (
        '<html><head><meta http-equiv="refresh" content="0; URL=' +
        (0, escape_html_1.escapeHtml)(url2) +
        '"><style>body {{ padding: 10px 15px; font-family: verdana; text-align: center; }}</style></head><body><h2>Thank you!</h2><p>Redirecting to the Slack App... click <a href="' +
        (0, escape_html_1.escapeHtml)(url2) +
        '">here</a>. If you use the browser version of Slack, click <a href="' +
        (0, escape_html_1.escapeHtml)(browserUrl) +
        '" target="_blank">this link</a> instead.</p></body></html>'
      );
    }
    async function renderSimpleCSSOAuthCompletionPage({
      appId,
      teamId,
      isEnterpriseInstall,
      enterpriseUrl,
    }) {
      let url2 = `slack://app?team=${teamId}&id=${appId}`;
      if (isEnterpriseInstall && enterpriseUrl !== void 0) {
        url2 = `${enterpriseUrl}manage/organization/apps/profile/${appId}/workspaces/add`;
      }
      const browserUrl = `https://app.slack.com/client/${teamId}`;
      return `<html>
      <head>
      <meta http-equiv="refresh" content="0; URL=${(0, escape_html_1.escapeHtml)(url2)}">
      <link rel="stylesheet" href="https://cdn.simplecss.org/simple.min.css">
      </head>
      <body>
      <main>
      <h2>Thank you!</h2>
      <p>Redirecting to the Slack App... click <a href="${(0, escape_html_1.escapeHtml)(url2)}">here</a>.
      If you use the browser version of Slack, click <a href="${(0, escape_html_1.escapeHtml)(browserUrl)}" target="_blank">this link</a> instead.</p>
      </main>
      </body>
      </html>`;
    }
  },
});

// node_modules/slack-edge/dist/oauth/hook.js
var require_hook = __commonJS({
  "node_modules/slack-edge/dist/oauth/hook.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultOnStateValidationError = defaultOnStateValidationError;
    exports.defaultOnFailure = defaultOnFailure;
    exports.defaultOAuthStart = defaultOAuthStart;
    exports.defaultOAuthCallback = defaultOAuthCallback;
    var error_codes_1 = require_error_codes();
    var oauth_page_renderer_1 = require_oauth_page_renderer();
    function defaultOnStateValidationError(renderer) {
      return async ({ startPath }) => {
        const renderPage =
          renderer ?? oauth_page_renderer_1.renderDefaultOAuthErrorPage;
        return new Response(
          await renderPage({
            installPath: startPath,
            reason: error_codes_1.InvalidStateParameter,
          }),
          {
            status: 400,
            headers: { "Content-Type": "text/html; charset=utf-8" },
          },
        );
      };
    }
    function defaultOnFailure(renderer) {
      return async ({ startPath, reason }) => {
        const renderPage =
          renderer ?? oauth_page_renderer_1.renderDefaultOAuthErrorPage;
        return new Response(
          await renderPage({ installPath: startPath, reason }),
          {
            status: 400,
            headers: { "Content-Type": "text/html; charset=utf-8" },
          },
        );
      };
    }
    function defaultOAuthStart(startImmediateRedirect, renderer) {
      return async ({ authorizeUrl, stateCookieName, stateValue }) => {
        const immediateRedirect = startImmediateRedirect !== false;
        const status = immediateRedirect ? 302 : 200;
        const renderPage =
          renderer ?? oauth_page_renderer_1.renderDefaultOAuthStartPage;
        return new Response(
          await renderPage({ immediateRedirect, url: authorizeUrl }),
          {
            status,
            headers: {
              Location: authorizeUrl,
              "Set-Cookie": `${stateCookieName}=${stateValue}; Secure; HttpOnly; Path=/; Max-Age=300`,
              "Content-Type": "text/html; charset=utf-8",
            },
          },
        );
      };
    }
    function defaultOAuthCallback(renderer) {
      return async ({
        oauthAccess,
        enterpriseUrl,
        stateCookieName,
        installation,
        authTestResponse,
      }) => {
        const renderPage =
          renderer ?? oauth_page_renderer_1.renderDefaultOAuthCompletionPage;
        return new Response(
          await renderPage({
            appId: oauthAccess.app_id,
            teamId: oauthAccess.team?.id,
            isEnterpriseInstall: oauthAccess.is_enterprise_install,
            enterpriseUrl,
            installation,
            authTestResponse,
          }),
          {
            status: 200,
            headers: {
              "Set-Cookie": `${stateCookieName}=deleted; Secure; HttpOnly; Path=/; Max-Age=0`,
              "Content-Type": "text/html; charset=utf-8",
            },
          },
        );
      };
    }
  },
});

// node_modules/slack-edge/dist/oidc/hook.js
var require_hook2 = __commonJS({
  "node_modules/slack-edge/dist/oidc/hook.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultOpenIDConnectCallback = void 0;
    var slack_web_api_client_1 = require_dist2();
    var slack_web_api_client_2 = require_dist2();
    var defaultOpenIDConnectCallback = async ({ env, token }) => {
      const client = new slack_web_api_client_1.SlackAPIClient(
        token.access_token,
        {
          logLevel: env.SLACK_LOGGING_LEVEL,
        },
      );
      const userInfo = await client.openid.connect.userInfo();
      const body = `<html><head><style>body {{ padding: 10px 15px; font-family: verdana; text-align: center; }}</style></head><body><h1>It works!</h1><p>This is the default handler. To change this, pass \`oidc: { callback: async (token, req) => new Response("TODO") }\` to your SlackOAuthApp constructor.</p><pre>${(0, slack_web_api_client_2.prettyPrint)(userInfo)}</pre></body></html>`;
      return new Response(body, {
        status: 200,
        headers: { "Content-Type": "text/html; charset=utf-8" },
      });
    };
    exports.defaultOpenIDConnectCallback = defaultOpenIDConnectCallback;
  },
});

// node_modules/slack-edge/dist/oidc/authorize-url-generator.js
var require_authorize_url_generator2 = __commonJS({
  "node_modules/slack-edge/dist/oidc/authorize-url-generator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateOIDCAuthorizeUrl = generateOIDCAuthorizeUrl;
    var errors_1 = require_errors2();
    function generateOIDCAuthorizeUrl(state, env) {
      if (!env.SLACK_OIDC_SCOPES) {
        throw new errors_1.ConfigError(
          "env.SLACK_OIDC_SCOPES must be present when enabling Sign in with Slack (OpenID Connect)",
        );
      }
      if (!env.SLACK_OIDC_REDIRECT_URI) {
        throw new errors_1.ConfigError(
          "env.SLACK_OIDC_REDIRECT_URI must be present when enabling Sign in with Slack (OpenID Connect)",
        );
      }
      let url2 = `https://slack.com/openid/connect/authorize?response_type=code&state=${state}`;
      url2 += `&client_id=${env.SLACK_CLIENT_ID}`;
      url2 += `&scope=${env.SLACK_OIDC_SCOPES}`;
      url2 += `&redirect_uri=${env.SLACK_OIDC_REDIRECT_URI}`;
      return url2;
    }
  },
});

// node_modules/slack-edge/dist/oauth-app.js
var require_oauth_app = __commonJS({
  "node_modules/slack-edge/dist/oauth-app.js"(exports) {
    "use strict";
    var __classPrivateFieldGet =
      (exports && exports.__classPrivateFieldGet) ||
      function (receiver, state, kind, f2) {
        if (kind === "a" && !f2)
          throw new TypeError("Private accessor was defined without a getter");
        if (
          typeof state === "function"
            ? receiver !== state || !f2
            : !state.has(receiver)
        )
          throw new TypeError(
            "Cannot read private member from an object whose class did not declare it",
          );
        return kind === "m"
          ? f2
          : kind === "a"
            ? f2.call(receiver)
            : f2
              ? f2.value
              : state.get(receiver);
      };
    var _SlackOAuthApp_instances;
    var _SlackOAuthApp_enableTokenRevocationHandlers;
    var _SlackOAuthApp_validateStateParameter;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SlackOAuthApp = void 0;
    var execution_context_1 = require_execution_context();
    var app_1 = require_app();
    var state_store_1 = require_state_store();
    var authorize_url_generator_1 = require_authorize_url_generator();
    var cookie_1 = require_cookie();
    var slack_web_api_client_1 = require_dist2();
    var installation_1 = require_installation();
    var hook_1 = require_hook();
    var hook_2 = require_hook2();
    var authorize_url_generator_2 = require_authorize_url_generator2();
    var error_codes_1 = require_error_codes();
    var SlackOAuthApp = class extends app_1.SlackApp {
      constructor(options) {
        super({
          env: options.env,
          authorize: options.installationStore.toAuthorize(),
          authorizeErrorHandler: options.authorizeErrorHandler,
          routes: { events: options.routes?.events ?? "/slack/events" },
          startLazyListenerAfterAck: options.startLazyListenerAfterAck,
          ignoreSelfEvents: options.ignoreSelfEvents,
          assistantThreadContextStore: options.assistantThreadContextStore,
        });
        _SlackOAuthApp_instances.add(this);
        this.env = options.env;
        this.installationStore = options.installationStore;
        this.stateStore =
          options.stateStore ?? new state_store_1.NoStorageStateStore();
        this.oauth = {
          stateCookieName:
            options.oauth?.stateCookieName ?? "slack-app-oauth-state",
          onFailure:
            options.oauth?.onFailure ??
            (0, hook_1.defaultOnFailure)(options.oauth?.onFailureRenderer),
          onStateValidationError:
            options.oauth?.onStateValidationError ??
            (0, hook_1.defaultOnStateValidationError)(
              options.oauth?.onStateValidationRenderer,
            ),
          redirectUri:
            options.oauth?.redirectUri ?? this.env.SLACK_REDIRECT_URI,
          start:
            options.oauth?.start ??
            (0, hook_1.defaultOAuthStart)(
              options.oauth?.startImmediateRedirect,
              options.oauth?.startRenderer,
            ),
          beforeInstallation: options.oauth?.beforeInstallation,
          afterInstallation: options.oauth?.afterInstallation,
          callback:
            options.oauth?.callback ??
            (0, hook_1.defaultOAuthCallback)(options.oauth?.callbackRenderer),
        };
        if (options.oidc) {
          this.oidc = {
            stateCookieName:
              options.oidc.stateCookieName ?? "slack-app-oidc-state",
            onFailure:
              options.oidc.onFailure ??
              (0, hook_1.defaultOnFailure)(options.oidc?.onFailureRenderer),
            onStateValidationError:
              options.oidc.onStateValidationError ??
              (0, hook_1.defaultOnStateValidationError)(
                options.oidc?.onStateValidationRenderer,
              ),
            start:
              options.oidc?.start ??
              (0, hook_1.defaultOAuthStart)(
                options.oidc?.startImmediateRedirect,
                options.oidc?.startRenderer,
              ),
            callback:
              options.oidc.callback ?? hook_2.defaultOpenIDConnectCallback,
            redirectUri:
              options.oidc.redirectUri ?? this.env.SLACK_OIDC_REDIRECT_URI,
          };
        } else {
          this.oidc = void 0;
        }
        this.routes = options.routes
          ? options.routes
          : {
              events: "/slack/events",
              oauth: {
                start: "/slack/install",
                callback: "/slack/oauth_redirect",
              },
              oidc: {
                start: "/slack/login",
                callback: "/slack/login/callback",
              },
            };
        __classPrivateFieldGet(
          this,
          _SlackOAuthApp_instances,
          "m",
          _SlackOAuthApp_enableTokenRevocationHandlers,
        ).call(this, options.installationStore);
      }
      async run(
        request2,
        ctx = new execution_context_1.NoopExecutionContext(),
      ) {
        const url2 = new URL(request2.url);
        if (request2.method === "GET") {
          if (url2.pathname === this.routes.oauth.start) {
            return await this.handleOAuthStartRequest(request2);
          } else if (url2.pathname === this.routes.oauth.callback) {
            return await this.handleOAuthCallbackRequest(request2);
          }
          if (this.routes.oidc) {
            if (url2.pathname === this.routes.oidc.start) {
              return await this.handleOIDCStartRequest(request2);
            } else if (url2.pathname === this.routes.oidc.callback) {
              return await this.handleOIDCCallbackRequest(request2);
            }
          }
        } else if (request2.method === "POST") {
          if (url2.pathname === this.routes.events) {
            return await this.handleEventRequest(request2, ctx);
          }
        }
        return new Response("Not found", { status: 404 });
      }
      /**
       * Handles an HTTP request from Slack's API server and returns a response to it.
       * @param request request
       * @param ctx execution context
       * @returns response
       */
      async handleEventRequest(request2, ctx) {
        return await super.handleEventRequest(request2, ctx);
      }
      /**
       * Handles an HTTP request to initiate the app-installation OAuth flow within a web browser.
       * @param request request
       * @returns response
       */
      async handleOAuthStartRequest(request2) {
        const stateValue = await this.stateStore.issueNewState();
        const url2 = new URL(request2.url);
        const team = url2.searchParams.get("team") || void 0;
        const authorizeUrl = (0,
        authorize_url_generator_1.generateAuthorizeUrl)(
          stateValue,
          this.env,
          team,
        );
        return await this.oauth.start({
          env: this.env,
          authorizeUrl,
          stateCookieName: this.oauth.stateCookieName,
          stateValue,
          request: request2,
        });
      }
      /**
       * Handles an HTTP request to handle the app-installation OAuth flow callback within a web browser.
       * @param request request
       * @returns response
       */
      async handleOAuthCallbackRequest(request2) {
        const errorResponse = await __classPrivateFieldGet(
          this,
          _SlackOAuthApp_instances,
          "m",
          _SlackOAuthApp_validateStateParameter,
        ).call(
          this,
          request2,
          this.routes.oauth.start,
          this.oauth.stateCookieName,
        );
        if (errorResponse) {
          return errorResponse;
        }
        const { searchParams } = new URL(request2.url);
        const error45 = searchParams.get("error");
        if (!error45 && error45 !== null) {
          return await this.oauth.onFailure({
            env: this.env,
            startPath: this.routes.oauth.start,
            reason: {
              code: error45,
              message: `The installation process failed due to "${error45}"`,
            },
            request: request2,
          });
        }
        const code = searchParams.get("code");
        if (!code) {
          return await this.oauth.onFailure({
            env: this.env,
            startPath: this.routes.oauth.start,
            reason: error_codes_1.MissingCode,
            request: request2,
          });
        }
        if (this.oauth.beforeInstallation) {
          const response = await this.oauth.beforeInstallation({
            env: this.env,
            request: request2,
          });
          if (response) {
            return response;
          }
        }
        const client = new slack_web_api_client_1.SlackAPIClient(void 0, {
          logLevel: this.env.SLACK_LOGGING_LEVEL,
        });
        let oauthAccess;
        try {
          oauthAccess = await client.oauth.v2.access({
            client_id: this.env.SLACK_CLIENT_ID,
            client_secret: this.env.SLACK_CLIENT_SECRET,
            redirect_uri: this.oauth.redirectUri,
            code,
          });
        } catch (e2) {
          console.log(e2);
          return await this.oauth.onFailure({
            env: this.env,
            startPath: this.routes.oauth.start,
            reason: error_codes_1.InstallationError,
            request: request2,
          });
        }
        const installation = (0, installation_1.toInstallation)(oauthAccess);
        if (this.oauth.afterInstallation) {
          const response = await this.oauth.afterInstallation({
            env: this.env,
            request: request2,
            installation,
          });
          if (response) {
            return response;
          }
        }
        try {
          await this.installationStore.save(installation, request2);
        } catch (e2) {
          console.log(e2);
          return await this.oauth.onFailure({
            env: this.env,
            startPath: this.routes.oauth.start,
            reason: error_codes_1.InstallationStoreError,
            request: request2,
          });
        }
        try {
          const authTestResponse = await client.auth.test({
            token: oauthAccess.access_token,
          });
          const enterpriseUrl = authTestResponse.url;
          return await this.oauth.callback({
            env: this.env,
            oauthAccess,
            enterpriseUrl,
            stateCookieName: this.oauth.stateCookieName,
            installation,
            authTestResponse,
            request: request2,
          });
        } catch (e2) {
          console.log(e2);
          return await this.oauth.onFailure({
            env: this.env,
            startPath: this.routes.oauth.start,
            reason: error_codes_1.CompletionPageError,
            request: request2,
          });
        }
      }
      /**
       * Handles an HTTP request to initiate the SIWS flow within a web browser.
       * @param request request
       * @returns response
       */
      async handleOIDCStartRequest(request2) {
        if (!this.oidc) {
          return new Response("Not found", { status: 404 });
        }
        const stateValue = await this.stateStore.issueNewState();
        const authorizeUrl = (0,
        authorize_url_generator_2.generateOIDCAuthorizeUrl)(
          stateValue,
          this.env,
        );
        return await this.oidc.start({
          env: this.env,
          authorizeUrl,
          stateCookieName: this.oidc.stateCookieName,
          stateValue,
          request: request2,
        });
      }
      /**
       * Handles an HTTP request to handle the SIWS callback within a web browser.
       * @param request request
       * @returns response
       */
      async handleOIDCCallbackRequest(request2) {
        if (!this.oidc || !this.routes.oidc) {
          return new Response("Not found", { status: 404 });
        }
        const errorResponse = await __classPrivateFieldGet(
          this,
          _SlackOAuthApp_instances,
          "m",
          _SlackOAuthApp_validateStateParameter,
        ).call(
          this,
          request2,
          this.routes.oidc.start,
          this.oidc.stateCookieName,
        );
        if (errorResponse) {
          return errorResponse;
        }
        const { searchParams } = new URL(request2.url);
        const code = searchParams.get("code");
        if (!code) {
          return await this.oidc.onFailure({
            env: this.env,
            startPath: this.routes.oidc.start,
            reason: error_codes_1.MissingCode,
            request: request2,
          });
        }
        try {
          const client = new slack_web_api_client_1.SlackAPIClient(void 0, {
            logLevel: this.env.SLACK_LOGGING_LEVEL,
          });
          const token = await client.openid.connect.token({
            client_id: this.env.SLACK_CLIENT_ID,
            client_secret: this.env.SLACK_CLIENT_SECRET,
            redirect_uri: this.oidc.redirectUri,
            code,
          });
          return await this.oidc.callback({
            env: this.env,
            token,
            request: request2,
          });
        } catch (e2) {
          console.log(e2);
          return await this.oidc.onFailure({
            env: this.env,
            startPath: this.routes.oidc.start,
            reason: error_codes_1.OpenIDConnectError,
            request: request2,
          });
        }
      }
    };
    exports.SlackOAuthApp = SlackOAuthApp;
    ((_SlackOAuthApp_instances = /* @__PURE__ */ new WeakSet()),
      (_SlackOAuthApp_enableTokenRevocationHandlers =
        function _SlackOAuthApp_enableTokenRevocationHandlers2(
          installationStore,
        ) {
          this.event("tokens_revoked", async ({ payload, body }) => {
            if (
              Array.isArray(payload.tokens.bot) &&
              payload.tokens.bot.length > 0
            ) {
              try {
                await installationStore.deleteBotInstallation({
                  enterpriseId: body.enterprise_id,
                  teamId: body.team_id,
                });
              } catch (e2) {
                console.log(
                  `Failed to delete a bot installation (error: ${e2})`,
                );
              }
            }
            if (
              Array.isArray(payload.tokens.oauth) &&
              payload.tokens.oauth.length > 0
            ) {
              for (const userId of payload.tokens.oauth) {
                try {
                  await installationStore.deleteUserInstallation({
                    enterpriseId: body.enterprise_id,
                    teamId: body.team_id,
                    userId,
                  });
                } catch (e2) {
                  console.log(
                    `Failed to delete a user installation (error: ${e2})`,
                  );
                }
              }
            }
          });
          this.event("app_uninstalled", async ({ body }) => {
            try {
              await installationStore.deleteAll({
                enterpriseId: body.enterprise_id,
                teamId: body.team_id,
              });
            } catch (e2) {
              console.log(
                `Failed to delete all installation for an app_uninstalled event (error: ${e2})`,
              );
            }
          });
          this.event("app_uninstalled_team", async ({ body }) => {
            try {
              await installationStore.deleteAll({
                enterpriseId: body.enterprise_id,
                teamId: body.team_id,
              });
            } catch (e2) {
              console.log(
                `Failed to delete all installation for an app_uninstalled_team event (error: ${e2})`,
              );
            }
          });
        }),
      (_SlackOAuthApp_validateStateParameter =
        async function _SlackOAuthApp_validateStateParameter2(
          request2,
          startPath,
          cookieName,
        ) {
          const { searchParams } = new URL(request2.url);
          const queryState = searchParams.get("state");
          const cookie = (0, cookie_1.parse)(
            request2.headers.get("Cookie") || "",
          );
          const cookieState = cookie[cookieName];
          if (
            queryState !== cookieState ||
            !(await this.stateStore.consume(queryState))
          ) {
            if (startPath === this.routes.oauth.start) {
              return await this.oauth.onStateValidationError({
                env: this.env,
                startPath,
                request: request2,
              });
            } else if (
              this.oidc &&
              this.routes.oidc &&
              startPath === this.routes.oidc.start
            ) {
              return await this.oidc.onStateValidationError({
                env: this.env,
                startPath,
                request: request2,
              });
            }
          }
          return void 0;
        }));
  },
});

// node_modules/slack-edge/dist/oauth/installation-store.js
var require_installation_store = __commonJS({
  "node_modules/slack-edge/dist/oauth/installation-store.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-edge/dist/oidc/login.js
var require_login = __commonJS({
  "node_modules/slack-edge/dist/oidc/login.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toLogin = toLogin;
    function toLogin(token, userInfo) {
      return {
        enterprise_id: userInfo["https://slack.com/enterprise_id"],
        team_id: userInfo["https://slack.com/team_id"],
        user_id: userInfo["https://slack.com/user_id"],
        email: userInfo.email,
        picture: userInfo.picture,
        access_token: token.access_token,
        refresh_token: token.refresh_token,
        token_expires_at: token.expires_in
          ? /* @__PURE__ */ new Date().getTime() / 1e3 + token.expires_in
          : void 0,
      };
    }
  },
});

// node_modules/slack-edge/dist/request/request-body.js
var require_request_body = __commonJS({
  "node_modules/slack-edge/dist/request/request-body.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-edge/dist/request/request.js
var require_request2 = __commonJS({
  "node_modules/slack-edge/dist/request/request.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-edge/dist/request/payload/block-action.js
var require_block_action = __commonJS({
  "node_modules/slack-edge/dist/request/payload/block-action.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-edge/dist/request/payload/block-suggestion.js
var require_block_suggestion = __commonJS({
  "node_modules/slack-edge/dist/request/payload/block-suggestion.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-edge/dist/request/payload/event.js
var require_event = __commonJS({
  "node_modules/slack-edge/dist/request/payload/event.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-edge/dist/request/payload/global-shortcut.js
var require_global_shortcut = __commonJS({
  "node_modules/slack-edge/dist/request/payload/global-shortcut.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-edge/dist/request/payload/message-shortcut.js
var require_message_shortcut = __commonJS({
  "node_modules/slack-edge/dist/request/payload/message-shortcut.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-edge/dist/request/payload/slash-command.js
var require_slash_command = __commonJS({
  "node_modules/slack-edge/dist/request/payload/slash-command.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-edge/dist/request/payload/view-submission.js
var require_view_submission = __commonJS({
  "node_modules/slack-edge/dist/request/payload/view-submission.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-edge/dist/request/payload/view-closed.js
var require_view_closed = __commonJS({
  "node_modules/slack-edge/dist/request/payload/view-closed.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-edge/dist/request/payload/view-objects.js
var require_view_objects = __commonJS({
  "node_modules/slack-edge/dist/request/payload/view-objects.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-edge/dist/response/response-body.js
var require_response_body = __commonJS({
  "node_modules/slack-edge/dist/response/response-body.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  },
});

// node_modules/slack-edge/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/slack-edge/dist/index.js"(exports) {
    "use strict";
    var __createBinding =
      (exports && exports.__createBinding) ||
      (Object.create
        ? function (o2, m2, k, k2) {
            if (k2 === void 0) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m2, k);
            if (
              !desc ||
              ("get" in desc
                ? !m2.__esModule
                : desc.writable || desc.configurable)
            ) {
              desc = {
                enumerable: true,
                get: function () {
                  return m2[k];
                },
              };
            }
            Object.defineProperty(o2, k2, desc);
          }
        : function (o2, m2, k, k2) {
            if (k2 === void 0) k2 = k;
            o2[k2] = m2[k];
          });
    var __exportStar =
      (exports && exports.__exportStar) ||
      function (m2, exports2) {
        for (var p2 in m2)
          if (
            p2 !== "default" &&
            !Object.prototype.hasOwnProperty.call(exports2, p2)
          )
            __createBinding(exports2, m2, p2);
      };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_app(), exports);
    __exportStar(require_app_env(), exports);
    __exportStar(require_execution_context(), exports);
    __exportStar(require_dist2(), exports);
    __exportStar(require_assistant(), exports);
    __exportStar(require_thread_context(), exports);
    __exportStar(require_thread_context_store(), exports);
    __exportStar(require_errors2(), exports);
    __exportStar(require_error_codes(), exports);
    __exportStar(require_handler(), exports);
    __exportStar(require_message_handler(), exports);
    __exportStar(require_options_handler(), exports);
    __exportStar(require_view_handler(), exports);
    __exportStar(require_authorize(), exports);
    __exportStar(require_authorize_error_handler(), exports);
    __exportStar(require_authorize_result(), exports);
    __exportStar(require_single_team_authorize(), exports);
    __exportStar(require_middleware(), exports);
    __exportStar(require_built_in_middleware(), exports);
    __exportStar(require_context(), exports);
    __exportStar(require_oauth_app(), exports);
    __exportStar(require_authorize_url_generator(), exports);
    __exportStar(require_hook(), exports);
    __exportStar(require_escape_html(), exports);
    __exportStar(require_installation(), exports);
    __exportStar(require_installation_store(), exports);
    __exportStar(require_oauth_page_renderer(), exports);
    __exportStar(require_state_store(), exports);
    __exportStar(require_authorize_url_generator2(), exports);
    __exportStar(require_hook2(), exports);
    __exportStar(require_login(), exports);
    __exportStar(require_request_body(), exports);
    __exportStar(require_request_verification(), exports);
    __exportStar(require_request2(), exports);
    __exportStar(require_payload_types(), exports);
    __exportStar(require_block_action(), exports);
    __exportStar(require_block_suggestion(), exports);
    __exportStar(require_event(), exports);
    __exportStar(require_global_shortcut(), exports);
    __exportStar(require_message_shortcut(), exports);
    __exportStar(require_slash_command(), exports);
    __exportStar(require_view_submission(), exports);
    __exportStar(require_view_closed(), exports);
    __exportStar(require_view_objects(), exports);
    __exportStar(require_response2(), exports);
    __exportStar(require_response_body(), exports);
    __exportStar(require_socket_mode_client(), exports);
    __exportStar(require_payload_handler(), exports);
    __exportStar(require_message_events(), exports);
  },
});

// node_modules/@ai-sdk/provider/dist/index.mjs
var marker = "vercel.ai.error";
var symbol = Symbol.for(marker);
var _a;
var _AISDKError = class _AISDKError2 extends Error {
  /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */
  constructor({ name: name143, message, cause }) {
    super(message);
    this[_a] = true;
    this.name = name143;
    this.cause = cause;
  }
  /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */
  static isInstance(error45) {
    return _AISDKError2.hasMarker(error45, marker);
  }
  static hasMarker(error45, marker153) {
    const markerSymbol = Symbol.for(marker153);
    return (
      error45 != null &&
      typeof error45 === "object" &&
      markerSymbol in error45 &&
      typeof error45[markerSymbol] === "boolean" &&
      error45[markerSymbol] === true
    );
  }
};
_a = symbol;
var AISDKError = _AISDKError;
var name = "AI_APICallError";
var marker2 = `vercel.ai.error.${name}`;
var symbol2 = Symbol.for(marker2);
var _a2;
var APICallError = class extends AISDKError {
  constructor({
    message,
    url: url2,
    requestBodyValues,
    statusCode,
    responseHeaders,
    responseBody,
    cause,
    isRetryable = statusCode != null &&
      (statusCode === 408 || // request timeout
        statusCode === 409 || // conflict
        statusCode === 429 || // too many requests
        statusCode >= 500),
    // server error
    data,
  }) {
    super({ name, message, cause });
    this[_a2] = true;
    this.url = url2;
    this.requestBodyValues = requestBodyValues;
    this.statusCode = statusCode;
    this.responseHeaders = responseHeaders;
    this.responseBody = responseBody;
    this.isRetryable = isRetryable;
    this.data = data;
  }
  static isInstance(error45) {
    return AISDKError.hasMarker(error45, marker2);
  }
};
_a2 = symbol2;
var name2 = "AI_EmptyResponseBodyError";
var marker3 = `vercel.ai.error.${name2}`;
var symbol3 = Symbol.for(marker3);
var _a3;
var EmptyResponseBodyError = class extends AISDKError {
  // used in isInstance
  constructor({ message = "Empty response body" } = {}) {
    super({ name: name2, message });
    this[_a3] = true;
  }
  static isInstance(error45) {
    return AISDKError.hasMarker(error45, marker3);
  }
};
_a3 = symbol3;
function getErrorMessage(error45) {
  if (error45 == null) {
    return "unknown error";
  }
  if (typeof error45 === "string") {
    return error45;
  }
  if (error45 instanceof Error) {
    return error45.message;
  }
  return JSON.stringify(error45);
}
var name3 = "AI_InvalidArgumentError";
var marker4 = `vercel.ai.error.${name3}`;
var symbol4 = Symbol.for(marker4);
var _a4;
var InvalidArgumentError = class extends AISDKError {
  constructor({ message, cause, argument }) {
    super({ name: name3, message, cause });
    this[_a4] = true;
    this.argument = argument;
  }
  static isInstance(error45) {
    return AISDKError.hasMarker(error45, marker4);
  }
};
_a4 = symbol4;
var name4 = "AI_InvalidPromptError";
var marker5 = `vercel.ai.error.${name4}`;
var symbol5 = Symbol.for(marker5);
var _a5;
var InvalidPromptError = class extends AISDKError {
  constructor({ prompt, message, cause }) {
    super({ name: name4, message: `Invalid prompt: ${message}`, cause });
    this[_a5] = true;
    this.prompt = prompt;
  }
  static isInstance(error45) {
    return AISDKError.hasMarker(error45, marker5);
  }
};
_a5 = symbol5;
var name5 = "AI_InvalidResponseDataError";
var marker6 = `vercel.ai.error.${name5}`;
var symbol6 = Symbol.for(marker6);
var _a6;
_a6 = symbol6;
var name6 = "AI_JSONParseError";
var marker7 = `vercel.ai.error.${name6}`;
var symbol7 = Symbol.for(marker7);
var _a7;
var JSONParseError = class extends AISDKError {
  constructor({ text: text2, cause }) {
    super({
      name: name6,
      message: `JSON parsing failed: Text: ${text2}.
Error message: ${getErrorMessage(cause)}`,
      cause,
    });
    this[_a7] = true;
    this.text = text2;
  }
  static isInstance(error45) {
    return AISDKError.hasMarker(error45, marker7);
  }
};
_a7 = symbol7;
var name7 = "AI_LoadAPIKeyError";
var marker8 = `vercel.ai.error.${name7}`;
var symbol8 = Symbol.for(marker8);
var _a8;
_a8 = symbol8;
var name8 = "AI_LoadSettingError";
var marker9 = `vercel.ai.error.${name8}`;
var symbol9 = Symbol.for(marker9);
var _a9;
_a9 = symbol9;
var name9 = "AI_NoContentGeneratedError";
var marker10 = `vercel.ai.error.${name9}`;
var symbol10 = Symbol.for(marker10);
var _a10;
_a10 = symbol10;
var name10 = "AI_NoSuchModelError";
var marker11 = `vercel.ai.error.${name10}`;
var symbol11 = Symbol.for(marker11);
var _a11;
var NoSuchModelError = class extends AISDKError {
  constructor({
    errorName = name10,
    modelId,
    modelType,
    message = `No such ${modelType}: ${modelId}`,
  }) {
    super({ name: errorName, message });
    this[_a11] = true;
    this.modelId = modelId;
    this.modelType = modelType;
  }
  static isInstance(error45) {
    return AISDKError.hasMarker(error45, marker11);
  }
};
_a11 = symbol11;
var name11 = "AI_TooManyEmbeddingValuesForCallError";
var marker12 = `vercel.ai.error.${name11}`;
var symbol12 = Symbol.for(marker12);
var _a12;
_a12 = symbol12;
var name12 = "AI_TypeValidationError";
var marker13 = `vercel.ai.error.${name12}`;
var symbol13 = Symbol.for(marker13);
var _a13;
var _TypeValidationError = class _TypeValidationError2 extends AISDKError {
  constructor({ value, cause }) {
    super({
      name: name12,
      message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage(cause)}`,
      cause,
    });
    this[_a13] = true;
    this.value = value;
  }
  static isInstance(error45) {
    return AISDKError.hasMarker(error45, marker13);
  }
  /**
   * Wraps an error into a TypeValidationError.
   * If the cause is already a TypeValidationError with the same value, it returns the cause.
   * Otherwise, it creates a new TypeValidationError.
   *
   * @param {Object} params - The parameters for wrapping the error.
   * @param {unknown} params.value - The value that failed validation.
   * @param {unknown} params.cause - The original error or cause of the validation failure.
   * @returns {TypeValidationError} A TypeValidationError instance.
   */
  static wrap({ value, cause }) {
    return _TypeValidationError2.isInstance(cause) && cause.value === value
      ? cause
      : new _TypeValidationError2({ value, cause });
  }
};
_a13 = symbol13;
var TypeValidationError = _TypeValidationError;
var name13 = "AI_UnsupportedFunctionalityError";
var marker14 = `vercel.ai.error.${name13}`;
var symbol14 = Symbol.for(marker14);
var _a14;
_a14 = symbol14;

// node_modules/eventsource-parser/dist/index.js
var ParseError = class extends Error {
  constructor(message, options) {
    (super(message),
      (this.name = "ParseError"),
      (this.type = options.type),
      (this.field = options.field),
      (this.value = options.value),
      (this.line = options.line));
  }
};
function noop(_arg) {}
function createParser(callbacks) {
  if (typeof callbacks == "function")
    throw new TypeError(
      "`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?",
    );
  const {
    onEvent = noop,
    onError = noop,
    onRetry = noop,
    onComment,
  } = callbacks;
  let incompleteLine = "",
    isFirstChunk = true,
    id,
    data = "",
    eventType = "";
  function feed(newChunk) {
    const chunk = isFirstChunk
        ? newChunk.replace(/^\xEF\xBB\xBF/, "")
        : newChunk,
      [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`);
    for (const line of complete) parseLine(line);
    ((incompleteLine = incomplete), (isFirstChunk = false));
  }
  function parseLine(line) {
    if (line === "") {
      dispatchEvent();
      return;
    }
    if (line.startsWith(":")) {
      onComment && onComment(line.slice(line.startsWith(": ") ? 2 : 1));
      return;
    }
    const fieldSeparatorIndex = line.indexOf(":");
    if (fieldSeparatorIndex !== -1) {
      const field = line.slice(0, fieldSeparatorIndex),
        offset = line[fieldSeparatorIndex + 1] === " " ? 2 : 1,
        value = line.slice(fieldSeparatorIndex + offset);
      processField(field, value, line);
      return;
    }
    processField(line, "", line);
  }
  function processField(field, value, line) {
    switch (field) {
      case "event":
        eventType = value;
        break;
      case "data":
        data = `${data}${value}
`;
        break;
      case "id":
        id = value.includes("\0") ? void 0 : value;
        break;
      case "retry":
        /^\d+$/.test(value)
          ? onRetry(parseInt(value, 10))
          : onError(
              new ParseError(`Invalid \`retry\` value: "${value}"`, {
                type: "invalid-retry",
                value,
                line,
              }),
            );
        break;
      default:
        onError(
          new ParseError(
            `Unknown field "${field.length > 20 ? `${field.slice(0, 20)}\u2026` : field}"`,
            { type: "unknown-field", field, value, line },
          ),
        );
        break;
    }
  }
  function dispatchEvent() {
    (data.length > 0 &&
      onEvent({
        id,
        event: eventType || void 0,
        // If the data buffer's last character is a U+000A LINE FEED (LF) character,
        // then remove the last character from the data buffer.
        data: data.endsWith(`
`)
          ? data.slice(0, -1)
          : data,
      }),
      (id = void 0),
      (data = ""),
      (eventType = ""));
  }
  function reset(options = {}) {
    (incompleteLine && options.consume && parseLine(incompleteLine),
      (isFirstChunk = true),
      (id = void 0),
      (data = ""),
      (eventType = ""),
      (incompleteLine = ""));
  }
  return { feed, reset };
}
function splitLines(chunk) {
  const lines = [];
  let incompleteLine = "",
    searchIndex = 0;
  for (; searchIndex < chunk.length; ) {
    const crIndex = chunk.indexOf("\r", searchIndex),
      lfIndex = chunk.indexOf(
        `
`,
        searchIndex,
      );
    let lineEnd = -1;
    if (
      (crIndex !== -1 && lfIndex !== -1
        ? (lineEnd = Math.min(crIndex, lfIndex))
        : crIndex !== -1
          ? crIndex === chunk.length - 1
            ? (lineEnd = -1)
            : (lineEnd = crIndex)
          : lfIndex !== -1 && (lineEnd = lfIndex),
      lineEnd === -1)
    ) {
      incompleteLine = chunk.slice(searchIndex);
      break;
    } else {
      const line = chunk.slice(searchIndex, lineEnd);
      (lines.push(line),
        (searchIndex = lineEnd + 1),
        chunk[searchIndex - 1] === "\r" &&
          chunk[searchIndex] ===
            `
` &&
          searchIndex++);
    }
  }
  return [lines, incompleteLine];
}

// node_modules/eventsource-parser/dist/stream.js
var EventSourceParserStream = class extends TransformStream {
  constructor({ onError, onRetry, onComment } = {}) {
    let parser;
    super({
      start(controller) {
        parser = createParser({
          onEvent: (event) => {
            controller.enqueue(event);
          },
          onError(error45) {
            onError === "terminate"
              ? controller.error(error45)
              : typeof onError == "function" && onError(error45);
          },
          onRetry,
          onComment,
        });
      },
      transform(chunk) {
        parser.feed(chunk);
      },
    });
  }
};

// node_modules/zod/v4/classic/external.js
var external_exports = {};
__export(external_exports, {
  $brand: () => $brand,
  $input: () => $input,
  $output: () => $output,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBase64: () => ZodBase64,
  ZodBase64URL: () => ZodBase64URL,
  ZodBigInt: () => ZodBigInt,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBoolean: () => ZodBoolean,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCUID: () => ZodCUID,
  ZodCUID2: () => ZodCUID2,
  ZodCatch: () => ZodCatch,
  ZodCodec: () => ZodCodec,
  ZodCustom: () => ZodCustom,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodE164: () => ZodE164,
  ZodEmail: () => ZodEmail,
  ZodEmoji: () => ZodEmoji,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodFile: () => ZodFile,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodGUID: () => ZodGUID,
  ZodIPv4: () => ZodIPv4,
  ZodIPv6: () => ZodIPv6,
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodJWT: () => ZodJWT,
  ZodKSUID: () => ZodKSUID,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNanoID: () => ZodNanoID,
  ZodNever: () => ZodNever,
  ZodNonOptional: () => ZodNonOptional,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodPipe: () => ZodPipe,
  ZodPrefault: () => ZodPrefault,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRealError: () => ZodRealError,
  ZodRecord: () => ZodRecord,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodStringFormat: () => ZodStringFormat,
  ZodSuccess: () => ZodSuccess,
  ZodSymbol: () => ZodSymbol,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodTransform: () => ZodTransform,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodULID: () => ZodULID,
  ZodURL: () => ZodURL,
  ZodUUID: () => ZodUUID,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  ZodXID: () => ZodXID,
  _ZodString: () => _ZodString,
  _default: () => _default2,
  _function: () => _function,
  any: () => any,
  array: () => array,
  base64: () => base642,
  base64url: () => base64url2,
  bigint: () => bigint2,
  boolean: () => boolean2,
  catch: () => _catch2,
  check: () => check,
  cidrv4: () => cidrv42,
  cidrv6: () => cidrv62,
  clone: () => clone,
  codec: () => codec,
  coerce: () => coerce_exports,
  config: () => config,
  core: () => core_exports2,
  cuid: () => cuid3,
  cuid2: () => cuid22,
  custom: () => custom,
  date: () => date3,
  decode: () => decode2,
  decodeAsync: () => decodeAsync2,
  discriminatedUnion: () => discriminatedUnion,
  e164: () => e1642,
  email: () => email2,
  emoji: () => emoji2,
  encode: () => encode2,
  encodeAsync: () => encodeAsync2,
  endsWith: () => _endsWith,
  enum: () => _enum2,
  file: () => file,
  flattenError: () => flattenError,
  float32: () => float32,
  float64: () => float64,
  formatError: () => formatError,
  function: () => _function,
  getErrorMap: () => getErrorMap,
  globalRegistry: () => globalRegistry,
  gt: () => _gt,
  gte: () => _gte,
  guid: () => guid2,
  hash: () => hash,
  hex: () => hex2,
  hostname: () => hostname2,
  httpUrl: () => httpUrl,
  includes: () => _includes,
  instanceof: () => _instanceof,
  int: () => int,
  int32: () => int32,
  int64: () => int64,
  intersection: () => intersection,
  ipv4: () => ipv42,
  ipv6: () => ipv62,
  iso: () => iso_exports,
  json: () => json,
  jwt: () => jwt,
  keyof: () => keyof,
  ksuid: () => ksuid2,
  lazy: () => lazy,
  length: () => _length,
  literal: () => literal,
  locales: () => locales_exports,
  looseObject: () => looseObject,
  lowercase: () => _lowercase,
  lt: () => _lt,
  lte: () => _lte,
  map: () => map,
  maxLength: () => _maxLength,
  maxSize: () => _maxSize,
  mime: () => _mime,
  minLength: () => _minLength,
  minSize: () => _minSize,
  multipleOf: () => _multipleOf,
  nan: () => nan,
  nanoid: () => nanoid2,
  nativeEnum: () => nativeEnum,
  negative: () => _negative,
  never: () => never,
  nonnegative: () => _nonnegative,
  nonoptional: () => nonoptional,
  nonpositive: () => _nonpositive,
  normalize: () => _normalize,
  null: () => _null3,
  nullable: () => nullable,
  nullish: () => nullish2,
  number: () => number2,
  object: () => object,
  optional: () => optional,
  overwrite: () => _overwrite,
  parse: () => parse2,
  parseAsync: () => parseAsync2,
  partialRecord: () => partialRecord,
  pipe: () => pipe,
  positive: () => _positive,
  prefault: () => prefault,
  preprocess: () => preprocess,
  prettifyError: () => prettifyError,
  promise: () => promise,
  property: () => _property,
  readonly: () => readonly,
  record: () => record,
  refine: () => refine,
  regex: () => _regex,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeDecode: () => safeDecode2,
  safeDecodeAsync: () => safeDecodeAsync2,
  safeEncode: () => safeEncode2,
  safeEncodeAsync: () => safeEncodeAsync2,
  safeParse: () => safeParse2,
  safeParseAsync: () => safeParseAsync2,
  set: () => set,
  setErrorMap: () => setErrorMap,
  size: () => _size,
  startsWith: () => _startsWith,
  strictObject: () => strictObject,
  string: () => string2,
  stringFormat: () => stringFormat,
  stringbool: () => stringbool,
  success: () => success,
  superRefine: () => superRefine,
  symbol: () => symbol15,
  templateLiteral: () => templateLiteral,
  toJSONSchema: () => toJSONSchema,
  toLowerCase: () => _toLowerCase,
  toUpperCase: () => _toUpperCase,
  transform: () => transform,
  treeifyError: () => treeifyError,
  trim: () => _trim,
  tuple: () => tuple,
  uint32: () => uint32,
  uint64: () => uint64,
  ulid: () => ulid2,
  undefined: () => _undefined3,
  union: () => union,
  unknown: () => unknown,
  uppercase: () => _uppercase,
  url: () => url,
  util: () => util_exports,
  uuid: () => uuid2,
  uuidv4: () => uuidv4,
  uuidv6: () => uuidv6,
  uuidv7: () => uuidv7,
  void: () => _void2,
  xid: () => xid2,
});

// node_modules/zod/v4/core/index.js
var core_exports2 = {};
__export(core_exports2, {
  $ZodAny: () => $ZodAny,
  $ZodArray: () => $ZodArray,
  $ZodAsyncError: () => $ZodAsyncError,
  $ZodBase64: () => $ZodBase64,
  $ZodBase64URL: () => $ZodBase64URL,
  $ZodBigInt: () => $ZodBigInt,
  $ZodBigIntFormat: () => $ZodBigIntFormat,
  $ZodBoolean: () => $ZodBoolean,
  $ZodCIDRv4: () => $ZodCIDRv4,
  $ZodCIDRv6: () => $ZodCIDRv6,
  $ZodCUID: () => $ZodCUID,
  $ZodCUID2: () => $ZodCUID2,
  $ZodCatch: () => $ZodCatch,
  $ZodCheck: () => $ZodCheck,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,
  $ZodCheckIncludes: () => $ZodCheckIncludes,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,
  $ZodCheckLessThan: () => $ZodCheckLessThan,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize,
  $ZodCheckMimeType: () => $ZodCheckMimeType,
  $ZodCheckMinLength: () => $ZodCheckMinLength,
  $ZodCheckMinSize: () => $ZodCheckMinSize,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite,
  $ZodCheckProperty: () => $ZodCheckProperty,
  $ZodCheckRegex: () => $ZodCheckRegex,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase,
  $ZodCodec: () => $ZodCodec,
  $ZodCustom: () => $ZodCustom,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat,
  $ZodDate: () => $ZodDate,
  $ZodDefault: () => $ZodDefault,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,
  $ZodE164: () => $ZodE164,
  $ZodEmail: () => $ZodEmail,
  $ZodEmoji: () => $ZodEmoji,
  $ZodEncodeError: () => $ZodEncodeError,
  $ZodEnum: () => $ZodEnum,
  $ZodError: () => $ZodError,
  $ZodFile: () => $ZodFile,
  $ZodFunction: () => $ZodFunction,
  $ZodGUID: () => $ZodGUID,
  $ZodIPv4: () => $ZodIPv4,
  $ZodIPv6: () => $ZodIPv6,
  $ZodISODate: () => $ZodISODate,
  $ZodISODateTime: () => $ZodISODateTime,
  $ZodISODuration: () => $ZodISODuration,
  $ZodISOTime: () => $ZodISOTime,
  $ZodIntersection: () => $ZodIntersection,
  $ZodJWT: () => $ZodJWT,
  $ZodKSUID: () => $ZodKSUID,
  $ZodLazy: () => $ZodLazy,
  $ZodLiteral: () => $ZodLiteral,
  $ZodMap: () => $ZodMap,
  $ZodNaN: () => $ZodNaN,
  $ZodNanoID: () => $ZodNanoID,
  $ZodNever: () => $ZodNever,
  $ZodNonOptional: () => $ZodNonOptional,
  $ZodNull: () => $ZodNull,
  $ZodNullable: () => $ZodNullable,
  $ZodNumber: () => $ZodNumber,
  $ZodNumberFormat: () => $ZodNumberFormat,
  $ZodObject: () => $ZodObject,
  $ZodObjectJIT: () => $ZodObjectJIT,
  $ZodOptional: () => $ZodOptional,
  $ZodPipe: () => $ZodPipe,
  $ZodPrefault: () => $ZodPrefault,
  $ZodPromise: () => $ZodPromise,
  $ZodReadonly: () => $ZodReadonly,
  $ZodRealError: () => $ZodRealError,
  $ZodRecord: () => $ZodRecord,
  $ZodRegistry: () => $ZodRegistry,
  $ZodSet: () => $ZodSet,
  $ZodString: () => $ZodString,
  $ZodStringFormat: () => $ZodStringFormat,
  $ZodSuccess: () => $ZodSuccess,
  $ZodSymbol: () => $ZodSymbol,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral,
  $ZodTransform: () => $ZodTransform,
  $ZodTuple: () => $ZodTuple,
  $ZodType: () => $ZodType,
  $ZodULID: () => $ZodULID,
  $ZodURL: () => $ZodURL,
  $ZodUUID: () => $ZodUUID,
  $ZodUndefined: () => $ZodUndefined,
  $ZodUnion: () => $ZodUnion,
  $ZodUnknown: () => $ZodUnknown,
  $ZodVoid: () => $ZodVoid,
  $ZodXID: () => $ZodXID,
  $brand: () => $brand,
  $constructor: () => $constructor,
  $input: () => $input,
  $output: () => $output,
  Doc: () => Doc,
  JSONSchema: () => json_schema_exports,
  JSONSchemaGenerator: () => JSONSchemaGenerator,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  _any: () => _any,
  _array: () => _array,
  _base64: () => _base64,
  _base64url: () => _base64url,
  _bigint: () => _bigint,
  _boolean: () => _boolean,
  _catch: () => _catch,
  _check: () => _check,
  _cidrv4: () => _cidrv4,
  _cidrv6: () => _cidrv6,
  _coercedBigint: () => _coercedBigint,
  _coercedBoolean: () => _coercedBoolean,
  _coercedDate: () => _coercedDate,
  _coercedNumber: () => _coercedNumber,
  _coercedString: () => _coercedString,
  _cuid: () => _cuid,
  _cuid2: () => _cuid2,
  _custom: () => _custom,
  _date: () => _date,
  _decode: () => _decode,
  _decodeAsync: () => _decodeAsync,
  _default: () => _default,
  _discriminatedUnion: () => _discriminatedUnion,
  _e164: () => _e164,
  _email: () => _email,
  _emoji: () => _emoji2,
  _encode: () => _encode,
  _encodeAsync: () => _encodeAsync,
  _endsWith: () => _endsWith,
  _enum: () => _enum,
  _file: () => _file,
  _float32: () => _float32,
  _float64: () => _float64,
  _gt: () => _gt,
  _gte: () => _gte,
  _guid: () => _guid,
  _includes: () => _includes,
  _int: () => _int,
  _int32: () => _int32,
  _int64: () => _int64,
  _intersection: () => _intersection,
  _ipv4: () => _ipv4,
  _ipv6: () => _ipv6,
  _isoDate: () => _isoDate,
  _isoDateTime: () => _isoDateTime,
  _isoDuration: () => _isoDuration,
  _isoTime: () => _isoTime,
  _jwt: () => _jwt,
  _ksuid: () => _ksuid,
  _lazy: () => _lazy,
  _length: () => _length,
  _literal: () => _literal,
  _lowercase: () => _lowercase,
  _lt: () => _lt,
  _lte: () => _lte,
  _map: () => _map,
  _max: () => _lte,
  _maxLength: () => _maxLength,
  _maxSize: () => _maxSize,
  _mime: () => _mime,
  _min: () => _gte,
  _minLength: () => _minLength,
  _minSize: () => _minSize,
  _multipleOf: () => _multipleOf,
  _nan: () => _nan,
  _nanoid: () => _nanoid,
  _nativeEnum: () => _nativeEnum,
  _negative: () => _negative,
  _never: () => _never,
  _nonnegative: () => _nonnegative,
  _nonoptional: () => _nonoptional,
  _nonpositive: () => _nonpositive,
  _normalize: () => _normalize,
  _null: () => _null2,
  _nullable: () => _nullable,
  _number: () => _number,
  _optional: () => _optional,
  _overwrite: () => _overwrite,
  _parse: () => _parse,
  _parseAsync: () => _parseAsync,
  _pipe: () => _pipe,
  _positive: () => _positive,
  _promise: () => _promise,
  _property: () => _property,
  _readonly: () => _readonly,
  _record: () => _record,
  _refine: () => _refine,
  _regex: () => _regex,
  _safeDecode: () => _safeDecode,
  _safeDecodeAsync: () => _safeDecodeAsync,
  _safeEncode: () => _safeEncode,
  _safeEncodeAsync: () => _safeEncodeAsync,
  _safeParse: () => _safeParse,
  _safeParseAsync: () => _safeParseAsync,
  _set: () => _set,
  _size: () => _size,
  _startsWith: () => _startsWith,
  _string: () => _string,
  _stringFormat: () => _stringFormat,
  _stringbool: () => _stringbool,
  _success: () => _success,
  _superRefine: () => _superRefine,
  _symbol: () => _symbol,
  _templateLiteral: () => _templateLiteral,
  _toLowerCase: () => _toLowerCase,
  _toUpperCase: () => _toUpperCase,
  _transform: () => _transform,
  _trim: () => _trim,
  _tuple: () => _tuple,
  _uint32: () => _uint32,
  _uint64: () => _uint64,
  _ulid: () => _ulid,
  _undefined: () => _undefined2,
  _union: () => _union,
  _unknown: () => _unknown,
  _uppercase: () => _uppercase,
  _url: () => _url,
  _uuid: () => _uuid,
  _uuidv4: () => _uuidv4,
  _uuidv6: () => _uuidv6,
  _uuidv7: () => _uuidv7,
  _void: () => _void,
  _xid: () => _xid,
  clone: () => clone,
  config: () => config,
  decode: () => decode,
  decodeAsync: () => decodeAsync,
  encode: () => encode,
  encodeAsync: () => encodeAsync,
  flattenError: () => flattenError,
  formatError: () => formatError,
  globalConfig: () => globalConfig,
  globalRegistry: () => globalRegistry,
  isValidBase64: () => isValidBase64,
  isValidBase64URL: () => isValidBase64URL,
  isValidJWT: () => isValidJWT,
  locales: () => locales_exports,
  parse: () => parse,
  parseAsync: () => parseAsync,
  prettifyError: () => prettifyError,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeDecode: () => safeDecode,
  safeDecodeAsync: () => safeDecodeAsync,
  safeEncode: () => safeEncode,
  safeEncodeAsync: () => safeEncodeAsync,
  safeParse: () => safeParse,
  safeParseAsync: () => safeParseAsync,
  toDotPath: () => toDotPath,
  toJSONSchema: () => toJSONSchema,
  treeifyError: () => treeifyError,
  util: () => util_exports,
  version: () => version,
});

// node_modules/zod/v4/core/core.js
var NEVER = Object.freeze({
  status: "aborted",
});
// @__NO_SIDE_EFFECTS__
function $constructor(name18, initializer4, params) {
  function init(inst, def) {
    var _a19;
    Object.defineProperty(inst, "_zod", {
      value: inst._zod ?? {},
      enumerable: false,
    });
    (_a19 = inst._zod).traits ?? (_a19.traits = /* @__PURE__ */ new Set());
    inst._zod.traits.add(name18);
    initializer4(inst, def);
    for (const k in _2.prototype) {
      if (!(k in inst))
        Object.defineProperty(inst, k, { value: _2.prototype[k].bind(inst) });
    }
    inst._zod.constr = _2;
    inst._zod.def = def;
  }
  const Parent = params?.Parent ?? Object;
  class Definition extends Parent {}
  Object.defineProperty(Definition, "name", { value: name18 });
  function _2(def) {
    var _a19;
    const inst = params?.Parent ? new Definition() : this;
    init(inst, def);
    (_a19 = inst._zod).deferred ?? (_a19.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_2, "init", { value: init });
  Object.defineProperty(_2, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent) return true;
      return inst?._zod?.traits?.has(name18);
    },
  });
  Object.defineProperty(_2, "name", { value: name18 });
  return _2;
}
var $brand = Symbol("zod_brand");
var $ZodAsyncError = class extends Error {
  constructor() {
    super(
      `Encountered Promise during synchronous parse. Use .parseAsync() instead.`,
    );
  }
};
var $ZodEncodeError = class extends Error {
  constructor(name18) {
    super(`Encountered unidirectional transform during encode: ${name18}`);
    this.name = "ZodEncodeError";
  }
};
var globalConfig = {};
function config(newConfig) {
  if (newConfig) Object.assign(globalConfig, newConfig);
  return globalConfig;
}

// node_modules/zod/v4/core/util.js
var util_exports = {};
__export(util_exports, {
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,
  Class: () => Class,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  aborted: () => aborted,
  allowsEval: () => allowsEval,
  assert: () => assert,
  assertEqual: () => assertEqual,
  assertIs: () => assertIs,
  assertNever: () => assertNever,
  assertNotEqual: () => assertNotEqual,
  assignProp: () => assignProp,
  base64ToUint8Array: () => base64ToUint8Array,
  base64urlToUint8Array: () => base64urlToUint8Array,
  cached: () => cached,
  captureStackTrace: () => captureStackTrace,
  cleanEnum: () => cleanEnum,
  cleanRegex: () => cleanRegex,
  clone: () => clone,
  cloneDef: () => cloneDef,
  createTransparentProxy: () => createTransparentProxy,
  defineLazy: () => defineLazy,
  esc: () => esc,
  escapeRegex: () => escapeRegex,
  extend: () => extend,
  finalizeIssue: () => finalizeIssue,
  floatSafeRemainder: () => floatSafeRemainder,
  getElementAtPath: () => getElementAtPath,
  getEnumValues: () => getEnumValues,
  getLengthableOrigin: () => getLengthableOrigin,
  getParsedType: () => getParsedType,
  getSizableOrigin: () => getSizableOrigin,
  hexToUint8Array: () => hexToUint8Array,
  isObject: () => isObject,
  isPlainObject: () => isPlainObject,
  issue: () => issue,
  joinValues: () => joinValues,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  merge: () => merge,
  mergeDefs: () => mergeDefs,
  normalizeParams: () => normalizeParams,
  nullish: () => nullish,
  numKeys: () => numKeys,
  objectClone: () => objectClone,
  omit: () => omit,
  optionalKeys: () => optionalKeys,
  partial: () => partial,
  pick: () => pick,
  prefixIssues: () => prefixIssues,
  primitiveTypes: () => primitiveTypes,
  promiseAllObject: () => promiseAllObject,
  propertyKeyTypes: () => propertyKeyTypes,
  randomString: () => randomString,
  required: () => required,
  safeExtend: () => safeExtend,
  shallowClone: () => shallowClone,
  stringifyPrimitive: () => stringifyPrimitive,
  uint8ArrayToBase64: () => uint8ArrayToBase64,
  uint8ArrayToBase64url: () => uint8ArrayToBase64url,
  uint8ArrayToHex: () => uint8ArrayToHex,
  unwrapMessage: () => unwrapMessage,
});
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {}
function assertNever(_x) {
  throw new Error();
}
function assert(_2) {}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter(
    (v2) => typeof v2 === "number",
  );
  const values = Object.entries(entries)
    .filter(([k, _2]) => numericValues.indexOf(+k) === -1)
    .map(([_2, v2]) => v2);
  return values;
}
function joinValues(array3, separator = "|") {
  return array3.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_2, value) {
  if (typeof value === "bigint") return value.toString();
  return value;
}
function cached(getter) {
  const set2 = false;
  return {
    get value() {
      if (!set2) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    },
  };
}
function nullish(input) {
  return input === null || input === void 0;
}
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepString = step.toString();
  let stepDecCount = (stepString.split(".")[1] || "").length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    const match = stepString.match(/\d?e-(\d?)/);
    if (match?.[1]) {
      stepDecCount = Number.parseInt(match[1]);
    }
  }
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return (valInt % stepInt) / 10 ** decCount;
}
var EVALUATING = Symbol("evaluating");
function defineLazy(object4, key, getter) {
  let value = void 0;
  Object.defineProperty(object4, key, {
    get() {
      if (value === EVALUATING) {
        return void 0;
      }
      if (value === void 0) {
        value = EVALUATING;
        value = getter();
      }
      return value;
    },
    set(v2) {
      Object.defineProperty(object4, key, {
        value: v2,
        // configurable: true,
      });
    },
    configurable: true,
  });
}
function objectClone(obj) {
  return Object.create(
    Object.getPrototypeOf(obj),
    Object.getOwnPropertyDescriptors(obj),
  );
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true,
  });
}
function mergeDefs(...defs) {
  const mergedDescriptors = {};
  for (const def of defs) {
    const descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
function cloneDef(schema) {
  return mergeDefs(schema._zod.def);
}
function getElementAtPath(obj, path) {
  if (!path) return obj;
  return path.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i2 = 0; i2 < keys.length; i2++) {
      resolvedObj[keys[i2]] = results[i2];
    }
    return resolvedObj;
  });
}
function randomString(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i2 = 0; i2 < length; i2++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
function esc(str) {
  return JSON.stringify(str);
}
var captureStackTrace =
  "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {};
function isObject(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
var allowsEval = cached(() => {
  if (
    typeof navigator !== "undefined" &&
    navigator?.userAgent?.includes("Cloudflare")
  ) {
    return false;
  }
  try {
    const F = Function;
    new F("");
    return true;
  } catch (_2) {
    return false;
  }
});
function isPlainObject(o2) {
  if (isObject(o2) === false) return false;
  const ctor = o2.constructor;
  if (ctor === void 0) return true;
  const prot = ctor.prototype;
  if (isObject(prot) === false) return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function shallowClone(o2) {
  if (isPlainObject(o2)) return { ...o2 };
  if (Array.isArray(o2)) return [...o2];
  return o2;
}
function numKeys(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
var getParsedType = (data) => {
  const t2 = typeof data;
  switch (t2) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (
        data.then &&
        typeof data.then === "function" &&
        data.catch &&
        typeof data.catch === "function"
      ) {
        return "promise";
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t2}`);
  }
};
var propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
var primitiveTypes = /* @__PURE__ */ new Set([
  "string",
  "number",
  "bigint",
  "boolean",
  "symbol",
  "undefined",
]);
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent) cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params) return {};
  if (typeof params === "string") return { error: () => params };
  if (params?.message !== void 0) {
    if (params?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy(
    {},
    {
      get(_2, prop, receiver) {
        target ?? (target = getter());
        return Reflect.get(target, prop, receiver);
      },
      set(_2, prop, value, receiver) {
        target ?? (target = getter());
        return Reflect.set(target, prop, value, receiver);
      },
      has(_2, prop) {
        target ?? (target = getter());
        return Reflect.has(target, prop);
      },
      deleteProperty(_2, prop) {
        target ?? (target = getter());
        return Reflect.deleteProperty(target, prop);
      },
      ownKeys(_2) {
        target ?? (target = getter());
        return Reflect.ownKeys(target);
      },
      getOwnPropertyDescriptor(_2, prop) {
        target ?? (target = getter());
        return Reflect.getOwnPropertyDescriptor(target, prop);
      },
      defineProperty(_2, prop, descriptor) {
        target ?? (target = getter());
        return Reflect.defineProperty(target, prop, descriptor);
      },
    },
  );
}
function stringifyPrimitive(value) {
  if (typeof value === "bigint") return value.toString() + "n";
  if (typeof value === "string") return `"${value}"`;
  return `${value}`;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => {
    return (
      shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional"
    );
  });
}
var NUMBER_FORMAT_RANGES = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE],
};
var BIGINT_FORMAT_RANGES = {
  int64: [
    /* @__PURE__ */ BigInt("-9223372036854775808"),
    /* @__PURE__ */ BigInt("9223372036854775807"),
  ],
  uint64: [
    /* @__PURE__ */ BigInt(0),
    /* @__PURE__ */ BigInt("18446744073709551615"),
  ],
};
function pick(schema, mask) {
  const currDef = schema._zod.def;
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = {};
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key]) continue;
        newShape[key] = currDef.shape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: [],
  });
  return clone(schema, def);
}
function omit(schema, mask) {
  const currDef = schema._zod.def;
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = { ...schema._zod.def.shape };
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key]) continue;
        delete newShape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: [],
  });
  return clone(schema, def);
}
function extend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const checks = schema._zod.def.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(
      "Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.",
    );
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: [],
  });
  return clone(schema, def);
}
function safeExtend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to safeExtend: expected a plain object");
  }
  const def = {
    ...schema._zod.def,
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: schema._zod.def.checks,
  };
  return clone(schema, def);
}
function merge(a2, b2) {
  const def = mergeDefs(a2._zod.def, {
    get shape() {
      const _shape = { ...a2._zod.def.shape, ...b2._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    get catchall() {
      return b2._zod.def.catchall;
    },
    checks: [],
    // delete existing checks
  });
  return clone(a2, def);
}
function partial(Class2, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in oldShape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key]) continue;
          shape[key] = Class2
            ? new Class2({
                type: "optional",
                innerType: oldShape[key],
              })
            : oldShape[key];
        }
      } else {
        for (const key in oldShape) {
          shape[key] = Class2
            ? new Class2({
                type: "optional",
                innerType: oldShape[key],
              })
            : oldShape[key];
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: [],
  });
  return clone(schema, def);
}
function required(Class2, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key]) continue;
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key],
          });
        }
      } else {
        for (const key in oldShape) {
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key],
          });
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: [],
  });
  return clone(schema, def);
}
function aborted(x, startIndex = 0) {
  if (x.aborted === true) return true;
  for (let i2 = startIndex; i2 < x.issues.length; i2++) {
    if (x.issues[i2]?.continue !== true) {
      return true;
    }
  }
  return false;
}
function prefixIssues(path, issues) {
  return issues.map((iss) => {
    var _a19;
    (_a19 = iss).path ?? (_a19.path = []);
    iss.path.unshift(path);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config3) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message =
      unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ??
      unwrapMessage(ctx?.error?.(iss)) ??
      unwrapMessage(config3.customError?.(iss)) ??
      unwrapMessage(config3.localeError?.(iss)) ??
      "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin(input) {
  if (input instanceof Set) return "set";
  if (input instanceof Map) return "map";
  if (input instanceof File) return "file";
  return "unknown";
}
function getLengthableOrigin(input) {
  if (Array.isArray(input)) return "array";
  if (typeof input === "string") return "string";
  return "unknown";
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst,
    };
  }
  return { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj)
    .filter(([k, _2]) => {
      return Number.isNaN(Number.parseInt(k, 10));
    })
    .map((el) => el[1]);
}
function base64ToUint8Array(base644) {
  const binaryString = atob(base644);
  const bytes = new Uint8Array(binaryString.length);
  for (let i2 = 0; i2 < binaryString.length; i2++) {
    bytes[i2] = binaryString.charCodeAt(i2);
  }
  return bytes;
}
function uint8ArrayToBase64(bytes) {
  let binaryString = "";
  for (let i2 = 0; i2 < bytes.length; i2++) {
    binaryString += String.fromCharCode(bytes[i2]);
  }
  return btoa(binaryString);
}
function base64urlToUint8Array(base64url4) {
  const base644 = base64url4.replace(/-/g, "+").replace(/_/g, "/");
  const padding = "=".repeat((4 - (base644.length % 4)) % 4);
  return base64ToUint8Array(base644 + padding);
}
function uint8ArrayToBase64url(bytes) {
  return uint8ArrayToBase64(bytes)
    .replace(/\+/g, "-")
    .replace(/\//g, "_")
    .replace(/=/g, "");
}
function hexToUint8Array(hex3) {
  const cleanHex = hex3.replace(/^0x/, "");
  if (cleanHex.length % 2 !== 0) {
    throw new Error("Invalid hex string length");
  }
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i2 = 0; i2 < cleanHex.length; i2 += 2) {
    bytes[i2 / 2] = Number.parseInt(cleanHex.slice(i2, i2 + 2), 16);
  }
  return bytes;
}
function uint8ArrayToHex(bytes) {
  return Array.from(bytes)
    .map((b2) => b2.toString(16).padStart(2, "0"))
    .join("");
}
var Class = class {
  constructor(..._args) {}
};

// node_modules/zod/v4/core/errors.js
var initializer = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false,
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false,
  });
  inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false,
  });
};
var $ZodError = $constructor("$ZodError", initializer);
var $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
function flattenError(error45, mapper = (issue3) => issue3.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error45.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error45, _mapper) {
  const mapper =
    _mapper ||
    function (issue3) {
      return issue3.message;
    };
  const fieldErrors = { _errors: [] };
  const processError = (error46) => {
    for (const issue3 of error46.issues) {
      if (issue3.code === "invalid_union" && issue3.errors.length) {
        issue3.errors.map((issues) => processError({ issues }));
      } else if (issue3.code === "invalid_key") {
        processError({ issues: issue3.issues });
      } else if (issue3.code === "invalid_element") {
        processError({ issues: issue3.issues });
      } else if (issue3.path.length === 0) {
        fieldErrors._errors.push(mapper(issue3));
      } else {
        let curr = fieldErrors;
        let i2 = 0;
        while (i2 < issue3.path.length) {
          const el = issue3.path[i2];
          const terminal = i2 === issue3.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue3));
          }
          curr = curr[el];
          i2++;
        }
      }
    }
  };
  processError(error45);
  return fieldErrors;
}
function treeifyError(error45, _mapper) {
  const mapper =
    _mapper ||
    function (issue3) {
      return issue3.message;
    };
  const result = { errors: [] };
  const processError = (error46, path = []) => {
    var _a19, _b9;
    for (const issue3 of error46.issues) {
      if (issue3.code === "invalid_union" && issue3.errors.length) {
        issue3.errors.map((issues) => processError({ issues }, issue3.path));
      } else if (issue3.code === "invalid_key") {
        processError({ issues: issue3.issues }, issue3.path);
      } else if (issue3.code === "invalid_element") {
        processError({ issues: issue3.issues }, issue3.path);
      } else {
        const fullpath = [...path, ...issue3.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue3));
          continue;
        }
        let curr = result;
        let i2 = 0;
        while (i2 < fullpath.length) {
          const el = fullpath[i2];
          const terminal = i2 === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a19 = curr.properties)[el] ?? (_a19[el] = { errors: [] });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b9 = curr.items)[el] ?? (_b9[el] = { errors: [] });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue3));
          }
          i2++;
        }
      }
    }
  };
  processError(error45);
  return result;
}
function toDotPath(_path) {
  const segs = [];
  const path = _path.map((seg) => (typeof seg === "object" ? seg.key : seg));
  for (const seg of path) {
    if (typeof seg === "number") segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg)) segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length) segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
function prettifyError(error45) {
  const lines = [];
  const issues = [...error45.issues].sort(
    (a2, b2) => (a2.path ?? []).length - (b2.path ?? []).length,
  );
  for (const issue3 of issues) {
    lines.push(`\u2716 ${issue3.message}`);
    if (issue3.path?.length)
      lines.push(`  \u2192 at ${toDotPath(issue3.path)}`);
  }
  return lines.join("\n");
}

// node_modules/zod/v4/core/parse.js
var _parse = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  if (result.issues.length) {
    const e2 = new (_params?.Err ?? _Err)(
      result.issues.map((iss) => finalizeIssue(iss, ctx, config())),
    );
    captureStackTrace(e2, _params?.callee);
    throw e2;
  }
  return result.value;
};
var parse = /* @__PURE__ */ _parse($ZodRealError);
var _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) result = await result;
  if (result.issues.length) {
    const e2 = new (params?.Err ?? _Err)(
      result.issues.map((iss) => finalizeIssue(iss, ctx, config())),
    );
    captureStackTrace(e2, params?.callee);
    throw e2;
  }
  return result.value;
};
var parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError);
var _safeParse = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  return result.issues.length
    ? {
        success: false,
        error: new (_Err ?? $ZodError)(
          result.issues.map((iss) => finalizeIssue(iss, ctx, config())),
        ),
      }
    : { success: true, data: result.value };
};
var safeParse = /* @__PURE__ */ _safeParse($ZodRealError);
var _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) result = await result;
  return result.issues.length
    ? {
        success: false,
        error: new _Err(
          result.issues.map((iss) => finalizeIssue(iss, ctx, config())),
        ),
      }
    : { success: true, data: result.value };
};
var safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);
var _encode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx
    ? Object.assign(_ctx, { direction: "backward" })
    : { direction: "backward" };
  return _parse(_Err)(schema, value, ctx);
};
var encode = /* @__PURE__ */ _encode($ZodRealError);
var _decode = (_Err) => (schema, value, _ctx) => {
  return _parse(_Err)(schema, value, _ctx);
};
var decode = /* @__PURE__ */ _decode($ZodRealError);
var _encodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx
    ? Object.assign(_ctx, { direction: "backward" })
    : { direction: "backward" };
  return _parseAsync(_Err)(schema, value, ctx);
};
var encodeAsync = /* @__PURE__ */ _encodeAsync($ZodRealError);
var _decodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _parseAsync(_Err)(schema, value, _ctx);
};
var decodeAsync = /* @__PURE__ */ _decodeAsync($ZodRealError);
var _safeEncode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx
    ? Object.assign(_ctx, { direction: "backward" })
    : { direction: "backward" };
  return _safeParse(_Err)(schema, value, ctx);
};
var safeEncode = /* @__PURE__ */ _safeEncode($ZodRealError);
var _safeDecode = (_Err) => (schema, value, _ctx) => {
  return _safeParse(_Err)(schema, value, _ctx);
};
var safeDecode = /* @__PURE__ */ _safeDecode($ZodRealError);
var _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx
    ? Object.assign(_ctx, { direction: "backward" })
    : { direction: "backward" };
  return _safeParseAsync(_Err)(schema, value, ctx);
};
var safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync($ZodRealError);
var _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _safeParseAsync(_Err)(schema, value, _ctx);
};
var safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync($ZodRealError);

// node_modules/zod/v4/core/regexes.js
var regexes_exports = {};
__export(regexes_exports, {
  base64: () => base64,
  base64url: () => base64url,
  bigint: () => bigint,
  boolean: () => boolean,
  browserEmail: () => browserEmail,
  cidrv4: () => cidrv4,
  cidrv6: () => cidrv6,
  cuid: () => cuid,
  cuid2: () => cuid2,
  date: () => date,
  datetime: () => datetime,
  domain: () => domain,
  duration: () => duration,
  e164: () => e164,
  email: () => email,
  emoji: () => emoji,
  extendedDuration: () => extendedDuration,
  guid: () => guid,
  hex: () => hex,
  hostname: () => hostname,
  html5Email: () => html5Email,
  idnEmail: () => idnEmail,
  integer: () => integer,
  ipv4: () => ipv4,
  ipv6: () => ipv6,
  ksuid: () => ksuid,
  lowercase: () => lowercase,
  md5_base64: () => md5_base64,
  md5_base64url: () => md5_base64url,
  md5_hex: () => md5_hex,
  nanoid: () => nanoid,
  null: () => _null,
  number: () => number,
  rfc5322Email: () => rfc5322Email,
  sha1_base64: () => sha1_base64,
  sha1_base64url: () => sha1_base64url,
  sha1_hex: () => sha1_hex,
  sha256_base64: () => sha256_base64,
  sha256_base64url: () => sha256_base64url,
  sha256_hex: () => sha256_hex,
  sha384_base64: () => sha384_base64,
  sha384_base64url: () => sha384_base64url,
  sha384_hex: () => sha384_hex,
  sha512_base64: () => sha512_base64,
  sha512_base64url: () => sha512_base64url,
  sha512_hex: () => sha512_hex,
  string: () => string,
  time: () => time,
  ulid: () => ulid,
  undefined: () => _undefined,
  unicodeEmail: () => unicodeEmail,
  uppercase: () => uppercase,
  uuid: () => uuid,
  uuid4: () => uuid4,
  uuid6: () => uuid6,
  uuid7: () => uuid7,
  xid: () => xid,
});
var cuid = /^[cC][^\s-]{8,}$/;
var cuid2 = /^[0-9a-z]+$/;
var ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var xid = /^[0-9a-vA-V]{20}$/;
var ksuid = /^[A-Za-z0-9]{27}$/;
var nanoid = /^[a-zA-Z0-9_-]{21}$/;
var duration =
  /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var extendedDuration =
  /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var guid =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var uuid = (version3) => {
  if (!version3)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
  return new RegExp(
    `^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version3}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`,
  );
};
var uuid4 = /* @__PURE__ */ uuid(4);
var uuid6 = /* @__PURE__ */ uuid(6);
var uuid7 = /* @__PURE__ */ uuid(7);
var email =
  /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
var html5Email =
  /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var rfc5322Email =
  /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
var idnEmail = unicodeEmail;
var browserEmail =
  /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
  return new RegExp(_emoji, "u");
}
var ipv4 =
  /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv6 =
  /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
var cidrv4 =
  /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var cidrv6 =
  /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64 =
  /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var base64url = /^[A-Za-z0-9_-]*$/;
var hostname =
  /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
var domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
var e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
var dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
var date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex =
    typeof args.precision === "number"
      ? args.precision === -1
        ? `${hhmm}`
        : args.precision === 0
          ? `${hhmm}:[0-5]\\d`
          : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}`
      : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime(args) {
  const time4 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local) opts.push("");
  if (args.offset) opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
  const timeRegex2 = `${time4}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex2})$`);
}
var string = (params) => {
  const regex = params
    ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}`
    : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
};
var bigint = /^-?\d+n?$/;
var integer = /^-?\d+$/;
var number = /^-?\d+(?:\.\d+)?/;
var boolean = /^(?:true|false)$/i;
var _null = /^null$/i;
var _undefined = /^undefined$/i;
var lowercase = /^[^A-Z]*$/;
var uppercase = /^[^a-z]*$/;
var hex = /^[0-9a-fA-F]*$/;
function fixedBase64(bodyLength, padding) {
  return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
}
function fixedBase64url(length) {
  return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);
}
var md5_hex = /^[0-9a-fA-F]{32}$/;
var md5_base64 = /* @__PURE__ */ fixedBase64(22, "==");
var md5_base64url = /* @__PURE__ */ fixedBase64url(22);
var sha1_hex = /^[0-9a-fA-F]{40}$/;
var sha1_base64 = /* @__PURE__ */ fixedBase64(27, "=");
var sha1_base64url = /* @__PURE__ */ fixedBase64url(27);
var sha256_hex = /^[0-9a-fA-F]{64}$/;
var sha256_base64 = /* @__PURE__ */ fixedBase64(43, "=");
var sha256_base64url = /* @__PURE__ */ fixedBase64url(43);
var sha384_hex = /^[0-9a-fA-F]{96}$/;
var sha384_base64 = /* @__PURE__ */ fixedBase64(64, "");
var sha384_base64url = /* @__PURE__ */ fixedBase64url(64);
var sha512_hex = /^[0-9a-fA-F]{128}$/;
var sha512_base64 = /* @__PURE__ */ fixedBase64(86, "==");
var sha512_base64url = /* @__PURE__ */ fixedBase64url(86);

// node_modules/zod/v4/core/checks.js
var $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
  var _a19;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a19 = inst._zod).onattach ?? (_a19.onattach = []);
});
var numericOriginMap = {
  number: "number",
  bigint: "bigint",
  object: "date",
};
var $ZodCheckLessThan = /* @__PURE__ */ $constructor(
  "$ZodCheckLessThan",
  (inst, def) => {
    $ZodCheck.init(inst, def);
    const origin = numericOriginMap[typeof def.value];
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      const curr =
        (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ??
        Number.POSITIVE_INFINITY;
      if (def.value < curr) {
        if (def.inclusive) bag.maximum = def.value;
        else bag.exclusiveMaximum = def.value;
      }
    });
    inst._zod.check = (payload) => {
      if (
        def.inclusive ? payload.value <= def.value : payload.value < def.value
      ) {
        return;
      }
      payload.issues.push({
        origin,
        code: "too_big",
        maximum: def.value,
        input: payload.value,
        inclusive: def.inclusive,
        inst,
        continue: !def.abort,
      });
    };
  },
);
var $ZodCheckGreaterThan = /* @__PURE__ */ $constructor(
  "$ZodCheckGreaterThan",
  (inst, def) => {
    $ZodCheck.init(inst, def);
    const origin = numericOriginMap[typeof def.value];
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      const curr =
        (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ??
        Number.NEGATIVE_INFINITY;
      if (def.value > curr) {
        if (def.inclusive) bag.minimum = def.value;
        else bag.exclusiveMinimum = def.value;
      }
    });
    inst._zod.check = (payload) => {
      if (
        def.inclusive ? payload.value >= def.value : payload.value > def.value
      ) {
        return;
      }
      payload.issues.push({
        origin,
        code: "too_small",
        minimum: def.value,
        input: payload.value,
        inclusive: def.inclusive,
        inst,
        continue: !def.abort,
      });
    };
  },
);
var $ZodCheckMultipleOf = /* @__PURE__ */ $constructor(
  "$ZodCheckMultipleOf",
  (inst, def) => {
    $ZodCheck.init(inst, def);
    inst._zod.onattach.push((inst2) => {
      var _a19;
      (_a19 = inst2._zod.bag).multipleOf ?? (_a19.multipleOf = def.value);
    });
    inst._zod.check = (payload) => {
      if (typeof payload.value !== typeof def.value)
        throw new Error("Cannot mix number and bigint in multiple_of check.");
      const isMultiple =
        typeof payload.value === "bigint"
          ? payload.value % def.value === BigInt(0)
          : floatSafeRemainder(payload.value, def.value) === 0;
      if (isMultiple) return;
      payload.issues.push({
        origin: typeof payload.value,
        code: "not_multiple_of",
        divisor: def.value,
        input: payload.value,
        inst,
        continue: !def.abort,
      });
    };
  },
);
var $ZodCheckNumberFormat = /* @__PURE__ */ $constructor(
  "$ZodCheckNumberFormat",
  (inst, def) => {
    $ZodCheck.init(inst, def);
    def.format = def.format || "float64";
    const isInt = def.format?.includes("int");
    const origin = isInt ? "int" : "number";
    const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.format = def.format;
      bag.minimum = minimum;
      bag.maximum = maximum;
      if (isInt) bag.pattern = integer;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      if (isInt) {
        if (!Number.isInteger(input)) {
          payload.issues.push({
            expected: origin,
            format: def.format,
            code: "invalid_type",
            continue: false,
            input,
            inst,
          });
          return;
        }
        if (!Number.isSafeInteger(input)) {
          if (input > 0) {
            payload.issues.push({
              input,
              code: "too_big",
              maximum: Number.MAX_SAFE_INTEGER,
              note: "Integers must be within the safe integer range.",
              inst,
              origin,
              continue: !def.abort,
            });
          } else {
            payload.issues.push({
              input,
              code: "too_small",
              minimum: Number.MIN_SAFE_INTEGER,
              note: "Integers must be within the safe integer range.",
              inst,
              origin,
              continue: !def.abort,
            });
          }
          return;
        }
      }
      if (input < minimum) {
        payload.issues.push({
          origin: "number",
          input,
          code: "too_small",
          minimum,
          inclusive: true,
          inst,
          continue: !def.abort,
        });
      }
      if (input > maximum) {
        payload.issues.push({
          origin: "number",
          input,
          code: "too_big",
          maximum,
          inst,
        });
      }
    };
  },
);
var $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor(
  "$ZodCheckBigIntFormat",
  (inst, def) => {
    $ZodCheck.init(inst, def);
    const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.format = def.format;
      bag.minimum = minimum;
      bag.maximum = maximum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      if (input < minimum) {
        payload.issues.push({
          origin: "bigint",
          input,
          code: "too_small",
          minimum,
          inclusive: true,
          inst,
          continue: !def.abort,
        });
      }
      if (input > maximum) {
        payload.issues.push({
          origin: "bigint",
          input,
          code: "too_big",
          maximum,
          inst,
        });
      }
    };
  },
);
var $ZodCheckMaxSize = /* @__PURE__ */ $constructor(
  "$ZodCheckMaxSize",
  (inst, def) => {
    var _a19;
    $ZodCheck.init(inst, def);
    (_a19 = inst._zod.def).when ??
      (_a19.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.size !== void 0;
      });
    inst._zod.onattach.push((inst2) => {
      const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
      if (def.maximum < curr) inst2._zod.bag.maximum = def.maximum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const size = input.size;
      if (size <= def.maximum) return;
      payload.issues.push({
        origin: getSizableOrigin(input),
        code: "too_big",
        maximum: def.maximum,
        inclusive: true,
        input,
        inst,
        continue: !def.abort,
      });
    };
  },
);
var $ZodCheckMinSize = /* @__PURE__ */ $constructor(
  "$ZodCheckMinSize",
  (inst, def) => {
    var _a19;
    $ZodCheck.init(inst, def);
    (_a19 = inst._zod.def).when ??
      (_a19.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.size !== void 0;
      });
    inst._zod.onattach.push((inst2) => {
      const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
      if (def.minimum > curr) inst2._zod.bag.minimum = def.minimum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const size = input.size;
      if (size >= def.minimum) return;
      payload.issues.push({
        origin: getSizableOrigin(input),
        code: "too_small",
        minimum: def.minimum,
        inclusive: true,
        input,
        inst,
        continue: !def.abort,
      });
    };
  },
);
var $ZodCheckSizeEquals = /* @__PURE__ */ $constructor(
  "$ZodCheckSizeEquals",
  (inst, def) => {
    var _a19;
    $ZodCheck.init(inst, def);
    (_a19 = inst._zod.def).when ??
      (_a19.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.size !== void 0;
      });
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.minimum = def.size;
      bag.maximum = def.size;
      bag.size = def.size;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const size = input.size;
      if (size === def.size) return;
      const tooBig = size > def.size;
      payload.issues.push({
        origin: getSizableOrigin(input),
        ...(tooBig
          ? { code: "too_big", maximum: def.size }
          : { code: "too_small", minimum: def.size }),
        inclusive: true,
        exact: true,
        input: payload.value,
        inst,
        continue: !def.abort,
      });
    };
  },
);
var $ZodCheckMaxLength = /* @__PURE__ */ $constructor(
  "$ZodCheckMaxLength",
  (inst, def) => {
    var _a19;
    $ZodCheck.init(inst, def);
    (_a19 = inst._zod.def).when ??
      (_a19.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.length !== void 0;
      });
    inst._zod.onattach.push((inst2) => {
      const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
      if (def.maximum < curr) inst2._zod.bag.maximum = def.maximum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const length = input.length;
      if (length <= def.maximum) return;
      const origin = getLengthableOrigin(input);
      payload.issues.push({
        origin,
        code: "too_big",
        maximum: def.maximum,
        inclusive: true,
        input,
        inst,
        continue: !def.abort,
      });
    };
  },
);
var $ZodCheckMinLength = /* @__PURE__ */ $constructor(
  "$ZodCheckMinLength",
  (inst, def) => {
    var _a19;
    $ZodCheck.init(inst, def);
    (_a19 = inst._zod.def).when ??
      (_a19.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.length !== void 0;
      });
    inst._zod.onattach.push((inst2) => {
      const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
      if (def.minimum > curr) inst2._zod.bag.minimum = def.minimum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const length = input.length;
      if (length >= def.minimum) return;
      const origin = getLengthableOrigin(input);
      payload.issues.push({
        origin,
        code: "too_small",
        minimum: def.minimum,
        inclusive: true,
        input,
        inst,
        continue: !def.abort,
      });
    };
  },
);
var $ZodCheckLengthEquals = /* @__PURE__ */ $constructor(
  "$ZodCheckLengthEquals",
  (inst, def) => {
    var _a19;
    $ZodCheck.init(inst, def);
    (_a19 = inst._zod.def).when ??
      (_a19.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.length !== void 0;
      });
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.minimum = def.length;
      bag.maximum = def.length;
      bag.length = def.length;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const length = input.length;
      if (length === def.length) return;
      const origin = getLengthableOrigin(input);
      const tooBig = length > def.length;
      payload.issues.push({
        origin,
        ...(tooBig
          ? { code: "too_big", maximum: def.length }
          : { code: "too_small", minimum: def.length }),
        inclusive: true,
        exact: true,
        input: payload.value,
        inst,
        continue: !def.abort,
      });
    };
  },
);
var $ZodCheckStringFormat = /* @__PURE__ */ $constructor(
  "$ZodCheckStringFormat",
  (inst, def) => {
    var _a19, _b9;
    $ZodCheck.init(inst, def);
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.format = def.format;
      if (def.pattern) {
        bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
        bag.patterns.add(def.pattern);
      }
    });
    if (def.pattern)
      (_a19 = inst._zod).check ??
        (_a19.check = (payload) => {
          def.pattern.lastIndex = 0;
          if (def.pattern.test(payload.value)) return;
          payload.issues.push({
            origin: "string",
            code: "invalid_format",
            format: def.format,
            input: payload.value,
            ...(def.pattern ? { pattern: def.pattern.toString() } : {}),
            inst,
            continue: !def.abort,
          });
        });
    else (_b9 = inst._zod).check ?? (_b9.check = () => {});
  },
);
var $ZodCheckRegex = /* @__PURE__ */ $constructor(
  "$ZodCheckRegex",
  (inst, def) => {
    $ZodCheckStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value)) return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: "regex",
        input: payload.value,
        pattern: def.pattern.toString(),
        inst,
        continue: !def.abort,
      });
    };
  },
);
var $ZodCheckLowerCase = /* @__PURE__ */ $constructor(
  "$ZodCheckLowerCase",
  (inst, def) => {
    def.pattern ?? (def.pattern = lowercase);
    $ZodCheckStringFormat.init(inst, def);
  },
);
var $ZodCheckUpperCase = /* @__PURE__ */ $constructor(
  "$ZodCheckUpperCase",
  (inst, def) => {
    def.pattern ?? (def.pattern = uppercase);
    $ZodCheckStringFormat.init(inst, def);
  },
);
var $ZodCheckIncludes = /* @__PURE__ */ $constructor(
  "$ZodCheckIncludes",
  (inst, def) => {
    $ZodCheck.init(inst, def);
    const escapedRegex = escapeRegex(def.includes);
    const pattern = new RegExp(
      typeof def.position === "number"
        ? `^.{${def.position}}${escapedRegex}`
        : escapedRegex,
    );
    def.pattern = pattern;
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(pattern);
    });
    inst._zod.check = (payload) => {
      if (payload.value.includes(def.includes, def.position)) return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: "includes",
        includes: def.includes,
        input: payload.value,
        inst,
        continue: !def.abort,
      });
    };
  },
);
var $ZodCheckStartsWith = /* @__PURE__ */ $constructor(
  "$ZodCheckStartsWith",
  (inst, def) => {
    $ZodCheck.init(inst, def);
    const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
    def.pattern ?? (def.pattern = pattern);
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(pattern);
    });
    inst._zod.check = (payload) => {
      if (payload.value.startsWith(def.prefix)) return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: "starts_with",
        prefix: def.prefix,
        input: payload.value,
        inst,
        continue: !def.abort,
      });
    };
  },
);
var $ZodCheckEndsWith = /* @__PURE__ */ $constructor(
  "$ZodCheckEndsWith",
  (inst, def) => {
    $ZodCheck.init(inst, def);
    const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
    def.pattern ?? (def.pattern = pattern);
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(pattern);
    });
    inst._zod.check = (payload) => {
      if (payload.value.endsWith(def.suffix)) return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: "ends_with",
        suffix: def.suffix,
        input: payload.value,
        inst,
        continue: !def.abort,
      });
    };
  },
);
function handleCheckPropertyResult(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues(property, result.issues));
  }
}
var $ZodCheckProperty = /* @__PURE__ */ $constructor(
  "$ZodCheckProperty",
  (inst, def) => {
    $ZodCheck.init(inst, def);
    inst._zod.check = (payload) => {
      const result = def.schema._zod.run(
        {
          value: payload.value[def.property],
          issues: [],
        },
        {},
      );
      if (result instanceof Promise) {
        return result.then((result2) =>
          handleCheckPropertyResult(result2, payload, def.property),
        );
      }
      handleCheckPropertyResult(result, payload, def.property);
      return;
    };
  },
);
var $ZodCheckMimeType = /* @__PURE__ */ $constructor(
  "$ZodCheckMimeType",
  (inst, def) => {
    $ZodCheck.init(inst, def);
    const mimeSet = new Set(def.mime);
    inst._zod.onattach.push((inst2) => {
      inst2._zod.bag.mime = def.mime;
    });
    inst._zod.check = (payload) => {
      if (mimeSet.has(payload.value.type)) return;
      payload.issues.push({
        code: "invalid_value",
        values: def.mime,
        input: payload.value.type,
        inst,
        continue: !def.abort,
      });
    };
  },
);
var $ZodCheckOverwrite = /* @__PURE__ */ $constructor(
  "$ZodCheckOverwrite",
  (inst, def) => {
    $ZodCheck.init(inst, def);
    inst._zod.check = (payload) => {
      payload.value = def.tx(payload.value);
    };
  },
);

// node_modules/zod/v4/core/doc.js
var Doc = class {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this) this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split("\n").filter((x) => x);
    const minIndent = Math.min(
      ...lines.map((x) => x.length - x.trimStart().length),
    );
    const dedented = lines
      .map((x) => x.slice(minIndent))
      .map((x) => " ".repeat(this.indent * 2) + x);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F = Function;
    const args = this?.args;
    const content = this?.content ?? [``];
    const lines = [...content.map((x) => `  ${x}`)];
    return new F(...args, lines.join("\n"));
  }
};

// node_modules/zod/v4/core/versions.js
var version = {
  major: 4,
  minor: 1,
  patch: 11,
};

// node_modules/zod/v4/core/schemas.js
var $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
  var _a19;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version;
  const checks = [...(inst._zod.def.checks ?? [])];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks.unshift(inst);
  }
  for (const ch of checks) {
    for (const fn of ch._zod.onattach) {
      fn(inst);
    }
  }
  if (checks.length === 0) {
    (_a19 = inst._zod).deferred ?? (_a19.deferred = []);
    inst._zod.deferred?.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = (payload, checks2, ctx) => {
      let isAborted2 = aborted(payload);
      let asyncResult;
      for (const ch of checks2) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun) continue;
        } else if (isAborted2) {
          continue;
        }
        const currLen = payload.issues.length;
        const _2 = ch._zod.check(payload);
        if (_2 instanceof Promise && ctx?.async === false) {
          throw new $ZodAsyncError();
        }
        if (asyncResult || _2 instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _2;
            const nextLen = payload.issues.length;
            if (nextLen === currLen) return;
            if (!isAborted2) isAborted2 = aborted(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen) continue;
          if (!isAborted2) isAborted2 = aborted(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    };
    const handleCanaryResult = (canary, payload, ctx) => {
      if (aborted(canary)) {
        canary.aborted = true;
        return canary;
      }
      const checkResult = runChecks(payload, checks, ctx);
      if (checkResult instanceof Promise) {
        if (ctx.async === false) throw new $ZodAsyncError();
        return checkResult.then((checkResult2) =>
          inst._zod.parse(checkResult2, ctx),
        );
      }
      return inst._zod.parse(checkResult, ctx);
    };
    inst._zod.run = (payload, ctx) => {
      if (ctx.skipChecks) {
        return inst._zod.parse(payload, ctx);
      }
      if (ctx.direction === "backward") {
        const canary = inst._zod.parse(
          { value: payload.value, issues: [] },
          { ...ctx, skipChecks: true },
        );
        if (canary instanceof Promise) {
          return canary.then((canary2) => {
            return handleCanaryResult(canary2, payload, ctx);
          });
        }
        return handleCanaryResult(canary, payload, ctx);
      }
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false) throw new $ZodAsyncError();
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  inst["~standard"] = {
    validate: (value) => {
      try {
        const r2 = safeParse(inst, value);
        return r2.success ? { value: r2.data } : { issues: r2.error?.issues };
      } catch (_2) {
        return safeParseAsync(inst, value).then((r2) =>
          r2.success ? { value: r2.data } : { issues: r2.error?.issues },
        );
      }
    },
    vendor: "zod",
    version: 1,
  };
});
var $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern =
    [...(inst?._zod.bag?.patterns ?? [])].pop() ?? string(inst._zod.bag);
  inst._zod.parse = (payload, _2) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_3) {}
    if (typeof payload.value === "string") return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst,
    });
    return payload;
  };
});
var $ZodStringFormat = /* @__PURE__ */ $constructor(
  "$ZodStringFormat",
  (inst, def) => {
    $ZodCheckStringFormat.init(inst, def);
    $ZodString.init(inst, def);
  },
);
var $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid);
  $ZodStringFormat.init(inst, def);
});
var $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8,
    };
    const v2 = versionMap[def.version];
    if (v2 === void 0)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid(v2));
  } else def.pattern ?? (def.pattern = uuid());
  $ZodStringFormat.init(inst, def);
});
var $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email);
  $ZodStringFormat.init(inst, def);
});
var $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const trimmed = payload.value.trim();
      const url2 = new URL(trimmed);
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url2.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: hostname.source,
            input: payload.value,
            inst,
            continue: !def.abort,
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (
          !def.protocol.test(
            url2.protocol.endsWith(":")
              ? url2.protocol.slice(0, -1)
              : url2.protocol,
          )
        ) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort,
          });
        }
      }
      if (def.normalize) {
        payload.value = url2.href;
      } else {
        payload.value = trimmed;
      }
      return;
    } catch (_2) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort,
      });
    }
  };
});
var $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji());
  $ZodStringFormat.init(inst, def);
});
var $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2);
  $ZodStringFormat.init(inst, def);
});
var $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid);
  $ZodStringFormat.init(inst, def);
});
var $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid);
  $ZodStringFormat.init(inst, def);
});
var $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodISODateTime = /* @__PURE__ */ $constructor(
  "$ZodISODateTime",
  (inst, def) => {
    def.pattern ?? (def.pattern = datetime(def));
    $ZodStringFormat.init(inst, def);
  },
);
var $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date);
  $ZodStringFormat.init(inst, def);
});
var $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODuration = /* @__PURE__ */ $constructor(
  "$ZodISODuration",
  (inst, def) => {
    def.pattern ?? (def.pattern = duration);
    $ZodStringFormat.init(inst, def);
  },
);
var $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv4`;
  });
});
var $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv6`;
  });
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort,
      });
    }
  };
});
var $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4);
  $ZodStringFormat.init(inst, def);
});
var $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    const parts = payload.value.split("/");
    try {
      if (parts.length !== 2) throw new Error();
      const [address, prefix] = parts;
      if (!prefix) throw new Error();
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix) throw new Error();
      if (prefixNum < 0 || prefixNum > 128) throw new Error();
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort,
      });
    }
  };
});
function isValidBase64(data) {
  if (data === "") return true;
  if (data.length % 4 !== 0) return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
var $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base64);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64(payload.value)) return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort,
    });
  };
});
function isValidBase64URL(data) {
  if (!base64url.test(data)) return false;
  const base644 = data.replace(/[-_]/g, (c2) => (c2 === "-" ? "+" : "/"));
  const padded = base644.padEnd(Math.ceil(base644.length / 4) * 4, "=");
  return isValidBase64(padded);
}
var $ZodBase64URL = /* @__PURE__ */ $constructor(
  "$ZodBase64URL",
  (inst, def) => {
    def.pattern ?? (def.pattern = base64url);
    $ZodStringFormat.init(inst, def);
    inst._zod.onattach.push((inst2) => {
      inst2._zod.bag.contentEncoding = "base64url";
    });
    inst._zod.check = (payload) => {
      if (isValidBase64URL(payload.value)) return;
      payload.issues.push({
        code: "invalid_format",
        format: "base64url",
        input: payload.value,
        inst,
        continue: !def.abort,
      });
    };
  },
);
var $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164);
  $ZodStringFormat.init(inst, def);
});
function isValidJWT(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3) return false;
    const [header] = tokensParts;
    if (!header) return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT") return false;
    if (!parsedHeader.alg) return false;
    if (
      algorithm &&
      (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm)
    )
      return false;
    return true;
  } catch {
    return false;
  }
}
var $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT(payload.value, def.alg)) return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort,
    });
  };
});
var $ZodCustomStringFormat = /* @__PURE__ */ $constructor(
  "$ZodCustomStringFormat",
  (inst, def) => {
    $ZodStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
      if (def.fn(payload.value)) return;
      payload.issues.push({
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        inst,
        continue: !def.abort,
      });
    };
  },
);
var $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_2) {}
    const input = payload.value;
    if (
      typeof input === "number" &&
      !Number.isNaN(input) &&
      Number.isFinite(input)
    ) {
      return payload;
    }
    const received =
      typeof input === "number"
        ? Number.isNaN(input)
          ? "NaN"
          : !Number.isFinite(input)
            ? "Infinity"
            : void 0
        : void 0;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...(received ? { received } : {}),
    });
    return payload;
  };
});
var $ZodNumberFormat = /* @__PURE__ */ $constructor(
  "$ZodNumber",
  (inst, def) => {
    $ZodCheckNumberFormat.init(inst, def);
    $ZodNumber.init(inst, def);
  },
);
var $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = boolean;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_2) {}
    const input = payload.value;
    if (typeof input === "boolean") return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst,
    });
    return payload;
  };
});
var $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = bigint;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = BigInt(payload.value);
      } catch (_2) {}
    if (typeof payload.value === "bigint") return payload;
    payload.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: payload.value,
      inst,
    });
    return payload;
  };
});
var $ZodBigIntFormat = /* @__PURE__ */ $constructor(
  "$ZodBigInt",
  (inst, def) => {
    $ZodCheckBigIntFormat.init(inst, def);
    $ZodBigInt.init(inst, def);
  },
);
var $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "symbol") return payload;
    payload.issues.push({
      expected: "symbol",
      code: "invalid_type",
      input,
      inst,
    });
    return payload;
  };
});
var $ZodUndefined = /* @__PURE__ */ $constructor(
  "$ZodUndefined",
  (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = _undefined;
    inst._zod.values = /* @__PURE__ */ new Set([void 0]);
    inst._zod.optin = "optional";
    inst._zod.optout = "optional";
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (typeof input === "undefined") return payload;
      payload.issues.push({
        expected: "undefined",
        code: "invalid_type",
        input,
        inst,
      });
      return payload;
    };
  },
);
var $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _null;
  inst._zod.values = /* @__PURE__ */ new Set([null]);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input === null) return payload;
    payload.issues.push({
      expected: "null",
      code: "invalid_type",
      input,
      inst,
    });
    return payload;
  };
});
var $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst,
    });
    return payload;
  };
});
var $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined") return payload;
    payload.issues.push({
      expected: "void",
      code: "invalid_type",
      input,
      inst,
    });
    return payload;
  };
});
var $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce) {
      try {
        payload.value = new Date(payload.value);
      } catch (_err) {}
    }
    const input = payload.value;
    const isDate = input instanceof Date;
    const isValidDate = isDate && !Number.isNaN(input.getTime());
    if (isValidDate) return payload;
    payload.issues.push({
      expected: "date",
      code: "invalid_type",
      input,
      ...(isDate ? { received: "Invalid Date" } : {}),
      inst,
    });
    return payload;
  };
});
function handleArrayResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst,
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i2 = 0; i2 < input.length; i2++) {
      const item = input[i2];
      const result = def.element._zod.run(
        {
          value: item,
          issues: [],
        },
        ctx,
      );
      if (result instanceof Promise) {
        proms.push(
          result.then((result2) => handleArrayResult(result2, payload, i2)),
        );
      } else {
        handleArrayResult(result, payload, i2);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handlePropertyResult(result, final, key, input) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(key, result.issues));
  }
  if (result.value === void 0) {
    if (key in input) {
      final.value[key] = void 0;
    }
  } else {
    final.value[key] = result.value;
  }
}
function normalizeDef(def) {
  const keys = Object.keys(def.shape);
  for (const k of keys) {
    if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) {
      throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
    }
  }
  const okeys = optionalKeys(def.shape);
  return {
    ...def,
    keys,
    keySet: new Set(keys),
    numKeys: keys.length,
    optionalKeys: new Set(okeys),
  };
}
function handleCatchall(proms, input, payload, ctx, def, inst) {
  const unrecognized = [];
  const keySet = def.keySet;
  const _catchall = def.catchall._zod;
  const t2 = _catchall.def.type;
  for (const key of Object.keys(input)) {
    if (keySet.has(key)) continue;
    if (t2 === "never") {
      unrecognized.push(key);
      continue;
    }
    const r2 = _catchall.run({ value: input[key], issues: [] }, ctx);
    if (r2 instanceof Promise) {
      proms.push(
        r2.then((r3) => handlePropertyResult(r3, payload, key, input)),
      );
    } else {
      handlePropertyResult(r2, payload, key, input);
    }
  }
  if (unrecognized.length) {
    payload.issues.push({
      code: "unrecognized_keys",
      keys: unrecognized,
      input,
      inst,
    });
  }
  if (!proms.length) return payload;
  return Promise.all(proms).then(() => {
    return payload;
  });
}
var $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
  $ZodType.init(inst, def);
  const desc = Object.getOwnPropertyDescriptor(def, "shape");
  if (!desc?.get) {
    const sh = def.shape;
    Object.defineProperty(def, "shape", {
      get: () => {
        const newSh = { ...sh };
        Object.defineProperty(def, "shape", {
          value: newSh,
        });
        return newSh;
      },
    });
  }
  const _normalized = cached(() => normalizeDef(def));
  defineLazy(inst._zod, "propValues", () => {
    const shape = def.shape;
    const propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
        for (const v2 of field.values) propValues[key].add(v2);
      }
    }
    return propValues;
  });
  const isObject3 = isObject;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject3(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst,
      });
      return payload;
    }
    payload.value = {};
    const proms = [];
    const shape = value.shape;
    for (const key of value.keys) {
      const el = shape[key];
      const r2 = el._zod.run({ value: input[key], issues: [] }, ctx);
      if (r2 instanceof Promise) {
        proms.push(
          r2.then((r3) => handlePropertyResult(r3, payload, key, input)),
        );
      } else {
        handlePropertyResult(r2, payload, key, input);
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
  };
});
var $ZodObjectJIT = /* @__PURE__ */ $constructor(
  "$ZodObjectJIT",
  (inst, def) => {
    $ZodObject.init(inst, def);
    const superParse = inst._zod.parse;
    const _normalized = cached(() => normalizeDef(def));
    const generateFastpass = (shape) => {
      const doc = new Doc(["shape", "payload", "ctx"]);
      const normalized = _normalized.value;
      const parseStr = (key) => {
        const k = esc(key);
        return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
      };
      doc.write(`const input = payload.value;`);
      const ids = /* @__PURE__ */ Object.create(null);
      let counter = 0;
      for (const key of normalized.keys) {
        ids[key] = `key_${counter++}`;
      }
      doc.write(`const newResult = {};`);
      for (const key of normalized.keys) {
        const id = ids[key];
        const k = esc(key);
        doc.write(`const ${id} = ${parseStr(key)};`);
        doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
      }
      doc.write(`payload.value = newResult;`);
      doc.write(`return payload;`);
      const fn = doc.compile();
      return (payload, ctx) => fn(shape, payload, ctx);
    };
    let fastpass;
    const isObject3 = isObject;
    const jit = !globalConfig.jitless;
    const allowsEval3 = allowsEval;
    const fastEnabled = jit && allowsEval3.value;
    const catchall = def.catchall;
    let value;
    inst._zod.parse = (payload, ctx) => {
      value ?? (value = _normalized.value);
      const input = payload.value;
      if (!isObject3(input)) {
        payload.issues.push({
          expected: "object",
          code: "invalid_type",
          input,
          inst,
        });
        return payload;
      }
      if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
        if (!fastpass) fastpass = generateFastpass(def.shape);
        payload = fastpass(payload, ctx);
        if (!catchall) return payload;
        return handleCatchall([], input, payload, ctx, value, inst);
      }
      return superParse(payload, ctx);
    };
  },
);
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  const nonaborted = results.filter((r2) => !aborted(r2));
  if (nonaborted.length === 1) {
    final.value = nonaborted[0].value;
    return nonaborted[0];
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) =>
      result.issues.map((iss) => finalizeIssue(iss, ctx, config())),
    ),
  });
  return final;
}
var $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () =>
    def.options.some((o2) => o2._zod.optin === "optional")
      ? "optional"
      : void 0,
  );
  defineLazy(inst._zod, "optout", () =>
    def.options.some((o2) => o2._zod.optout === "optional")
      ? "optional"
      : void 0,
  );
  defineLazy(inst._zod, "values", () => {
    if (def.options.every((o2) => o2._zod.values)) {
      return new Set(
        def.options.flatMap((option) => Array.from(option._zod.values)),
      );
    }
    return void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o2) => o2._zod.pattern)) {
      const patterns = def.options.map((o2) => o2._zod.pattern);
      return new RegExp(
        `^(${patterns.map((p2) => cleanRegex(p2.source)).join("|")})$`,
      );
    }
    return void 0;
  });
  const single = def.options.length === 1;
  const first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single) {
      return first(payload, ctx);
    }
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run(
        {
          value: payload.value,
          issues: [],
        },
        ctx,
      );
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        if (result.issues.length === 0) return result;
        results.push(result);
      }
    }
    if (!async) return handleUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults(results2, payload, inst, ctx);
    });
  };
});
var $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor(
  "$ZodDiscriminatedUnion",
  (inst, def) => {
    $ZodUnion.init(inst, def);
    const _super = inst._zod.parse;
    defineLazy(inst._zod, "propValues", () => {
      const propValues = {};
      for (const option of def.options) {
        const pv = option._zod.propValues;
        if (!pv || Object.keys(pv).length === 0)
          throw new Error(
            `Invalid discriminated union option at index "${def.options.indexOf(option)}"`,
          );
        for (const [k, v2] of Object.entries(pv)) {
          if (!propValues[k]) propValues[k] = /* @__PURE__ */ new Set();
          for (const val of v2) {
            propValues[k].add(val);
          }
        }
      }
      return propValues;
    });
    const disc = cached(() => {
      const opts = def.options;
      const map2 = /* @__PURE__ */ new Map();
      for (const o2 of opts) {
        const values = o2._zod.propValues?.[def.discriminator];
        if (!values || values.size === 0)
          throw new Error(
            `Invalid discriminated union option at index "${def.options.indexOf(o2)}"`,
          );
        for (const v2 of values) {
          if (map2.has(v2)) {
            throw new Error(`Duplicate discriminator value "${String(v2)}"`);
          }
          map2.set(v2, o2);
        }
      }
      return map2;
    });
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!isObject(input)) {
        payload.issues.push({
          code: "invalid_type",
          expected: "object",
          input,
          inst,
        });
        return payload;
      }
      const opt = disc.value.get(input?.[def.discriminator]);
      if (opt) {
        return opt._zod.run(payload, ctx);
      }
      if (def.unionFallback) {
        return _super(payload, ctx);
      }
      payload.issues.push({
        code: "invalid_union",
        errors: [],
        note: "No matching discriminator",
        discriminator: def.discriminator,
        input,
        path: [def.discriminator],
        inst,
      });
      return payload;
    };
  },
);
var $ZodIntersection = /* @__PURE__ */ $constructor(
  "$ZodIntersection",
  (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      const left = def.left._zod.run({ value: input, issues: [] }, ctx);
      const right = def.right._zod.run({ value: input, issues: [] }, ctx);
      const async = left instanceof Promise || right instanceof Promise;
      if (async) {
        return Promise.all([left, right]).then(([left2, right2]) => {
          return handleIntersectionResults(payload, left2, right2);
        });
      }
      return handleIntersectionResults(payload, left, right);
    };
  },
);
function mergeValues(a2, b2) {
  if (a2 === b2) {
    return { valid: true, data: a2 };
  }
  if (a2 instanceof Date && b2 instanceof Date && +a2 === +b2) {
    return { valid: true, data: a2 };
  }
  if (isPlainObject(a2) && isPlainObject(b2)) {
    const bKeys = Object.keys(b2);
    const sharedKeys = Object.keys(a2).filter(
      (key) => bKeys.indexOf(key) !== -1,
    );
    const newObj = { ...a2, ...b2 };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a2[key], b2[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath],
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a2) && Array.isArray(b2)) {
    if (a2.length !== b2.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0; index < a2.length; index++) {
      const itemA = a2[index];
      const itemB = b2[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath],
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  if (left.issues.length) {
    result.issues.push(...left.issues);
  }
  if (right.issues.length) {
    result.issues.push(...right.issues);
  }
  if (aborted(result)) return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid) {
    throw new Error(
      `Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`,
    );
  }
  result.value = merged.data;
  return result;
}
var $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
  $ZodType.init(inst, def);
  const items = def.items;
  const optStart =
    items.length -
    [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        input,
        inst,
        expected: "tuple",
        code: "invalid_type",
      });
      return payload;
    }
    payload.value = [];
    const proms = [];
    if (!def.rest) {
      const tooBig = input.length > items.length;
      const tooSmall = input.length < optStart - 1;
      if (tooBig || tooSmall) {
        payload.issues.push({
          ...(tooBig
            ? { code: "too_big", maximum: items.length }
            : { code: "too_small", minimum: items.length }),
          input,
          inst,
          origin: "array",
        });
        return payload;
      }
    }
    let i2 = -1;
    for (const item of items) {
      i2++;
      if (i2 >= input.length) {
        if (i2 >= optStart) continue;
      }
      const result = item._zod.run(
        {
          value: input[i2],
          issues: [],
        },
        ctx,
      );
      if (result instanceof Promise) {
        proms.push(
          result.then((result2) => handleTupleResult(result2, payload, i2)),
        );
      } else {
        handleTupleResult(result, payload, i2);
      }
    }
    if (def.rest) {
      const rest = input.slice(items.length);
      for (const el of rest) {
        i2++;
        const result = def.rest._zod.run(
          {
            value: el,
            issues: [],
          },
          ctx,
        );
        if (result instanceof Promise) {
          proms.push(
            result.then((result2) => handleTupleResult(result2, payload, i2)),
          );
        } else {
          handleTupleResult(result, payload, i2);
        }
      }
    }
    if (proms.length) return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleTupleResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isPlainObject(input)) {
      payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst,
      });
      return payload;
    }
    const proms = [];
    if (def.keyType._zod.values) {
      const values = def.keyType._zod.values;
      payload.value = {};
      for (const key of values) {
        if (
          typeof key === "string" ||
          typeof key === "number" ||
          typeof key === "symbol"
        ) {
          const result = def.valueType._zod.run(
            { value: input[key], issues: [] },
            ctx,
          );
          if (result instanceof Promise) {
            proms.push(
              result.then((result2) => {
                if (result2.issues.length) {
                  payload.issues.push(...prefixIssues(key, result2.issues));
                }
                payload.value[key] = result2.value;
              }),
            );
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues(key, result.issues));
            }
            payload.value[key] = result.value;
          }
        }
      }
      let unrecognized;
      for (const key in input) {
        if (!values.has(key)) {
          unrecognized = unrecognized ?? [];
          unrecognized.push(key);
        }
      }
      if (unrecognized && unrecognized.length > 0) {
        payload.issues.push({
          code: "unrecognized_keys",
          input,
          inst,
          keys: unrecognized,
        });
      }
    } else {
      payload.value = {};
      for (const key of Reflect.ownKeys(input)) {
        if (key === "__proto__") continue;
        const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        if (keyResult instanceof Promise) {
          throw new Error(
            "Async schemas not supported in object keys currently",
          );
        }
        if (keyResult.issues.length) {
          payload.issues.push({
            code: "invalid_key",
            origin: "record",
            issues: keyResult.issues.map((iss) =>
              finalizeIssue(iss, ctx, config()),
            ),
            input: key,
            path: [key],
            inst,
          });
          payload.value[keyResult.value] = keyResult.value;
          continue;
        }
        const result = def.valueType._zod.run(
          { value: input[key], issues: [] },
          ctx,
        );
        if (result instanceof Promise) {
          proms.push(
            result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues(key, result2.issues));
              }
              payload.value[keyResult.value] = result2.value;
            }),
          );
        } else {
          if (result.issues.length) {
            payload.issues.push(...prefixIssues(key, result.issues));
          }
          payload.value[keyResult.value] = result.value;
        }
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
var $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Map)) {
      payload.issues.push({
        expected: "map",
        code: "invalid_type",
        input,
        inst,
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Map();
    for (const [key, value] of input) {
      const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
      const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
      if (keyResult instanceof Promise || valueResult instanceof Promise) {
        proms.push(
          Promise.all([keyResult, valueResult]).then(
            ([keyResult2, valueResult2]) => {
              handleMapResult(
                keyResult2,
                valueResult2,
                payload,
                key,
                input,
                inst,
                ctx,
              );
            },
          ),
        );
      } else {
        handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
      }
    }
    if (proms.length) return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, keyResult.issues));
    } else {
      final.issues.push({
        code: "invalid_key",
        origin: "map",
        input,
        inst,
        issues: keyResult.issues.map((iss) =>
          finalizeIssue(iss, ctx, config()),
        ),
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) =>
          finalizeIssue(iss, ctx, config()),
        ),
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
var $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Set)) {
      payload.issues.push({
        input,
        inst,
        expected: "set",
        code: "invalid_type",
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Set();
    for (const item of input) {
      const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleSetResult(result2, payload)));
      } else handleSetResult(result, payload);
    }
    if (proms.length) return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleSetResult(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
var $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  const values = getEnumValues(def.entries);
  const valuesSet = new Set(values);
  inst._zod.values = valuesSet;
  inst._zod.pattern = new RegExp(
    `^(${values
      .filter((k) => propertyKeyTypes.has(typeof k))
      .map((o2) => (typeof o2 === "string" ? escapeRegex(o2) : o2.toString()))
      .join("|")})$`,
  );
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (valuesSet.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst,
    });
    return payload;
  };
});
var $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  if (def.values.length === 0) {
    throw new Error("Cannot create literal schema with no valid values");
  }
  inst._zod.values = new Set(def.values);
  inst._zod.pattern = new RegExp(
    `^(${def.values.map((o2) => (typeof o2 === "string" ? escapeRegex(o2) : o2 ? escapeRegex(o2.toString()) : String(o2))).join("|")})$`,
  );
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst,
    });
    return payload;
  };
});
var $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input instanceof File) return payload;
    payload.issues.push({
      expected: "file",
      code: "invalid_type",
      input,
      inst,
    });
    return payload;
  };
});
var $ZodTransform = /* @__PURE__ */ $constructor(
  "$ZodTransform",
  (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        throw new $ZodEncodeError(inst.constructor.name);
      }
      const _out = def.transform(payload.value, payload);
      if (ctx.async) {
        const output = _out instanceof Promise ? _out : Promise.resolve(_out);
        return output.then((output2) => {
          payload.value = output2;
          return payload;
        });
      }
      if (_out instanceof Promise) {
        throw new $ZodAsyncError();
      }
      payload.value = _out;
      return payload;
    };
  },
);
function handleOptionalResult(result, input) {
  if (result.issues.length && input === void 0) {
    return { issues: [], value: void 0 };
  }
  return result;
}
var $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values
      ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0])
      : void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise)
        return result.then((r2) => handleOptionalResult(r2, payload.value));
      return handleOptionalResult(result, payload.value);
    }
    if (payload.value === void 0) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern
      ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`)
      : void 0;
  });
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values
      ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null])
      : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null) return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult(result2, def));
    }
    return handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  if (payload.value === void 0) {
    payload.value = def.defaultValue;
  }
  return payload;
}
var $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNonOptional = /* @__PURE__ */ $constructor(
  "$ZodNonOptional",
  (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "values", () => {
      const v2 = def.innerType._zod.values;
      return v2 ? new Set([...v2].filter((x) => x !== void 0)) : void 0;
    });
    inst._zod.parse = (payload, ctx) => {
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) {
        return result.then((result2) => handleNonOptionalResult(result2, inst));
      }
      return handleNonOptionalResult(result, inst);
    };
  },
);
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === void 0) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst,
    });
  }
  return payload;
}
var $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError("ZodSuccess");
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.issues.length === 0;
        return payload;
      });
    }
    payload.value = result.issues.length === 0;
    return payload;
  };
});
var $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) =>
                finalizeIssue(iss, ctx, config()),
              ),
            },
            input: payload.value,
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config())),
        },
        input: payload.value,
      });
      payload.issues = [];
    }
    return payload;
  };
});
var $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "nan",
        code: "invalid_type",
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handlePipeResult(right2, def.in, ctx));
      }
      return handlePipeResult(right, def.in, ctx);
    }
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult(left2, def.out, ctx));
    }
    return handlePipeResult(left, def.out, ctx);
  };
});
function handlePipeResult(left, next, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
var $ZodCodec = /* @__PURE__ */ $constructor("$ZodCodec", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    const direction = ctx.direction || "forward";
    if (direction === "forward") {
      const left = def.in._zod.run(payload, ctx);
      if (left instanceof Promise) {
        return left.then((left2) => handleCodecAResult(left2, def, ctx));
      }
      return handleCodecAResult(left, def, ctx);
    } else {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handleCodecAResult(right2, def, ctx));
      }
      return handleCodecAResult(right, def, ctx);
    }
  };
});
function handleCodecAResult(result, def, ctx) {
  if (result.issues.length) {
    result.aborted = true;
    return result;
  }
  const direction = ctx.direction || "forward";
  if (direction === "forward") {
    const transformed = def.transform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) =>
        handleCodecTxResult(result, value, def.out, ctx),
      );
    }
    return handleCodecTxResult(result, transformed, def.out, ctx);
  } else {
    const transformed = def.reverseTransform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) =>
        handleCodecTxResult(result, value, def.in, ctx),
      );
    }
    return handleCodecTxResult(result, transformed, def.in, ctx);
  }
}
function handleCodecTxResult(left, value, nextSchema, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return nextSchema._zod.run({ value, issues: left.issues }, ctx);
}
var $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult);
    }
    return handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
var $ZodTemplateLiteral = /* @__PURE__ */ $constructor(
  "$ZodTemplateLiteral",
  (inst, def) => {
    $ZodType.init(inst, def);
    const regexParts = [];
    for (const part of def.parts) {
      if (typeof part === "object" && part !== null) {
        if (!part._zod.pattern) {
          throw new Error(
            `Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`,
          );
        }
        const source =
          part._zod.pattern instanceof RegExp
            ? part._zod.pattern.source
            : part._zod.pattern;
        if (!source)
          throw new Error(`Invalid template literal part: ${part._zod.traits}`);
        const start = source.startsWith("^") ? 1 : 0;
        const end = source.endsWith("$") ? source.length - 1 : source.length;
        regexParts.push(source.slice(start, end));
      } else if (part === null || primitiveTypes.has(typeof part)) {
        regexParts.push(escapeRegex(`${part}`));
      } else {
        throw new Error(`Invalid template literal part: ${part}`);
      }
    }
    inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
    inst._zod.parse = (payload, _ctx) => {
      if (typeof payload.value !== "string") {
        payload.issues.push({
          input: payload.value,
          inst,
          expected: "template_literal",
          code: "invalid_type",
        });
        return payload;
      }
      inst._zod.pattern.lastIndex = 0;
      if (!inst._zod.pattern.test(payload.value)) {
        payload.issues.push({
          input: payload.value,
          inst,
          code: "invalid_format",
          format: def.format ?? "template_literal",
          pattern: inst._zod.pattern.source,
        });
        return payload;
      }
      return payload;
    };
  },
);
var $ZodFunction = /* @__PURE__ */ $constructor("$ZodFunction", (inst, def) => {
  $ZodType.init(inst, def);
  inst._def = def;
  inst._zod.def = def;
  inst.implement = (func) => {
    if (typeof func !== "function") {
      throw new Error("implement() must be called with a function");
    }
    return function (...args) {
      const parsedArgs = inst._def.input ? parse(inst._def.input, args) : args;
      const result = Reflect.apply(func, this, parsedArgs);
      if (inst._def.output) {
        return parse(inst._def.output, result);
      }
      return result;
    };
  };
  inst.implementAsync = (func) => {
    if (typeof func !== "function") {
      throw new Error("implementAsync() must be called with a function");
    }
    return async function (...args) {
      const parsedArgs = inst._def.input
        ? await parseAsync(inst._def.input, args)
        : args;
      const result = await Reflect.apply(func, this, parsedArgs);
      if (inst._def.output) {
        return await parseAsync(inst._def.output, result);
      }
      return result;
    };
  };
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "function") {
      payload.issues.push({
        code: "invalid_type",
        expected: "function",
        input: payload.value,
        inst,
      });
      return payload;
    }
    const hasPromiseOutput =
      inst._def.output && inst._def.output._zod.def.type === "promise";
    if (hasPromiseOutput) {
      payload.value = inst.implementAsync(payload.value);
    } else {
      payload.value = inst.implement(payload.value);
    }
    return payload;
  };
  inst.input = (...args) => {
    const F = inst.constructor;
    if (Array.isArray(args[0])) {
      return new F({
        type: "function",
        input: new $ZodTuple({
          type: "tuple",
          items: args[0],
          rest: args[1],
        }),
        output: inst._def.output,
      });
    }
    return new F({
      type: "function",
      input: args[0],
      output: inst._def.output,
    });
  };
  inst.output = (output) => {
    const F = inst.constructor;
    return new F({
      type: "function",
      input: inst._def.input,
      output,
    });
  };
  return inst;
});
var $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    return Promise.resolve(payload.value).then((inner) =>
      def.innerType._zod.run({ value: inner, issues: [] }, ctx),
    );
  };
});
var $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "innerType", () => def.getter());
  defineLazy(inst._zod, "pattern", () => inst._zod.innerType._zod.pattern);
  defineLazy(
    inst._zod,
    "propValues",
    () => inst._zod.innerType._zod.propValues,
  );
  defineLazy(
    inst._zod,
    "optin",
    () => inst._zod.innerType._zod.optin ?? void 0,
  );
  defineLazy(
    inst._zod,
    "optout",
    () => inst._zod.innerType._zod.optout ?? void 0,
  );
  inst._zod.parse = (payload, ctx) => {
    const inner = inst._zod.innerType;
    return inner._zod.run(payload, ctx);
  };
});
var $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def);
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _2) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r2 = def.fn(input);
    if (r2 instanceof Promise) {
      return r2.then((r3) => handleRefineResult(r3, payload, input, inst));
    }
    handleRefineResult(r2, payload, input, inst);
    return;
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      // incorporates params.error into issue reporting
      path: [...(inst._zod.def.path ?? [])],
      // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort,
      // params: inst._zod.def.params,
    };
    if (inst._zod.def.params) _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}

// node_modules/zod/v4/locales/index.js
var locales_exports = {};
__export(locales_exports, {
  ar: () => ar_default,
  az: () => az_default,
  be: () => be_default,
  ca: () => ca_default,
  cs: () => cs_default,
  da: () => da_default,
  de: () => de_default,
  en: () => en_default,
  eo: () => eo_default,
  es: () => es_default,
  fa: () => fa_default,
  fi: () => fi_default,
  fr: () => fr_default,
  frCA: () => fr_CA_default,
  he: () => he_default,
  hu: () => hu_default,
  id: () => id_default,
  is: () => is_default,
  it: () => it_default,
  ja: () => ja_default,
  ka: () => ka_default,
  kh: () => kh_default,
  km: () => km_default,
  ko: () => ko_default,
  lt: () => lt_default,
  mk: () => mk_default,
  ms: () => ms_default,
  nl: () => nl_default,
  no: () => no_default,
  ota: () => ota_default,
  pl: () => pl_default,
  ps: () => ps_default,
  pt: () => pt_default,
  ru: () => ru_default,
  sl: () => sl_default,
  sv: () => sv_default,
  ta: () => ta_default,
  th: () => th_default,
  tr: () => tr_default,
  ua: () => ua_default,
  uk: () => uk_default,
  ur: () => ur_default,
  vi: () => vi_default,
  yo: () => yo_default,
  zhCN: () => zh_CN_default,
  zhTW: () => zh_TW_default,
});

// node_modules/zod/v4/locales/ar.js
var error = () => {
  const Sizable = {
    string: {
      unit: "\u062D\u0631\u0641",
      verb: "\u0623\u0646 \u064A\u062D\u0648\u064A",
    },
    file: {
      unit: "\u0628\u0627\u064A\u062A",
      verb: "\u0623\u0646 \u064A\u062D\u0648\u064A",
    },
    array: {
      unit: "\u0639\u0646\u0635\u0631",
      verb: "\u0623\u0646 \u064A\u062D\u0648\u064A",
    },
    set: {
      unit: "\u0639\u0646\u0635\u0631",
      verb: "\u0623\u0646 \u064A\u062D\u0648\u064A",
    },
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (
          Object.getPrototypeOf(data) !== Object.prototype &&
          data.constructor
        ) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "\u0645\u062F\u062E\u0644",
    email:
      "\u0628\u0631\u064A\u062F \u0625\u0644\u0643\u062A\u0631\u0648\u0646\u064A",
    url: "\u0631\u0627\u0628\u0637",
    emoji: "\u0625\u064A\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime:
      "\u062A\u0627\u0631\u064A\u062E \u0648\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    date: "\u062A\u0627\u0631\u064A\u062E \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    time: "\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    duration: "\u0645\u062F\u0629 \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    ipv4: "\u0639\u0646\u0648\u0627\u0646 IPv4",
    ipv6: "\u0639\u0646\u0648\u0627\u0646 IPv6",
    cidrv4:
      "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv4",
    cidrv6:
      "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv6",
    base64:
      "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64-encoded",
    base64url:
      "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64url-encoded",
    json_string:
      "\u0646\u064E\u0635 \u0639\u0644\u0649 \u0647\u064A\u0626\u0629 JSON",
    e164: "\u0631\u0642\u0645 \u0647\u0627\u062A\u0641 \u0628\u0645\u0639\u064A\u0627\u0631 E.164",
    jwt: "JWT",
    template_literal: "\u0645\u062F\u062E\u0644",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${issue3.expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${stringifyPrimitive(issue3.values[0])}`;
        return `\u0627\u062E\u062A\u064A\u0627\u0631 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062A\u0648\u0642\u0639 \u0627\u0646\u062A\u0642\u0627\u0621 \u0623\u062D\u062F \u0647\u0630\u0647 \u0627\u0644\u062E\u064A\u0627\u0631\u0627\u062A: ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return ` \u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue3.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"}`;
        return `\u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue3.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue3.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue3.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0628\u062F\u0623 \u0628\u0640 "${issue3.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0646\u062A\u0647\u064A \u0628\u0640 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u062A\u0636\u0645\u0651\u064E\u0646 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0637\u0627\u0628\u0642 \u0627\u0644\u0646\u0645\u0637 ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644`;
      }
      case "not_multiple_of":
        return `\u0631\u0642\u0645 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0645\u0646 \u0645\u0636\u0627\u0639\u0641\u0627\u062A ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\u0645\u0639\u0631\u0641${issue3.keys.length > 1 ? "\u0627\u062A" : ""} \u063A\u0631\u064A\u0628${issue3.keys.length > 1 ? "\u0629" : ""}: ${joinValues(issue3.keys, "\u060C ")}`;
      case "invalid_key":
        return `\u0645\u0639\u0631\u0641 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue3.origin}`;
      case "invalid_union":
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
      case "invalid_element":
        return `\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue3.origin}`;
      default:
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
    }
  };
};
function ar_default() {
  return {
    localeError: error(),
  };
}

// node_modules/zod/v4/locales/az.js
var error2 = () => {
  const Sizable = {
    string: { unit: "simvol", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "element", verb: "olmal\u0131d\u0131r" },
    set: { unit: "element", verb: "olmal\u0131d\u0131r" },
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (
          Object.getPrototypeOf(data) !== Object.prototype &&
          data.constructor
        ) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${issue3.expected}, daxil olan ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${stringifyPrimitive(issue3.values[0])}`;
        return `Yanl\u0131\u015F se\xE7im: a\u015Fa\u011F\u0131dak\u0131lardan biri olmal\u0131d\u0131r: ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue3.origin ?? "d\u0259y\u0259r"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "element"}`;
        return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue3.origin ?? "d\u0259y\u0259r"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.prefix}" il\u0259 ba\u015Flamal\u0131d\u0131r`;
        if (_issue.format === "ends_with")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.suffix}" il\u0259 bitm\u0259lidir`;
        if (_issue.format === "includes")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.includes}" daxil olmal\u0131d\u0131r`;
        if (_issue.format === "regex")
          return `Yanl\u0131\u015F m\u0259tn: ${_issue.pattern} \u015Fablonuna uy\u011Fun olmal\u0131d\u0131r`;
        return `Yanl\u0131\u015F ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Yanl\u0131\u015F \u0259d\u0259d: ${issue3.divisor} il\u0259 b\xF6l\xFCn\u0259 bil\u0259n olmal\u0131d\u0131r`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan a\xE7ar${issue3.keys.length > 1 ? "lar" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} daxilind\u0259 yanl\u0131\u015F a\xE7ar`;
      case "invalid_union":
        return "Yanl\u0131\u015F d\u0259y\u0259r";
      case "invalid_element":
        return `${issue3.origin} daxilind\u0259 yanl\u0131\u015F d\u0259y\u0259r`;
      default:
        return `Yanl\u0131\u015F d\u0259y\u0259r`;
    }
  };
};
function az_default() {
  return {
    localeError: error2(),
  };
}

// node_modules/zod/v4/locales/be.js
function getBelarusianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error3 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0456\u043C\u0432\u0430\u043B",
        few: "\u0441\u0456\u043C\u0432\u0430\u043B\u044B",
        many: "\u0441\u0456\u043C\u0432\u0430\u043B\u0430\u045E",
      },
      verb: "\u043C\u0435\u0446\u044C",
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E",
      },
      verb: "\u043C\u0435\u0446\u044C",
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E",
      },
      verb: "\u043C\u0435\u0446\u044C",
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u044B",
        many: "\u0431\u0430\u0439\u0442\u0430\u045E",
      },
      verb: "\u043C\u0435\u0446\u044C",
    },
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u043B\u0456\u043A";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043C\u0430\u0441\u0456\u045E";
        }
        if (data === null) {
          return "null";
        }
        if (
          Object.getPrototypeOf(data) !== Object.prototype &&
          data.constructor
        ) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "\u0443\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0430\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0430 \u0456 \u0447\u0430\u0441",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0447\u0430\u0441",
    duration:
      "ISO \u043F\u0440\u0430\u0446\u044F\u0433\u043B\u0430\u0441\u0446\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0430\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0430\u0441",
    cidrv4: "IPv4 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    base64:
      "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64",
    base64url:
      "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64url",
    json_string: "JSON \u0440\u0430\u0434\u043E\u043A",
    e164: "\u043D\u0443\u043C\u0430\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0443\u0432\u043E\u0434",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F ${issue3.expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F ${stringifyPrimitive(issue3.values[0])}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0432\u0430\u0440\u044B\u044F\u043D\u0442: \u0447\u0430\u043A\u0430\u045E\u0441\u044F \u0430\u0434\u0437\u0456\u043D \u0437 ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const maxValue = Number(issue3.maximum);
          const unit = getBelarusianPlural(
            maxValue,
            sizing.unit.one,
            sizing.unit.few,
            sizing.unit.many,
          );
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue3.maximum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const minValue = Number(issue3.minimum);
          const unit = getBelarusianPlural(
            minValue,
            sizing.unit.one,
            sizing.unit.few,
            sizing.unit.many,
          );
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue3.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue3.minimum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue3.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u043F\u0430\u0447\u044B\u043D\u0430\u0446\u0446\u0430 \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u0430\u043A\u0430\u043D\u0447\u0432\u0430\u0446\u0446\u0430 \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u043C\u044F\u0448\u0447\u0430\u0446\u044C "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0430\u0434\u043F\u0430\u0432\u044F\u0434\u0430\u0446\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043B\u0456\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0431\u044B\u0446\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u0430\u0437\u043D\u0430\u043D\u044B ${issue3.keys.length > 1 ? "\u043A\u043B\u044E\u0447\u044B" : "\u043A\u043B\u044E\u0447"}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043A\u043B\u044E\u0447 \u0443 ${issue3.origin}`;
      case "invalid_union":
        return "\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434";
      case "invalid_element":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u0430\u0435 \u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435 \u045E ${issue3.origin}`;
      default:
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434`;
    }
  };
};
function be_default() {
  return {
    localeError: error3(),
  };
}

// node_modules/zod/v4/locales/ca.js
var error4 = () => {
  const Sizable = {
    string: { unit: "car\xE0cters", verb: "contenir" },
    file: { unit: "bytes", verb: "contenir" },
    array: { unit: "elements", verb: "contenir" },
    set: { unit: "elements", verb: "contenir" },
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (
          Object.getPrototypeOf(data) !== Object.prototype &&
          data.constructor
        ) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "entrada",
    email: "adre\xE7a electr\xF2nica",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durada ISO",
    ipv4: "adre\xE7a IPv4",
    ipv6: "adre\xE7a IPv6",
    cidrv4: "rang IPv4",
    cidrv6: "rang IPv6",
    base64: "cadena codificada en base64",
    base64url: "cadena codificada en base64url",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Tipus inv\xE0lid: s'esperava ${issue3.expected}, s'ha rebut ${parsedType7(issue3.input)}`;
      // return `Tipus invàlid: s'esperava ${issue.expected}, s'ha rebut ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Valor inv\xE0lid: s'esperava ${stringifyPrimitive(issue3.values[0])}`;
        return `Opci\xF3 inv\xE0lida: s'esperava una de ${joinValues(issue3.values, " o ")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "com a m\xE0xim" : "menys de";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Massa gran: s'esperava que ${issue3.origin ?? "el valor"} contingu\xE9s ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Massa gran: s'esperava que ${issue3.origin ?? "el valor"} fos ${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "com a m\xEDnim" : "m\xE9s de";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Massa petit: s'esperava que ${issue3.origin} contingu\xE9s ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Massa petit: s'esperava que ${issue3.origin} fos ${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Format inv\xE0lid: ha de comen\xE7ar amb "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Format inv\xE0lid: ha d'acabar amb "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Format inv\xE0lid: ha d'incloure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Format inv\xE0lid: ha de coincidir amb el patr\xF3 ${_issue.pattern}`;
        return `Format inv\xE0lid per a ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE0lid: ha de ser m\xFAltiple de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Clau${issue3.keys.length > 1 ? "s" : ""} no reconeguda${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Clau inv\xE0lida a ${issue3.origin}`;
      case "invalid_union":
        return "Entrada inv\xE0lida";
      // Could also be "Tipus d'unió invàlid" but "Entrada invàlida" is more general
      case "invalid_element":
        return `Element inv\xE0lid a ${issue3.origin}`;
      default:
        return `Entrada inv\xE0lida`;
    }
  };
};
function ca_default() {
  return {
    localeError: error4(),
  };
}

// node_modules/zod/v4/locales/cs.js
var error5 = () => {
  const Sizable = {
    string: { unit: "znak\u016F", verb: "m\xEDt" },
    file: { unit: "bajt\u016F", verb: "m\xEDt" },
    array: { unit: "prvk\u016F", verb: "m\xEDt" },
    set: { unit: "prvk\u016F", verb: "m\xEDt" },
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u010D\xEDslo";
      }
      case "string": {
        return "\u0159et\u011Bzec";
      }
      case "boolean": {
        return "boolean";
      }
      case "bigint": {
        return "bigint";
      }
      case "function": {
        return "funkce";
      }
      case "symbol": {
        return "symbol";
      }
      case "undefined": {
        return "undefined";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "pole";
        }
        if (data === null) {
          return "null";
        }
        if (
          Object.getPrototypeOf(data) !== Object.prototype &&
          data.constructor
        ) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "regul\xE1rn\xED v\xFDraz",
    email: "e-mailov\xE1 adresa",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "datum a \u010Das ve form\xE1tu ISO",
    date: "datum ve form\xE1tu ISO",
    time: "\u010Das ve form\xE1tu ISO",
    duration: "doba trv\xE1n\xED ISO",
    ipv4: "IPv4 adresa",
    ipv6: "IPv6 adresa",
    cidrv4: "rozsah IPv4",
    cidrv6: "rozsah IPv6",
    base64: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64",
    base64url: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64url",
    json_string: "\u0159et\u011Bzec ve form\xE1tu JSON",
    e164: "\u010D\xEDslo E.164",
    jwt: "JWT",
    template_literal: "vstup",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${issue3.expected}, obdr\u017Eeno ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${stringifyPrimitive(issue3.values[0])}`;
        return `Neplatn\xE1 mo\u017Enost: o\u010Dek\xE1v\xE1na jedna z hodnot ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue3.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue3.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue3.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue3.minimum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue3.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED za\u010D\xEDnat na "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED kon\u010Dit na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED obsahovat "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED odpov\xEDdat vzoru ${_issue.pattern}`;
        return `Neplatn\xFD form\xE1t ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Neplatn\xE9 \u010D\xEDslo: mus\xED b\xFDt n\xE1sobkem ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Nezn\xE1m\xE9 kl\xED\u010De: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Neplatn\xFD kl\xED\u010D v ${issue3.origin}`;
      case "invalid_union":
        return "Neplatn\xFD vstup";
      case "invalid_element":
        return `Neplatn\xE1 hodnota v ${issue3.origin}`;
      default:
        return `Neplatn\xFD vstup`;
    }
  };
};
function cs_default() {
  return {
    localeError: error5(),
  };
}

// node_modules/zod/v4/locales/da.js
var error6 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "havde" },
    file: { unit: "bytes", verb: "havde" },
    array: { unit: "elementer", verb: "indeholdt" },
    set: { unit: "elementer", verb: "indeholdt" },
  };
  const TypeNames = {
    string: "streng",
    number: "tal",
    boolean: "boolean",
    array: "liste",
    object: "objekt",
    set: "s\xE6t",
    file: "fil",
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  function getTypeName(type) {
    return TypeNames[type] ?? type;
  }
  const parsedType7 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "tal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "liste";
        }
        if (data === null) {
          return "null";
        }
        if (
          Object.getPrototypeOf(data) !== Object.prototype &&
          data.constructor
        ) {
          return data.constructor.name;
        }
        return "objekt";
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "input",
    email: "e-mailadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkesl\xE6t",
    date: "ISO-dato",
    time: "ISO-klokkesl\xE6t",
    duration: "ISO-varighed",
    ipv4: "IPv4-omr\xE5de",
    ipv6: "IPv6-omr\xE5de",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodet streng",
    base64url: "base64url-kodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ugyldigt input: forventede ${getTypeName(issue3.expected)}, fik ${getTypeName(parsedType7(issue3.input))}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ugyldig v\xE6rdi: forventede ${stringifyPrimitive(issue3.values[0])}`;
        return `Ugyldigt valg: forventede en af f\xF8lgende ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        const origin = getTypeName(issue3.origin);
        if (sizing)
          return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        const origin = getTypeName(issue3.origin);
        if (sizing) {
          return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `For lille: forventede ${origin} havde ${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: skal starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: skal ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: skal indeholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: skal matche m\xF8nsteret ${_issue.pattern}`;
        return `Ugyldig ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ugyldigt tal: skal v\xE6re deleligt med ${issue3.divisor}`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Ukendte n\xF8gler" : "Ukendt n\xF8gle"}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig n\xF8gle i ${issue3.origin}`;
      case "invalid_union":
        return "Ugyldigt input: matcher ingen af de tilladte typer";
      case "invalid_element":
        return `Ugyldig v\xE6rdi i ${issue3.origin}`;
      default:
        return `Ugyldigt input`;
    }
  };
};
function da_default() {
  return {
    localeError: error6(),
  };
}

// node_modules/zod/v4/locales/de.js
var error7 = () => {
  const Sizable = {
    string: { unit: "Zeichen", verb: "zu haben" },
    file: { unit: "Bytes", verb: "zu haben" },
    array: { unit: "Elemente", verb: "zu haben" },
    set: { unit: "Elemente", verb: "zu haben" },
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "Zahl";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "Array";
        }
        if (data === null) {
          return "null";
        }
        if (
          Object.getPrototypeOf(data) !== Object.prototype &&
          data.constructor
        ) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "Eingabe",
    email: "E-Mail-Adresse",
    url: "URL",
    emoji: "Emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-Datum und -Uhrzeit",
    date: "ISO-Datum",
    time: "ISO-Uhrzeit",
    duration: "ISO-Dauer",
    ipv4: "IPv4-Adresse",
    ipv6: "IPv6-Adresse",
    cidrv4: "IPv4-Bereich",
    cidrv6: "IPv6-Bereich",
    base64: "Base64-codierter String",
    base64url: "Base64-URL-codierter String",
    json_string: "JSON-String",
    e164: "E.164-Nummer",
    jwt: "JWT",
    template_literal: "Eingabe",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ung\xFCltige Eingabe: erwartet ${issue3.expected}, erhalten ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ung\xFCltige Eingabe: erwartet ${stringifyPrimitive(issue3.values[0])}`;
        return `Ung\xFCltige Option: erwartet eine von ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Zu gro\xDF: erwartet, dass ${issue3.origin ?? "Wert"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
        return `Zu gro\xDF: erwartet, dass ${issue3.origin ?? "Wert"} ${adj}${issue3.maximum.toString()} ist`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Zu klein: erwartet, dass ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit} hat`;
        }
        return `Zu klein: erwartet, dass ${issue3.origin} ${adj}${issue3.minimum.toString()} ist`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Ung\xFCltiger String: muss mit "${_issue.prefix}" beginnen`;
        if (_issue.format === "ends_with")
          return `Ung\xFCltiger String: muss mit "${_issue.suffix}" enden`;
        if (_issue.format === "includes")
          return `Ung\xFCltiger String: muss "${_issue.includes}" enthalten`;
        if (_issue.format === "regex")
          return `Ung\xFCltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
        return `Ung\xFCltig: ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ung\xFCltige Zahl: muss ein Vielfaches von ${issue3.divisor} sein`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Unbekannte Schl\xFCssel" : "Unbekannter Schl\xFCssel"}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ung\xFCltiger Schl\xFCssel in ${issue3.origin}`;
      case "invalid_union":
        return "Ung\xFCltige Eingabe";
      case "invalid_element":
        return `Ung\xFCltiger Wert in ${issue3.origin}`;
      default:
        return `Ung\xFCltige Eingabe`;
    }
  };
};
function de_default() {
  return {
    localeError: error7(),
  };
}

// node_modules/zod/v4/locales/en.js
var parsedType = (data) => {
  const t2 = typeof data;
  switch (t2) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (
        Object.getPrototypeOf(data) !== Object.prototype &&
        data.constructor
      ) {
        return data.constructor.name;
      }
    }
  }
  return t2;
};
var error8 = () => {
  const Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" },
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Invalid input: expected ${issue3.expected}, received ${parsedType(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue3.values[0])}`;
        return `Invalid option: expected one of ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Too big: expected ${issue3.origin ?? "value"} to have ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Too big: expected ${issue3.origin ?? "value"} to be ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Too small: expected ${issue3.origin} to have ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Too small: expected ${issue3.origin} to be ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Invalid string: must start with "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Invalid string: must end with "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Invalid string: must include "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Invalid string: must match pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue3.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue3.origin}`;
      default:
        return `Invalid input`;
    }
  };
};
function en_default() {
  return {
    localeError: error8(),
  };
}

// node_modules/zod/v4/locales/eo.js
var parsedType2 = (data) => {
  const t2 = typeof data;
  switch (t2) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "nombro";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "tabelo";
      }
      if (data === null) {
        return "senvalora";
      }
      if (
        Object.getPrototypeOf(data) !== Object.prototype &&
        data.constructor
      ) {
        return data.constructor.name;
      }
    }
  }
  return t2;
};
var error9 = () => {
  const Sizable = {
    string: { unit: "karaktrojn", verb: "havi" },
    file: { unit: "bajtojn", verb: "havi" },
    array: { unit: "elementojn", verb: "havi" },
    set: { unit: "elementojn", verb: "havi" },
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "enigo",
    email: "retadreso",
    url: "URL",
    emoji: "emo\u011Dio",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datotempo",
    date: "ISO-dato",
    time: "ISO-tempo",
    duration: "ISO-da\u016Dro",
    ipv4: "IPv4-adreso",
    ipv6: "IPv6-adreso",
    cidrv4: "IPv4-rango",
    cidrv6: "IPv6-rango",
    base64: "64-ume kodita karaktraro",
    base64url: "URL-64-ume kodita karaktraro",
    json_string: "JSON-karaktraro",
    e164: "E.164-nombro",
    jwt: "JWT",
    template_literal: "enigo",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Nevalida enigo: atendi\u011Dis ${issue3.expected}, ricevi\u011Dis ${parsedType2(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Nevalida enigo: atendi\u011Dis ${stringifyPrimitive(issue3.values[0])}`;
        return `Nevalida opcio: atendi\u011Dis unu el ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Tro granda: atendi\u011Dis ke ${issue3.origin ?? "valoro"} havu ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
        return `Tro granda: atendi\u011Dis ke ${issue3.origin ?? "valoro"} havu ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Tro malgranda: atendi\u011Dis ke ${issue3.origin} havu ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Tro malgranda: atendi\u011Dis ke ${issue3.origin} estu ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Nevalida karaktraro: devas komenci\u011Di per "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nevalida karaktraro: devas fini\u011Di per "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
        return `Nevalida ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${issue3.keys.length > 1 ? "j" : ""} \u015Dlosilo${issue3.keys.length > 1 ? "j" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida \u015Dlosilo en ${issue3.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${issue3.origin}`;
      default:
        return `Nevalida enigo`;
    }
  };
};
function eo_default() {
  return {
    localeError: error9(),
  };
}

// node_modules/zod/v4/locales/es.js
var error10 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "tener" },
    file: { unit: "bytes", verb: "tener" },
    array: { unit: "elementos", verb: "tener" },
    set: { unit: "elementos", verb: "tener" },
  };
  const TypeNames = {
    string: "texto",
    number: "n\xFAmero",
    boolean: "booleano",
    array: "arreglo",
    object: "objeto",
    set: "conjunto",
    file: "archivo",
    date: "fecha",
    bigint: "n\xFAmero grande",
    symbol: "s\xEDmbolo",
    undefined: "indefinido",
    null: "nulo",
    function: "funci\xF3n",
    map: "mapa",
    record: "registro",
    tuple: "tupla",
    enum: "enumeraci\xF3n",
    union: "uni\xF3n",
    literal: "literal",
    promise: "promesa",
    void: "vac\xEDo",
    never: "nunca",
    unknown: "desconocido",
    any: "cualquiera",
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  function getTypeName(type) {
    return TypeNames[type] ?? type;
  }
  const parsedType7 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype) {
          return data.constructor.name;
        }
        return "object";
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "entrada",
    email: "direcci\xF3n de correo electr\xF3nico",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "fecha y hora ISO",
    date: "fecha ISO",
    time: "hora ISO",
    duration: "duraci\xF3n ISO",
    ipv4: "direcci\xF3n IPv4",
    ipv6: "direcci\xF3n IPv6",
    cidrv4: "rango IPv4",
    cidrv6: "rango IPv6",
    base64: "cadena codificada en base64",
    base64url: "URL codificada en base64",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Entrada inv\xE1lida: se esperaba ${getTypeName(issue3.expected)}, recibido ${getTypeName(parsedType7(issue3.input))}`;
      // return `Entrada inválida: se esperaba ${issue.expected}, recibido ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Entrada inv\xE1lida: se esperaba ${stringifyPrimitive(issue3.values[0])}`;
        return `Opci\xF3n inv\xE1lida: se esperaba una de ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        const origin = getTypeName(issue3.origin);
        if (sizing)
          return `Demasiado grande: se esperaba que ${origin ?? "valor"} tuviera ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Demasiado grande: se esperaba que ${origin ?? "valor"} fuera ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        const origin = getTypeName(issue3.origin);
        if (sizing) {
          return `Demasiado peque\xF1o: se esperaba que ${origin} tuviera ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Demasiado peque\xF1o: se esperaba que ${origin} fuera ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Cadena inv\xE1lida: debe comenzar con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cadena inv\xE1lida: debe terminar en "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cadena inv\xE1lida: debe incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cadena inv\xE1lida: debe coincidir con el patr\xF3n ${_issue.pattern}`;
        return `Inv\xE1lido ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: debe ser m\xFAltiplo de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Llave${issue3.keys.length > 1 ? "s" : ""} desconocida${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Llave inv\xE1lida en ${getTypeName(issue3.origin)}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido en ${getTypeName(issue3.origin)}`;
      default:
        return `Entrada inv\xE1lida`;
    }
  };
};
function es_default() {
  return {
    localeError: error10(),
  };
}

// node_modules/zod/v4/locales/fa.js
var error11 = () => {
  const Sizable = {
    string: {
      unit: "\u06A9\u0627\u0631\u0627\u06A9\u062A\u0631",
      verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F",
    },
    file: {
      unit: "\u0628\u0627\u06CC\u062A",
      verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F",
    },
    array: {
      unit: "\u0622\u06CC\u062A\u0645",
      verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F",
    },
    set: {
      unit: "\u0622\u06CC\u062A\u0645",
      verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F",
    },
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0639\u062F\u062F";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0622\u0631\u0627\u06CC\u0647";
        }
        if (data === null) {
          return "null";
        }
        if (
          Object.getPrototypeOf(data) !== Object.prototype &&
          data.constructor
        ) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "\u0648\u0631\u0648\u062F\u06CC",
    email: "\u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644",
    url: "URL",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime:
      "\u062A\u0627\u0631\u06CC\u062E \u0648 \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    date: "\u062A\u0627\u0631\u06CC\u062E \u0627\u06CC\u0632\u0648",
    time: "\u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    duration:
      "\u0645\u062F\u062A \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    ipv4: "IPv4 \u0622\u062F\u0631\u0633",
    ipv6: "IPv6 \u0622\u062F\u0631\u0633",
    cidrv4: "IPv4 \u062F\u0627\u0645\u0646\u0647",
    cidrv6: "IPv6 \u062F\u0627\u0645\u0646\u0647",
    base64: "base64-encoded \u0631\u0634\u062A\u0647",
    base64url: "base64url-encoded \u0631\u0634\u062A\u0647",
    json_string: "JSON \u0631\u0634\u062A\u0647",
    e164: "E.164 \u0639\u062F\u062F",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u06CC",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${issue3.expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${parsedType7(issue3.input)} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
      case "invalid_value":
        if (issue3.values.length === 1) {
          return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${stringifyPrimitive(issue3.values[0])} \u0645\u06CC\u200C\u0628\u0648\u062F`;
        }
        return `\u06AF\u0632\u06CC\u0646\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A \u06CC\u06A9\u06CC \u0627\u0632 ${joinValues(issue3.values, "|")} \u0645\u06CC\u200C\u0628\u0648\u062F`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue3.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue3.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue3.maximum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue3.origin} \u0628\u0627\u06CC\u062F ${adj}${issue3.minimum.toString()} ${sizing.unit} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue3.origin} \u0628\u0627\u06CC\u062F ${adj}${issue3.minimum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.prefix}" \u0634\u0631\u0648\u0639 \u0634\u0648\u062F`;
        }
        if (_issue.format === "ends_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.suffix}" \u062A\u0645\u0627\u0645 \u0634\u0648\u062F`;
        }
        if (_issue.format === "includes") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0634\u0627\u0645\u0644 "${_issue.includes}" \u0628\u0627\u0634\u062F`;
        }
        if (_issue.format === "regex") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 \u0627\u0644\u06AF\u0648\u06CC ${_issue.pattern} \u0645\u0637\u0627\u0628\u0642\u062A \u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F`;
        }
        return `${Nouns[_issue.format] ?? issue3.format} \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      }
      case "not_multiple_of":
        return `\u0639\u062F\u062F \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0645\u0636\u0631\u0628 ${issue3.divisor} \u0628\u0627\u0634\u062F`;
      case "unrecognized_keys":
        return `\u06A9\u0644\u06CC\u062F${issue3.keys.length > 1 ? "\u0647\u0627\u06CC" : ""} \u0646\u0627\u0634\u0646\u0627\u0633: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u06A9\u0644\u06CC\u062F \u0646\u0627\u0634\u0646\u0627\u0633 \u062F\u0631 ${issue3.origin}`;
      case "invalid_union":
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      case "invalid_element":
        return `\u0645\u0642\u062F\u0627\u0631 \u0646\u0627\u0645\u0639\u062A\u0628\u0631 \u062F\u0631 ${issue3.origin}`;
      default:
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
    }
  };
};
function fa_default() {
  return {
    localeError: error11(),
  };
}

// node_modules/zod/v4/locales/fi.js
var error12 = () => {
  const Sizable = {
    string: { unit: "merkki\xE4", subject: "merkkijonon" },
    file: { unit: "tavua", subject: "tiedoston" },
    array: { unit: "alkiota", subject: "listan" },
    set: { unit: "alkiota", subject: "joukon" },
    number: { unit: "", subject: "luvun" },
    bigint: { unit: "", subject: "suuren kokonaisluvun" },
    int: { unit: "", subject: "kokonaisluvun" },
    date: { unit: "", subject: "p\xE4iv\xE4m\xE4\xE4r\xE4n" },
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (
          Object.getPrototypeOf(data) !== Object.prototype &&
          data.constructor
        ) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "s\xE4\xE4nn\xF6llinen lauseke",
    email: "s\xE4hk\xF6postiosoite",
    url: "URL-osoite",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-aikaleima",
    date: "ISO-p\xE4iv\xE4m\xE4\xE4r\xE4",
    time: "ISO-aika",
    duration: "ISO-kesto",
    ipv4: "IPv4-osoite",
    ipv6: "IPv6-osoite",
    cidrv4: "IPv4-alue",
    cidrv6: "IPv6-alue",
    base64: "base64-koodattu merkkijono",
    base64url: "base64url-koodattu merkkijono",
    json_string: "JSON-merkkijono",
    e164: "E.164-luku",
    jwt: "JWT",
    template_literal: "templaattimerkkijono",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Virheellinen tyyppi: odotettiin ${issue3.expected}, oli ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Virheellinen sy\xF6te: t\xE4ytyy olla ${stringifyPrimitive(issue3.values[0])}`;
        return `Virheellinen valinta: t\xE4ytyy olla yksi seuraavista: ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Liian suuri: ${sizing.subject} t\xE4ytyy olla ${adj}${issue3.maximum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian suuri: arvon t\xE4ytyy olla ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Liian pieni: ${sizing.subject} t\xE4ytyy olla ${adj}${issue3.minimum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian pieni: arvon t\xE4ytyy olla ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Virheellinen sy\xF6te: t\xE4ytyy alkaa "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Virheellinen sy\xF6te: t\xE4ytyy loppua "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Virheellinen sy\xF6te: t\xE4ytyy sis\xE4lt\xE4\xE4 "${_issue.includes}"`;
        if (_issue.format === "regex") {
          return `Virheellinen sy\xF6te: t\xE4ytyy vastata s\xE4\xE4nn\xF6llist\xE4 lauseketta ${_issue.pattern}`;
        }
        return `Virheellinen ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: t\xE4ytyy olla luvun ${issue3.divisor} monikerta`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return `Virheellinen sy\xF6te`;
    }
  };
};
function fi_default() {
  return {
    localeError: error12(),
  };
}

// node_modules/zod/v4/locales/fr.js
var error13 = () => {
  const Sizable = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" },
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombre";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tableau";
        }
        if (data === null) {
          return "null";
        }
        if (
          Object.getPrototypeOf(data) !== Object.prototype &&
          data.constructor
        ) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "entr\xE9e",
    email: "adresse e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date et heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Entr\xE9e invalide : ${issue3.expected} attendu, ${parsedType7(issue3.input)} re\xE7u`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Entr\xE9e invalide : ${stringifyPrimitive(issue3.values[0])} attendu`;
        return `Option invalide : une valeur parmi ${joinValues(issue3.values, "|")} attendue`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Trop grand : ${issue3.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\xE9l\xE9ment(s)"}`;
        return `Trop grand : ${issue3.origin ?? "valeur"} doit \xEAtre ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Trop petit : ${issue3.origin} doit ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : ${issue3.origin} doit \xEAtre ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cha\xEEne invalide : doit correspondre au mod\xE8le ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue3.keys.length > 1 ? "s" : ""} non reconnue${issue3.keys.length > 1 ? "s" : ""} : ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue3.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue3.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
};
function fr_default() {
  return {
    localeError: error13(),
  };
}

// node_modules/zod/v4/locales/fr-CA.js
var error14 = () => {
  const Sizable = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" },
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (
          Object.getPrototypeOf(data) !== Object.prototype &&
          data.constructor
        ) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "entr\xE9e",
    email: "adresse courriel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date-heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Entr\xE9e invalide : attendu ${issue3.expected}, re\xE7u ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Entr\xE9e invalide : attendu ${stringifyPrimitive(issue3.values[0])}`;
        return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "\u2264" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Trop grand : attendu que ${issue3.origin ?? "la valeur"} ait ${adj}${issue3.maximum.toString()} ${sizing.unit}`;
        return `Trop grand : attendu que ${issue3.origin ?? "la valeur"} soit ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "\u2265" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Trop petit : attendu que ${issue3.origin} ait ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : attendu que ${issue3.origin} soit ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cha\xEEne invalide : doit correspondre au motif ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue3.keys.length > 1 ? "s" : ""} non reconnue${issue3.keys.length > 1 ? "s" : ""} : ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue3.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue3.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
};
function fr_CA_default() {
  return {
    localeError: error14(),
  };
}

// node_modules/zod/v4/locales/he.js
var error15 = () => {
  const Sizable = {
    string: {
      unit: "\u05D0\u05D5\u05EA\u05D9\u05D5\u05EA",
      verb: "\u05DC\u05DB\u05DC\u05D5\u05DC",
    },
    file: {
      unit: "\u05D1\u05D9\u05D9\u05D8\u05D9\u05DD",
      verb: "\u05DC\u05DB\u05DC\u05D5\u05DC",
    },
    array: {
      unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD",
      verb: "\u05DC\u05DB\u05DC\u05D5\u05DC",
    },
    set: {
      unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD",
      verb: "\u05DC\u05DB\u05DC\u05D5\u05DC",
    },
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (
          Object.getPrototypeOf(data) !== Object.prototype &&
          data.constructor
        ) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "\u05E7\u05DC\u05D8",
    email:
      "\u05DB\u05EA\u05D5\u05D1\u05EA \u05D0\u05D9\u05DE\u05D9\u05D9\u05DC",
    url: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05E8\u05E9\u05EA",
    emoji: "\u05D0\u05D9\u05DE\u05D5\u05D2'\u05D9",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u05EA\u05D0\u05E8\u05D9\u05DA \u05D5\u05D6\u05DE\u05DF ISO",
    date: "\u05EA\u05D0\u05E8\u05D9\u05DA ISO",
    time: "\u05D6\u05DE\u05DF ISO",
    duration: "\u05DE\u05E9\u05DA \u05D6\u05DE\u05DF ISO",
    ipv4: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv4",
    ipv6: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv6",
    cidrv4: "\u05D8\u05D5\u05D5\u05D7 IPv4",
    cidrv6: "\u05D8\u05D5\u05D5\u05D7 IPv6",
    base64:
      "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64",
    base64url:
      "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64 \u05DC\u05DB\u05EA\u05D5\u05D1\u05D5\u05EA \u05E8\u05E9\u05EA",
    json_string: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA JSON",
    e164: "\u05DE\u05E1\u05E4\u05E8 E.164",
    jwt: "JWT",
    template_literal: "\u05E7\u05DC\u05D8",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA ${issue3.expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${parsedType7(issue3.input)}`;
      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA ${stringifyPrimitive(issue3.values[0])}`;
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05D0\u05D7\u05EA \u05DE\u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA  ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${issue3.origin ?? "value"} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${issue3.origin ?? "value"} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${issue3.origin} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${issue3.origin} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D7\u05D9\u05DC \u05D1"${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05DB\u05DC\u05D5\u05DC "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D0\u05D9\u05DD \u05DC\u05EA\u05D1\u05E0\u05D9\u05EA ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
      }
      case "not_multiple_of":
        return `\u05DE\u05E1\u05E4\u05E8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05DB\u05E4\u05DC\u05D4 \u05E9\u05DC ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\u05DE\u05E4\u05EA\u05D7${issue3.keys.length > 1 ? "\u05D5\u05EA" : ""} \u05DC\u05D0 \u05DE\u05D6\u05D5\u05D4${issue3.keys.length > 1 ? "\u05D9\u05DD" : "\u05D4"}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u05DE\u05E4\u05EA\u05D7 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${issue3.origin}`;
      case "invalid_union":
        return "\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF";
      case "invalid_element":
        return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${issue3.origin}`;
      default:
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
    }
  };
};
function he_default() {
  return {
    localeError: error15(),
  };
}

// node_modules/zod/v4/locales/hu.js
var error16 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "legyen" },
    file: { unit: "byte", verb: "legyen" },
    array: { unit: "elem", verb: "legyen" },
    set: { unit: "elem", verb: "legyen" },
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "sz\xE1m";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "t\xF6mb";
        }
        if (data === null) {
          return "null";
        }
        if (
          Object.getPrototypeOf(data) !== Object.prototype &&
          data.constructor
        ) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "bemenet",
    email: "email c\xEDm",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO id\u0151b\xE9lyeg",
    date: "ISO d\xE1tum",
    time: "ISO id\u0151",
    duration: "ISO id\u0151intervallum",
    ipv4: "IPv4 c\xEDm",
    ipv6: "IPv6 c\xEDm",
    cidrv4: "IPv4 tartom\xE1ny",
    cidrv6: "IPv6 tartom\xE1ny",
    base64: "base64-k\xF3dolt string",
    base64url: "base64url-k\xF3dolt string",
    json_string: "JSON string",
    e164: "E.164 sz\xE1m",
    jwt: "JWT",
    template_literal: "bemenet",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${issue3.expected}, a kapott \xE9rt\xE9k ${parsedType7(issue3.input)}`;
      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${stringifyPrimitive(issue3.values[0])}`;
        return `\xC9rv\xE9nytelen opci\xF3: valamelyik \xE9rt\xE9k v\xE1rt ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `T\xFAl nagy: ${issue3.origin ?? "\xE9rt\xE9k"} m\xE9rete t\xFAl nagy ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elem"}`;
        return `T\xFAl nagy: a bemeneti \xE9rt\xE9k ${issue3.origin ?? "\xE9rt\xE9k"} t\xFAl nagy: ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue3.origin} m\xE9rete t\xFAl kicsi ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue3.origin} t\xFAl kicsi ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\xC9rv\xE9nytelen string: "${_issue.prefix}" \xE9rt\xE9kkel kell kezd\u0151dnie`;
        if (_issue.format === "ends_with")
          return `\xC9rv\xE9nytelen string: "${_issue.suffix}" \xE9rt\xE9kkel kell v\xE9gz\u0151dnie`;
        if (_issue.format === "includes")
          return `\xC9rv\xE9nytelen string: "${_issue.includes}" \xE9rt\xE9ket kell tartalmaznia`;
        if (_issue.format === "regex")
          return `\xC9rv\xE9nytelen string: ${_issue.pattern} mint\xE1nak kell megfelelnie`;
        return `\xC9rv\xE9nytelen ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\xC9rv\xE9nytelen sz\xE1m: ${issue3.divisor} t\xF6bbsz\xF6r\xF6s\xE9nek kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\xC9rv\xE9nytelen kulcs ${issue3.origin}`;
      case "invalid_union":
        return "\xC9rv\xE9nytelen bemenet";
      case "invalid_element":
        return `\xC9rv\xE9nytelen \xE9rt\xE9k: ${issue3.origin}`;
      default:
        return `\xC9rv\xE9nytelen bemenet`;
    }
  };
};
function hu_default() {
  return {
    localeError: error16(),
  };
}

// node_modules/zod/v4/locales/id.js
var error17 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "memiliki" },
    file: { unit: "byte", verb: "memiliki" },
    array: { unit: "item", verb: "memiliki" },
    set: { unit: "item", verb: "memiliki" },
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (
          Object.getPrototypeOf(data) !== Object.prototype &&
          data.constructor
        ) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "input",
    email: "alamat email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tanggal dan waktu format ISO",
    date: "tanggal format ISO",
    time: "jam format ISO",
    duration: "durasi format ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "rentang alamat IPv4",
    cidrv6: "rentang alamat IPv6",
    base64: "string dengan enkode base64",
    base64url: "string dengan enkode base64url",
    json_string: "string JSON",
    e164: "angka E.164",
    jwt: "JWT",
    template_literal: "input",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Input tidak valid: diharapkan ${issue3.expected}, diterima ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Input tidak valid: diharapkan ${stringifyPrimitive(issue3.values[0])}`;
        return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Terlalu besar: diharapkan ${issue3.origin ?? "value"} memiliki ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: diharapkan ${issue3.origin ?? "value"} menjadi ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Terlalu kecil: diharapkan ${issue3.origin} memiliki ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: diharapkan ${issue3.origin} menjadi ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak valid: harus menyertakan "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${issue3.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${issue3.origin}`;
      default:
        return `Input tidak valid`;
    }
  };
};
function id_default() {
  return {
    localeError: error17(),
  };
}

// node_modules/zod/v4/locales/is.js
var parsedType3 = (data) => {
  const t2 = typeof data;
  switch (t2) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "n\xFAmer";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "fylki";
      }
      if (data === null) {
        return "null";
      }
      if (
        Object.getPrototypeOf(data) !== Object.prototype &&
        data.constructor
      ) {
        return data.constructor.name;
      }
    }
  }
  return t2;
};
var error18 = () => {
  const Sizable = {
    string: { unit: "stafi", verb: "a\xF0 hafa" },
    file: { unit: "b\xE6ti", verb: "a\xF0 hafa" },
    array: { unit: "hluti", verb: "a\xF0 hafa" },
    set: { unit: "hluti", verb: "a\xF0 hafa" },
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "gildi",
    email: "netfang",
    url: "vefsl\xF3\xF0",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dagsetning og t\xEDmi",
    date: "ISO dagsetning",
    time: "ISO t\xEDmi",
    duration: "ISO t\xEDmalengd",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded strengur",
    base64url: "base64url-encoded strengur",
    json_string: "JSON strengur",
    e164: "E.164 t\xF6lugildi",
    jwt: "JWT",
    template_literal: "gildi",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Rangt gildi: \xDE\xFA sl\xF3st inn ${parsedType3(issue3.input)} \xFEar sem \xE1 a\xF0 vera ${issue3.expected}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Rangt gildi: gert r\xE1\xF0 fyrir ${stringifyPrimitive(issue3.values[0])}`;
        return `\xD3gilt val: m\xE1 vera eitt af eftirfarandi ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue3.origin ?? "gildi"} hafi ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "hluti"}`;
        return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue3.origin ?? "gildi"} s\xE9 ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue3.origin} hafi ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue3.origin} s\xE9 ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\xD3gildur strengur: ver\xF0ur a\xF0 byrja \xE1 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 enda \xE1 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 innihalda "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 fylgja mynstri ${_issue.pattern}`;
        return `Rangt ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `R\xF6ng tala: ver\xF0ur a\xF0 vera margfeldi af ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\xD3\xFEekkt ${issue3.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Rangur lykill \xED ${issue3.origin}`;
      case "invalid_union":
        return "Rangt gildi";
      case "invalid_element":
        return `Rangt gildi \xED ${issue3.origin}`;
      default:
        return `Rangt gildi`;
    }
  };
};
function is_default() {
  return {
    localeError: error18(),
  };
}

// node_modules/zod/v4/locales/it.js
var error19 = () => {
  const Sizable = {
    string: { unit: "caratteri", verb: "avere" },
    file: { unit: "byte", verb: "avere" },
    array: { unit: "elementi", verb: "avere" },
    set: { unit: "elementi", verb: "avere" },
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "vettore";
        }
        if (data === null) {
          return "null";
        }
        if (
          Object.getPrototypeOf(data) !== Object.prototype &&
          data.constructor
        ) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "input",
    email: "indirizzo email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e ora ISO",
    date: "data ISO",
    time: "ora ISO",
    duration: "durata ISO",
    ipv4: "indirizzo IPv4",
    ipv6: "indirizzo IPv6",
    cidrv4: "intervallo IPv4",
    cidrv6: "intervallo IPv6",
    base64: "stringa codificata in base64",
    base64url: "URL codificata in base64",
    json_string: "stringa JSON",
    e164: "numero E.164",
    jwt: "JWT",
    template_literal: "input",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Input non valido: atteso ${issue3.expected}, ricevuto ${parsedType7(issue3.input)}`;
      // return `Input non valido: atteso ${issue.expected}, ricevuto ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Input non valido: atteso ${stringifyPrimitive(issue3.values[0])}`;
        return `Opzione non valida: atteso uno tra ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Troppo grande: ${issue3.origin ?? "valore"} deve avere ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementi"}`;
        return `Troppo grande: ${issue3.origin ?? "valore"} deve essere ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Troppo piccolo: ${issue3.origin} deve avere ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Troppo piccolo: ${issue3.origin} deve essere ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Stringa non valida: deve includere "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Chiav${issue3.keys.length > 1 ? "i" : "e"} non riconosciut${issue3.keys.length > 1 ? "e" : "a"}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${issue3.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${issue3.origin}`;
      default:
        return `Input non valido`;
    }
  };
};
function it_default() {
  return {
    localeError: error19(),
  };
}

// node_modules/zod/v4/locales/ja.js
var error20 = () => {
  const Sizable = {
    string: { unit: "\u6587\u5B57", verb: "\u3067\u3042\u308B" },
    file: { unit: "\u30D0\u30A4\u30C8", verb: "\u3067\u3042\u308B" },
    array: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" },
    set: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" },
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u6570\u5024";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u914D\u5217";
        }
        if (data === null) {
          return "null";
        }
        if (
          Object.getPrototypeOf(data) !== Object.prototype &&
          data.constructor
        ) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "\u5165\u529B\u5024",
    email: "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9",
    url: "URL",
    emoji: "\u7D75\u6587\u5B57",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u6642",
    date: "ISO\u65E5\u4ED8",
    time: "ISO\u6642\u523B",
    duration: "ISO\u671F\u9593",
    ipv4: "IPv4\u30A2\u30C9\u30EC\u30B9",
    ipv6: "IPv6\u30A2\u30C9\u30EC\u30B9",
    cidrv4: "IPv4\u7BC4\u56F2",
    cidrv6: "IPv6\u7BC4\u56F2",
    base64: "base64\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    base64url: "base64url\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    json_string: "JSON\u6587\u5B57\u5217",
    e164: "E.164\u756A\u53F7",
    jwt: "JWT",
    template_literal: "\u5165\u529B\u5024",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u7121\u52B9\u306A\u5165\u529B: ${issue3.expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${parsedType7(issue3.input)}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u7121\u52B9\u306A\u5165\u529B: ${stringifyPrimitive(issue3.values[0])}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F`;
        return `\u7121\u52B9\u306A\u9078\u629E: ${joinValues(issue3.values, "\u3001")}\u306E\u3044\u305A\u308C\u304B\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "too_big": {
        const adj = issue3.inclusive
          ? "\u4EE5\u4E0B\u3067\u3042\u308B"
          : "\u3088\u308A\u5C0F\u3055\u3044";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue3.origin ?? "\u5024"}\u306F${issue3.maximum.toString()}${sizing.unit ?? "\u8981\u7D20"}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue3.origin ?? "\u5024"}\u306F${issue3.maximum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "too_small": {
        const adj = issue3.inclusive
          ? "\u4EE5\u4E0A\u3067\u3042\u308B"
          : "\u3088\u308A\u5927\u304D\u3044";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue3.origin}\u306F${issue3.minimum.toString()}${sizing.unit}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue3.origin}\u306F${issue3.minimum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.prefix}"\u3067\u59CB\u307E\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "ends_with")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.suffix}"\u3067\u7D42\u308F\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "includes")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.includes}"\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "regex")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: \u30D1\u30BF\u30FC\u30F3${_issue.pattern}\u306B\u4E00\u81F4\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u7121\u52B9\u306A${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u52B9\u306A\u6570\u5024: ${issue3.divisor}\u306E\u500D\u6570\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "unrecognized_keys":
        return `\u8A8D\u8B58\u3055\u308C\u3066\u3044\u306A\u3044\u30AD\u30FC${issue3.keys.length > 1 ? "\u7FA4" : ""}: ${joinValues(issue3.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue3.origin}\u5185\u306E\u7121\u52B9\u306A\u30AD\u30FC`;
      case "invalid_union":
        return "\u7121\u52B9\u306A\u5165\u529B";
      case "invalid_element":
        return `${issue3.origin}\u5185\u306E\u7121\u52B9\u306A\u5024`;
      default:
        return `\u7121\u52B9\u306A\u5165\u529B`;
    }
  };
};
function ja_default() {
  return {
    localeError: error20(),
  };
}

// node_modules/zod/v4/locales/ka.js
var parsedType4 = (data) => {
  const t2 = typeof data;
  switch (t2) {
    case "number": {
      return Number.isNaN(data)
        ? "NaN"
        : "\u10E0\u10D8\u10EA\u10EE\u10D5\u10D8";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "\u10DB\u10D0\u10E1\u10D8\u10D5\u10D8";
      }
      if (data === null) {
        return "null";
      }
      if (
        Object.getPrototypeOf(data) !== Object.prototype &&
        data.constructor
      ) {
        return data.constructor.name;
      }
    }
  }
  const typeMap = {
    string: "\u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    boolean: "\u10D1\u10E3\u10DA\u10D4\u10D0\u10DC\u10D8",
    undefined: "undefined",
    bigint: "bigint",
    symbol: "symbol",
    function: "\u10E4\u10E3\u10DC\u10E5\u10EA\u10D8\u10D0",
  };
  return typeMap[t2] ?? t2;
};
var error21 = () => {
  const Sizable = {
    string: {
      unit: "\u10E1\u10D8\u10DB\u10D1\u10DD\u10DA\u10DD",
      verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1",
    },
    file: {
      unit: "\u10D1\u10D0\u10D8\u10E2\u10D8",
      verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1",
    },
    array: {
      unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8",
      verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1",
    },
    set: {
      unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8",
      verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1",
    },
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0",
    email:
      "\u10D4\u10DA-\u10E4\u10DD\u10E1\u10E2\u10D8\u10E1 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    url: "URL",
    emoji: "\u10D4\u10DB\u10DD\u10EF\u10D8",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8-\u10D3\u10E0\u10DD",
    date: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8",
    time: "\u10D3\u10E0\u10DD",
    duration:
      "\u10EE\u10D0\u10DC\u10D2\u10E0\u10EB\u10DA\u10D8\u10D5\u10DD\u10D1\u10D0",
    ipv4: "IPv4 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    ipv6: "IPv6 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    cidrv4: "IPv4 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
    cidrv6: "IPv6 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
    base64:
      "base64-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    base64url:
      "base64url-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    json_string: "JSON \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    e164: "E.164 \u10DC\u10DD\u10DB\u10D4\u10E0\u10D8",
    jwt: "JWT",
    template_literal: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue3.expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${parsedType4(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${stringifyPrimitive(issue3.values[0])}`;
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D5\u10D0\u10E0\u10D8\u10D0\u10DC\u10E2\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8\u10D0 \u10D4\u10E0\u10D7-\u10D4\u10E0\u10D7\u10D8 ${joinValues(issue3.values, "|")}-\u10D3\u10D0\u10DC`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue3.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit}`;
        return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue3.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue3.origin} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10EC\u10E7\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.prefix}"-\u10D8\u10D7`;
        }
        if (_issue.format === "ends_with")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10DB\u10D7\u10D0\u10D5\u10E0\u10D3\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.suffix}"-\u10D8\u10D7`;
        if (_issue.format === "includes")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1 "${_issue.includes}"-\u10E1`;
        if (_issue.format === "regex")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D4\u10E1\u10D0\u10D1\u10D0\u10DB\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 \u10E8\u10D0\u10D1\u10DA\u10DD\u10DC\u10E1 ${_issue.pattern}`;
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E0\u10D8\u10EA\u10EE\u10D5\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10E7\u10DD\u10E1 ${issue3.divisor}-\u10D8\u10E1 \u10EF\u10D4\u10E0\u10D0\u10D3\u10D8`;
      case "unrecognized_keys":
        return `\u10E3\u10EA\u10DC\u10DD\u10D1\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1${issue3.keys.length > 1 ? "\u10D4\u10D1\u10D8" : "\u10D8"}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1\u10D8 ${issue3.origin}-\u10E8\u10D8`;
      case "invalid_union":
        return "\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0";
      case "invalid_element":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0 ${issue3.origin}-\u10E8\u10D8`;
      default:
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0`;
    }
  };
};
function ka_default() {
  return {
    localeError: error21(),
  };
}

// node_modules/zod/v4/locales/km.js
var error22 = () => {
  const Sizable = {
    string: {
      unit: "\u178F\u17BD\u17A2\u1780\u17D2\u179F\u179A",
      verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793",
    },
    file: {
      unit: "\u1794\u17C3",
      verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793",
    },
    array: {
      unit: "\u1792\u17B6\u178F\u17BB",
      verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793",
    },
    set: {
      unit: "\u1792\u17B6\u178F\u17BB",
      verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793",
    },
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data)
          ? "\u1798\u17B7\u1793\u1798\u17C2\u1793\u1787\u17B6\u179B\u17C1\u1781 (NaN)"
          : "\u179B\u17C1\u1781";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u17A2\u17B6\u179A\u17C1 (Array)";
        }
        if (data === null) {
          return "\u1782\u17D2\u1798\u17B6\u1793\u178F\u1798\u17D2\u179B\u17C3 (null)";
        }
        if (
          Object.getPrototypeOf(data) !== Object.prototype &&
          data.constructor
        ) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex:
      "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B",
    email:
      "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793\u17A2\u17CA\u17B8\u1798\u17C2\u179B",
    url: "URL",
    emoji:
      "\u179F\u1789\u17D2\u1789\u17B6\u17A2\u17B6\u179A\u1798\u17D2\u1798\u178E\u17CD",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime:
      "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 \u1793\u17B7\u1784\u1798\u17C9\u17C4\u1784 ISO",
    date: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 ISO",
    time: "\u1798\u17C9\u17C4\u1784 ISO",
    duration: "\u179A\u1799\u17C8\u1796\u17C1\u179B ISO",
    ipv4: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    ipv6: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    cidrv4:
      "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    cidrv6:
      "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    base64:
      "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64",
    base64url:
      "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64url",
    json_string: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A JSON",
    e164: "\u179B\u17C1\u1781 E.164",
    jwt: "JWT",
    template_literal:
      "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue3.expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${stringifyPrimitive(issue3.values[0])}`;
        return `\u1787\u1798\u17D2\u179A\u17BE\u179F\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1787\u17B6\u1798\u17BD\u1799\u1780\u17D2\u1793\u17BB\u1784\u1785\u17C6\u178E\u17C4\u1798 ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue3.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "\u1792\u17B6\u178F\u17BB"}`;
        return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue3.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue3.origin} ${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue3.origin} ${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1785\u17B6\u1794\u17CB\u1795\u17D2\u178F\u17BE\u1798\u178A\u17C4\u1799 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1794\u1789\u17D2\u1785\u1794\u17CB\u178A\u17C4\u1799 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1798\u17B6\u1793 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1795\u17D2\u1782\u17BC\u1795\u17D2\u1782\u1784\u1793\u17B9\u1784\u1791\u1798\u17D2\u179A\u1784\u17CB\u178A\u17C2\u179B\u1794\u17B6\u1793\u1780\u17C6\u178E\u178F\u17CB ${_issue.pattern}`;
        return `\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u179B\u17C1\u1781\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1787\u17B6\u1796\u17A0\u17BB\u1782\u17BB\u178E\u1793\u17C3 ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\u179A\u1780\u1783\u17BE\u1789\u179F\u17C4\u1798\u17B7\u1793\u179F\u17D2\u1782\u17B6\u179B\u17CB\u17D6 ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u179F\u17C4\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue3.origin}`;
      case "invalid_union":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
      case "invalid_element":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue3.origin}`;
      default:
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
    }
  };
};
function km_default() {
  return {
    localeError: error22(),
  };
}

// node_modules/zod/v4/locales/kh.js
function kh_default() {
  return km_default();
}

// node_modules/zod/v4/locales/ko.js
var error23 = () => {
  const Sizable = {
    string: { unit: "\uBB38\uC790", verb: "to have" },
    file: { unit: "\uBC14\uC774\uD2B8", verb: "to have" },
    array: { unit: "\uAC1C", verb: "to have" },
    set: { unit: "\uAC1C", verb: "to have" },
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (
          Object.getPrototypeOf(data) !== Object.prototype &&
          data.constructor
        ) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "\uC785\uB825",
    email: "\uC774\uBA54\uC77C \uC8FC\uC18C",
    url: "URL",
    emoji: "\uC774\uBAA8\uC9C0",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \uB0A0\uC9DC\uC2DC\uAC04",
    date: "ISO \uB0A0\uC9DC",
    time: "ISO \uC2DC\uAC04",
    duration: "ISO \uAE30\uAC04",
    ipv4: "IPv4 \uC8FC\uC18C",
    ipv6: "IPv6 \uC8FC\uC18C",
    cidrv4: "IPv4 \uBC94\uC704",
    cidrv6: "IPv6 \uBC94\uC704",
    base64: "base64 \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    base64url: "base64url \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    json_string: "JSON \uBB38\uC790\uC5F4",
    e164: "E.164 \uBC88\uD638",
    jwt: "JWT",
    template_literal: "\uC785\uB825",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 ${issue3.expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${parsedType7(issue3.input)}\uC785\uB2C8\uB2E4`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\uC798\uBABB\uB41C \uC785\uB825: \uAC12\uC740 ${stringifyPrimitive(issue3.values[0])} \uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C \uC635\uC158: ${joinValues(issue3.values, "\uB610\uB294 ")} \uC911 \uD558\uB098\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "too_big": {
        const adj = issue3.inclusive ? "\uC774\uD558" : "\uBBF8\uB9CC";
        const suffix =
          adj === "\uBBF8\uB9CC"
            ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4"
            : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue3.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing)
          return `${issue3.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue3.maximum.toString()}${unit} ${adj}${suffix}`;
        return `${issue3.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue3.maximum.toString()} ${adj}${suffix}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? "\uC774\uC0C1" : "\uCD08\uACFC";
        const suffix =
          adj === "\uC774\uC0C1"
            ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4"
            : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue3.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing) {
          return `${issue3.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue3.minimum.toString()}${unit} ${adj}${suffix}`;
        }
        return `${issue3.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue3.minimum.toString()} ${adj}${suffix}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.prefix}"(\uC73C)\uB85C \uC2DC\uC791\uD574\uC57C \uD569\uB2C8\uB2E4`;
        }
        if (_issue.format === "ends_with")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.suffix}"(\uC73C)\uB85C \uB05D\uB098\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "includes")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.includes}"\uC744(\uB97C) \uD3EC\uD568\uD574\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "regex")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: \uC815\uADDC\uC2DD ${_issue.pattern} \uD328\uD134\uACFC \uC77C\uCE58\uD574\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\uC798\uBABB\uB41C \uC22B\uC790: ${issue3.divisor}\uC758 \uBC30\uC218\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "unrecognized_keys":
        return `\uC778\uC2DD\uD560 \uC218 \uC5C6\uB294 \uD0A4: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\uC798\uBABB\uB41C \uD0A4: ${issue3.origin}`;
      case "invalid_union":
        return `\uC798\uBABB\uB41C \uC785\uB825`;
      case "invalid_element":
        return `\uC798\uBABB\uB41C \uAC12: ${issue3.origin}`;
      default:
        return `\uC798\uBABB\uB41C \uC785\uB825`;
    }
  };
};
function ko_default() {
  return {
    localeError: error23(),
  };
}

// node_modules/zod/v4/locales/lt.js
var parsedType5 = (data) => {
  const t2 = typeof data;
  return parsedTypeFromType(t2, data);
};
var parsedTypeFromType = (t2, data = void 0) => {
  switch (t2) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "skai\u010Dius";
    }
    case "bigint": {
      return "sveikasis skai\u010Dius";
    }
    case "string": {
      return "eilut\u0117";
    }
    case "boolean": {
      return "login\u0117 reik\u0161m\u0117";
    }
    case "undefined":
    case "void": {
      return "neapibr\u0117\u017Eta reik\u0161m\u0117";
    }
    case "function": {
      return "funkcija";
    }
    case "symbol": {
      return "simbolis";
    }
    case "object": {
      if (data === void 0) return "ne\u017Einomas objektas";
      if (data === null) return "nulin\u0117 reik\u0161m\u0117";
      if (Array.isArray(data)) return "masyvas";
      if (
        Object.getPrototypeOf(data) !== Object.prototype &&
        data.constructor
      ) {
        return data.constructor.name;
      }
      return "objektas";
    }
    //Zod types below
    case "null": {
      return "nulin\u0117 reik\u0161m\u0117";
    }
  }
  return t2;
};
var capitalizeFirstCharacter = (text2) => {
  return text2.charAt(0).toUpperCase() + text2.slice(1);
};
function getUnitTypeFromNumber(number4) {
  const abs = Math.abs(number4);
  const last = abs % 10;
  const last2 = abs % 100;
  if ((last2 >= 11 && last2 <= 19) || last === 0) return "many";
  if (last === 1) return "one";
  return "few";
}
var error24 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "simbolis",
        few: "simboliai",
        many: "simboli\u0173",
      },
      verb: {
        smaller: {
          inclusive: "turi b\u016Bti ne ilgesn\u0117 kaip",
          notInclusive: "turi b\u016Bti trumpesn\u0117 kaip",
        },
        bigger: {
          inclusive: "turi b\u016Bti ne trumpesn\u0117 kaip",
          notInclusive: "turi b\u016Bti ilgesn\u0117 kaip",
        },
      },
    },
    file: {
      unit: {
        one: "baitas",
        few: "baitai",
        many: "bait\u0173",
      },
      verb: {
        smaller: {
          inclusive: "turi b\u016Bti ne didesnis kaip",
          notInclusive: "turi b\u016Bti ma\u017Eesnis kaip",
        },
        bigger: {
          inclusive: "turi b\u016Bti ne ma\u017Eesnis kaip",
          notInclusive: "turi b\u016Bti didesnis kaip",
        },
      },
    },
    array: {
      unit: {
        one: "element\u0105",
        few: "elementus",
        many: "element\u0173",
      },
      verb: {
        smaller: {
          inclusive: "turi tur\u0117ti ne daugiau kaip",
          notInclusive: "turi tur\u0117ti ma\u017Eiau kaip",
        },
        bigger: {
          inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
          notInclusive: "turi tur\u0117ti daugiau kaip",
        },
      },
    },
    set: {
      unit: {
        one: "element\u0105",
        few: "elementus",
        many: "element\u0173",
      },
      verb: {
        smaller: {
          inclusive: "turi tur\u0117ti ne daugiau kaip",
          notInclusive: "turi tur\u0117ti ma\u017Eiau kaip",
        },
        bigger: {
          inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
          notInclusive: "turi tur\u0117ti daugiau kaip",
        },
      },
    },
  };
  function getSizing(origin, unitType, inclusive, targetShouldBe) {
    const result = Sizable[origin] ?? null;
    if (result === null) return result;
    return {
      unit: result.unit[unitType],
      verb: result.verb[targetShouldBe][
        inclusive ? "inclusive" : "notInclusive"
      ],
    };
  }
  const Nouns = {
    regex: "\u012Fvestis",
    email: "el. pa\u0161to adresas",
    url: "URL",
    emoji: "jaustukas",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO data ir laikas",
    date: "ISO data",
    time: "ISO laikas",
    duration: "ISO trukm\u0117",
    ipv4: "IPv4 adresas",
    ipv6: "IPv6 adresas",
    cidrv4: "IPv4 tinklo prefiksas (CIDR)",
    cidrv6: "IPv6 tinklo prefiksas (CIDR)",
    base64: "base64 u\u017Ekoduota eilut\u0117",
    base64url: "base64url u\u017Ekoduota eilut\u0117",
    json_string: "JSON eilut\u0117",
    e164: "E.164 numeris",
    jwt: "JWT",
    template_literal: "\u012Fvestis",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Gautas tipas ${parsedType5(issue3.input)}, o tik\u0117tasi - ${parsedTypeFromType(issue3.expected)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Privalo b\u016Bti ${stringifyPrimitive(issue3.values[0])}`;
        return `Privalo b\u016Bti vienas i\u0161 ${joinValues(issue3.values, "|")} pasirinkim\u0173`;
      case "too_big": {
        const origin = parsedTypeFromType(issue3.origin);
        const sizing = getSizing(
          issue3.origin,
          getUnitTypeFromNumber(Number(issue3.maximum)),
          issue3.inclusive ?? false,
          "smaller",
        );
        if (sizing?.verb)
          return `${capitalizeFirstCharacter(origin ?? issue3.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue3.maximum.toString()} ${sizing.unit ?? "element\u0173"}`;
        const adj = issue3.inclusive
          ? "ne didesnis kaip"
          : "ma\u017Eesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue3.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue3.maximum.toString()} ${sizing?.unit}`;
      }
      case "too_small": {
        const origin = parsedTypeFromType(issue3.origin);
        const sizing = getSizing(
          issue3.origin,
          getUnitTypeFromNumber(Number(issue3.minimum)),
          issue3.inclusive ?? false,
          "bigger",
        );
        if (sizing?.verb)
          return `${capitalizeFirstCharacter(origin ?? issue3.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue3.minimum.toString()} ${sizing.unit ?? "element\u0173"}`;
        const adj = issue3.inclusive
          ? "ne ma\u017Eesnis kaip"
          : "didesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue3.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue3.minimum.toString()} ${sizing?.unit}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Eilut\u0117 privalo prasid\u0117ti "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Eilut\u0117 privalo pasibaigti "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Eilut\u0117 privalo \u012Ftraukti "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Eilut\u0117 privalo atitikti ${_issue.pattern}`;
        return `Neteisingas ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Skai\u010Dius privalo b\u016Bti ${issue3.divisor} kartotinis.`;
      case "unrecognized_keys":
        return `Neatpa\u017Eint${issue3.keys.length > 1 ? "i" : "as"} rakt${issue3.keys.length > 1 ? "ai" : "as"}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return "Rastas klaidingas raktas";
      case "invalid_union":
        return "Klaidinga \u012Fvestis";
      case "invalid_element": {
        const origin = parsedTypeFromType(issue3.origin);
        return `${capitalizeFirstCharacter(origin ?? issue3.origin ?? "reik\u0161m\u0117")} turi klaiding\u0105 \u012Fvest\u012F`;
      }
      default:
        return "Klaidinga \u012Fvestis";
    }
  };
};
function lt_default() {
  return {
    localeError: error24(),
  };
}

// node_modules/zod/v4/locales/mk.js
var error25 = () => {
  const Sizable = {
    string: {
      unit: "\u0437\u043D\u0430\u0446\u0438",
      verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442",
    },
    file: {
      unit: "\u0431\u0430\u0458\u0442\u0438",
      verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442",
    },
    array: {
      unit: "\u0441\u0442\u0430\u0432\u043A\u0438",
      verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442",
    },
    set: {
      unit: "\u0441\u0442\u0430\u0432\u043A\u0438",
      verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442",
    },
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0431\u0440\u043E\u0458";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043D\u0438\u0437\u0430";
        }
        if (data === null) {
          return "null";
        }
        if (
          Object.getPrototypeOf(data) !== Object.prototype &&
          data.constructor
        ) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "\u0432\u043D\u0435\u0441",
    email:
      "\u0430\u0434\u0440\u0435\u0441\u0430 \u043D\u0430 \u0435-\u043F\u043E\u0448\u0442\u0430",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u045F\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime:
      "ISO \u0434\u0430\u0442\u0443\u043C \u0438 \u0432\u0440\u0435\u043C\u0435",
    date: "ISO \u0434\u0430\u0442\u0443\u043C",
    time: "ISO \u0432\u0440\u0435\u043C\u0435",
    duration:
      "ISO \u0432\u0440\u0435\u043C\u0435\u0442\u0440\u0430\u0435\u045A\u0435",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441\u0430",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441\u0430",
    cidrv4: "IPv4 \u043E\u043F\u0441\u0435\u0433",
    cidrv6: "IPv6 \u043E\u043F\u0441\u0435\u0433",
    base64:
      "base64-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    base64url:
      "base64url-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    json_string: "JSON \u043D\u0438\u0437\u0430",
    e164: "E.164 \u0431\u0440\u043E\u0458",
    jwt: "JWT",
    template_literal: "\u0432\u043D\u0435\u0441",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue3.expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${parsedType7(issue3.input)}`;
      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue3.values[0])}`;
        return `\u0413\u0440\u0435\u0448\u0430\u043D\u0430 \u043E\u043F\u0446\u0438\u0458\u0430: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 \u0435\u0434\u043D\u0430 ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue3.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0438"}`;
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue3.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue3.origin} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue3.origin} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u043D\u0443\u0432\u0430 \u0441\u043E "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u0432\u0440\u0448\u0443\u0432\u0430 \u0441\u043E "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0432\u043A\u043B\u0443\u0447\u0443\u0432\u0430 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u043E\u0434\u0433\u043E\u0430\u0440\u0430 \u043D\u0430 \u043F\u0430\u0442\u0435\u0440\u043D\u043E\u0442 ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0431\u0440\u043E\u0458: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0431\u0438\u0434\u0435 \u0434\u0435\u043B\u0438\u0432 \u0441\u043E ${issue3.divisor}`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D\u0438 \u043A\u043B\u0443\u0447\u0435\u0432\u0438" : "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D \u043A\u043B\u0443\u0447"}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u043A\u043B\u0443\u0447 \u0432\u043E ${issue3.origin}`;
      case "invalid_union":
        return "\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441";
      case "invalid_element":
        return `\u0413\u0440\u0435\u0448\u043D\u0430 \u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442 \u0432\u043E ${issue3.origin}`;
      default:
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441`;
    }
  };
};
function mk_default() {
  return {
    localeError: error25(),
  };
}

// node_modules/zod/v4/locales/ms.js
var error26 = () => {
  const Sizable = {
    string: { unit: "aksara", verb: "mempunyai" },
    file: { unit: "bait", verb: "mempunyai" },
    array: { unit: "elemen", verb: "mempunyai" },
    set: { unit: "elemen", verb: "mempunyai" },
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombor";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (
          Object.getPrototypeOf(data) !== Object.prototype &&
          data.constructor
        ) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "input",
    email: "alamat e-mel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tarikh masa ISO",
    date: "tarikh ISO",
    time: "masa ISO",
    duration: "tempoh ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "julat IPv4",
    cidrv6: "julat IPv6",
    base64: "string dikodkan base64",
    base64url: "string dikodkan base64url",
    json_string: "string JSON",
    e164: "nombor E.164",
    jwt: "JWT",
    template_literal: "input",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Input tidak sah: dijangka ${issue3.expected}, diterima ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Input tidak sah: dijangka ${stringifyPrimitive(issue3.values[0])}`;
        return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Terlalu besar: dijangka ${issue3.origin ?? "nilai"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: dijangka ${issue3.origin ?? "nilai"} adalah ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Terlalu kecil: dijangka ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: dijangka ${issue3.origin} adalah ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${issue3.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${issue3.origin}`;
      default:
        return `Input tidak sah`;
    }
  };
};
function ms_default() {
  return {
    localeError: error26(),
  };
}

// node_modules/zod/v4/locales/nl.js
var error27 = () => {
  const Sizable = {
    string: { unit: "tekens" },
    file: { unit: "bytes" },
    array: { unit: "elementen" },
    set: { unit: "elementen" },
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "getal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (
          Object.getPrototypeOf(data) !== Object.prototype &&
          data.constructor
        ) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "invoer",
    email: "emailadres",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum en tijd",
    date: "ISO datum",
    time: "ISO tijd",
    duration: "ISO duur",
    ipv4: "IPv4-adres",
    ipv6: "IPv6-adres",
    cidrv4: "IPv4-bereik",
    cidrv6: "IPv6-bereik",
    base64: "base64-gecodeerde tekst",
    base64url: "base64 URL-gecodeerde tekst",
    json_string: "JSON string",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "invoer",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ongeldige invoer: verwacht ${issue3.expected}, ontving ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue3.values[0])}`;
        return `Ongeldige optie: verwacht \xE9\xE9n van ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Te lang: verwacht dat ${issue3.origin ?? "waarde"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementen"} bevat`;
        return `Te lang: verwacht dat ${issue3.origin ?? "waarde"} ${adj}${issue3.maximum.toString()} is`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Te kort: verwacht dat ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit} bevat`;
        }
        return `Te kort: verwacht dat ${issue3.origin} ${adj}${issue3.minimum.toString()} is`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
        }
        if (_issue.format === "ends_with")
          return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
        if (_issue.format === "includes")
          return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
        if (_issue.format === "regex")
          return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
        return `Ongeldig: ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${issue3.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${issue3.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${issue3.origin}`;
      default:
        return `Ongeldige invoer`;
    }
  };
};
function nl_default() {
  return {
    localeError: error27(),
  };
}

// node_modules/zod/v4/locales/no.js
var error28 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "\xE5 ha" },
    file: { unit: "bytes", verb: "\xE5 ha" },
    array: { unit: "elementer", verb: "\xE5 inneholde" },
    set: { unit: "elementer", verb: "\xE5 inneholde" },
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "tall";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "liste";
        }
        if (data === null) {
          return "null";
        }
        if (
          Object.getPrototypeOf(data) !== Object.prototype &&
          data.constructor
        ) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "input",
    email: "e-postadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslett",
    date: "ISO-dato",
    time: "ISO-klokkeslett",
    duration: "ISO-varighet",
    ipv4: "IPv4-omr\xE5de",
    ipv6: "IPv6-omr\xE5de",
    cidrv4: "IPv4-spekter",
    cidrv6: "IPv6-spekter",
    base64: "base64-enkodet streng",
    base64url: "base64url-enkodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ugyldig input: forventet ${issue3.expected}, fikk ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ugyldig verdi: forventet ${stringifyPrimitive(issue3.values[0])}`;
        return `Ugyldig valg: forventet en av ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `For stor(t): forventet ${issue3.origin ?? "value"} til \xE5 ha ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor(t): forventet ${issue3.origin ?? "value"} til \xE5 ha ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `For lite(n): forventet ${issue3.origin} til \xE5 ha ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `For lite(n): forventet ${issue3.origin} til \xE5 ha ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: m\xE5 starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: m\xE5 ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: m\xE5 inneholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: m\xE5 matche m\xF8nsteret ${_issue.pattern}`;
        return `Ugyldig ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: m\xE5 v\xE6re et multiplum av ${issue3.divisor}`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Ukjente n\xF8kler" : "Ukjent n\xF8kkel"}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig n\xF8kkel i ${issue3.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${issue3.origin}`;
      default:
        return `Ugyldig input`;
    }
  };
};
function no_default() {
  return {
    localeError: error28(),
  };
}

// node_modules/zod/v4/locales/ota.js
var error29 = () => {
  const Sizable = {
    string: { unit: "harf", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "unsur", verb: "olmal\u0131d\u0131r" },
    set: { unit: "unsur", verb: "olmal\u0131d\u0131r" },
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numara";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "saf";
        }
        if (data === null) {
          return "gayb";
        }
        if (
          Object.getPrototypeOf(data) !== Object.prototype &&
          data.constructor
        ) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "giren",
    email: "epostag\xE2h",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO heng\xE2m\u0131",
    date: "ISO tarihi",
    time: "ISO zaman\u0131",
    duration: "ISO m\xFCddeti",
    ipv4: "IPv4 ni\u015F\xE2n\u0131",
    ipv6: "IPv6 ni\u015F\xE2n\u0131",
    cidrv4: "IPv4 menzili",
    cidrv6: "IPv6 menzili",
    base64: "base64-\u015Fifreli metin",
    base64url: "base64url-\u015Fifreli metin",
    json_string: "JSON metin",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "giren",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `F\xE2sit giren: umulan ${issue3.expected}, al\u0131nan ${parsedType7(issue3.input)}`;
      // return `Fâsit giren: umulan ${issue.expected}, alınan ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `F\xE2sit giren: umulan ${stringifyPrimitive(issue3.values[0])}`;
        return `F\xE2sit tercih: m\xFBteberler ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Fazla b\xFCy\xFCk: ${issue3.origin ?? "value"}, ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmal\u0131yd\u0131.`;
        return `Fazla b\xFCy\xFCk: ${issue3.origin ?? "value"}, ${adj}${issue3.maximum.toString()} olmal\u0131yd\u0131.`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Fazla k\xFC\xE7\xFCk: ${issue3.origin}, ${adj}${issue3.minimum.toString()} ${sizing.unit} sahip olmal\u0131yd\u0131.`;
        }
        return `Fazla k\xFC\xE7\xFCk: ${issue3.origin}, ${adj}${issue3.minimum.toString()} olmal\u0131yd\u0131.`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `F\xE2sit metin: "${_issue.prefix}" ile ba\u015Flamal\u0131.`;
        if (_issue.format === "ends_with")
          return `F\xE2sit metin: "${_issue.suffix}" ile bitmeli.`;
        if (_issue.format === "includes")
          return `F\xE2sit metin: "${_issue.includes}" ihtiv\xE2 etmeli.`;
        if (_issue.format === "regex")
          return `F\xE2sit metin: ${_issue.pattern} nak\u015F\u0131na uymal\u0131.`;
        return `F\xE2sit ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `F\xE2sit say\u0131: ${issue3.divisor} kat\u0131 olmal\u0131yd\u0131.`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar ${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} i\xE7in tan\u0131nmayan anahtar var.`;
      case "invalid_union":
        return "Giren tan\u0131namad\u0131.";
      case "invalid_element":
        return `${issue3.origin} i\xE7in tan\u0131nmayan k\u0131ymet var.`;
      default:
        return `K\u0131ymet tan\u0131namad\u0131.`;
    }
  };
};
function ota_default() {
  return {
    localeError: error29(),
  };
}

// node_modules/zod/v4/locales/ps.js
var error30 = () => {
  const Sizable = {
    string: {
      unit: "\u062A\u0648\u06A9\u064A",
      verb: "\u0648\u0644\u0631\u064A",
    },
    file: {
      unit: "\u0628\u0627\u06CC\u067C\u0633",
      verb: "\u0648\u0644\u0631\u064A",
    },
    array: {
      unit: "\u062A\u0648\u06A9\u064A",
      verb: "\u0648\u0644\u0631\u064A",
    },
    set: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0639\u062F\u062F";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0627\u0631\u06D0";
        }
        if (data === null) {
          return "null";
        }
        if (
          Object.getPrototypeOf(data) !== Object.prototype &&
          data.constructor
        ) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "\u0648\u0631\u0648\u062F\u064A",
    email: "\u0628\u0631\u06CC\u069A\u0646\u0627\u0644\u06CC\u06A9",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0646\u06CC\u067C\u0647 \u0627\u0648 \u0648\u062E\u062A",
    date: "\u0646\u06D0\u067C\u0647",
    time: "\u0648\u062E\u062A",
    duration: "\u0645\u0648\u062F\u0647",
    ipv4: "\u062F IPv4 \u067E\u062A\u0647",
    ipv6: "\u062F IPv6 \u067E\u062A\u0647",
    cidrv4: "\u062F IPv4 \u0633\u0627\u062D\u0647",
    cidrv6: "\u062F IPv6 \u0633\u0627\u062D\u0647",
    base64: "base64-encoded \u0645\u062A\u0646",
    base64url: "base64url-encoded \u0645\u062A\u0646",
    json_string: "JSON \u0645\u062A\u0646",
    e164: "\u062F E.164 \u0634\u0645\u06D0\u0631\u0647",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u064A",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${issue3.expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${parsedType7(issue3.input)} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
      case "invalid_value":
        if (issue3.values.length === 1) {
          return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${stringifyPrimitive(issue3.values[0])} \u0648\u0627\u06CC`;
        }
        return `\u0646\u0627\u0633\u0645 \u0627\u0646\u062A\u062E\u0627\u0628: \u0628\u0627\u06CC\u062F \u06CC\u0648 \u0644\u0647 ${joinValues(issue3.values, "|")} \u0685\u062E\u0647 \u0648\u0627\u06CC`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue3.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631\u0648\u0646\u0647"} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue3.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue3.maximum.toString()} \u0648\u064A`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue3.origin} \u0628\u0627\u06CC\u062F ${adj}${issue3.minimum.toString()} ${sizing.unit} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue3.origin} \u0628\u0627\u06CC\u062F ${adj}${issue3.minimum.toString()} \u0648\u064A`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.prefix}" \u0633\u0631\u0647 \u067E\u06CC\u0644 \u0634\u064A`;
        }
        if (_issue.format === "ends_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.suffix}" \u0633\u0631\u0647 \u067E\u0627\u06CC \u062A\u0647 \u0648\u0631\u0633\u064A\u0696\u064A`;
        }
        if (_issue.format === "includes") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F "${_issue.includes}" \u0648\u0644\u0631\u064A`;
        }
        if (_issue.format === "regex") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F ${_issue.pattern} \u0633\u0631\u0647 \u0645\u0637\u0627\u0628\u0642\u062A \u0648\u0644\u0631\u064A`;
        }
        return `${Nouns[_issue.format] ?? issue3.format} \u0646\u0627\u0633\u0645 \u062F\u06CC`;
      }
      case "not_multiple_of":
        return `\u0646\u0627\u0633\u0645 \u0639\u062F\u062F: \u0628\u0627\u06CC\u062F \u062F ${issue3.divisor} \u0645\u0636\u0631\u0628 \u0648\u064A`;
      case "unrecognized_keys":
        return `\u0646\u0627\u0633\u0645 ${issue3.keys.length > 1 ? "\u06A9\u0644\u06CC\u0689\u0648\u0646\u0647" : "\u06A9\u0644\u06CC\u0689"}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u0646\u0627\u0633\u0645 \u06A9\u0644\u06CC\u0689 \u067E\u0647 ${issue3.origin} \u06A9\u06D0`;
      case "invalid_union":
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
      case "invalid_element":
        return `\u0646\u0627\u0633\u0645 \u0639\u0646\u0635\u0631 \u067E\u0647 ${issue3.origin} \u06A9\u06D0`;
      default:
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
    }
  };
};
function ps_default() {
  return {
    localeError: error30(),
  };
}

// node_modules/zod/v4/locales/pl.js
var error31 = () => {
  const Sizable = {
    string: { unit: "znak\xF3w", verb: "mie\u0107" },
    file: { unit: "bajt\xF3w", verb: "mie\u0107" },
    array: { unit: "element\xF3w", verb: "mie\u0107" },
    set: { unit: "element\xF3w", verb: "mie\u0107" },
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "liczba";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tablica";
        }
        if (data === null) {
          return "null";
        }
        if (
          Object.getPrototypeOf(data) !== Object.prototype &&
          data.constructor
        ) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "wyra\u017Cenie",
    email: "adres email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i godzina w formacie ISO",
    date: "data w formacie ISO",
    time: "godzina w formacie ISO",
    duration: "czas trwania ISO",
    ipv4: "adres IPv4",
    ipv6: "adres IPv6",
    cidrv4: "zakres IPv4",
    cidrv6: "zakres IPv6",
    base64: "ci\u0105g znak\xF3w zakodowany w formacie base64",
    base64url: "ci\u0105g znak\xF3w zakodowany w formacie base64url",
    json_string: "ci\u0105g znak\xF3w w formacie JSON",
    e164: "liczba E.164",
    jwt: "JWT",
    template_literal: "wej\u015Bcie",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${issue3.expected}, otrzymano ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${stringifyPrimitive(issue3.values[0])}`;
        return `Nieprawid\u0142owa opcja: oczekiwano jednej z warto\u015Bci ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Za du\u017Ca warto\u015B\u0107: oczekiwano, \u017Ce ${issue3.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt du\u017C(y/a/e): oczekiwano, \u017Ce ${issue3.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Za ma\u0142a warto\u015B\u0107: oczekiwano, \u017Ce ${issue3.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue3.minimum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt ma\u0142(y/a/e): oczekiwano, \u017Ce ${issue3.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zaczyna\u0107 si\u0119 od "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi ko\u0144czy\u0107 si\u0119 na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zawiera\u0107 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi odpowiada\u0107 wzorcowi ${_issue.pattern}`;
        return `Nieprawid\u0142ow(y/a/e) ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Nieprawid\u0142owa liczba: musi by\u0107 wielokrotno\u015Bci\u0105 ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawid\u0142owy klucz w ${issue3.origin}`;
      case "invalid_union":
        return "Nieprawid\u0142owe dane wej\u015Bciowe";
      case "invalid_element":
        return `Nieprawid\u0142owa warto\u015B\u0107 w ${issue3.origin}`;
      default:
        return `Nieprawid\u0142owe dane wej\u015Bciowe`;
    }
  };
};
function pl_default() {
  return {
    localeError: error31(),
  };
}

// node_modules/zod/v4/locales/pt.js
var error32 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "ter" },
    file: { unit: "bytes", verb: "ter" },
    array: { unit: "itens", verb: "ter" },
    set: { unit: "itens", verb: "ter" },
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "n\xFAmero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "nulo";
        }
        if (
          Object.getPrototypeOf(data) !== Object.prototype &&
          data.constructor
        ) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "padr\xE3o",
    email: "endere\xE7o de e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "dura\xE7\xE3o ISO",
    ipv4: "endere\xE7o IPv4",
    ipv6: "endere\xE7o IPv6",
    cidrv4: "faixa de IPv4",
    cidrv6: "faixa de IPv6",
    base64: "texto codificado em base64",
    base64url: "URL codificada em base64",
    json_string: "texto JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Tipo inv\xE1lido: esperado ${issue3.expected}, recebido ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Entrada inv\xE1lida: esperado ${stringifyPrimitive(issue3.values[0])}`;
        return `Op\xE7\xE3o inv\xE1lida: esperada uma das ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Muito grande: esperado que ${issue3.origin ?? "valor"} tivesse ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Muito grande: esperado que ${issue3.origin ?? "valor"} fosse ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Muito pequeno: esperado que ${issue3.origin} tivesse ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Muito pequeno: esperado que ${issue3.origin} fosse ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Texto inv\xE1lido: deve come\xE7ar com "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Texto inv\xE1lido: deve terminar com "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Texto inv\xE1lido: deve incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Texto inv\xE1lido: deve corresponder ao padr\xE3o ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} inv\xE1lido`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: deve ser m\xFAltiplo de ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Chave${issue3.keys.length > 1 ? "s" : ""} desconhecida${issue3.keys.length > 1 ? "s" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Chave inv\xE1lida em ${issue3.origin}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido em ${issue3.origin}`;
      default:
        return `Campo inv\xE1lido`;
    }
  };
};
function pt_default() {
  return {
    localeError: error32(),
  };
}

// node_modules/zod/v4/locales/ru.js
function getRussianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error33 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0438\u043C\u0432\u043E\u043B",
        few: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430",
        many: "\u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432",
      },
      verb: "\u0438\u043C\u0435\u0442\u044C",
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u0430",
        many: "\u0431\u0430\u0439\u0442",
      },
      verb: "\u0438\u043C\u0435\u0442\u044C",
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432",
      },
      verb: "\u0438\u043C\u0435\u0442\u044C",
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432",
      },
      verb: "\u0438\u043C\u0435\u0442\u044C",
    },
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043C\u0430\u0441\u0441\u0438\u0432";
        }
        if (data === null) {
          return "null";
        }
        if (
          Object.getPrototypeOf(data) !== Object.prototype &&
          data.constructor
        ) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "\u0432\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0435\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime:
      "ISO \u0434\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043C\u044F",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0432\u0440\u0435\u043C\u044F",
    duration:
      "ISO \u0434\u043B\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
    cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    base64:
      "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64",
    base64url:
      "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64url",
    json_string: "JSON \u0441\u0442\u0440\u043E\u043A\u0430",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0432\u0432\u043E\u0434",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${issue3.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${stringifyPrimitive(issue3.values[0])}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0430\u0440\u0438\u0430\u043D\u0442: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0434\u043D\u043E \u0438\u0437 ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const maxValue = Number(issue3.maximum);
          const unit = getRussianPlural(
            maxValue,
            sizing.unit.one,
            sizing.unit.few,
            sizing.unit.many,
          );
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue3.maximum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          const minValue = Number(issue3.minimum);
          const unit = getRussianPlural(
            minValue,
            sizing.unit.one,
            sizing.unit.few,
            sizing.unit.many,
          );
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue3.origin} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue3.minimum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue3.origin} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u043E\u0432\u0430\u0442\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E: \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u043E\u0437\u043D\u0430\u043D\u043D${issue3.keys.length > 1 ? "\u044B\u0435" : "\u044B\u0439"} \u043A\u043B\u044E\u0447${issue3.keys.length > 1 ? "\u0438" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u043A\u043B\u044E\u0447 \u0432 ${issue3.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435";
      case "invalid_element":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0432 ${issue3.origin}`;
      default:
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435`;
    }
  };
};
function ru_default() {
  return {
    localeError: error33(),
  };
}

// node_modules/zod/v4/locales/sl.js
var error34 = () => {
  const Sizable = {
    string: { unit: "znakov", verb: "imeti" },
    file: { unit: "bajtov", verb: "imeti" },
    array: { unit: "elementov", verb: "imeti" },
    set: { unit: "elementov", verb: "imeti" },
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0161tevilo";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tabela";
        }
        if (data === null) {
          return "null";
        }
        if (
          Object.getPrototypeOf(data) !== Object.prototype &&
          data.constructor
        ) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "vnos",
    email: "e-po\u0161tni naslov",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum in \u010Das",
    date: "ISO datum",
    time: "ISO \u010Das",
    duration: "ISO trajanje",
    ipv4: "IPv4 naslov",
    ipv6: "IPv6 naslov",
    cidrv4: "obseg IPv4",
    cidrv6: "obseg IPv6",
    base64: "base64 kodiran niz",
    base64url: "base64url kodiran niz",
    json_string: "JSON niz",
    e164: "E.164 \u0161tevilka",
    jwt: "JWT",
    template_literal: "vnos",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Neveljaven vnos: pri\u010Dakovano ${issue3.expected}, prejeto ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Neveljaven vnos: pri\u010Dakovano ${stringifyPrimitive(issue3.values[0])}`;
        return `Neveljavna mo\u017Enost: pri\u010Dakovano eno izmed ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Preveliko: pri\u010Dakovano, da bo ${issue3.origin ?? "vrednost"} imelo ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "elementov"}`;
        return `Preveliko: pri\u010Dakovano, da bo ${issue3.origin ?? "vrednost"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Premajhno: pri\u010Dakovano, da bo ${issue3.origin} imelo ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Premajhno: pri\u010Dakovano, da bo ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Neveljaven niz: mora se za\u010Deti z "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Neveljaven niz: mora se kon\u010Dati z "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
        return `Neveljaven ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno \u0161tevilo: mora biti ve\u010Dkratnik ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${issue3.keys.length > 1 ? "i klju\u010Di" : " klju\u010D"}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven klju\u010D v ${issue3.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${issue3.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
function sl_default() {
  return {
    localeError: error34(),
  };
}

// node_modules/zod/v4/locales/sv.js
var error35 = () => {
  const Sizable = {
    string: { unit: "tecken", verb: "att ha" },
    file: { unit: "bytes", verb: "att ha" },
    array: { unit: "objekt", verb: "att inneh\xE5lla" },
    set: { unit: "objekt", verb: "att inneh\xE5lla" },
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "antal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "lista";
        }
        if (data === null) {
          return "null";
        }
        if (
          Object.getPrototypeOf(data) !== Object.prototype &&
          data.constructor
        ) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "regulj\xE4rt uttryck",
    email: "e-postadress",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datum och tid",
    date: "ISO-datum",
    time: "ISO-tid",
    duration: "ISO-varaktighet",
    ipv4: "IPv4-intervall",
    ipv6: "IPv6-intervall",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodad str\xE4ng",
    base64url: "base64url-kodad str\xE4ng",
    json_string: "JSON-str\xE4ng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "mall-literal",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ogiltig inmatning: f\xF6rv\xE4ntat ${issue3.expected}, fick ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ogiltig inmatning: f\xF6rv\xE4ntat ${stringifyPrimitive(issue3.values[0])}`;
        return `Ogiltigt val: f\xF6rv\xE4ntade en av ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `F\xF6r stor(t): f\xF6rv\xE4ntade ${issue3.origin ?? "v\xE4rdet"} att ha ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "element"}`;
        }
        return `F\xF6r stor(t): f\xF6rv\xE4ntat ${issue3.origin ?? "v\xE4rdet"} att ha ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue3.origin ?? "v\xE4rdet"} att ha ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue3.origin ?? "v\xE4rdet"} att ha ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `Ogiltig str\xE4ng: m\xE5ste b\xF6rja med "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Ogiltig str\xE4ng: m\xE5ste sluta med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ogiltig str\xE4ng: m\xE5ste inneh\xE5lla "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ogiltig str\xE4ng: m\xE5ste matcha m\xF6nstret "${_issue.pattern}"`;
        return `Ogiltig(t) ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: m\xE5ste vara en multipel av ${issue3.divisor}`;
      case "unrecognized_keys":
        return `${issue3.keys.length > 1 ? "Ok\xE4nda nycklar" : "Ok\xE4nd nyckel"}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${issue3.origin ?? "v\xE4rdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt v\xE4rde i ${issue3.origin ?? "v\xE4rdet"}`;
      default:
        return `Ogiltig input`;
    }
  };
};
function sv_default() {
  return {
    localeError: error35(),
  };
}

// node_modules/zod/v4/locales/ta.js
var error36 = () => {
  const Sizable = {
    string: {
      unit: "\u0B8E\u0BB4\u0BC1\u0BA4\u0BCD\u0BA4\u0BC1\u0B95\u0BCD\u0B95\u0BB3\u0BCD",
      verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD",
    },
    file: {
      unit: "\u0BAA\u0BC8\u0B9F\u0BCD\u0B9F\u0BC1\u0B95\u0BB3\u0BCD",
      verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD",
    },
    array: {
      unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD",
      verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD",
    },
    set: {
      unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD",
      verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD",
    },
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data)
          ? "\u0B8E\u0BA3\u0BCD \u0B85\u0BB2\u0BCD\u0BB2\u0BBE\u0BA4\u0BA4\u0BC1"
          : "\u0B8E\u0BA3\u0BCD";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0B85\u0BA3\u0BBF";
        }
        if (data === null) {
          return "\u0BB5\u0BC6\u0BB1\u0BC1\u0BAE\u0BC8";
        }
        if (
          Object.getPrototypeOf(data) !== Object.prototype &&
          data.constructor
        ) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "\u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1",
    email:
      "\u0BAE\u0BBF\u0BA9\u0BCD\u0BA9\u0B9E\u0BCD\u0B9A\u0BB2\u0BCD \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0BA4\u0BC7\u0BA4\u0BBF \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    date: "ISO \u0BA4\u0BC7\u0BA4\u0BBF",
    time: "ISO \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    duration: "ISO \u0B95\u0BBE\u0BB2 \u0B85\u0BB3\u0BB5\u0BC1",
    ipv4: "IPv4 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    ipv6: "IPv6 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    cidrv4: "IPv4 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    cidrv6: "IPv6 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    base64: "base64-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    base64url: "base64url-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    json_string: "JSON \u0B9A\u0BB0\u0BAE\u0BCD",
    e164: "E.164 \u0B8E\u0BA3\u0BCD",
    jwt: "JWT",
    template_literal: "input",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue3.expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${stringifyPrimitive(issue3.values[0])}`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0BB0\u0BC1\u0BAA\u0BCD\u0BAA\u0BAE\u0BCD: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${joinValues(issue3.values, "|")} \u0B87\u0BB2\u0BCD \u0B92\u0BA9\u0BCD\u0BB1\u0BC1`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue3.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD"} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue3.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue3.maximum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue3.origin} ${adj}${issue3.minimum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.prefix}" \u0B87\u0BB2\u0BCD \u0BA4\u0BCA\u0B9F\u0B99\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "ends_with")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.suffix}" \u0B87\u0BB2\u0BCD \u0BAE\u0BC1\u0B9F\u0BBF\u0BB5\u0B9F\u0BC8\u0BAF \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "includes")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.includes}" \u0B90 \u0B89\u0BB3\u0BCD\u0BB3\u0B9F\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "regex")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: ${_issue.pattern} \u0BAE\u0BC1\u0BB1\u0BC8\u0BAA\u0BBE\u0B9F\u0BCD\u0B9F\u0BC1\u0B9F\u0BA9\u0BCD \u0BAA\u0BCA\u0BB0\u0BC1\u0BA8\u0BCD\u0BA4 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B8E\u0BA3\u0BCD: ${issue3.divisor} \u0B87\u0BA9\u0BCD \u0BAA\u0BB2\u0BAE\u0BBE\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      case "unrecognized_keys":
        return `\u0B85\u0B9F\u0BC8\u0BAF\u0BBE\u0BB3\u0BAE\u0BCD \u0BA4\u0BC6\u0BB0\u0BBF\u0BAF\u0BBE\u0BA4 \u0BB5\u0BBF\u0B9A\u0BC8${issue3.keys.length > 1 ? "\u0B95\u0BB3\u0BCD" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0B9A\u0BC8`;
      case "invalid_union":
        return "\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1";
      case "invalid_element":
        return `${issue3.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1`;
      default:
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1`;
    }
  };
};
function ta_default() {
  return {
    localeError: error36(),
  };
}

// node_modules/zod/v4/locales/th.js
var error37 = () => {
  const Sizable = {
    string: {
      unit: "\u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23",
      verb: "\u0E04\u0E27\u0E23\u0E21\u0E35",
    },
    file: {
      unit: "\u0E44\u0E1A\u0E15\u0E4C",
      verb: "\u0E04\u0E27\u0E23\u0E21\u0E35",
    },
    array: {
      unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23",
      verb: "\u0E04\u0E27\u0E23\u0E21\u0E35",
    },
    set: {
      unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23",
      verb: "\u0E04\u0E27\u0E23\u0E21\u0E35",
    },
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data)
          ? "\u0E44\u0E21\u0E48\u0E43\u0E0A\u0E48\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02 (NaN)"
          : "\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0E2D\u0E32\u0E23\u0E4C\u0E40\u0E23\u0E22\u0E4C (Array)";
        }
        if (data === null) {
          return "\u0E44\u0E21\u0E48\u0E21\u0E35\u0E04\u0E48\u0E32 (null)";
        }
        if (
          Object.getPrototypeOf(data) !== Object.prototype &&
          data.constructor
        ) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex:
      "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19",
    email:
      "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48\u0E2D\u0E35\u0E40\u0E21\u0E25",
    url: "URL",
    emoji: "\u0E2D\u0E34\u0E42\u0E21\u0E08\u0E34",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime:
      "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    date: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E41\u0E1A\u0E1A ISO",
    time: "\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    duration:
      "\u0E0A\u0E48\u0E27\u0E07\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    ipv4: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv4",
    ipv6: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv6",
    cidrv4: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv4",
    cidrv6: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv6",
    base64:
      "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64",
    base64url:
      "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64 \u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A URL",
    json_string:
      "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A JSON",
    e164: "\u0E40\u0E1A\u0E2D\u0E23\u0E4C\u0E42\u0E17\u0E23\u0E28\u0E31\u0E1E\u0E17\u0E4C\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E1B\u0E23\u0E30\u0E40\u0E17\u0E28 (E.164)",
    jwt: "\u0E42\u0E17\u0E40\u0E04\u0E19 JWT",
    template_literal:
      "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${issue3.expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u0E04\u0E48\u0E32\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${stringifyPrimitive(issue3.values[0])}`;
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E43\u0E19 ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive
          ? "\u0E44\u0E21\u0E48\u0E40\u0E01\u0E34\u0E19"
          : "\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue3.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue3.maximum.toString()} ${sizing.unit ?? "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23"}`;
        return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue3.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive
          ? "\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E19\u0E49\u0E2D\u0E22"
          : "\u0E21\u0E32\u0E01\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue3.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue3.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E02\u0E36\u0E49\u0E19\u0E15\u0E49\u0E19\u0E14\u0E49\u0E27\u0E22 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E25\u0E07\u0E17\u0E49\u0E32\u0E22\u0E14\u0E49\u0E27\u0E22 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35 "${_issue.includes}" \u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21`;
        if (_issue.format === "regex")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14 ${_issue.pattern}`;
        return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E08\u0E33\u0E19\u0E27\u0E19\u0E17\u0E35\u0E48\u0E2B\u0E32\u0E23\u0E14\u0E49\u0E27\u0E22 ${issue3.divisor} \u0E44\u0E14\u0E49\u0E25\u0E07\u0E15\u0E31\u0E27`;
      case "unrecognized_keys":
        return `\u0E1E\u0E1A\u0E04\u0E35\u0E22\u0E4C\u0E17\u0E35\u0E48\u0E44\u0E21\u0E48\u0E23\u0E39\u0E49\u0E08\u0E31\u0E01: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u0E04\u0E35\u0E22\u0E4C\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue3.origin}`;
      case "invalid_union":
        return "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E44\u0E21\u0E48\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E22\u0E39\u0E40\u0E19\u0E35\u0E22\u0E19\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14\u0E44\u0E27\u0E49";
      case "invalid_element":
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue3.origin}`;
      default:
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07`;
    }
  };
};
function th_default() {
  return {
    localeError: error37(),
  };
}

// node_modules/zod/v4/locales/tr.js
var parsedType6 = (data) => {
  const t2 = typeof data;
  switch (t2) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (
        Object.getPrototypeOf(data) !== Object.prototype &&
        data.constructor
      ) {
        return data.constructor.name;
      }
    }
  }
  return t2;
};
var error38 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "olmal\u0131" },
    file: { unit: "bayt", verb: "olmal\u0131" },
    array: { unit: "\xF6\u011Fe", verb: "olmal\u0131" },
    set: { unit: "\xF6\u011Fe", verb: "olmal\u0131" },
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "girdi",
    email: "e-posta adresi",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO tarih ve saat",
    date: "ISO tarih",
    time: "ISO saat",
    duration: "ISO s\xFCre",
    ipv4: "IPv4 adresi",
    ipv6: "IPv6 adresi",
    cidrv4: "IPv4 aral\u0131\u011F\u0131",
    cidrv6: "IPv6 aral\u0131\u011F\u0131",
    base64: "base64 ile \u015Fifrelenmi\u015F metin",
    base64url: "base64url ile \u015Fifrelenmi\u015F metin",
    json_string: "JSON dizesi",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "\u015Eablon dizesi",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `Ge\xE7ersiz de\u011Fer: beklenen ${issue3.expected}, al\u0131nan ${parsedType6(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `Ge\xE7ersiz de\u011Fer: beklenen ${stringifyPrimitive(issue3.values[0])}`;
        return `Ge\xE7ersiz se\xE7enek: a\u015Fa\u011F\u0131dakilerden biri olmal\u0131: ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\xC7ok b\xFCy\xFCk: beklenen ${issue3.origin ?? "de\u011Fer"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\xF6\u011Fe"}`;
        return `\xC7ok b\xFCy\xFCk: beklenen ${issue3.origin ?? "de\u011Fer"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Ge\xE7ersiz metin: "${_issue.prefix}" ile ba\u015Flamal\u0131`;
        if (_issue.format === "ends_with")
          return `Ge\xE7ersiz metin: "${_issue.suffix}" ile bitmeli`;
        if (_issue.format === "includes")
          return `Ge\xE7ersiz metin: "${_issue.includes}" i\xE7ermeli`;
        if (_issue.format === "regex")
          return `Ge\xE7ersiz metin: ${_issue.pattern} desenine uymal\u0131`;
        return `Ge\xE7ersiz ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `Ge\xE7ersiz say\u0131: ${issue3.divisor} ile tam b\xF6l\xFCnebilmeli`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar${issue3.keys.length > 1 ? "lar" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} i\xE7inde ge\xE7ersiz anahtar`;
      case "invalid_union":
        return "Ge\xE7ersiz de\u011Fer";
      case "invalid_element":
        return `${issue3.origin} i\xE7inde ge\xE7ersiz de\u011Fer`;
      default:
        return `Ge\xE7ersiz de\u011Fer`;
    }
  };
};
function tr_default() {
  return {
    localeError: error38(),
  };
}

// node_modules/zod/v4/locales/uk.js
var error39 = () => {
  const Sizable = {
    string: {
      unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0456\u0432",
      verb: "\u043C\u0430\u0442\u0438\u043C\u0435",
    },
    file: {
      unit: "\u0431\u0430\u0439\u0442\u0456\u0432",
      verb: "\u043C\u0430\u0442\u0438\u043C\u0435",
    },
    array: {
      unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432",
      verb: "\u043C\u0430\u0442\u0438\u043C\u0435",
    },
    set: {
      unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432",
      verb: "\u043C\u0430\u0442\u0438\u043C\u0435",
    },
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043C\u0430\u0441\u0438\u0432";
        }
        if (data === null) {
          return "null";
        }
        if (
          Object.getPrototypeOf(data) !== Object.prototype &&
          data.constructor
        ) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456",
    email:
      "\u0430\u0434\u0440\u0435\u0441\u0430 \u0435\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u043E\u0457 \u043F\u043E\u0448\u0442\u0438",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0434\u0430\u0442\u0430 \u0442\u0430 \u0447\u0430\u0441 ISO",
    date: "\u0434\u0430\u0442\u0430 ISO",
    time: "\u0447\u0430\u0441 ISO",
    duration:
      "\u0442\u0440\u0438\u0432\u0430\u043B\u0456\u0441\u0442\u044C ISO",
    ipv4: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv4",
    ipv6: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv6",
    cidrv4: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv4",
    cidrv6: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv6",
    base64:
      "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64",
    base64url:
      "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64url",
    json_string: "\u0440\u044F\u0434\u043E\u043A JSON",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal:
      "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${issue3.expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${parsedType7(issue3.input)}`;
      // return `Неправильні вхідні дані: очікується ${issue.expected}, отримано ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${stringifyPrimitive(issue3.values[0])}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0430 \u043E\u043F\u0446\u0456\u044F: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F \u043E\u0434\u043D\u0435 \u0437 ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432"}`;
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue3.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} \u0431\u0443\u0434\u0435 ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue3.origin} \u0431\u0443\u0434\u0435 ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043F\u043E\u0447\u0438\u043D\u0430\u0442\u0438\u0441\u044F \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0437\u0430\u043A\u0456\u043D\u0447\u0443\u0432\u0430\u0442\u0438\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043C\u0456\u0441\u0442\u0438\u0442\u0438 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0434\u0430\u0442\u0438 \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0447\u0438\u0441\u043B\u043E: \u043F\u043E\u0432\u0438\u043D\u043D\u043E \u0431\u0443\u0442\u0438 \u043A\u0440\u0430\u0442\u043D\u0438\u043C ${issue3.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u043D\u0438\u0439 \u043A\u043B\u044E\u0447${issue3.keys.length > 1 ? "\u0456" : ""}: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u043A\u043B\u044E\u0447 \u0443 ${issue3.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456";
      case "invalid_element":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F \u0443 ${issue3.origin}`;
      default:
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456`;
    }
  };
};
function uk_default() {
  return {
    localeError: error39(),
  };
}

// node_modules/zod/v4/locales/ua.js
function ua_default() {
  return uk_default();
}

// node_modules/zod/v4/locales/ur.js
var error40 = () => {
  const Sizable = {
    string: {
      unit: "\u062D\u0631\u0648\u0641",
      verb: "\u06C1\u0648\u0646\u0627",
    },
    file: {
      unit: "\u0628\u0627\u0626\u0679\u0633",
      verb: "\u06C1\u0648\u0646\u0627",
    },
    array: {
      unit: "\u0622\u0626\u0679\u0645\u0632",
      verb: "\u06C1\u0648\u0646\u0627",
    },
    set: {
      unit: "\u0622\u0626\u0679\u0645\u0632",
      verb: "\u06C1\u0648\u0646\u0627",
    },
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0646\u0645\u0628\u0631";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0622\u0631\u06D2";
        }
        if (data === null) {
          return "\u0646\u0644";
        }
        if (
          Object.getPrototypeOf(data) !== Object.prototype &&
          data.constructor
        ) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "\u0627\u0646 \u067E\u0679",
    email:
      "\u0627\u06CC \u0645\u06CC\u0644 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    uuidv4:
      "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 4",
    uuidv6:
      "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 6",
    nanoid: "\u0646\u06CC\u0646\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    guid: "\u062C\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid2: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC 2",
    ulid: "\u06CC\u0648 \u0627\u06CC\u0644 \u0622\u0626\u06CC \u0688\u06CC",
    xid: "\u0627\u06CC\u06A9\u0633 \u0622\u0626\u06CC \u0688\u06CC",
    ksuid:
      "\u06A9\u06D2 \u0627\u06CC\u0633 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    datetime:
      "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0688\u06CC\u0679 \u0679\u0627\u0626\u0645",
    date: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u062A\u0627\u0631\u06CC\u062E",
    time: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0648\u0642\u062A",
    duration:
      "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0645\u062F\u062A",
    ipv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    ipv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    cidrv4:
      "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0631\u06CC\u0646\u062C",
    cidrv6:
      "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0631\u06CC\u0646\u062C",
    base64:
      "\u0628\u06CC\u0633 64 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    base64url:
      "\u0628\u06CC\u0633 64 \u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    json_string:
      "\u062C\u06D2 \u0627\u06CC\u0633 \u0627\u0648 \u0627\u06CC\u0646 \u0633\u0679\u0631\u0646\u06AF",
    e164: "\u0627\u06CC 164 \u0646\u0645\u0628\u0631",
    jwt: "\u062C\u06D2 \u0688\u0628\u0644\u06CC\u0648 \u0679\u06CC",
    template_literal: "\u0627\u0646 \u067E\u0679",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${issue3.expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${parsedType7(issue3.input)} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${stringifyPrimitive(issue3.values[0])} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
        return `\u063A\u0644\u0637 \u0622\u067E\u0634\u0646: ${joinValues(issue3.values, "|")} \u0645\u06CC\u06BA \u0633\u06D2 \u0627\u06CC\u06A9 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue3.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u06D2 ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0627\u0635\u0631"} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue3.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u0627 ${adj}${issue3.maximum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue3.origin} \u06A9\u06D2 ${adj}${issue3.minimum.toString()} ${sizing.unit} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        }
        return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue3.origin} \u06A9\u0627 ${adj}${issue3.minimum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.prefix}" \u0633\u06D2 \u0634\u0631\u0648\u0639 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        }
        if (_issue.format === "ends_with")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.suffix}" \u067E\u0631 \u062E\u062A\u0645 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "includes")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.includes}" \u0634\u0627\u0645\u0644 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "regex")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: \u067E\u06CC\u0679\u0631\u0646 ${_issue.pattern} \u0633\u06D2 \u0645\u06CC\u0686 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        return `\u063A\u0644\u0637 ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u063A\u0644\u0637 \u0646\u0645\u0628\u0631: ${issue3.divisor} \u06A9\u0627 \u0645\u0636\u0627\u0639\u0641 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
      case "unrecognized_keys":
        return `\u063A\u06CC\u0631 \u062A\u0633\u0644\u06CC\u0645 \u0634\u062F\u06C1 \u06A9\u06CC${issue3.keys.length > 1 ? "\u0632" : ""}: ${joinValues(issue3.keys, "\u060C ")}`;
      case "invalid_key":
        return `${issue3.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u06A9\u06CC`;
      case "invalid_union":
        return "\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679";
      case "invalid_element":
        return `${issue3.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u0648\u06CC\u0644\u06CC\u0648`;
      default:
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679`;
    }
  };
};
function ur_default() {
  return {
    localeError: error40(),
  };
}

// node_modules/zod/v4/locales/vi.js
var error41 = () => {
  const Sizable = {
    string: { unit: "k\xFD t\u1EF1", verb: "c\xF3" },
    file: { unit: "byte", verb: "c\xF3" },
    array: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" },
    set: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" },
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "s\u1ED1";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "m\u1EA3ng";
        }
        if (data === null) {
          return "null";
        }
        if (
          Object.getPrototypeOf(data) !== Object.prototype &&
          data.constructor
        ) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "\u0111\u1EA7u v\xE0o",
    email: "\u0111\u1ECBa ch\u1EC9 email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ng\xE0y gi\u1EDD ISO",
    date: "ng\xE0y ISO",
    time: "gi\u1EDD ISO",
    duration: "kho\u1EA3ng th\u1EDDi gian ISO",
    ipv4: "\u0111\u1ECBa ch\u1EC9 IPv4",
    ipv6: "\u0111\u1ECBa ch\u1EC9 IPv6",
    cidrv4: "d\u1EA3i IPv4",
    cidrv6: "d\u1EA3i IPv6",
    base64: "chu\u1ED7i m\xE3 h\xF3a base64",
    base64url: "chu\u1ED7i m\xE3 h\xF3a base64url",
    json_string: "chu\u1ED7i JSON",
    e164: "s\u1ED1 E.164",
    jwt: "JWT",
    template_literal: "\u0111\u1EA7u v\xE0o",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${issue3.expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${stringifyPrimitive(issue3.values[0])}`;
        return `T\xF9y ch\u1ECDn kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i m\u1ED9t trong c\xE1c gi\xE1 tr\u1ECB ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue3.origin ?? "gi\xE1 tr\u1ECB"} ${sizing.verb} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "ph\u1EA7n t\u1EED"}`;
        return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue3.origin ?? "gi\xE1 tr\u1ECB"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i b\u1EAFt \u0111\u1EA7u b\u1EB1ng "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i k\u1EBFt th\xFAc b\u1EB1ng "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i bao g\u1ED3m "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i kh\u1EDBp v\u1EDBi m\u1EABu ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue3.format} kh\xF4ng h\u1EE3p l\u1EC7`;
      }
      case "not_multiple_of":
        return `S\u1ED1 kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i l\xE0 b\u1ED9i s\u1ED1 c\u1EE7a ${issue3.divisor}`;
      case "unrecognized_keys":
        return `Kh\xF3a kh\xF4ng \u0111\u01B0\u1EE3c nh\u1EADn d\u1EA1ng: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `Kh\xF3a kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue3.origin}`;
      case "invalid_union":
        return "\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7";
      case "invalid_element":
        return `Gi\xE1 tr\u1ECB kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue3.origin}`;
      default:
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7`;
    }
  };
};
function vi_default() {
  return {
    localeError: error41(),
  };
}

// node_modules/zod/v4/locales/zh-CN.js
var error42 = () => {
  const Sizable = {
    string: { unit: "\u5B57\u7B26", verb: "\u5305\u542B" },
    file: { unit: "\u5B57\u8282", verb: "\u5305\u542B" },
    array: { unit: "\u9879", verb: "\u5305\u542B" },
    set: { unit: "\u9879", verb: "\u5305\u542B" },
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "\u975E\u6570\u5B57(NaN)" : "\u6570\u5B57";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u6570\u7EC4";
        }
        if (data === null) {
          return "\u7A7A\u503C(null)";
        }
        if (
          Object.getPrototypeOf(data) !== Object.prototype &&
          data.constructor
        ) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "\u8F93\u5165",
    email: "\u7535\u5B50\u90AE\u4EF6",
    url: "URL",
    emoji: "\u8868\u60C5\u7B26\u53F7",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u671F\u65F6\u95F4",
    date: "ISO\u65E5\u671F",
    time: "ISO\u65F6\u95F4",
    duration: "ISO\u65F6\u957F",
    ipv4: "IPv4\u5730\u5740",
    ipv6: "IPv6\u5730\u5740",
    cidrv4: "IPv4\u7F51\u6BB5",
    cidrv6: "IPv6\u7F51\u6BB5",
    base64: "base64\u7F16\u7801\u5B57\u7B26\u4E32",
    base64url: "base64url\u7F16\u7801\u5B57\u7B26\u4E32",
    json_string: "JSON\u5B57\u7B26\u4E32",
    e164: "E.164\u53F7\u7801",
    jwt: "JWT",
    template_literal: "\u8F93\u5165",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${issue3.expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${stringifyPrimitive(issue3.values[0])}`;
        return `\u65E0\u6548\u9009\u9879\uFF1A\u671F\u671B\u4EE5\u4E0B\u4E4B\u4E00 ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue3.origin ?? "\u503C"} ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u4E2A\u5143\u7D20"}`;
        return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue3.origin ?? "\u503C"} ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue3.origin} ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue3.origin} ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.prefix}" \u5F00\u5934`;
        if (_issue.format === "ends_with")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.suffix}" \u7ED3\u5C3E`;
        if (_issue.format === "includes")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u6EE1\u8DB3\u6B63\u5219\u8868\u8FBE\u5F0F ${_issue.pattern}`;
        return `\u65E0\u6548${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u65E0\u6548\u6570\u5B57\uFF1A\u5FC5\u987B\u662F ${issue3.divisor} \u7684\u500D\u6570`;
      case "unrecognized_keys":
        return `\u51FA\u73B0\u672A\u77E5\u7684\u952E(key): ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `${issue3.origin} \u4E2D\u7684\u952E(key)\u65E0\u6548`;
      case "invalid_union":
        return "\u65E0\u6548\u8F93\u5165";
      case "invalid_element":
        return `${issue3.origin} \u4E2D\u5305\u542B\u65E0\u6548\u503C(value)`;
      default:
        return `\u65E0\u6548\u8F93\u5165`;
    }
  };
};
function zh_CN_default() {
  return {
    localeError: error42(),
  };
}

// node_modules/zod/v4/locales/zh-TW.js
var error43 = () => {
  const Sizable = {
    string: { unit: "\u5B57\u5143", verb: "\u64C1\u6709" },
    file: { unit: "\u4F4D\u5143\u7D44", verb: "\u64C1\u6709" },
    array: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" },
    set: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" },
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (
          Object.getPrototypeOf(data) !== Object.prototype &&
          data.constructor
        ) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "\u8F38\u5165",
    email: "\u90F5\u4EF6\u5730\u5740",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u65E5\u671F\u6642\u9593",
    date: "ISO \u65E5\u671F",
    time: "ISO \u6642\u9593",
    duration: "ISO \u671F\u9593",
    ipv4: "IPv4 \u4F4D\u5740",
    ipv6: "IPv6 \u4F4D\u5740",
    cidrv4: "IPv4 \u7BC4\u570D",
    cidrv6: "IPv6 \u7BC4\u570D",
    base64: "base64 \u7DE8\u78BC\u5B57\u4E32",
    base64url: "base64url \u7DE8\u78BC\u5B57\u4E32",
    json_string: "JSON \u5B57\u4E32",
    e164: "E.164 \u6578\u503C",
    jwt: "JWT",
    template_literal: "\u8F38\u5165",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${issue3.expected}\uFF0C\u4F46\u6536\u5230 ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${stringifyPrimitive(issue3.values[0])}`;
        return `\u7121\u6548\u7684\u9078\u9805\uFF1A\u9810\u671F\u70BA\u4EE5\u4E0B\u5176\u4E2D\u4E4B\u4E00 ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue3.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue3.maximum.toString()} ${sizing.unit ?? "\u500B\u5143\u7D20"}`;
        return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue3.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue3.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing) {
          return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue3.origin} \u61C9\u70BA ${adj}${issue3.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue3.origin} \u61C9\u70BA ${adj}${issue3.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with") {
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.prefix}" \u958B\u982D`;
        }
        if (_issue.format === "ends_with")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.suffix}" \u7D50\u5C3E`;
        if (_issue.format === "includes")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u7B26\u5408\u683C\u5F0F ${_issue.pattern}`;
        return `\u7121\u6548\u7684 ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u6548\u7684\u6578\u5B57\uFF1A\u5FC5\u9808\u70BA ${issue3.divisor} \u7684\u500D\u6578`;
      case "unrecognized_keys":
        return `\u7121\u6CD5\u8B58\u5225\u7684\u9375\u503C${issue3.keys.length > 1 ? "\u5011" : ""}\uFF1A${joinValues(issue3.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue3.origin} \u4E2D\u6709\u7121\u6548\u7684\u9375\u503C`;
      case "invalid_union":
        return "\u7121\u6548\u7684\u8F38\u5165\u503C";
      case "invalid_element":
        return `${issue3.origin} \u4E2D\u6709\u7121\u6548\u7684\u503C`;
      default:
        return `\u7121\u6548\u7684\u8F38\u5165\u503C`;
    }
  };
};
function zh_TW_default() {
  return {
    localeError: error43(),
  };
}

// node_modules/zod/v4/locales/yo.js
var error44 = () => {
  const Sizable = {
    string: { unit: "\xE0mi", verb: "n\xED" },
    file: { unit: "bytes", verb: "n\xED" },
    array: { unit: "nkan", verb: "n\xED" },
    set: { unit: "nkan", verb: "n\xED" },
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "n\u1ECD\u0301mb\xE0";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "akop\u1ECD";
        }
        if (data === null) {
          return "null";
        }
        if (
          Object.getPrototypeOf(data) !== Object.prototype &&
          data.constructor
        ) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9",
    email: "\xE0d\xEDr\u1EB9\u0301s\xEC \xECm\u1EB9\u0301l\xEC",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\xE0k\xF3k\xF2 ISO",
    date: "\u1ECDj\u1ECD\u0301 ISO",
    time: "\xE0k\xF3k\xF2 ISO",
    duration: "\xE0k\xF3k\xF2 t\xF3 p\xE9 ISO",
    ipv4: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv4",
    ipv6: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv6",
    cidrv4: "\xE0gb\xE8gb\xE8 IPv4",
    cidrv6: "\xE0gb\xE8gb\xE8 IPv6",
    base64: "\u1ECD\u0300r\u1ECD\u0300 t\xED a k\u1ECD\u0301 n\xED base64",
    base64url: "\u1ECD\u0300r\u1ECD\u0300 base64url",
    json_string: "\u1ECD\u0300r\u1ECD\u0300 JSON",
    e164: "n\u1ECD\u0301mb\xE0 E.164",
    jwt: "JWT",
    template_literal: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9",
  };
  return (issue3) => {
    switch (issue3.code) {
      case "invalid_type":
        return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${issue3.expected}, \xE0m\u1ECD\u0300 a r\xED ${parsedType7(issue3.input)}`;
      case "invalid_value":
        if (issue3.values.length === 1)
          return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${stringifyPrimitive(issue3.values[0])}`;
        return `\xC0\u1E63\xE0y\xE0n a\u1E63\xEC\u1E63e: yan \u1ECD\u0300kan l\xE1ra ${joinValues(issue3.values, "|")}`;
      case "too_big": {
        const adj = issue3.inclusive ? "<=" : "<";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue3.origin ?? "iye"} ${sizing.verb} ${adj}${issue3.maximum} ${sizing.unit}`;
        return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue3.maximum}`;
      }
      case "too_small": {
        const adj = issue3.inclusive ? ">=" : ">";
        const sizing = getSizing(issue3.origin);
        if (sizing)
          return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue3.origin} ${sizing.verb} ${adj}${issue3.minimum} ${sizing.unit}`;
        return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue3.minimum}`;
      }
      case "invalid_format": {
        const _issue = issue3;
        if (_issue.format === "starts_with")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\u1EB9\u0300r\u1EB9\u0300 p\u1EB9\u0300l\xFA "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 par\xED p\u1EB9\u0300l\xFA "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 n\xED "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\xE1 \xE0p\u1EB9\u1EB9r\u1EB9 mu ${_issue.pattern}`;
        return `A\u1E63\xEC\u1E63e: ${Nouns[_issue.format] ?? issue3.format}`;
      }
      case "not_multiple_of":
        return `N\u1ECD\u0301mb\xE0 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 j\u1EB9\u0301 \xE8y\xE0 p\xEDp\xEDn ti ${issue3.divisor}`;
      case "unrecognized_keys":
        return `B\u1ECDt\xECn\xEC \xE0\xECm\u1ECD\u0300: ${joinValues(issue3.keys, ", ")}`;
      case "invalid_key":
        return `B\u1ECDt\xECn\xEC a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue3.origin}`;
      case "invalid_union":
        return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
      case "invalid_element":
        return `Iye a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue3.origin}`;
      default:
        return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
    }
  };
};
function yo_default() {
  return {
    localeError: error44(),
  };
}

// node_modules/zod/v4/core/registries.js
var $output = Symbol("ZodOutput");
var $input = Symbol("ZodInput");
var $ZodRegistry = class {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap();
    this._idmap = /* @__PURE__ */ new Map();
  }
  add(schema, ..._meta) {
    const meta = _meta[0];
    this._map.set(schema, meta);
    if (meta && typeof meta === "object" && "id" in meta) {
      if (this._idmap.has(meta.id)) {
        throw new Error(`ID ${meta.id} already exists in the registry`);
      }
      this._idmap.set(meta.id, schema);
    }
    return this;
  }
  clear() {
    this._map = /* @__PURE__ */ new WeakMap();
    this._idmap = /* @__PURE__ */ new Map();
    return this;
  }
  remove(schema) {
    const meta = this._map.get(schema);
    if (meta && typeof meta === "object" && "id" in meta) {
      this._idmap.delete(meta.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p2 = schema._zod.parent;
    if (p2) {
      const pm = { ...(this.get(p2) ?? {}) };
      delete pm.id;
      const f2 = { ...pm, ...this._map.get(schema) };
      return Object.keys(f2).length ? f2 : void 0;
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
};
function registry() {
  return new $ZodRegistry();
}
var globalRegistry = /* @__PURE__ */ registry();

// node_modules/zod/v4/core/api.js
function _string(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams(params),
  });
}
function _coercedString(Class2, params) {
  return new Class2({
    type: "string",
    coerce: true,
    ...normalizeParams(params),
  });
}
function _email(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params),
  });
}
function _guid(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params),
  });
}
function _uuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params),
  });
}
function _uuidv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params),
  });
}
function _uuidv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params),
  });
}
function _uuidv7(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params),
  });
}
function _url(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params),
  });
}
function _emoji2(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params),
  });
}
function _nanoid(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params),
  });
}
function _cuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params),
  });
}
function _cuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params),
  });
}
function _ulid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params),
  });
}
function _xid(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params),
  });
}
function _ksuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params),
  });
}
function _ipv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params),
  });
}
function _ipv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params),
  });
}
function _cidrv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params),
  });
}
function _cidrv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params),
  });
}
function _base64(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params),
  });
}
function _base64url(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params),
  });
}
function _e164(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params),
  });
}
function _jwt(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params),
  });
}
var TimePrecision = {
  Any: null,
  Minute: -1,
  Second: 0,
  Millisecond: 3,
  Microsecond: 6,
};
function _isoDateTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params),
  });
}
function _isoDate(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params),
  });
}
function _isoTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params),
  });
}
function _isoDuration(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params),
  });
}
function _number(Class2, params) {
  return new Class2({
    type: "number",
    checks: [],
    ...normalizeParams(params),
  });
}
function _coercedNumber(Class2, params) {
  return new Class2({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams(params),
  });
}
function _int(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params),
  });
}
function _float32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams(params),
  });
}
function _float64(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams(params),
  });
}
function _int32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams(params),
  });
}
function _uint32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams(params),
  });
}
function _boolean(Class2, params) {
  return new Class2({
    type: "boolean",
    ...normalizeParams(params),
  });
}
function _coercedBoolean(Class2, params) {
  return new Class2({
    type: "boolean",
    coerce: true,
    ...normalizeParams(params),
  });
}
function _bigint(Class2, params) {
  return new Class2({
    type: "bigint",
    ...normalizeParams(params),
  });
}
function _coercedBigint(Class2, params) {
  return new Class2({
    type: "bigint",
    coerce: true,
    ...normalizeParams(params),
  });
}
function _int64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams(params),
  });
}
function _uint64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams(params),
  });
}
function _symbol(Class2, params) {
  return new Class2({
    type: "symbol",
    ...normalizeParams(params),
  });
}
function _undefined2(Class2, params) {
  return new Class2({
    type: "undefined",
    ...normalizeParams(params),
  });
}
function _null2(Class2, params) {
  return new Class2({
    type: "null",
    ...normalizeParams(params),
  });
}
function _any(Class2) {
  return new Class2({
    type: "any",
  });
}
function _unknown(Class2) {
  return new Class2({
    type: "unknown",
  });
}
function _never(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams(params),
  });
}
function _void(Class2, params) {
  return new Class2({
    type: "void",
    ...normalizeParams(params),
  });
}
function _date(Class2, params) {
  return new Class2({
    type: "date",
    ...normalizeParams(params),
  });
}
function _coercedDate(Class2, params) {
  return new Class2({
    type: "date",
    coerce: true,
    ...normalizeParams(params),
  });
}
function _nan(Class2, params) {
  return new Class2({
    type: "nan",
    ...normalizeParams(params),
  });
}
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false,
  });
}
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true,
  });
}
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false,
  });
}
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true,
  });
}
function _positive(params) {
  return _gt(0, params);
}
function _negative(params) {
  return _lt(0, params);
}
function _nonpositive(params) {
  return _lte(0, params);
}
function _nonnegative(params) {
  return _gte(0, params);
}
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value,
  });
}
function _maxSize(maximum, params) {
  return new $ZodCheckMaxSize({
    check: "max_size",
    ...normalizeParams(params),
    maximum,
  });
}
function _minSize(minimum, params) {
  return new $ZodCheckMinSize({
    check: "min_size",
    ...normalizeParams(params),
    minimum,
  });
}
function _size(size, params) {
  return new $ZodCheckSizeEquals({
    check: "size_equals",
    ...normalizeParams(params),
    size,
  });
}
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum,
  });
  return ch;
}
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum,
  });
}
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length,
  });
}
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern,
  });
}
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params),
  });
}
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params),
  });
}
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes,
  });
}
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix,
  });
}
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix,
  });
}
function _property(property, schema, params) {
  return new $ZodCheckProperty({
    check: "property",
    property,
    schema,
    ...normalizeParams(params),
  });
}
function _mime(types, params) {
  return new $ZodCheckMimeType({
    check: "mime_type",
    mime: types,
    ...normalizeParams(params),
  });
}
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx,
  });
}
function _normalize(form) {
  return _overwrite((input) => input.normalize(form));
}
function _trim() {
  return _overwrite((input) => input.trim());
}
function _toLowerCase() {
  return _overwrite((input) => input.toLowerCase());
}
function _toUpperCase() {
  return _overwrite((input) => input.toUpperCase());
}
function _array(Class2, element, params) {
  return new Class2({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...normalizeParams(params),
  });
}
function _union(Class2, options, params) {
  return new Class2({
    type: "union",
    options,
    ...normalizeParams(params),
  });
}
function _discriminatedUnion(Class2, discriminator, options, params) {
  return new Class2({
    type: "union",
    options,
    discriminator,
    ...normalizeParams(params),
  });
}
function _intersection(Class2, left, right) {
  return new Class2({
    type: "intersection",
    left,
    right,
  });
}
function _tuple(Class2, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class2({
    type: "tuple",
    items,
    rest,
    ...normalizeParams(params),
  });
}
function _record(Class2, keyType, valueType, params) {
  return new Class2({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams(params),
  });
}
function _map(Class2, keyType, valueType, params) {
  return new Class2({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams(params),
  });
}
function _set(Class2, valueType, params) {
  return new Class2({
    type: "set",
    valueType,
    ...normalizeParams(params),
  });
}
function _enum(Class2, values, params) {
  const entries = Array.isArray(values)
    ? Object.fromEntries(values.map((v2) => [v2, v2]))
    : values;
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params),
  });
}
function _nativeEnum(Class2, entries, params) {
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params),
  });
}
function _literal(Class2, value, params) {
  return new Class2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams(params),
  });
}
function _file(Class2, params) {
  return new Class2({
    type: "file",
    ...normalizeParams(params),
  });
}
function _transform(Class2, fn) {
  return new Class2({
    type: "transform",
    transform: fn,
  });
}
function _optional(Class2, innerType) {
  return new Class2({
    type: "optional",
    innerType,
  });
}
function _nullable(Class2, innerType) {
  return new Class2({
    type: "nullable",
    innerType,
  });
}
function _default(Class2, innerType, defaultValue) {
  return new Class2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function"
        ? defaultValue()
        : shallowClone(defaultValue);
    },
  });
}
function _nonoptional(Class2, innerType, params) {
  return new Class2({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params),
  });
}
function _success(Class2, innerType) {
  return new Class2({
    type: "success",
    innerType,
  });
}
function _catch(Class2, innerType, catchValue) {
  return new Class2({
    type: "catch",
    innerType,
    catchValue:
      typeof catchValue === "function" ? catchValue : () => catchValue,
  });
}
function _pipe(Class2, in_, out) {
  return new Class2({
    type: "pipe",
    in: in_,
    out,
  });
}
function _readonly(Class2, innerType) {
  return new Class2({
    type: "readonly",
    innerType,
  });
}
function _templateLiteral(Class2, parts, params) {
  return new Class2({
    type: "template_literal",
    parts,
    ...normalizeParams(params),
  });
}
function _lazy(Class2, getter) {
  return new Class2({
    type: "lazy",
    getter,
  });
}
function _promise(Class2, innerType) {
  return new Class2({
    type: "promise",
    innerType,
  });
}
function _custom(Class2, fn, _params) {
  const norm = normalizeParams(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...norm,
  });
  return schema;
}
function _refine(Class2, fn, _params) {
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params),
  });
  return schema;
}
function _superRefine(fn) {
  const ch = _check((payload) => {
    payload.addIssue = (issue3) => {
      if (typeof issue3 === "string") {
        payload.issues.push(issue(issue3, payload.value, ch._zod.def));
      } else {
        const _issue = issue3;
        if (_issue.fatal) _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(issue(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
function _check(fn, params) {
  const ch = new $ZodCheck({
    check: "custom",
    ...normalizeParams(params),
  });
  ch._zod.check = fn;
  return ch;
}
function _stringbool(Classes, _params) {
  const params = normalizeParams(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v2) =>
      typeof v2 === "string" ? v2.toLowerCase() : v2,
    );
    falsyArray = falsyArray.map((v2) =>
      typeof v2 === "string" ? v2.toLowerCase() : v2,
    );
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Codec = Classes.Codec ?? $ZodCodec;
  const _Boolean = Classes.Boolean ?? $ZodBoolean;
  const _String = Classes.String ?? $ZodString;
  const stringSchema = new _String({ type: "string", error: params.error });
  const booleanSchema = new _Boolean({ type: "boolean", error: params.error });
  const codec2 = new _Codec({
    type: "pipe",
    in: stringSchema,
    out: booleanSchema,
    transform: (input, payload) => {
      let data = input;
      if (params.case !== "sensitive") data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: codec2,
          continue: false,
        });
        return {};
      }
    },
    reverseTransform: (input, _payload) => {
      if (input === true) {
        return truthyArray[0] || "true";
      } else {
        return falsyArray[0] || "false";
      }
    },
    error: params.error,
  });
  return codec2;
}
function _stringFormat(Class2, format, fnOrRegex, _params = {}) {
  const params = normalizeParams(_params);
  const def = {
    ...normalizeParams(_params),
    check: "string_format",
    type: "string",
    format,
    fn:
      typeof fnOrRegex === "function"
        ? fnOrRegex
        : (val) => fnOrRegex.test(val),
    ...params,
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class2(def);
  return inst;
}

// node_modules/zod/v4/core/to-json-schema.js
var JSONSchemaGenerator = class {
  constructor(params) {
    this.counter = 0;
    this.metadataRegistry = params?.metadata ?? globalRegistry;
    this.target = params?.target ?? "draft-2020-12";
    this.unrepresentable = params?.unrepresentable ?? "throw";
    this.override = params?.override ?? (() => {});
    this.io = params?.io ?? "output";
    this.seen = /* @__PURE__ */ new Map();
  }
  process(schema, _params = { path: [], schemaPath: [] }) {
    var _a19;
    const def = schema._zod.def;
    const formatMap = {
      guid: "uuid",
      url: "uri",
      datetime: "date-time",
      json_string: "json-string",
      regex: "",
      // do not set
    };
    const seen = this.seen.get(schema);
    if (seen) {
      seen.count++;
      const isCycle = _params.schemaPath.includes(schema);
      if (isCycle) {
        seen.cycle = _params.path;
      }
      return seen.schema;
    }
    const result = { schema: {}, count: 1, cycle: void 0, path: _params.path };
    this.seen.set(schema, result);
    const overrideSchema = schema._zod.toJSONSchema?.();
    if (overrideSchema) {
      result.schema = overrideSchema;
    } else {
      const params = {
        ..._params,
        schemaPath: [..._params.schemaPath, schema],
        path: _params.path,
      };
      const parent = schema._zod.parent;
      if (parent) {
        result.ref = parent;
        this.process(parent, params);
        this.seen.get(parent).isParent = true;
      } else {
        const _json = result.schema;
        switch (def.type) {
          case "string": {
            const json2 = _json;
            json2.type = "string";
            const { minimum, maximum, format, patterns, contentEncoding } =
              schema._zod.bag;
            if (typeof minimum === "number") json2.minLength = minimum;
            if (typeof maximum === "number") json2.maxLength = maximum;
            if (format) {
              json2.format = formatMap[format] ?? format;
              if (json2.format === "") delete json2.format;
            }
            if (contentEncoding) json2.contentEncoding = contentEncoding;
            if (patterns && patterns.size > 0) {
              const regexes = [...patterns];
              if (regexes.length === 1) json2.pattern = regexes[0].source;
              else if (regexes.length > 1) {
                result.schema.allOf = [
                  ...regexes.map((regex) => ({
                    ...(this.target === "draft-7" ||
                    this.target === "draft-4" ||
                    this.target === "openapi-3.0"
                      ? { type: "string" }
                      : {}),
                    pattern: regex.source,
                  })),
                ];
              }
            }
            break;
          }
          case "number": {
            const json2 = _json;
            const {
              minimum,
              maximum,
              format,
              multipleOf,
              exclusiveMaximum,
              exclusiveMinimum,
            } = schema._zod.bag;
            if (typeof format === "string" && format.includes("int"))
              json2.type = "integer";
            else json2.type = "number";
            if (typeof exclusiveMinimum === "number") {
              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                json2.minimum = exclusiveMinimum;
                json2.exclusiveMinimum = true;
              } else {
                json2.exclusiveMinimum = exclusiveMinimum;
              }
            }
            if (typeof minimum === "number") {
              json2.minimum = minimum;
              if (
                typeof exclusiveMinimum === "number" &&
                this.target !== "draft-4"
              ) {
                if (exclusiveMinimum >= minimum) delete json2.minimum;
                else delete json2.exclusiveMinimum;
              }
            }
            if (typeof exclusiveMaximum === "number") {
              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                json2.maximum = exclusiveMaximum;
                json2.exclusiveMaximum = true;
              } else {
                json2.exclusiveMaximum = exclusiveMaximum;
              }
            }
            if (typeof maximum === "number") {
              json2.maximum = maximum;
              if (
                typeof exclusiveMaximum === "number" &&
                this.target !== "draft-4"
              ) {
                if (exclusiveMaximum <= maximum) delete json2.maximum;
                else delete json2.exclusiveMaximum;
              }
            }
            if (typeof multipleOf === "number") json2.multipleOf = multipleOf;
            break;
          }
          case "boolean": {
            const json2 = _json;
            json2.type = "boolean";
            break;
          }
          case "bigint": {
            if (this.unrepresentable === "throw") {
              throw new Error("BigInt cannot be represented in JSON Schema");
            }
            break;
          }
          case "symbol": {
            if (this.unrepresentable === "throw") {
              throw new Error("Symbols cannot be represented in JSON Schema");
            }
            break;
          }
          case "null": {
            if (this.target === "openapi-3.0") {
              _json.type = "string";
              _json.nullable = true;
              _json.enum = [null];
            } else _json.type = "null";
            break;
          }
          case "any": {
            break;
          }
          case "unknown": {
            break;
          }
          case "undefined": {
            if (this.unrepresentable === "throw") {
              throw new Error("Undefined cannot be represented in JSON Schema");
            }
            break;
          }
          case "void": {
            if (this.unrepresentable === "throw") {
              throw new Error("Void cannot be represented in JSON Schema");
            }
            break;
          }
          case "never": {
            _json.not = {};
            break;
          }
          case "date": {
            if (this.unrepresentable === "throw") {
              throw new Error("Date cannot be represented in JSON Schema");
            }
            break;
          }
          case "array": {
            const json2 = _json;
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number") json2.minItems = minimum;
            if (typeof maximum === "number") json2.maxItems = maximum;
            json2.type = "array";
            json2.items = this.process(def.element, {
              ...params,
              path: [...params.path, "items"],
            });
            break;
          }
          case "object": {
            const json2 = _json;
            json2.type = "object";
            json2.properties = {};
            const shape = def.shape;
            for (const key in shape) {
              json2.properties[key] = this.process(shape[key], {
                ...params,
                path: [...params.path, "properties", key],
              });
            }
            const allKeys = new Set(Object.keys(shape));
            const requiredKeys = new Set(
              [...allKeys].filter((key) => {
                const v2 = def.shape[key]._zod;
                if (this.io === "input") {
                  return v2.optin === void 0;
                } else {
                  return v2.optout === void 0;
                }
              }),
            );
            if (requiredKeys.size > 0) {
              json2.required = Array.from(requiredKeys);
            }
            if (def.catchall?._zod.def.type === "never") {
              json2.additionalProperties = false;
            } else if (!def.catchall) {
              if (this.io === "output") json2.additionalProperties = false;
            } else if (def.catchall) {
              json2.additionalProperties = this.process(def.catchall, {
                ...params,
                path: [...params.path, "additionalProperties"],
              });
            }
            break;
          }
          case "union": {
            const json2 = _json;
            const options = def.options.map((x, i2) =>
              this.process(x, {
                ...params,
                path: [...params.path, "anyOf", i2],
              }),
            );
            json2.anyOf = options;
            break;
          }
          case "intersection": {
            const json2 = _json;
            const a2 = this.process(def.left, {
              ...params,
              path: [...params.path, "allOf", 0],
            });
            const b2 = this.process(def.right, {
              ...params,
              path: [...params.path, "allOf", 1],
            });
            const isSimpleIntersection = (val) =>
              "allOf" in val && Object.keys(val).length === 1;
            const allOf = [
              ...(isSimpleIntersection(a2) ? a2.allOf : [a2]),
              ...(isSimpleIntersection(b2) ? b2.allOf : [b2]),
            ];
            json2.allOf = allOf;
            break;
          }
          case "tuple": {
            const json2 = _json;
            json2.type = "array";
            const prefixPath =
              this.target === "draft-2020-12" ? "prefixItems" : "items";
            const restPath =
              this.target === "draft-2020-12"
                ? "items"
                : this.target === "openapi-3.0"
                  ? "items"
                  : "additionalItems";
            const prefixItems = def.items.map((x, i2) =>
              this.process(x, {
                ...params,
                path: [...params.path, prefixPath, i2],
              }),
            );
            const rest = def.rest
              ? this.process(def.rest, {
                  ...params,
                  path: [
                    ...params.path,
                    restPath,
                    ...(this.target === "openapi-3.0"
                      ? [def.items.length]
                      : []),
                  ],
                })
              : null;
            if (this.target === "draft-2020-12") {
              json2.prefixItems = prefixItems;
              if (rest) {
                json2.items = rest;
              }
            } else if (this.target === "openapi-3.0") {
              json2.items = {
                anyOf: prefixItems,
              };
              if (rest) {
                json2.items.anyOf.push(rest);
              }
              json2.minItems = prefixItems.length;
              if (!rest) {
                json2.maxItems = prefixItems.length;
              }
            } else {
              json2.items = prefixItems;
              if (rest) {
                json2.additionalItems = rest;
              }
            }
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number") json2.minItems = minimum;
            if (typeof maximum === "number") json2.maxItems = maximum;
            break;
          }
          case "record": {
            const json2 = _json;
            json2.type = "object";
            if (this.target === "draft-7" || this.target === "draft-2020-12") {
              json2.propertyNames = this.process(def.keyType, {
                ...params,
                path: [...params.path, "propertyNames"],
              });
            }
            json2.additionalProperties = this.process(def.valueType, {
              ...params,
              path: [...params.path, "additionalProperties"],
            });
            break;
          }
          case "map": {
            if (this.unrepresentable === "throw") {
              throw new Error("Map cannot be represented in JSON Schema");
            }
            break;
          }
          case "set": {
            if (this.unrepresentable === "throw") {
              throw new Error("Set cannot be represented in JSON Schema");
            }
            break;
          }
          case "enum": {
            const json2 = _json;
            const values = getEnumValues(def.entries);
            if (values.every((v2) => typeof v2 === "number"))
              json2.type = "number";
            if (values.every((v2) => typeof v2 === "string"))
              json2.type = "string";
            json2.enum = values;
            break;
          }
          case "literal": {
            const json2 = _json;
            const vals = [];
            for (const val of def.values) {
              if (val === void 0) {
                if (this.unrepresentable === "throw") {
                  throw new Error(
                    "Literal `undefined` cannot be represented in JSON Schema",
                  );
                } else {
                }
              } else if (typeof val === "bigint") {
                if (this.unrepresentable === "throw") {
                  throw new Error(
                    "BigInt literals cannot be represented in JSON Schema",
                  );
                } else {
                  vals.push(Number(val));
                }
              } else {
                vals.push(val);
              }
            }
            if (vals.length === 0) {
            } else if (vals.length === 1) {
              const val = vals[0];
              json2.type = val === null ? "null" : typeof val;
              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                json2.enum = [val];
              } else {
                json2.const = val;
              }
            } else {
              if (vals.every((v2) => typeof v2 === "number"))
                json2.type = "number";
              if (vals.every((v2) => typeof v2 === "string"))
                json2.type = "string";
              if (vals.every((v2) => typeof v2 === "boolean"))
                json2.type = "string";
              if (vals.every((v2) => v2 === null)) json2.type = "null";
              json2.enum = vals;
            }
            break;
          }
          case "file": {
            const json2 = _json;
            const file2 = {
              type: "string",
              format: "binary",
              contentEncoding: "binary",
            };
            const { minimum, maximum, mime } = schema._zod.bag;
            if (minimum !== void 0) file2.minLength = minimum;
            if (maximum !== void 0) file2.maxLength = maximum;
            if (mime) {
              if (mime.length === 1) {
                file2.contentMediaType = mime[0];
                Object.assign(json2, file2);
              } else {
                json2.anyOf = mime.map((m2) => {
                  const mFile = { ...file2, contentMediaType: m2 };
                  return mFile;
                });
              }
            } else {
              Object.assign(json2, file2);
            }
            break;
          }
          case "transform": {
            if (this.unrepresentable === "throw") {
              throw new Error(
                "Transforms cannot be represented in JSON Schema",
              );
            }
            break;
          }
          case "nullable": {
            const inner = this.process(def.innerType, params);
            if (this.target === "openapi-3.0") {
              result.ref = def.innerType;
              _json.nullable = true;
            } else {
              _json.anyOf = [inner, { type: "null" }];
            }
            break;
          }
          case "nonoptional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "success": {
            const json2 = _json;
            json2.type = "boolean";
            break;
          }
          case "default": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.default = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "prefault": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            if (this.io === "input")
              _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "catch": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            let catchValue;
            try {
              catchValue = def.catchValue(void 0);
            } catch {
              throw new Error(
                "Dynamic catch values are not supported in JSON Schema",
              );
            }
            _json.default = catchValue;
            break;
          }
          case "nan": {
            if (this.unrepresentable === "throw") {
              throw new Error("NaN cannot be represented in JSON Schema");
            }
            break;
          }
          case "template_literal": {
            const json2 = _json;
            const pattern = schema._zod.pattern;
            if (!pattern)
              throw new Error("Pattern not found in template literal");
            json2.type = "string";
            json2.pattern = pattern.source;
            break;
          }
          case "pipe": {
            const innerType =
              this.io === "input"
                ? def.in._zod.def.type === "transform"
                  ? def.out
                  : def.in
                : def.out;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "readonly": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.readOnly = true;
            break;
          }
          // passthrough types
          case "promise": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "optional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "lazy": {
            const innerType = schema._zod.innerType;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "custom": {
            if (this.unrepresentable === "throw") {
              throw new Error(
                "Custom types cannot be represented in JSON Schema",
              );
            }
            break;
          }
          case "function": {
            if (this.unrepresentable === "throw") {
              throw new Error(
                "Function types cannot be represented in JSON Schema",
              );
            }
            break;
          }
          default: {
            def;
          }
        }
      }
    }
    const meta = this.metadataRegistry.get(schema);
    if (meta) Object.assign(result.schema, meta);
    if (this.io === "input" && isTransforming(schema)) {
      delete result.schema.examples;
      delete result.schema.default;
    }
    if (this.io === "input" && result.schema._prefault)
      (_a19 = result.schema).default ??
        (_a19.default = result.schema._prefault);
    delete result.schema._prefault;
    const _result = this.seen.get(schema);
    return _result.schema;
  }
  emit(schema, _params) {
    const params = {
      cycles: _params?.cycles ?? "ref",
      reused: _params?.reused ?? "inline",
      // unrepresentable: _params?.unrepresentable ?? "throw",
      // uri: _params?.uri ?? ((id) => `${id}`),
      external: _params?.external ?? void 0,
    };
    const root = this.seen.get(schema);
    if (!root) throw new Error("Unprocessed schema. This is a bug in Zod.");
    const makeURI = (entry) => {
      const defsSegment =
        this.target === "draft-2020-12" ? "$defs" : "definitions";
      if (params.external) {
        const externalId = params.external.registry.get(entry[0])?.id;
        const uriGenerator = params.external.uri ?? ((id2) => id2);
        if (externalId) {
          return { ref: uriGenerator(externalId) };
        }
        const id =
          entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;
        entry[1].defId = id;
        return {
          defId: id,
          ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}`,
        };
      }
      if (entry[1] === root) {
        return { ref: "#" };
      }
      const uriPrefix = `#`;
      const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
      const defId = entry[1].schema.id ?? `__schema${this.counter++}`;
      return { defId, ref: defUriPrefix + defId };
    };
    const extractToDef = (entry) => {
      if (entry[1].schema.$ref) {
        return;
      }
      const seen = entry[1];
      const { ref, defId } = makeURI(entry);
      seen.def = { ...seen.schema };
      if (defId) seen.defId = defId;
      const schema2 = seen.schema;
      for (const key in schema2) {
        delete schema2[key];
      }
      schema2.$ref = ref;
    };
    if (params.cycles === "throw") {
      for (const entry of this.seen.entries()) {
        const seen = entry[1];
        if (seen.cycle) {
          throw new Error(`Cycle detected: #/${seen.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
        }
      }
    }
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (schema === entry[0]) {
        extractToDef(entry);
        continue;
      }
      if (params.external) {
        const ext = params.external.registry.get(entry[0])?.id;
        if (schema !== entry[0] && ext) {
          extractToDef(entry);
          continue;
        }
      }
      const id = this.metadataRegistry.get(entry[0])?.id;
      if (id) {
        extractToDef(entry);
        continue;
      }
      if (seen.cycle) {
        extractToDef(entry);
        continue;
      }
      if (seen.count > 1) {
        if (params.reused === "ref") {
          extractToDef(entry);
          continue;
        }
      }
    }
    const flattenRef = (zodSchema2, params2) => {
      const seen = this.seen.get(zodSchema2);
      const schema2 = seen.def ?? seen.schema;
      const _cached = { ...schema2 };
      if (seen.ref === null) {
        return;
      }
      const ref = seen.ref;
      seen.ref = null;
      if (ref) {
        flattenRef(ref, params2);
        const refSchema = this.seen.get(ref).schema;
        if (
          refSchema.$ref &&
          (params2.target === "draft-7" ||
            params2.target === "draft-4" ||
            params2.target === "openapi-3.0")
        ) {
          schema2.allOf = schema2.allOf ?? [];
          schema2.allOf.push(refSchema);
        } else {
          Object.assign(schema2, refSchema);
          Object.assign(schema2, _cached);
        }
      }
      if (!seen.isParent)
        this.override({
          zodSchema: zodSchema2,
          jsonSchema: schema2,
          path: seen.path ?? [],
        });
    };
    for (const entry of [...this.seen.entries()].reverse()) {
      flattenRef(entry[0], { target: this.target });
    }
    const result = {};
    if (this.target === "draft-2020-12") {
      result.$schema = "https://json-schema.org/draft/2020-12/schema";
    } else if (this.target === "draft-7") {
      result.$schema = "http://json-schema.org/draft-07/schema#";
    } else if (this.target === "draft-4") {
      result.$schema = "http://json-schema.org/draft-04/schema#";
    } else if (this.target === "openapi-3.0") {
    } else {
      console.warn(`Invalid target: ${this.target}`);
    }
    if (params.external?.uri) {
      const id = params.external.registry.get(schema)?.id;
      if (!id) throw new Error("Schema is missing an `id` property");
      result.$id = params.external.uri(id);
    }
    Object.assign(result, root.def);
    const defs = params.external?.defs ?? {};
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (seen.def && seen.defId) {
        defs[seen.defId] = seen.def;
      }
    }
    if (params.external) {
    } else {
      if (Object.keys(defs).length > 0) {
        if (this.target === "draft-2020-12") {
          result.$defs = defs;
        } else {
          result.definitions = defs;
        }
      }
    }
    try {
      return JSON.parse(JSON.stringify(result));
    } catch (_err) {
      throw new Error("Error converting schema to JSON.");
    }
  }
};
function toJSONSchema(input, _params) {
  if (input instanceof $ZodRegistry) {
    const gen2 = new JSONSchemaGenerator(_params);
    const defs = {};
    for (const entry of input._idmap.entries()) {
      const [_2, schema] = entry;
      gen2.process(schema);
    }
    const schemas = {};
    const external = {
      registry: input,
      uri: _params?.uri,
      defs,
    };
    for (const entry of input._idmap.entries()) {
      const [key, schema] = entry;
      schemas[key] = gen2.emit(schema, {
        ..._params,
        external,
      });
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment =
        gen2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas.__shared = {
        [defsSegment]: defs,
      };
    }
    return { schemas };
  }
  const gen = new JSONSchemaGenerator(_params);
  gen.process(input);
  return gen.emit(input, _params);
}
function isTransforming(_schema, _ctx) {
  const ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
  if (ctx.seen.has(_schema)) return false;
  ctx.seen.add(_schema);
  const schema = _schema;
  const def = schema._zod.def;
  switch (def.type) {
    case "string":
    case "number":
    case "bigint":
    case "boolean":
    case "date":
    case "symbol":
    case "undefined":
    case "null":
    case "any":
    case "unknown":
    case "never":
    case "void":
    case "literal":
    case "enum":
    case "nan":
    case "file":
    case "template_literal":
      return false;
    case "array": {
      return isTransforming(def.element, ctx);
    }
    case "object": {
      for (const key in def.shape) {
        if (isTransforming(def.shape[key], ctx)) return true;
      }
      return false;
    }
    case "union": {
      for (const option of def.options) {
        if (isTransforming(option, ctx)) return true;
      }
      return false;
    }
    case "intersection": {
      return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
    }
    case "tuple": {
      for (const item of def.items) {
        if (isTransforming(item, ctx)) return true;
      }
      if (def.rest && isTransforming(def.rest, ctx)) return true;
      return false;
    }
    case "record": {
      return (
        isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx)
      );
    }
    case "map": {
      return (
        isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx)
      );
    }
    case "set": {
      return isTransforming(def.valueType, ctx);
    }
    // inner types
    case "promise":
    case "optional":
    case "nonoptional":
    case "nullable":
    case "readonly":
      return isTransforming(def.innerType, ctx);
    case "lazy":
      return isTransforming(def.getter(), ctx);
    case "default": {
      return isTransforming(def.innerType, ctx);
    }
    case "prefault": {
      return isTransforming(def.innerType, ctx);
    }
    case "custom": {
      return false;
    }
    case "transform": {
      return true;
    }
    case "pipe": {
      return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
    }
    case "success": {
      return false;
    }
    case "catch": {
      return false;
    }
    case "function": {
      return false;
    }
    default:
      def;
  }
  throw new Error(`Unknown schema type: ${def.type}`);
}

// node_modules/zod/v4/core/json-schema.js
var json_schema_exports = {};

// node_modules/zod/v4/classic/iso.js
var iso_exports = {};
__export(iso_exports, {
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  date: () => date2,
  datetime: () => datetime2,
  duration: () => duration2,
  time: () => time2,
});
var ZodISODateTime = /* @__PURE__ */ $constructor(
  "ZodISODateTime",
  (inst, def) => {
    $ZodISODateTime.init(inst, def);
    ZodStringFormat.init(inst, def);
  },
);
function datetime2(params) {
  return _isoDateTime(ZodISODateTime, params);
}
var ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function date2(params) {
  return _isoDate(ZodISODate, params);
}
var ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function time2(params) {
  return _isoTime(ZodISOTime, params);
}
var ZodISODuration = /* @__PURE__ */ $constructor(
  "ZodISODuration",
  (inst, def) => {
    $ZodISODuration.init(inst, def);
    ZodStringFormat.init(inst, def);
  },
);
function duration2(params) {
  return _isoDuration(ZodISODuration, params);
}

// node_modules/zod/v4/classic/errors.js
var initializer2 = (inst, issues) => {
  $ZodError.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError(inst, mapper),
      // enumerable: false,
    },
    flatten: {
      value: (mapper) => flattenError(inst, mapper),
      // enumerable: false,
    },
    addIssue: {
      value: (issue3) => {
        inst.issues.push(issue3);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      },
      // enumerable: false,
    },
    addIssues: {
      value: (issues2) => {
        inst.issues.push(...issues2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      },
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      },
      // enumerable: false,
    },
  });
};
var ZodError = $constructor("ZodError", initializer2);
var ZodRealError = $constructor("ZodError", initializer2, {
  Parent: Error,
});

// node_modules/zod/v4/classic/parse.js
var parse2 = /* @__PURE__ */ _parse(ZodRealError);
var parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError);
var safeParse2 = /* @__PURE__ */ _safeParse(ZodRealError);
var safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError);
var encode2 = /* @__PURE__ */ _encode(ZodRealError);
var decode2 = /* @__PURE__ */ _decode(ZodRealError);
var encodeAsync2 = /* @__PURE__ */ _encodeAsync(ZodRealError);
var decodeAsync2 = /* @__PURE__ */ _decodeAsync(ZodRealError);
var safeEncode2 = /* @__PURE__ */ _safeEncode(ZodRealError);
var safeDecode2 = /* @__PURE__ */ _safeDecode(ZodRealError);
var safeEncodeAsync2 = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);
var safeDecodeAsync2 = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);

// node_modules/zod/v4/classic/schemas.js
var ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
  $ZodType.init(inst, def);
  inst.def = def;
  inst.type = def.type;
  Object.defineProperty(inst, "_def", { value: def });
  inst.check = (...checks) => {
    return inst.clone(
      util_exports.mergeDefs(def, {
        checks: [
          ...(def.checks ?? []),
          ...checks.map((ch) =>
            typeof ch === "function"
              ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } }
              : ch,
          ),
        ],
      }),
    );
  };
  inst.clone = (def2, params) => clone(inst, def2, params);
  inst.brand = () => inst;
  inst.register = (reg, meta) => {
    reg.add(inst, meta);
    return inst;
  };
  inst.parse = (data, params) =>
    parse2(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse2(inst, data, params);
  inst.parseAsync = async (data, params) =>
    parseAsync2(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) =>
    safeParseAsync2(inst, data, params);
  inst.spa = inst.safeParseAsync;
  inst.encode = (data, params) => encode2(inst, data, params);
  inst.decode = (data, params) => decode2(inst, data, params);
  inst.encodeAsync = async (data, params) => encodeAsync2(inst, data, params);
  inst.decodeAsync = async (data, params) => decodeAsync2(inst, data, params);
  inst.safeEncode = (data, params) => safeEncode2(inst, data, params);
  inst.safeDecode = (data, params) => safeDecode2(inst, data, params);
  inst.safeEncodeAsync = async (data, params) =>
    safeEncodeAsync2(inst, data, params);
  inst.safeDecodeAsync = async (data, params) =>
    safeDecodeAsync2(inst, data, params);
  inst.refine = (check2, params) => inst.check(refine(check2, params));
  inst.superRefine = (refinement) => inst.check(superRefine(refinement));
  inst.overwrite = (fn) => inst.check(_overwrite(fn));
  inst.optional = () => optional(inst);
  inst.nullable = () => nullable(inst);
  inst.nullish = () => optional(nullable(inst));
  inst.nonoptional = (params) => nonoptional(inst, params);
  inst.array = () => array(inst);
  inst.or = (arg) => union([inst, arg]);
  inst.and = (arg) => intersection(inst, arg);
  inst.transform = (tx) => pipe(inst, transform(tx));
  inst.default = (def2) => _default2(inst, def2);
  inst.prefault = (def2) => prefault(inst, def2);
  inst.catch = (params) => _catch2(inst, params);
  inst.pipe = (target) => pipe(inst, target);
  inst.readonly = () => readonly(inst);
  inst.describe = (description) => {
    const cl = inst.clone();
    globalRegistry.add(cl, { description });
    return cl;
  };
  Object.defineProperty(inst, "description", {
    get() {
      return globalRegistry.get(inst)?.description;
    },
    configurable: true,
  });
  inst.meta = (...args) => {
    if (args.length === 0) {
      return globalRegistry.get(inst);
    }
    const cl = inst.clone();
    globalRegistry.add(cl, args[0]);
    return cl;
  };
  inst.isOptional = () => inst.safeParse(void 0).success;
  inst.isNullable = () => inst.safeParse(null).success;
  return inst;
});
var _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  ZodType.init(inst, def);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null;
  inst.minLength = bag.minimum ?? null;
  inst.maxLength = bag.maximum ?? null;
  inst.regex = (...args) => inst.check(_regex(...args));
  inst.includes = (...args) => inst.check(_includes(...args));
  inst.startsWith = (...args) => inst.check(_startsWith(...args));
  inst.endsWith = (...args) => inst.check(_endsWith(...args));
  inst.min = (...args) => inst.check(_minLength(...args));
  inst.max = (...args) => inst.check(_maxLength(...args));
  inst.length = (...args) => inst.check(_length(...args));
  inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
  inst.lowercase = (params) => inst.check(_lowercase(params));
  inst.uppercase = (params) => inst.check(_uppercase(params));
  inst.trim = () => inst.check(_trim());
  inst.normalize = (...args) => inst.check(_normalize(...args));
  inst.toLowerCase = () => inst.check(_toLowerCase());
  inst.toUpperCase = () => inst.check(_toUpperCase());
});
var ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  _ZodString.init(inst, def);
  inst.email = (params) => inst.check(_email(ZodEmail, params));
  inst.url = (params) => inst.check(_url(ZodURL, params));
  inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
  inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
  inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
  inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
  inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
  inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
  inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
  inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
  inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
  inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
  inst.xid = (params) => inst.check(_xid(ZodXID, params));
  inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
  inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
  inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
  inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
  inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
  inst.e164 = (params) => inst.check(_e164(ZodE164, params));
  inst.datetime = (params) => inst.check(datetime2(params));
  inst.date = (params) => inst.check(date2(params));
  inst.time = (params) => inst.check(time2(params));
  inst.duration = (params) => inst.check(duration2(params));
});
function string2(params) {
  return _string(ZodString, params);
}
var ZodStringFormat = /* @__PURE__ */ $constructor(
  "ZodStringFormat",
  (inst, def) => {
    $ZodStringFormat.init(inst, def);
    _ZodString.init(inst, def);
  },
);
var ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
  $ZodEmail.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function email2(params) {
  return _email(ZodEmail, params);
}
var ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
  $ZodGUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function guid2(params) {
  return _guid(ZodGUID, params);
}
var ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
  $ZodUUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function uuid2(params) {
  return _uuid(ZodUUID, params);
}
function uuidv4(params) {
  return _uuidv4(ZodUUID, params);
}
function uuidv6(params) {
  return _uuidv6(ZodUUID, params);
}
function uuidv7(params) {
  return _uuidv7(ZodUUID, params);
}
var ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
  $ZodURL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function url(params) {
  return _url(ZodURL, params);
}
function httpUrl(params) {
  return _url(ZodURL, {
    protocol: /^https?$/,
    hostname: regexes_exports.domain,
    ...util_exports.normalizeParams(params),
  });
}
var ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function emoji2(params) {
  return _emoji2(ZodEmoji, params);
}
var ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function nanoid2(params) {
  return _nanoid(ZodNanoID, params);
}
var ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
  $ZodCUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid3(params) {
  return _cuid(ZodCUID, params);
}
var ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid22(params) {
  return _cuid2(ZodCUID2, params);
}
var ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
  $ZodULID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ulid2(params) {
  return _ulid(ZodULID, params);
}
var ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
  $ZodXID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function xid2(params) {
  return _xid(ZodXID, params);
}
var ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ksuid2(params) {
  return _ksuid(ZodKSUID, params);
}
var ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv42(params) {
  return _ipv4(ZodIPv4, params);
}
var ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv62(params) {
  return _ipv6(ZodIPv6, params);
}
var ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv42(params) {
  return _cidrv4(ZodCIDRv4, params);
}
var ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv62(params) {
  return _cidrv6(ZodCIDRv6, params);
}
var ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
  $ZodBase64.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base642(params) {
  return _base64(ZodBase64, params);
}
var ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base64url2(params) {
  return _base64url(ZodBase64URL, params);
}
var ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
  $ZodE164.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function e1642(params) {
  return _e164(ZodE164, params);
}
var ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
  $ZodJWT.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function jwt(params) {
  return _jwt(ZodJWT, params);
}
var ZodCustomStringFormat = /* @__PURE__ */ $constructor(
  "ZodCustomStringFormat",
  (inst, def) => {
    $ZodCustomStringFormat.init(inst, def);
    ZodStringFormat.init(inst, def);
  },
);
function stringFormat(format, fnOrRegex, _params = {}) {
  return _stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);
}
function hostname2(_params) {
  return _stringFormat(
    ZodCustomStringFormat,
    "hostname",
    regexes_exports.hostname,
    _params,
  );
}
function hex2(_params) {
  return _stringFormat(
    ZodCustomStringFormat,
    "hex",
    regexes_exports.hex,
    _params,
  );
}
function hash(alg, params) {
  const enc = params?.enc ?? "hex";
  const format = `${alg}_${enc}`;
  const regex = regexes_exports[format];
  if (!regex) throw new Error(`Unrecognized hash format: ${format}`);
  return _stringFormat(ZodCustomStringFormat, format, regex, params);
}
var ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
  $ZodNumber.init(inst, def);
  ZodType.init(inst, def);
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.int = (params) => inst.check(int(params));
  inst.safe = (params) => inst.check(int(params));
  inst.positive = (params) => inst.check(_gt(0, params));
  inst.nonnegative = (params) => inst.check(_gte(0, params));
  inst.negative = (params) => inst.check(_lt(0, params));
  inst.nonpositive = (params) => inst.check(_lte(0, params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  inst.step = (value, params) => inst.check(_multipleOf(value, params));
  inst.finite = () => inst;
  const bag = inst._zod.bag;
  inst.minValue =
    Math.max(
      bag.minimum ?? Number.NEGATIVE_INFINITY,
      bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY,
    ) ?? null;
  inst.maxValue =
    Math.min(
      bag.maximum ?? Number.POSITIVE_INFINITY,
      bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY,
    ) ?? null;
  inst.isInt =
    (bag.format ?? "").includes("int") ||
    Number.isSafeInteger(bag.multipleOf ?? 0.5);
  inst.isFinite = true;
  inst.format = bag.format ?? null;
});
function number2(params) {
  return _number(ZodNumber, params);
}
var ZodNumberFormat = /* @__PURE__ */ $constructor(
  "ZodNumberFormat",
  (inst, def) => {
    $ZodNumberFormat.init(inst, def);
    ZodNumber.init(inst, def);
  },
);
function int(params) {
  return _int(ZodNumberFormat, params);
}
function float32(params) {
  return _float32(ZodNumberFormat, params);
}
function float64(params) {
  return _float64(ZodNumberFormat, params);
}
function int32(params) {
  return _int32(ZodNumberFormat, params);
}
function uint32(params) {
  return _uint32(ZodNumberFormat, params);
}
var ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def);
  ZodType.init(inst, def);
});
function boolean2(params) {
  return _boolean(ZodBoolean, params);
}
var ZodBigInt = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
  $ZodBigInt.init(inst, def);
  ZodType.init(inst, def);
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.positive = (params) => inst.check(_gt(BigInt(0), params));
  inst.negative = (params) => inst.check(_lt(BigInt(0), params));
  inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
  inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  const bag = inst._zod.bag;
  inst.minValue = bag.minimum ?? null;
  inst.maxValue = bag.maximum ?? null;
  inst.format = bag.format ?? null;
});
function bigint2(params) {
  return _bigint(ZodBigInt, params);
}
var ZodBigIntFormat = /* @__PURE__ */ $constructor(
  "ZodBigIntFormat",
  (inst, def) => {
    $ZodBigIntFormat.init(inst, def);
    ZodBigInt.init(inst, def);
  },
);
function int64(params) {
  return _int64(ZodBigIntFormat, params);
}
function uint64(params) {
  return _uint64(ZodBigIntFormat, params);
}
var ZodSymbol = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {
  $ZodSymbol.init(inst, def);
  ZodType.init(inst, def);
});
function symbol15(params) {
  return _symbol(ZodSymbol, params);
}
var ZodUndefined = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {
  $ZodUndefined.init(inst, def);
  ZodType.init(inst, def);
});
function _undefined3(params) {
  return _undefined2(ZodUndefined, params);
}
var ZodNull = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
  $ZodNull.init(inst, def);
  ZodType.init(inst, def);
});
function _null3(params) {
  return _null2(ZodNull, params);
}
var ZodAny = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
  $ZodAny.init(inst, def);
  ZodType.init(inst, def);
});
function any() {
  return _any(ZodAny);
}
var ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodType.init(inst, def);
});
function unknown() {
  return _unknown(ZodUnknown);
}
var ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
  $ZodNever.init(inst, def);
  ZodType.init(inst, def);
});
function never(params) {
  return _never(ZodNever, params);
}
var ZodVoid = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {
  $ZodVoid.init(inst, def);
  ZodType.init(inst, def);
});
function _void2(params) {
  return _void(ZodVoid, params);
}
var ZodDate = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
  $ZodDate.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  const c2 = inst._zod.bag;
  inst.minDate = c2.minimum ? new Date(c2.minimum) : null;
  inst.maxDate = c2.maximum ? new Date(c2.maximum) : null;
});
function date3(params) {
  return _date(ZodDate, params);
}
var ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
  $ZodArray.init(inst, def);
  ZodType.init(inst, def);
  inst.element = def.element;
  inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
  inst.nonempty = (params) => inst.check(_minLength(1, params));
  inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
  inst.length = (len, params) => inst.check(_length(len, params));
  inst.unwrap = () => inst.element;
});
function array(element, params) {
  return _array(ZodArray, element, params);
}
function keyof(schema) {
  const shape = schema._zod.def.shape;
  return _enum2(Object.keys(shape));
}
var ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
  $ZodObjectJIT.init(inst, def);
  ZodType.init(inst, def);
  util_exports.defineLazy(inst, "shape", () => {
    return def.shape;
  });
  inst.keyof = () => _enum2(Object.keys(inst._zod.def.shape));
  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
  inst.passthrough = () =>
    inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });
  inst.extend = (incoming) => {
    return util_exports.extend(inst, incoming);
  };
  inst.safeExtend = (incoming) => {
    return util_exports.safeExtend(inst, incoming);
  };
  inst.merge = (other) => util_exports.merge(inst, other);
  inst.pick = (mask) => util_exports.pick(inst, mask);
  inst.omit = (mask) => util_exports.omit(inst, mask);
  inst.partial = (...args) => util_exports.partial(ZodOptional, inst, args[0]);
  inst.required = (...args) =>
    util_exports.required(ZodNonOptional, inst, args[0]);
});
function object(shape, params) {
  const def = {
    type: "object",
    shape: shape ?? {},
    ...util_exports.normalizeParams(params),
  };
  return new ZodObject(def);
}
function strictObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: never(),
    ...util_exports.normalizeParams(params),
  });
}
function looseObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: unknown(),
    ...util_exports.normalizeParams(params),
  });
}
var ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodType.init(inst, def);
  inst.options = def.options;
});
function union(options, params) {
  return new ZodUnion({
    type: "union",
    options,
    ...util_exports.normalizeParams(params),
  });
}
var ZodDiscriminatedUnion = /* @__PURE__ */ $constructor(
  "ZodDiscriminatedUnion",
  (inst, def) => {
    ZodUnion.init(inst, def);
    $ZodDiscriminatedUnion.init(inst, def);
  },
);
function discriminatedUnion(discriminator, options, params) {
  return new ZodDiscriminatedUnion({
    type: "union",
    options,
    discriminator,
    ...util_exports.normalizeParams(params),
  });
}
var ZodIntersection = /* @__PURE__ */ $constructor(
  "ZodIntersection",
  (inst, def) => {
    $ZodIntersection.init(inst, def);
    ZodType.init(inst, def);
  },
);
function intersection(left, right) {
  return new ZodIntersection({
    type: "intersection",
    left,
    right,
  });
}
var ZodTuple = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
  $ZodTuple.init(inst, def);
  ZodType.init(inst, def);
  inst.rest = (rest) =>
    inst.clone({
      ...inst._zod.def,
      rest,
    });
});
function tuple(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple({
    type: "tuple",
    items,
    rest,
    ...util_exports.normalizeParams(params),
  });
}
var ZodRecord = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
  $ZodRecord.init(inst, def);
  ZodType.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function record(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params),
  });
}
function partialRecord(keyType, valueType, params) {
  const k = clone(keyType);
  k._zod.values = void 0;
  return new ZodRecord({
    type: "record",
    keyType: k,
    valueType,
    ...util_exports.normalizeParams(params),
  });
}
var ZodMap = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {
  $ZodMap.init(inst, def);
  ZodType.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function map(keyType, valueType, params) {
  return new ZodMap({
    type: "map",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params),
  });
}
var ZodSet = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {
  $ZodSet.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (...args) => inst.check(_minSize(...args));
  inst.nonempty = (params) => inst.check(_minSize(1, params));
  inst.max = (...args) => inst.check(_maxSize(...args));
  inst.size = (...args) => inst.check(_size(...args));
});
function set(valueType, params) {
  return new ZodSet({
    type: "set",
    valueType,
    ...util_exports.normalizeParams(params),
  });
}
var ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodType.init(inst, def);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    const newEntries = {};
    for (const value of values) {
      if (keys.has(value)) {
        newEntries[value] = def.entries[value];
      } else throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries,
    });
  };
  inst.exclude = (values, params) => {
    const newEntries = { ...def.entries };
    for (const value of values) {
      if (keys.has(value)) {
        delete newEntries[value];
      } else throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries,
    });
  };
});
function _enum2(values, params) {
  const entries = Array.isArray(values)
    ? Object.fromEntries(values.map((v2) => [v2, v2]))
    : values;
  return new ZodEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params),
  });
}
function nativeEnum(entries, params) {
  return new ZodEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params),
  });
}
var ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def);
  ZodType.init(inst, def);
  inst.values = new Set(def.values);
  Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1) {
        throw new Error(
          "This schema contains multiple valid literal values. Use `.values` instead.",
        );
      }
      return def.values[0];
    },
  });
});
function literal(value, params) {
  return new ZodLiteral({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...util_exports.normalizeParams(params),
  });
}
var ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {
  $ZodFile.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (size, params) => inst.check(_minSize(size, params));
  inst.max = (size, params) => inst.check(_maxSize(size, params));
  inst.mime = (types, params) =>
    inst.check(_mime(Array.isArray(types) ? types : [types], params));
});
function file(params) {
  return _file(ZodFile, params);
}
var ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (_ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    payload.addIssue = (issue3) => {
      if (typeof issue3 === "string") {
        payload.issues.push(util_exports.issue(issue3, payload.value, def));
      } else {
        const _issue = issue3;
        if (_issue.fatal) _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = inst);
        payload.issues.push(util_exports.issue(_issue));
      }
    };
    const output = def.transform(payload.value, payload);
    if (output instanceof Promise) {
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    payload.value = output;
    return payload;
  };
});
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn,
  });
}
var ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
  return new ZodOptional({
    type: "optional",
    innerType,
  });
}
var ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
  return new ZodNullable({
    type: "nullable",
    innerType,
  });
}
function nullish2(innerType) {
  return optional(nullable(innerType));
}
var ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function _default2(innerType, defaultValue) {
  return new ZodDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function"
        ? defaultValue()
        : util_exports.shallowClone(defaultValue);
    },
  });
}
var ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function"
        ? defaultValue()
        : util_exports.shallowClone(defaultValue);
    },
  });
}
var ZodNonOptional = /* @__PURE__ */ $constructor(
  "ZodNonOptional",
  (inst, def) => {
    $ZodNonOptional.init(inst, def);
    ZodType.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
  },
);
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...util_exports.normalizeParams(params),
  });
}
var ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {
  $ZodSuccess.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function success(innerType) {
  return new ZodSuccess({
    type: "success",
    innerType,
  });
}
var ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
  $ZodCatch.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function _catch2(innerType, catchValue) {
  return new ZodCatch({
    type: "catch",
    innerType,
    catchValue:
      typeof catchValue === "function" ? catchValue : () => catchValue,
  });
}
var ZodNaN = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {
  $ZodNaN.init(inst, def);
  ZodType.init(inst, def);
});
function nan(params) {
  return _nan(ZodNaN, params);
}
var ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodType.init(inst, def);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out,
    // ...util.normalizeParams(params),
  });
}
var ZodCodec = /* @__PURE__ */ $constructor("ZodCodec", (inst, def) => {
  ZodPipe.init(inst, def);
  $ZodCodec.init(inst, def);
});
function codec(in_, out, params) {
  return new ZodCodec({
    type: "pipe",
    in: in_,
    out,
    transform: params.decode,
    reverseTransform: params.encode,
  });
}
var ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function readonly(innerType) {
  return new ZodReadonly({
    type: "readonly",
    innerType,
  });
}
var ZodTemplateLiteral = /* @__PURE__ */ $constructor(
  "ZodTemplateLiteral",
  (inst, def) => {
    $ZodTemplateLiteral.init(inst, def);
    ZodType.init(inst, def);
  },
);
function templateLiteral(parts, params) {
  return new ZodTemplateLiteral({
    type: "template_literal",
    parts,
    ...util_exports.normalizeParams(params),
  });
}
var ZodLazy = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {
  $ZodLazy.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.getter();
});
function lazy(getter) {
  return new ZodLazy({
    type: "lazy",
    getter,
  });
}
var ZodPromise = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {
  $ZodPromise.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function promise(innerType) {
  return new ZodPromise({
    type: "promise",
    innerType,
  });
}
var ZodFunction = /* @__PURE__ */ $constructor("ZodFunction", (inst, def) => {
  $ZodFunction.init(inst, def);
  ZodType.init(inst, def);
});
function _function(params) {
  return new ZodFunction({
    type: "function",
    input: Array.isArray(params?.input)
      ? tuple(params?.input)
      : (params?.input ?? array(unknown())),
    output: params?.output ?? unknown(),
  });
}
var ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodType.init(inst, def);
});
function check(fn) {
  const ch = new $ZodCheck({
    check: "custom",
    // ...util.normalizeParams(params),
  });
  ch._zod.check = fn;
  return ch;
}
function custom(fn, _params) {
  return _custom(ZodCustom, fn ?? (() => true), _params);
}
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
  return _superRefine(fn);
}
function _instanceof(
  cls,
  params = {
    error: `Input not instance of ${cls.name}`,
  },
) {
  const inst = new ZodCustom({
    type: "custom",
    check: "custom",
    fn: (data) => data instanceof cls,
    abort: true,
    ...util_exports.normalizeParams(params),
  });
  inst._zod.bag.Class = cls;
  return inst;
}
var stringbool = (...args) =>
  _stringbool(
    {
      Codec: ZodCodec,
      Boolean: ZodBoolean,
      String: ZodString,
    },
    ...args,
  );
function json(params) {
  const jsonSchema2 = lazy(() => {
    return union([
      string2(params),
      number2(),
      boolean2(),
      _null3(),
      array(jsonSchema2),
      record(string2(), jsonSchema2),
    ]);
  });
  return jsonSchema2;
}
function preprocess(fn, schema) {
  return pipe(transform(fn), schema);
}

// node_modules/zod/v4/classic/compat.js
var ZodIssueCode = {
  invalid_type: "invalid_type",
  too_big: "too_big",
  too_small: "too_small",
  invalid_format: "invalid_format",
  not_multiple_of: "not_multiple_of",
  unrecognized_keys: "unrecognized_keys",
  invalid_union: "invalid_union",
  invalid_key: "invalid_key",
  invalid_element: "invalid_element",
  invalid_value: "invalid_value",
  custom: "custom",
};
function setErrorMap(map2) {
  config({
    customError: map2,
  });
}
function getErrorMap() {
  return config().customError;
}
var ZodFirstPartyTypeKind;
/* @__PURE__ */ (function (ZodFirstPartyTypeKind3) {})(
  ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}),
);

// node_modules/zod/v4/classic/coerce.js
var coerce_exports = {};
__export(coerce_exports, {
  bigint: () => bigint3,
  boolean: () => boolean3,
  date: () => date4,
  number: () => number3,
  string: () => string3,
});
function string3(params) {
  return _coercedString(ZodString, params);
}
function number3(params) {
  return _coercedNumber(ZodNumber, params);
}
function boolean3(params) {
  return _coercedBoolean(ZodBoolean, params);
}
function bigint3(params) {
  return _coercedBigint(ZodBigInt, params);
}
function date4(params) {
  return _coercedDate(ZodDate, params);
}

// node_modules/zod/v4/classic/external.js
config(en_default());

// node_modules/zod/v3/helpers/util.js
var util;
(function (util2) {
  util2.assertEqual = (_2) => {};
  function assertIs2(_arg) {}
  util2.assertIs = assertIs2;
  function assertNever2(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever2;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2
      .objectKeys(obj)
      .filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function (e2) {
      return obj[e2];
    });
  };
  util2.objectKeys =
    typeof Object.keys === "function"
      ? (obj) => Object.keys(obj)
      : (object4) => {
          const keys = [];
          for (const key in object4) {
            if (Object.prototype.hasOwnProperty.call(object4, key)) {
              keys.push(key);
            }
          }
          return keys;
        };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item)) return item;
    }
    return void 0;
  };
  util2.isInteger =
    typeof Number.isInteger === "function"
      ? (val) => Number.isInteger(val)
      : (val) =>
          typeof val === "number" &&
          Number.isFinite(val) &&
          Math.floor(val) === val;
  function joinValues2(array3, separator = " | ") {
    return array3
      .map((val) => (typeof val === "string" ? `'${val}'` : val))
      .join(separator);
  }
  util2.joinValues = joinValues2;
  util2.jsonStringifyReplacer = (_2, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function (objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second,
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set",
]);
var getParsedType2 = (data) => {
  const t2 = typeof data;
  switch (t2) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (
        data.then &&
        typeof data.then === "function" &&
        data.catch &&
        typeof data.catch === "function"
      ) {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};

// node_modules/zod/v3/ZodError.js
var ZodIssueCode2 = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite",
]);
var ZodError2 = class _ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper =
      _mapper ||
      function (issue3) {
        return issue3.message;
      };
    const fieldErrors = { _errors: [] };
    const processError = (error45) => {
      for (const issue3 of error45.issues) {
        if (issue3.code === "invalid_union") {
          issue3.unionErrors.map(processError);
        } else if (issue3.code === "invalid_return_type") {
          processError(issue3.returnTypeError);
        } else if (issue3.code === "invalid_arguments") {
          processError(issue3.argumentsError);
        } else if (issue3.path.length === 0) {
          fieldErrors._errors.push(mapper(issue3));
        } else {
          let curr = fieldErrors;
          let i2 = 0;
          while (i2 < issue3.path.length) {
            const el = issue3.path[i2];
            const terminal = i2 === issue3.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue3));
            }
            curr = curr[el];
            i2++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof _ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue3) => issue3.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError2.create = (issues) => {
  const error45 = new ZodError2(issues);
  return error45;
};

// node_modules/zod/v3/locales/en.js
var errorMap = (issue3, _ctx) => {
  let message;
  switch (issue3.code) {
    case ZodIssueCode2.invalid_type:
      if (issue3.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue3.expected}, received ${issue3.received}`;
      }
      break;
    case ZodIssueCode2.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue3.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode2.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue3.keys, ", ")}`;
      break;
    case ZodIssueCode2.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode2.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue3.options)}`;
      break;
    case ZodIssueCode2.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue3.options)}, received '${issue3.received}'`;
      break;
    case ZodIssueCode2.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode2.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode2.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode2.invalid_string:
      if (typeof issue3.validation === "object") {
        if ("includes" in issue3.validation) {
          message = `Invalid input: must include "${issue3.validation.includes}"`;
          if (typeof issue3.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue3.validation.position}`;
          }
        } else if ("startsWith" in issue3.validation) {
          message = `Invalid input: must start with "${issue3.validation.startsWith}"`;
        } else if ("endsWith" in issue3.validation) {
          message = `Invalid input: must end with "${issue3.validation.endsWith}"`;
        } else {
          util.assertNever(issue3.validation);
        }
      } else if (issue3.validation !== "regex") {
        message = `Invalid ${issue3.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode2.too_small:
      if (issue3.type === "array")
        message = `Array must contain ${issue3.exact ? "exactly" : issue3.inclusive ? `at least` : `more than`} ${issue3.minimum} element(s)`;
      else if (issue3.type === "string")
        message = `String must contain ${issue3.exact ? "exactly" : issue3.inclusive ? `at least` : `over`} ${issue3.minimum} character(s)`;
      else if (issue3.type === "number")
        message = `Number must be ${issue3.exact ? `exactly equal to ` : issue3.inclusive ? `greater than or equal to ` : `greater than `}${issue3.minimum}`;
      else if (issue3.type === "bigint")
        message = `Number must be ${issue3.exact ? `exactly equal to ` : issue3.inclusive ? `greater than or equal to ` : `greater than `}${issue3.minimum}`;
      else if (issue3.type === "date")
        message = `Date must be ${issue3.exact ? `exactly equal to ` : issue3.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue3.minimum))}`;
      else message = "Invalid input";
      break;
    case ZodIssueCode2.too_big:
      if (issue3.type === "array")
        message = `Array must contain ${issue3.exact ? `exactly` : issue3.inclusive ? `at most` : `less than`} ${issue3.maximum} element(s)`;
      else if (issue3.type === "string")
        message = `String must contain ${issue3.exact ? `exactly` : issue3.inclusive ? `at most` : `under`} ${issue3.maximum} character(s)`;
      else if (issue3.type === "number")
        message = `Number must be ${issue3.exact ? `exactly` : issue3.inclusive ? `less than or equal to` : `less than`} ${issue3.maximum}`;
      else if (issue3.type === "bigint")
        message = `BigInt must be ${issue3.exact ? `exactly` : issue3.inclusive ? `less than or equal to` : `less than`} ${issue3.maximum}`;
      else if (issue3.type === "date")
        message = `Date must be ${issue3.exact ? `exactly` : issue3.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue3.maximum))}`;
      else message = "Invalid input";
      break;
    case ZodIssueCode2.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode2.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode2.not_multiple_of:
      message = `Number must be a multiple of ${issue3.multipleOf}`;
      break;
    case ZodIssueCode2.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue3);
  }
  return { message };
};
var en_default2 = errorMap;

// node_modules/zod/v3/errors.js
var overrideErrorMap = en_default2;
function getErrorMap2() {
  return overrideErrorMap;
}

// node_modules/zod/v3/helpers/parseUtil.js
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...(issueData.path || [])];
  const fullIssue = {
    ...issueData,
    path: fullPath,
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message,
    };
  }
  let errorMessage = "";
  const maps = errorMaps
    .filter((m2) => !!m2)
    .slice()
    .reverse();
  for (const map2 of maps) {
    errorMessage = map2(fullIssue, {
      data,
      defaultError: errorMessage,
    }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage,
  };
};
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap2();
  const issue3 = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === en_default2 ? void 0 : en_default2,
      // then global default map
    ].filter((x) => !!x),
  });
  ctx.common.issues.push(issue3);
}
var ParseStatus = class _ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid") this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted") this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s2 of results) {
      if (s2.status === "aborted") return INVALID;
      if (s2.status === "dirty") status.dirty();
      arrayValue.push(s2.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value,
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted") return INVALID;
      if (value.status === "aborted") return INVALID;
      if (key.status === "dirty") status.dirty();
      if (value.status === "dirty") status.dirty();
      if (
        key.value !== "__proto__" &&
        (typeof value.value !== "undefined" || pair.alwaysSet)
      ) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted",
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;

// node_modules/zod/v3/helpers/errorUtil.js
var errorUtil;
(function (errorUtil2) {
  errorUtil2.errToObj = (message) =>
    typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) =>
    typeof message === "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));

// node_modules/zod/v3/types.js
var ParseInputLazyPath = class {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error) return this._error;
        const error45 = new ZodError2(ctx.common.issues);
        this._error = error45;
        return this._error;
      },
    };
  }
};
function processCreateParams(params) {
  if (!params) return {};
  const {
    errorMap: errorMap2,
    invalid_type_error,
    required_error,
    description,
  } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(
      `Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`,
    );
  }
  if (errorMap2) return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type") return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType2 = class {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType2(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return (
      ctx || {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType2(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent,
      }
    );
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType2(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent,
      },
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success) return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: params?.async ?? false,
        contextualErrorMap: params?.errorMap,
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType2(data),
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async,
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType2(data),
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result)
          ? {
              value: result.value,
            }
          : {
              issues: ctx.common.issues,
            };
      } catch (err2) {
        if (err2?.message?.toLowerCase()?.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true,
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) =>
      isValid(result)
        ? {
            value: result.value,
          }
        : {
            issues: ctx.common.issues,
          },
    );
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success) return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: true,
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType2(data),
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult)
      ? maybeAsyncResult
      : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check2, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check2(val);
      const setError = () =>
        ctx.addIssue({
          code: ZodIssueCode2.custom,
          ...getIssueProperties(val),
        });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check2, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check2(val)) {
        ctx.addIssue(
          typeof refinementData === "function"
            ? refinementData(val, ctx)
            : refinementData,
        );
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind2.ZodEffects,
      effect: { type: "refinement", refinement },
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data),
    };
  }
  optional() {
    return ZodOptional2.create(this, this._def);
  }
  nullable() {
    return ZodNullable2.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray2.create(this);
  }
  promise() {
    return ZodPromise2.create(this, this._def);
  }
  or(option) {
    return ZodUnion2.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection2.create(this, incoming, this._def);
  }
  transform(transform3) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind2.ZodEffects,
      effect: { type: "transform", transform: transform3 },
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault2({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind2.ZodDefault,
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind2.ZodBranded,
      type: this,
      ...processCreateParams(this._def),
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch2({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind2.ZodCatch,
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description,
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly2.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var uuidRegex =
  /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var durationRegex =
  /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex =
  /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex =
  /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv4CidrRegex =
  /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var ipv6Regex =
  /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ipv6CidrRegex =
  /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64Regex =
  /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var base64urlRegex =
  /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset) opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version3) {
  if ((version3 === "v4" || !version3) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version3 === "v6" || !version3) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT2(jwt2, alg) {
  if (!jwtRegex.test(jwt2)) return false;
  try {
    const [header] = jwt2.split(".");
    if (!header) return false;
    const base644 = header
      .replace(/-/g, "+")
      .replace(/_/g, "/")
      .padEnd(header.length + ((4 - (header.length % 4)) % 4), "=");
    const decoded = JSON.parse(atob(base644));
    if (typeof decoded !== "object" || decoded === null) return false;
    if ("typ" in decoded && decoded?.typ !== "JWT") return false;
    if (!decoded.alg) return false;
    if (alg && decoded.alg !== alg) return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr(ip, version3) {
  if ((version3 === "v4" || !version3) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version3 === "v6" || !version3) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
var ZodString2 = class _ZodString3 extends ZodType2 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType7 = this._getType(input);
    if (parsedType7 !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType,
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        if (input.data.length < check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.too_small,
            minimum: check2.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check2.message,
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        if (input.data.length > check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.too_big,
            maximum: check2.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check2.message,
          });
          status.dirty();
        }
      } else if (check2.kind === "length") {
        const tooBig = input.data.length > check2.value;
        const tooSmall = input.data.length < check2.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode2.too_big,
              maximum: check2.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check2.message,
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode2.too_small,
              minimum: check2.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check2.message,
            });
          }
          status.dirty();
        }
      } else if (check2.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode2.invalid_string,
            message: check2.message,
          });
          status.dirty();
        }
      } else if (check2.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode2.invalid_string,
            message: check2.message,
          });
          status.dirty();
        }
      } else if (check2.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode2.invalid_string,
            message: check2.message,
          });
          status.dirty();
        }
      } else if (check2.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode2.invalid_string,
            message: check2.message,
          });
          status.dirty();
        }
      } else if (check2.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode2.invalid_string,
            message: check2.message,
          });
          status.dirty();
        }
      } else if (check2.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode2.invalid_string,
            message: check2.message,
          });
          status.dirty();
        }
      } else if (check2.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode2.invalid_string,
            message: check2.message,
          });
          status.dirty();
        }
      } else if (check2.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode2.invalid_string,
            message: check2.message,
          });
          status.dirty();
        }
      } else if (check2.kind === "regex") {
        check2.regex.lastIndex = 0;
        const testResult = check2.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode2.invalid_string,
            message: check2.message,
          });
          status.dirty();
        }
      } else if (check2.kind === "trim") {
        input.data = input.data.trim();
      } else if (check2.kind === "includes") {
        if (!input.data.includes(check2.value, check2.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_string,
            validation: { includes: check2.value, position: check2.position },
            message: check2.message,
          });
          status.dirty();
        }
      } else if (check2.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check2.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check2.kind === "startsWith") {
        if (!input.data.startsWith(check2.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_string,
            validation: { startsWith: check2.value },
            message: check2.message,
          });
          status.dirty();
        }
      } else if (check2.kind === "endsWith") {
        if (!input.data.endsWith(check2.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_string,
            validation: { endsWith: check2.value },
            message: check2.message,
          });
          status.dirty();
        }
      } else if (check2.kind === "datetime") {
        const regex = datetimeRegex(check2);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_string,
            validation: "datetime",
            message: check2.message,
          });
          status.dirty();
        }
      } else if (check2.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_string,
            validation: "date",
            message: check2.message,
          });
          status.dirty();
        }
      } else if (check2.kind === "time") {
        const regex = timeRegex(check2);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_string,
            validation: "time",
            message: check2.message,
          });
          status.dirty();
        }
      } else if (check2.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode2.invalid_string,
            message: check2.message,
          });
          status.dirty();
        }
      } else if (check2.kind === "ip") {
        if (!isValidIP(input.data, check2.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode2.invalid_string,
            message: check2.message,
          });
          status.dirty();
        }
      } else if (check2.kind === "jwt") {
        if (!isValidJWT2(input.data, check2.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode2.invalid_string,
            message: check2.message,
          });
          status.dirty();
        }
      } else if (check2.kind === "cidr") {
        if (!isValidCidr(input.data, check2.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode2.invalid_string,
            message: check2.message,
          });
          status.dirty();
        }
      } else if (check2.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode2.invalid_string,
            message: check2.message,
          });
          status.dirty();
        }
      } else if (check2.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode2.invalid_string,
            message: check2.message,
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode2.invalid_string,
      ...errorUtil.errToObj(message),
    });
  }
  _addCheck(check2) {
    return new _ZodString3({
      ...this._def,
      checks: [...this._def.checks, check2],
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message),
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options,
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision:
        typeof options?.precision === "undefined" ? null : options?.precision,
      offset: options?.offset ?? false,
      local: options?.local ?? false,
      ...errorUtil.errToObj(options?.message),
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options,
      });
    }
    return this._addCheck({
      kind: "time",
      precision:
        typeof options?.precision === "undefined" ? null : options?.precision,
      ...errorUtil.errToObj(options?.message),
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message),
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options?.position,
      ...errorUtil.errToObj(options?.message),
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message),
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message),
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message),
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message),
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message),
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new _ZodString3({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }],
    });
  }
  toLowerCase() {
    return new _ZodString3({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }],
    });
  }
  toUpperCase() {
    return new _ZodString3({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }],
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min) min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2) max2 = ch.value;
      }
    }
    return max2;
  }
};
ZodString2.create = (params) => {
  return new ZodString2({
    checks: [],
    typeName: ZodFirstPartyTypeKind2.ZodString,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params),
  });
};
function floatSafeRemainder2(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return (valInt % stepInt) / 10 ** decCount;
}
var ZodNumber2 = class _ZodNumber extends ZodType2 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType7 = this._getType(input);
    if (parsedType7 !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType,
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check2 of this._def.checks) {
      if (check2.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: "integer",
            received: "float",
            message: check2.message,
          });
          status.dirty();
        }
      } else if (check2.kind === "min") {
        const tooSmall = check2.inclusive
          ? input.data < check2.value
          : input.data <= check2.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.too_small,
            minimum: check2.value,
            type: "number",
            inclusive: check2.inclusive,
            exact: false,
            message: check2.message,
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        const tooBig = check2.inclusive
          ? input.data > check2.value
          : input.data >= check2.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.too_big,
            maximum: check2.value,
            type: "number",
            inclusive: check2.inclusive,
            exact: false,
            message: check2.message,
          });
          status.dirty();
        }
      } else if (check2.kind === "multipleOf") {
        if (floatSafeRemainder2(input.data, check2.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.not_multiple_of,
            multipleOf: check2.value,
            message: check2.message,
          });
          status.dirty();
        }
      } else if (check2.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.not_finite,
            message: check2.message,
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message),
        },
      ],
    });
  }
  _addCheck(check2) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check2],
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message),
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message),
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message),
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message),
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message),
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message),
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message),
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message),
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message),
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min) min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2) max2 = ch.value;
      }
    }
    return max2;
  }
  get isInt() {
    return !!this._def.checks.find(
      (ch) =>
        ch.kind === "int" ||
        (ch.kind === "multipleOf" && util.isInteger(ch.value)),
    );
  }
  get isFinite() {
    let max2 = null;
    let min = null;
    for (const ch of this._def.checks) {
      if (
        ch.kind === "finite" ||
        ch.kind === "int" ||
        ch.kind === "multipleOf"
      ) {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min) min = ch.value;
      } else if (ch.kind === "max") {
        if (max2 === null || ch.value < max2) max2 = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max2);
  }
};
ZodNumber2.create = (params) => {
  return new ZodNumber2({
    checks: [],
    typeName: ZodFirstPartyTypeKind2.ZodNumber,
    coerce: params?.coerce || false,
    ...processCreateParams(params),
  });
};
var ZodBigInt2 = class _ZodBigInt extends ZodType2 {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType7 = this._getType(input);
    if (parsedType7 !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        const tooSmall = check2.inclusive
          ? input.data < check2.value
          : input.data <= check2.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.too_small,
            type: "bigint",
            minimum: check2.value,
            inclusive: check2.inclusive,
            message: check2.message,
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        const tooBig = check2.inclusive
          ? input.data > check2.value
          : input.data >= check2.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.too_big,
            type: "bigint",
            maximum: check2.value,
            inclusive: check2.inclusive,
            message: check2.message,
          });
          status.dirty();
        }
      } else if (check2.kind === "multipleOf") {
        if (input.data % check2.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.not_multiple_of,
            multipleOf: check2.value,
            message: check2.message,
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode2.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType,
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message),
        },
      ],
    });
  }
  _addCheck(check2) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check2],
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message),
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message),
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message),
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message),
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message),
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min) min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2) max2 = ch.value;
      }
    }
    return max2;
  }
};
ZodBigInt2.create = (params) => {
  return new ZodBigInt2({
    checks: [],
    typeName: ZodFirstPartyTypeKind2.ZodBigInt,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params),
  });
};
var ZodBoolean2 = class extends ZodType2 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType7 = this._getType(input);
    if (parsedType7 !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean2.create = (params) => {
  return new ZodBoolean2({
    typeName: ZodFirstPartyTypeKind2.ZodBoolean,
    coerce: params?.coerce || false,
    ...processCreateParams(params),
  });
};
var ZodDate2 = class _ZodDate extends ZodType2 {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType7 = this._getType(input);
    if (parsedType7 !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType,
      });
      return INVALID;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode2.invalid_date,
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        if (input.data.getTime() < check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.too_small,
            message: check2.message,
            inclusive: true,
            exact: false,
            minimum: check2.value,
            type: "date",
          });
          status.dirty();
        }
      } else if (check2.kind === "max") {
        if (input.data.getTime() > check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode2.too_big,
            message: check2.message,
            inclusive: true,
            exact: false,
            maximum: check2.value,
            type: "date",
          });
          status.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime()),
    };
  }
  _addCheck(check2) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check2],
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message),
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message),
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min) min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2) max2 = ch.value;
      }
    }
    return max2 != null ? new Date(max2) : null;
  }
};
ZodDate2.create = (params) => {
  return new ZodDate2({
    checks: [],
    coerce: params?.coerce || false,
    typeName: ZodFirstPartyTypeKind2.ZodDate,
    ...processCreateParams(params),
  });
};
var ZodSymbol2 = class extends ZodType2 {
  _parse(input) {
    const parsedType7 = this._getType(input);
    if (parsedType7 !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol2.create = (params) => {
  return new ZodSymbol2({
    typeName: ZodFirstPartyTypeKind2.ZodSymbol,
    ...processCreateParams(params),
  });
};
var ZodUndefined2 = class extends ZodType2 {
  _parse(input) {
    const parsedType7 = this._getType(input);
    if (parsedType7 !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined2.create = (params) => {
  return new ZodUndefined2({
    typeName: ZodFirstPartyTypeKind2.ZodUndefined,
    ...processCreateParams(params),
  });
};
var ZodNull2 = class extends ZodType2 {
  _parse(input) {
    const parsedType7 = this._getType(input);
    if (parsedType7 !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull2.create = (params) => {
  return new ZodNull2({
    typeName: ZodFirstPartyTypeKind2.ZodNull,
    ...processCreateParams(params),
  });
};
var ZodAny2 = class extends ZodType2 {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny2.create = (params) => {
  return new ZodAny2({
    typeName: ZodFirstPartyTypeKind2.ZodAny,
    ...processCreateParams(params),
  });
};
var ZodUnknown2 = class extends ZodType2 {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown2.create = (params) => {
  return new ZodUnknown2({
    typeName: ZodFirstPartyTypeKind2.ZodUnknown,
    ...processCreateParams(params),
  });
};
var ZodNever2 = class extends ZodType2 {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode2.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType,
    });
    return INVALID;
  }
};
ZodNever2.create = (params) => {
  return new ZodNever2({
    typeName: ZodFirstPartyTypeKind2.ZodNever,
    ...processCreateParams(params),
  });
};
var ZodVoid2 = class extends ZodType2 {
  _parse(input) {
    const parsedType7 = this._getType(input);
    if (parsedType7 !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid2.create = (params) => {
  return new ZodVoid2({
    typeName: ZodFirstPartyTypeKind2.ZodVoid,
    ...processCreateParams(params),
  });
};
var ZodArray2 = class _ZodArray extends ZodType2 {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode2.too_big : ZodIssueCode2.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message,
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode2.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message,
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode2.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message,
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all(
        [...ctx.data].map((item, i2) => {
          return def.type._parseAsync(
            new ParseInputLazyPath(ctx, item, ctx.path, i2),
          );
        }),
      ).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i2) => {
      return def.type._parseSync(
        new ParseInputLazyPath(ctx, item, ctx.path, i2),
      );
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) },
    });
  }
  max(maxLength, message) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) },
    });
  }
  length(len, message) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) },
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray2.create = (schema, params) => {
  return new ZodArray2({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind2.ZodArray,
    ...processCreateParams(params),
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject2) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional2.create(deepPartialify(fieldSchema));
    }
    return new ZodObject2({
      ...schema._def,
      shape: () => newShape,
    });
  } else if (schema instanceof ZodArray2) {
    return new ZodArray2({
      ...schema._def,
      type: deepPartialify(schema.element),
    });
  } else if (schema instanceof ZodOptional2) {
    return ZodOptional2.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable2) {
    return ZodNullable2.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple2) {
    return ZodTuple2.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
var ZodObject2 = class _ZodObject extends ZodType2 {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null) return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType7 = this._getType(input);
    if (parsedType7 !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType,
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (
      !(
        this._def.catchall instanceof ZodNever2 &&
        this._def.unknownKeys === "strip"
      )
    ) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(
          new ParseInputLazyPath(ctx, value, ctx.path, key),
        ),
        alwaysSet: key in ctx.data,
      });
    }
    if (this._def.catchall instanceof ZodNever2) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] },
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode2.unrecognized_keys,
            keys: extraKeys,
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") {
      } else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key),
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data,
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve()
        .then(async () => {
          const syncPairs = [];
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            syncPairs.push({
              key,
              value,
              alwaysSet: pair.alwaysSet,
            });
          }
          return syncPairs;
        })
        .then((syncPairs) => {
          return ParseStatus.mergeObjectSync(status, syncPairs);
        });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...(message !== void 0
        ? {
            errorMap: (issue3, ctx) => {
              const defaultError =
                this._def.errorMap?.(issue3, ctx).message ?? ctx.defaultError;
              if (issue3.code === "unrecognized_keys")
                return {
                  message: errorUtil.errToObj(message).message ?? defaultError,
                };
              return {
                message: defaultError,
              };
            },
          }
        : {}),
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip",
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough",
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation,
      }),
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape(),
      }),
      typeName: ZodFirstPartyTypeKind2.ZodObject,
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new _ZodObject({
      ...this._def,
      catchall: index,
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => shape,
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => shape,
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => newShape,
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional2) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => newShape,
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject2.create = (shape, params) => {
  return new ZodObject2({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever2.create(),
    typeName: ZodFirstPartyTypeKind2.ZodObject,
    ...processCreateParams(params),
  });
};
ZodObject2.strictCreate = (shape, params) => {
  return new ZodObject2({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever2.create(),
    typeName: ZodFirstPartyTypeKind2.ZodObject,
    ...processCreateParams(params),
  });
};
ZodObject2.lazycreate = (shape, params) => {
  return new ZodObject2({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever2.create(),
    typeName: ZodFirstPartyTypeKind2.ZodObject,
    ...processCreateParams(params),
  });
};
var ZodUnion2 = class extends ZodType2 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map(
        (result) => new ZodError2(result.ctx.common.issues),
      );
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_union,
        unionErrors,
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(
        options.map(async (option) => {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: [],
            },
            parent: null,
          };
          return {
            result: await option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx,
            }),
            ctx: childCtx,
          };
        }),
      ).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: [],
          },
          parent: null,
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx,
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError2(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_union,
        unionErrors,
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion2.create = (types, params) => {
  return new ZodUnion2({
    options: types,
    typeName: ZodFirstPartyTypeKind2.ZodUnion,
    ...processCreateParams(params),
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy2) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral2) {
    return [type.value];
  } else if (type instanceof ZodEnum2) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault2) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined2) {
    return [void 0];
  } else if (type instanceof ZodNull2) {
    return [null];
  } else if (type instanceof ZodOptional2) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable2) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly2) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch2) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};
var ZodDiscriminatedUnion2 = class _ZodDiscriminatedUnion extends ZodType2 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator],
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx,
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx,
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(
          `A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`,
        );
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(
            `Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`,
          );
        }
        optionsMap.set(value, type);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind2.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params),
    });
  }
};
function mergeValues2(a2, b2) {
  const aType = getParsedType2(a2);
  const bType = getParsedType2(b2);
  if (a2 === b2) {
    return { valid: true, data: a2 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b2);
    const sharedKeys = util
      .objectKeys(a2)
      .filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a2, ...b2 };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues2(a2[key], b2[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a2.length !== b2.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a2.length; index++) {
      const itemA = a2[index];
      const itemB = b2[index];
      const sharedValue = mergeValues2(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (
    aType === ZodParsedType.date &&
    bType === ZodParsedType.date &&
    +a2 === +b2
  ) {
    return { valid: true, data: a2 };
  } else {
    return { valid: false };
  }
}
var ZodIntersection2 = class extends ZodType2 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues2(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode2.invalid_intersection_types,
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx,
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx,
        }),
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(
        this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx,
        }),
        this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx,
        }),
      );
    }
  }
};
ZodIntersection2.create = (left, right, params) => {
  return new ZodIntersection2({
    left,
    right,
    typeName: ZodFirstPartyTypeKind2.ZodIntersection,
    ...processCreateParams(params),
  });
};
var ZodTuple2 = class _ZodTuple extends ZodType2 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode2.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array",
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode2.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array",
      });
      status.dirty();
    }
    const items = [...ctx.data]
      .map((item, itemIndex) => {
        const schema = this._def.items[itemIndex] || this._def.rest;
        if (!schema) return null;
        return schema._parse(
          new ParseInputLazyPath(ctx, item, ctx.path, itemIndex),
        );
      })
      .filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest,
    });
  }
};
ZodTuple2.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple2({
    items: schemas,
    typeName: ZodFirstPartyTypeKind2.ZodTuple,
    rest: null,
    ...processCreateParams(params),
  });
};
var ZodRecord2 = class _ZodRecord extends ZodType2 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(
          new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key),
        ),
        alwaysSet: key in ctx.data,
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType2) {
      return new _ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind2.ZodRecord,
        ...processCreateParams(third),
      });
    }
    return new _ZodRecord({
      keyType: ZodString2.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind2.ZodRecord,
      ...processCreateParams(second),
    });
  }
};
var ZodMap2 = class extends ZodType2 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(
          new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"]),
        ),
        value: valueType._parse(
          new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]),
        ),
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap2.create = (keyType, valueType, params) => {
  return new ZodMap2({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind2.ZodMap,
    ...processCreateParams(params),
  });
};
var ZodSet2 = class _ZodSet extends ZodType2 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode2.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message,
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode2.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message,
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted") return INVALID;
        if (element.status === "dirty") status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i2) =>
      valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i2)),
    );
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) },
    });
  }
  max(maxSize, message) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) },
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet2.create = (valueType, params) => {
  return new ZodSet2({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind2.ZodSet,
    ...processCreateParams(params),
  });
};
var ZodFunction2 = class _ZodFunction extends ZodType2 {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    function makeArgsIssue(args, error45) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap2(),
          en_default2,
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode2.invalid_arguments,
          argumentsError: error45,
        },
      });
    }
    function makeReturnsIssue(returns, error45) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap2(),
          en_default2,
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode2.invalid_return_type,
          returnTypeError: error45,
        },
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise2) {
      const me = this;
      return OK(async function (...args) {
        const error45 = new ZodError2([]);
        const parsedArgs = await me._def.args
          .parseAsync(args, params)
          .catch((e2) => {
            error45.addIssue(makeArgsIssue(args, e2));
            throw error45;
          });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type
          .parseAsync(result, params)
          .catch((e2) => {
            error45.addIssue(makeReturnsIssue(result, e2));
            throw error45;
          });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function (...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError2([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError2([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple2.create(items).rest(ZodUnknown2.create()),
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType,
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new _ZodFunction({
      args: args ? args : ZodTuple2.create([]).rest(ZodUnknown2.create()),
      returns: returns || ZodUnknown2.create(),
      typeName: ZodFirstPartyTypeKind2.ZodFunction,
      ...processCreateParams(params),
    });
  }
};
var ZodLazy2 = class extends ZodType2 {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy2.create = (getter, params) => {
  return new ZodLazy2({
    getter,
    typeName: ZodFirstPartyTypeKind2.ZodLazy,
    ...processCreateParams(params),
  });
};
var ZodLiteral2 = class extends ZodType2 {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode2.invalid_literal,
        expected: this._def.value,
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral2.create = (value, params) => {
  return new ZodLiteral2({
    value,
    typeName: ZodFirstPartyTypeKind2.ZodLiteral,
    ...processCreateParams(params),
  });
};
function createZodEnum(values, params) {
  return new ZodEnum2({
    values,
    typeName: ZodFirstPartyTypeKind2.ZodEnum,
    ...processCreateParams(params),
  });
}
var ZodEnum2 = class _ZodEnum extends ZodType2 {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode2.invalid_type,
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode2.invalid_enum_value,
        options: expectedValues,
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return _ZodEnum.create(values, {
      ...this._def,
      ...newDef,
    });
  }
  exclude(values, newDef = this._def) {
    return _ZodEnum.create(
      this.options.filter((opt) => !values.includes(opt)),
      {
        ...this._def,
        ...newDef,
      },
    );
  }
};
ZodEnum2.create = createZodEnum;
var ZodNativeEnum = class extends ZodType2 {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (
      ctx.parsedType !== ZodParsedType.string &&
      ctx.parsedType !== ZodParsedType.number
    ) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode2.invalid_type,
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(util.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode2.invalid_enum_value,
        options: expectedValues,
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind2.ZodNativeEnum,
    ...processCreateParams(params),
  });
};
var ZodPromise2 = class extends ZodType2 {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (
      ctx.parsedType !== ZodParsedType.promise &&
      ctx.common.async === false
    ) {
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    const promisified =
      ctx.parsedType === ZodParsedType.promise
        ? ctx.data
        : Promise.resolve(ctx.data);
    return OK(
      promisified.then((data) => {
        return this._def.type.parseAsync(data, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap,
        });
      }),
    );
  }
};
ZodPromise2.create = (schema, params) => {
  return new ZodPromise2({
    type: schema,
    typeName: ZodFirstPartyTypeKind2.ZodPromise,
    ...processCreateParams(params),
  });
};
var ZodEffects = class extends ZodType2 {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind2.ZodEffects
      ? this._def.schema.sourceType()
      : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      },
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted") return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx,
          });
          if (result.status === "aborted") return INVALID;
          if (result.status === "dirty") return DIRTY(result.value);
          if (status.value === "dirty") return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted") return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx,
        });
        if (result.status === "aborted") return INVALID;
        if (result.status === "dirty") return DIRTY(result.value);
        if (status.value === "dirty") return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error(
            "Async refinement encountered during synchronous parse operation. Use .parseAsync instead.",
          );
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx,
        });
        if (inner.status === "aborted") return INVALID;
        if (inner.status === "dirty") status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema
          ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
          .then((inner) => {
            if (inner.status === "aborted") return INVALID;
            if (inner.status === "dirty") status.dirty();
            return executeRefinement(inner.value).then(() => {
              return { status: status.value, value: inner.value };
            });
          });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx,
        });
        if (!isValid(base)) return INVALID;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(
            `Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`,
          );
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema
          ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
          .then((base) => {
            if (!isValid(base)) return INVALID;
            return Promise.resolve(effect.transform(base.value, checkCtx)).then(
              (result) => ({
                status: status.value,
                value: result,
              }),
            );
          });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind2.ZodEffects,
    effect,
    ...processCreateParams(params),
  });
};
ZodEffects.createWithPreprocess = (preprocess2, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess2 },
    typeName: ZodFirstPartyTypeKind2.ZodEffects,
    ...processCreateParams(params),
  });
};
var ZodOptional2 = class extends ZodType2 {
  _parse(input) {
    const parsedType7 = this._getType(input);
    if (parsedType7 === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional2.create = (type, params) => {
  return new ZodOptional2({
    innerType: type,
    typeName: ZodFirstPartyTypeKind2.ZodOptional,
    ...processCreateParams(params),
  });
};
var ZodNullable2 = class extends ZodType2 {
  _parse(input) {
    const parsedType7 = this._getType(input);
    if (parsedType7 === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable2.create = (type, params) => {
  return new ZodNullable2({
    innerType: type,
    typeName: ZodFirstPartyTypeKind2.ZodNullable,
    ...processCreateParams(params),
  });
};
var ZodDefault2 = class extends ZodType2 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx,
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault2.create = (type, params) => {
  return new ZodDefault2({
    innerType: type,
    typeName: ZodFirstPartyTypeKind2.ZodDefault,
    defaultValue:
      typeof params.default === "function"
        ? params.default
        : () => params.default,
    ...processCreateParams(params),
  });
};
var ZodCatch2 = class extends ZodType2 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: [],
      },
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx,
      },
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value:
            result2.status === "valid"
              ? result2.value
              : this._def.catchValue({
                  get error() {
                    return new ZodError2(newCtx.common.issues);
                  },
                  input: newCtx.data,
                }),
        };
      });
    } else {
      return {
        status: "valid",
        value:
          result.status === "valid"
            ? result.value
            : this._def.catchValue({
                get error() {
                  return new ZodError2(newCtx.common.issues);
                },
                input: newCtx.data,
              }),
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch2.create = (type, params) => {
  return new ZodCatch2({
    innerType: type,
    typeName: ZodFirstPartyTypeKind2.ZodCatch,
    catchValue:
      typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params),
  });
};
var ZodNaN2 = class extends ZodType2 {
  _parse(input) {
    const parsedType7 = this._getType(input);
    if (parsedType7 !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType,
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN2.create = (params) => {
  return new ZodNaN2({
    typeName: ZodFirstPartyTypeKind2.ZodNaN,
    ...processCreateParams(params),
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType2 {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx,
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class _ZodPipeline extends ZodType2 {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx,
        });
        if (inResult.status === "aborted") return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx,
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx,
      });
      if (inResult.status === "aborted") return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value,
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx,
        });
      }
    }
  }
  static create(a2, b2) {
    return new _ZodPipeline({
      in: a2,
      out: b2,
      typeName: ZodFirstPartyTypeKind2.ZodPipeline,
    });
  }
};
var ZodReadonly2 = class extends ZodType2 {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result)
      ? result.then((data) => freeze(data))
      : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly2.create = (type, params) => {
  return new ZodReadonly2({
    innerType: type,
    typeName: ZodFirstPartyTypeKind2.ZodReadonly,
    ...processCreateParams(params),
  });
};
var late = {
  object: ZodObject2.lazycreate,
};
var ZodFirstPartyTypeKind2;
(function (ZodFirstPartyTypeKind3) {
  ZodFirstPartyTypeKind3["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind3["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind3["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind3["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind3["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind3["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind3["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind3["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind3["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind3["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind3["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind3["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind3["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind3["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind3["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind3["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind3["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind3["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind3["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind3["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind3["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind3["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind3["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind3["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind3["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind3["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind3["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind3["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind3["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind3["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind3["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind3["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind3["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind3["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind3["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind3["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind2 || (ZodFirstPartyTypeKind2 = {}));
var stringType = ZodString2.create;
var numberType = ZodNumber2.create;
var nanType = ZodNaN2.create;
var bigIntType = ZodBigInt2.create;
var booleanType = ZodBoolean2.create;
var dateType = ZodDate2.create;
var symbolType = ZodSymbol2.create;
var undefinedType = ZodUndefined2.create;
var nullType = ZodNull2.create;
var anyType = ZodAny2.create;
var unknownType = ZodUnknown2.create;
var neverType = ZodNever2.create;
var voidType = ZodVoid2.create;
var arrayType = ZodArray2.create;
var objectType = ZodObject2.create;
var strictObjectType = ZodObject2.strictCreate;
var unionType = ZodUnion2.create;
var discriminatedUnionType = ZodDiscriminatedUnion2.create;
var intersectionType = ZodIntersection2.create;
var tupleType = ZodTuple2.create;
var recordType = ZodRecord2.create;
var mapType = ZodMap2.create;
var setType = ZodSet2.create;
var functionType = ZodFunction2.create;
var lazyType = ZodLazy2.create;
var literalType = ZodLiteral2.create;
var enumType = ZodEnum2.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise2.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional2.create;
var nullableType = ZodNullable2.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;

// node_modules/@ai-sdk/provider-utils/dist/index.mjs
function combineHeaders(...headers) {
  return headers.reduce(
    (combinedHeaders, currentHeaders) => ({
      ...combinedHeaders,
      ...(currentHeaders != null ? currentHeaders : {}),
    }),
    {},
  );
}
async function delay(delayInMs, options) {
  if (delayInMs == null) {
    return Promise.resolve();
  }
  const signal = options == null ? void 0 : options.abortSignal;
  return new Promise((resolve2, reject) => {
    if (signal == null ? void 0 : signal.aborted) {
      reject(createAbortError());
      return;
    }
    const timeoutId = setTimeout(() => {
      cleanup();
      resolve2();
    }, delayInMs);
    const cleanup = () => {
      clearTimeout(timeoutId);
      signal == null ? void 0 : signal.removeEventListener("abort", onAbort);
    };
    const onAbort = () => {
      cleanup();
      reject(createAbortError());
    };
    signal == null ? void 0 : signal.addEventListener("abort", onAbort);
  });
}
function createAbortError() {
  return new DOMException("Delay was aborted", "AbortError");
}
function extractResponseHeaders(response) {
  return Object.fromEntries([...response.headers]);
}
function getRuntimeEnvironmentUserAgent(globalThisAny = globalThis) {
  var _a19, _b9, _c;
  if (globalThisAny.window) {
    return `runtime/browser`;
  }
  if ((_a19 = globalThisAny.navigator) == null ? void 0 : _a19.userAgent) {
    return `runtime/${globalThisAny.navigator.userAgent.toLowerCase()}`;
  }
  if (
    (_c = (_b9 = globalThisAny.process) == null ? void 0 : _b9.versions) == null
      ? void 0
      : _c.node
  ) {
    return `runtime/node.js/${globalThisAny.process.version.substring(0)}`;
  }
  if (globalThisAny.EdgeRuntime) {
    return `runtime/vercel-edge`;
  }
  return "runtime/unknown";
}
function removeUndefinedEntries(record2) {
  return Object.fromEntries(
    Object.entries(record2).filter(([_key, value]) => value != null),
  );
}
function withUserAgentSuffix(headers, ...userAgentSuffixParts) {
  const cleanedHeaders = removeUndefinedEntries(headers != null ? headers : {});
  const normalizedHeaders = new Headers(cleanedHeaders);
  const currentUserAgentHeader = normalizedHeaders.get("user-agent") || "";
  normalizedHeaders.set(
    "user-agent",
    [currentUserAgentHeader, ...userAgentSuffixParts].filter(Boolean).join(" "),
  );
  return Object.fromEntries(normalizedHeaders);
}
var createIdGenerator = ({
  prefix,
  size = 16,
  alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator = "-",
} = {}) => {
  const generator = () => {
    const alphabetLength = alphabet.length;
    const chars = new Array(size);
    for (let i2 = 0; i2 < size; i2++) {
      chars[i2] = alphabet[(Math.random() * alphabetLength) | 0];
    }
    return chars.join("");
  };
  if (prefix == null) {
    return generator;
  }
  if (alphabet.includes(separator)) {
    throw new InvalidArgumentError({
      argument: "separator",
      message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`,
    });
  }
  return () => `${prefix}${separator}${generator()}`;
};
var generateId = createIdGenerator();
function getErrorMessage2(error45) {
  if (error45 == null) {
    return "unknown error";
  }
  if (typeof error45 === "string") {
    return error45;
  }
  if (error45 instanceof Error) {
    return error45.message;
  }
  return JSON.stringify(error45);
}
function isAbortError(error45) {
  return (
    (error45 instanceof Error || error45 instanceof DOMException) &&
    (error45.name === "AbortError" ||
      error45.name === "ResponseAborted" || // Next.js
      error45.name === "TimeoutError")
  );
}
var FETCH_FAILED_ERROR_MESSAGES = ["fetch failed", "failed to fetch"];
function handleFetchError({ error: error45, url: url2, requestBodyValues }) {
  if (isAbortError(error45)) {
    return error45;
  }
  if (
    error45 instanceof TypeError &&
    FETCH_FAILED_ERROR_MESSAGES.includes(error45.message.toLowerCase())
  ) {
    const cause = error45.cause;
    if (cause != null) {
      return new APICallError({
        message: `Cannot connect to API: ${cause.message}`,
        cause,
        url: url2,
        requestBodyValues,
        isRetryable: true,
        // retry when network error
      });
    }
  }
  return error45;
}
var VERSION = true ? "3.0.9" : "0.0.0-test";
var getOriginalFetch = () => globalThis.fetch;
var getFromApi = async ({
  url: url2,
  headers = {},
  successfulResponseHandler,
  failedResponseHandler,
  abortSignal,
  fetch: fetch2 = getOriginalFetch(),
}) => {
  try {
    const response = await fetch2(url2, {
      method: "GET",
      headers: withUserAgentSuffix(
        headers,
        `ai-sdk/provider-utils/${VERSION}`,
        getRuntimeEnvironmentUserAgent(),
      ),
      signal: abortSignal,
    });
    const responseHeaders = extractResponseHeaders(response);
    if (!response.ok) {
      let errorInformation;
      try {
        errorInformation = await failedResponseHandler({
          response,
          url: url2,
          requestBodyValues: {},
        });
      } catch (error45) {
        if (isAbortError(error45) || APICallError.isInstance(error45)) {
          throw error45;
        }
        throw new APICallError({
          message: "Failed to process error response",
          cause: error45,
          statusCode: response.status,
          url: url2,
          responseHeaders,
          requestBodyValues: {},
        });
      }
      throw errorInformation.value;
    }
    try {
      return await successfulResponseHandler({
        response,
        url: url2,
        requestBodyValues: {},
      });
    } catch (error45) {
      if (error45 instanceof Error) {
        if (isAbortError(error45) || APICallError.isInstance(error45)) {
          throw error45;
        }
      }
      throw new APICallError({
        message: "Failed to process successful response",
        cause: error45,
        statusCode: response.status,
        url: url2,
        responseHeaders,
        requestBodyValues: {},
      });
    }
  } catch (error45) {
    throw handleFetchError({
      error: error45,
      url: url2,
      requestBodyValues: {},
    });
  }
};
function isUrlSupported({ mediaType, url: url2, supportedUrls }) {
  url2 = url2.toLowerCase();
  mediaType = mediaType.toLowerCase();
  return Object.entries(supportedUrls)
    .map(([key, value]) => {
      const mediaType2 = key.toLowerCase();
      return mediaType2 === "*" || mediaType2 === "*/*"
        ? { mediaTypePrefix: "", regexes: value }
        : { mediaTypePrefix: mediaType2.replace(/\*/, ""), regexes: value };
    })
    .filter(({ mediaTypePrefix }) => mediaType.startsWith(mediaTypePrefix))
    .flatMap(({ regexes }) => regexes)
    .some((pattern) => pattern.test(url2));
}
function loadOptionalSetting({ settingValue, environmentVariableName }) {
  if (typeof settingValue === "string") {
    return settingValue;
  }
  if (settingValue != null || typeof process === "undefined") {
    return void 0;
  }
  settingValue = process.env[environmentVariableName];
  if (settingValue == null || typeof settingValue !== "string") {
    return void 0;
  }
  return settingValue;
}
var suspectProtoRx = /"__proto__"\s*:/;
var suspectConstructorRx = /"constructor"\s*:/;
function _parse2(text2) {
  const obj = JSON.parse(text2);
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  if (
    suspectProtoRx.test(text2) === false &&
    suspectConstructorRx.test(text2) === false
  ) {
    return obj;
  }
  return filter(obj);
}
function filter(obj) {
  let next = [obj];
  while (next.length) {
    const nodes = next;
    next = [];
    for (const node of nodes) {
      if (Object.prototype.hasOwnProperty.call(node, "__proto__")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      if (
        Object.prototype.hasOwnProperty.call(node, "constructor") &&
        Object.prototype.hasOwnProperty.call(node.constructor, "prototype")
      ) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      for (const key in node) {
        const value = node[key];
        if (value && typeof value === "object") {
          next.push(value);
        }
      }
    }
  }
  return obj;
}
function secureJsonParse(text2) {
  const { stackTraceLimit } = Error;
  Error.stackTraceLimit = 0;
  try {
    return _parse2(text2);
  } finally {
    Error.stackTraceLimit = stackTraceLimit;
  }
}
var validatorSymbol = Symbol.for("vercel.ai.validator");
function validator(validate) {
  return { [validatorSymbol]: true, validate };
}
function isValidator(value) {
  return (
    typeof value === "object" &&
    value !== null &&
    validatorSymbol in value &&
    value[validatorSymbol] === true &&
    "validate" in value
  );
}
function asValidator(value) {
  return isValidator(value) ? value : standardSchemaValidator(value);
}
function standardSchemaValidator(standardSchema) {
  return validator(async (value) => {
    const result = await standardSchema["~standard"].validate(value);
    return result.issues == null
      ? { success: true, value: result.value }
      : {
          success: false,
          error: new TypeValidationError({
            value,
            cause: result.issues,
          }),
        };
  });
}
async function validateTypes({ value, schema }) {
  const result = await safeValidateTypes({ value, schema });
  if (!result.success) {
    throw TypeValidationError.wrap({ value, cause: result.error });
  }
  return result.value;
}
async function safeValidateTypes({ value, schema }) {
  const validator2 = asValidator(schema);
  try {
    if (validator2.validate == null) {
      return { success: true, value, rawValue: value };
    }
    const result = await validator2.validate(value);
    if (result.success) {
      return { success: true, value: result.value, rawValue: value };
    }
    return {
      success: false,
      error: TypeValidationError.wrap({ value, cause: result.error }),
      rawValue: value,
    };
  } catch (error45) {
    return {
      success: false,
      error: TypeValidationError.wrap({ value, cause: error45 }),
      rawValue: value,
    };
  }
}
async function parseJSON({ text: text2, schema }) {
  try {
    const value = secureJsonParse(text2);
    if (schema == null) {
      return value;
    }
    return validateTypes({ value, schema });
  } catch (error45) {
    if (
      JSONParseError.isInstance(error45) ||
      TypeValidationError.isInstance(error45)
    ) {
      throw error45;
    }
    throw new JSONParseError({ text: text2, cause: error45 });
  }
}
async function safeParseJSON({ text: text2, schema }) {
  try {
    const value = secureJsonParse(text2);
    if (schema == null) {
      return { success: true, value, rawValue: value };
    }
    return await safeValidateTypes({ value, schema });
  } catch (error45) {
    return {
      success: false,
      error: JSONParseError.isInstance(error45)
        ? error45
        : new JSONParseError({ text: text2, cause: error45 }),
      rawValue: void 0,
    };
  }
}
function parseJsonEventStream({ stream, schema }) {
  return stream
    .pipeThrough(new TextDecoderStream())
    .pipeThrough(new EventSourceParserStream())
    .pipeThrough(
      new TransformStream({
        async transform({ data }, controller) {
          if (data === "[DONE]") {
            return;
          }
          controller.enqueue(await safeParseJSON({ text: data, schema }));
        },
      }),
    );
}
var getOriginalFetch2 = () => globalThis.fetch;
var postJsonToApi = async ({
  url: url2,
  headers,
  body,
  failedResponseHandler,
  successfulResponseHandler,
  abortSignal,
  fetch: fetch2,
}) =>
  postToApi({
    url: url2,
    headers: {
      "Content-Type": "application/json",
      ...headers,
    },
    body: {
      content: JSON.stringify(body),
      values: body,
    },
    failedResponseHandler,
    successfulResponseHandler,
    abortSignal,
    fetch: fetch2,
  });
var postToApi = async ({
  url: url2,
  headers = {},
  body,
  successfulResponseHandler,
  failedResponseHandler,
  abortSignal,
  fetch: fetch2 = getOriginalFetch2(),
}) => {
  try {
    const response = await fetch2(url2, {
      method: "POST",
      headers: withUserAgentSuffix(
        headers,
        `ai-sdk/provider-utils/${VERSION}`,
        getRuntimeEnvironmentUserAgent(),
      ),
      body: body.content,
      signal: abortSignal,
    });
    const responseHeaders = extractResponseHeaders(response);
    if (!response.ok) {
      let errorInformation;
      try {
        errorInformation = await failedResponseHandler({
          response,
          url: url2,
          requestBodyValues: body.values,
        });
      } catch (error45) {
        if (isAbortError(error45) || APICallError.isInstance(error45)) {
          throw error45;
        }
        throw new APICallError({
          message: "Failed to process error response",
          cause: error45,
          statusCode: response.status,
          url: url2,
          responseHeaders,
          requestBodyValues: body.values,
        });
      }
      throw errorInformation.value;
    }
    try {
      return await successfulResponseHandler({
        response,
        url: url2,
        requestBodyValues: body.values,
      });
    } catch (error45) {
      if (error45 instanceof Error) {
        if (isAbortError(error45) || APICallError.isInstance(error45)) {
          throw error45;
        }
      }
      throw new APICallError({
        message: "Failed to process successful response",
        cause: error45,
        statusCode: response.status,
        url: url2,
        responseHeaders,
        requestBodyValues: body.values,
      });
    }
  } catch (error45) {
    throw handleFetchError({
      error: error45,
      url: url2,
      requestBodyValues: body.values,
    });
  }
};
function tool(tool22) {
  return tool22;
}
async function resolve(value) {
  if (typeof value === "function") {
    value = value();
  }
  return Promise.resolve(value);
}
var createJsonErrorResponseHandler =
  ({ errorSchema, errorToMessage, isRetryable }) =>
  async ({ response, url: url2, requestBodyValues }) => {
    const responseBody = await response.text();
    const responseHeaders = extractResponseHeaders(response);
    if (responseBody.trim() === "") {
      return {
        responseHeaders,
        value: new APICallError({
          message: response.statusText,
          url: url2,
          requestBodyValues,
          statusCode: response.status,
          responseHeaders,
          responseBody,
          isRetryable: isRetryable == null ? void 0 : isRetryable(response),
        }),
      };
    }
    try {
      const parsedError = await parseJSON({
        text: responseBody,
        schema: errorSchema,
      });
      return {
        responseHeaders,
        value: new APICallError({
          message: errorToMessage(parsedError),
          url: url2,
          requestBodyValues,
          statusCode: response.status,
          responseHeaders,
          responseBody,
          data: parsedError,
          isRetryable:
            isRetryable == null ? void 0 : isRetryable(response, parsedError),
        }),
      };
    } catch (parseError) {
      return {
        responseHeaders,
        value: new APICallError({
          message: response.statusText,
          url: url2,
          requestBodyValues,
          statusCode: response.status,
          responseHeaders,
          responseBody,
          isRetryable: isRetryable == null ? void 0 : isRetryable(response),
        }),
      };
    }
  };
var createEventSourceResponseHandler =
  (chunkSchema) =>
  async ({ response }) => {
    const responseHeaders = extractResponseHeaders(response);
    if (response.body == null) {
      throw new EmptyResponseBodyError({});
    }
    return {
      responseHeaders,
      value: parseJsonEventStream({
        stream: response.body,
        schema: chunkSchema,
      }),
    };
  };
var createJsonResponseHandler =
  (responseSchema) =>
  async ({ response, url: url2, requestBodyValues }) => {
    const responseBody = await response.text();
    const parsedResult = await safeParseJSON({
      text: responseBody,
      schema: responseSchema,
    });
    const responseHeaders = extractResponseHeaders(response);
    if (!parsedResult.success) {
      throw new APICallError({
        message: "Invalid JSON response",
        cause: parsedResult.error,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        url: url2,
        requestBodyValues,
      });
    }
    return {
      responseHeaders,
      value: parsedResult.value,
      rawValue: parsedResult.rawValue,
    };
  };
var getRelativePath = (pathA, pathB) => {
  let i2 = 0;
  for (; i2 < pathA.length && i2 < pathB.length; i2++) {
    if (pathA[i2] !== pathB[i2]) break;
  }
  return [(pathA.length - i2).toString(), ...pathB.slice(i2)].join("/");
};
var ignoreOverride = Symbol(
  "Let zodToJsonSchema decide on which parser to use",
);
var defaultOptions = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: true,
  rejectedAdditionalProperties: false,
  definitionPath: "definitions",
  strictUnions: false,
  definitions: {},
  errorMessages: false,
  patternStrategy: "escape",
  applyRegexFlags: false,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref",
};
var getDefaultOptions = (options) =>
  typeof options === "string"
    ? {
        ...defaultOptions,
        name: options,
      }
    : {
        ...defaultOptions,
        ...options,
      };
function parseAnyDef() {
  return {};
}
function parseArrayDef(def, refs) {
  var _a19, _b9, _c;
  const res = {
    type: "array",
  };
  if (
    ((_a19 = def.type) == null ? void 0 : _a19._def) &&
    ((_c = (_b9 = def.type) == null ? void 0 : _b9._def) == null
      ? void 0
      : _c.typeName) !== ZodFirstPartyTypeKind2.ZodAny
  ) {
    res.items = parseDef(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"],
    });
  }
  if (def.minLength) {
    res.minItems = def.minLength.value;
  }
  if (def.maxLength) {
    res.maxItems = def.maxLength.value;
  }
  if (def.exactLength) {
    res.minItems = def.exactLength.value;
    res.maxItems = def.exactLength.value;
  }
  return res;
}
function parseBigintDef(def) {
  const res = {
    type: "integer",
    format: "int64",
  };
  if (!def.checks) return res;
  for (const check2 of def.checks) {
    switch (check2.kind) {
      case "min":
        if (check2.inclusive) {
          res.minimum = check2.value;
        } else {
          res.exclusiveMinimum = check2.value;
        }
        break;
      case "max":
        if (check2.inclusive) {
          res.maximum = check2.value;
        } else {
          res.exclusiveMaximum = check2.value;
        }
        break;
      case "multipleOf":
        res.multipleOf = check2.value;
        break;
    }
  }
  return res;
}
function parseBooleanDef() {
  return { type: "boolean" };
}
function parseBrandedDef(_def, refs) {
  return parseDef(_def.type._def, refs);
}
var parseCatchDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
};
function parseDateDef(def, refs, overrideDateStrategy) {
  const strategy =
    overrideDateStrategy != null ? overrideDateStrategy : refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i2) => parseDateDef(def, refs, item)),
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time",
      };
    case "format:date":
      return {
        type: "string",
        format: "date",
      };
    case "integer":
      return integerDateParser(def);
  }
}
var integerDateParser = (def) => {
  const res = {
    type: "integer",
    format: "unix-time",
  };
  for (const check2 of def.checks) {
    switch (check2.kind) {
      case "min":
        res.minimum = check2.value;
        break;
      case "max":
        res.maximum = check2.value;
        break;
    }
  }
  return res;
};
function parseDefaultDef(_def, refs) {
  return {
    ...parseDef(_def.innerType._def, refs),
    default: _def.defaultValue(),
  };
}
function parseEffectsDef(_def, refs) {
  return refs.effectStrategy === "input"
    ? parseDef(_def.schema._def, refs)
    : parseAnyDef();
}
function parseEnumDef(def) {
  return {
    type: "string",
    enum: Array.from(def.values),
  };
}
var isJsonSchema7AllOfType = (type) => {
  if ("type" in type && type.type === "string") return false;
  return "allOf" in type;
};
function parseIntersectionDef(def, refs) {
  const allOf = [
    parseDef(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"],
    }),
    parseDef(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"],
    }),
  ].filter((x) => !!x);
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType(schema)) {
      mergedAllOf.push(...schema.allOf);
    } else {
      let nestedSchema = schema;
      if (
        "additionalProperties" in schema &&
        schema.additionalProperties === false
      ) {
        const { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? { allOf: mergedAllOf } : void 0;
}
function parseLiteralDef(def) {
  const parsedType7 = typeof def.value;
  if (
    parsedType7 !== "bigint" &&
    parsedType7 !== "number" &&
    parsedType7 !== "boolean" &&
    parsedType7 !== "string"
  ) {
    return {
      type: Array.isArray(def.value) ? "array" : "object",
    };
  }
  return {
    type: parsedType7 === "bigint" ? "integer" : parsedType7,
    const: def.value,
  };
}
var emojiRegex2 = void 0;
var zodPatterns = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email:
    /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: () => {
    if (emojiRegex2 === void 0) {
      emojiRegex2 = RegExp(
        "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
        "u",
      );
    }
    return emojiRegex2;
  },
  /**
   * Unused
   */
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  /**
   * Unused
   */
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr:
    /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  /**
   * Unused
   */
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr:
    /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url:
    /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/,
};
function parseStringDef(def, refs) {
  const res = {
    type: "string",
  };
  if (def.checks) {
    for (const check2 of def.checks) {
      switch (check2.kind) {
        case "min":
          res.minLength =
            typeof res.minLength === "number"
              ? Math.max(res.minLength, check2.value)
              : check2.value;
          break;
        case "max":
          res.maxLength =
            typeof res.maxLength === "number"
              ? Math.min(res.maxLength, check2.value)
              : check2.value;
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat(res, "email", check2.message, refs);
              break;
            case "format:idn-email":
              addFormat(res, "idn-email", check2.message, refs);
              break;
            case "pattern:zod":
              addPattern(res, zodPatterns.email, check2.message, refs);
              break;
          }
          break;
        case "url":
          addFormat(res, "uri", check2.message, refs);
          break;
        case "uuid":
          addFormat(res, "uuid", check2.message, refs);
          break;
        case "regex":
          addPattern(res, check2.regex, check2.message, refs);
          break;
        case "cuid":
          addPattern(res, zodPatterns.cuid, check2.message, refs);
          break;
        case "cuid2":
          addPattern(res, zodPatterns.cuid2, check2.message, refs);
          break;
        case "startsWith":
          addPattern(
            res,
            RegExp(`^${escapeLiteralCheckValue(check2.value, refs)}`),
            check2.message,
            refs,
          );
          break;
        case "endsWith":
          addPattern(
            res,
            RegExp(`${escapeLiteralCheckValue(check2.value, refs)}$`),
            check2.message,
            refs,
          );
          break;
        case "datetime":
          addFormat(res, "date-time", check2.message, refs);
          break;
        case "date":
          addFormat(res, "date", check2.message, refs);
          break;
        case "time":
          addFormat(res, "time", check2.message, refs);
          break;
        case "duration":
          addFormat(res, "duration", check2.message, refs);
          break;
        case "length":
          res.minLength =
            typeof res.minLength === "number"
              ? Math.max(res.minLength, check2.value)
              : check2.value;
          res.maxLength =
            typeof res.maxLength === "number"
              ? Math.min(res.maxLength, check2.value)
              : check2.value;
          break;
        case "includes": {
          addPattern(
            res,
            RegExp(escapeLiteralCheckValue(check2.value, refs)),
            check2.message,
            refs,
          );
          break;
        }
        case "ip": {
          if (check2.version !== "v6") {
            addFormat(res, "ipv4", check2.message, refs);
          }
          if (check2.version !== "v4") {
            addFormat(res, "ipv6", check2.message, refs);
          }
          break;
        }
        case "base64url":
          addPattern(res, zodPatterns.base64url, check2.message, refs);
          break;
        case "jwt":
          addPattern(res, zodPatterns.jwt, check2.message, refs);
          break;
        case "cidr": {
          if (check2.version !== "v6") {
            addPattern(res, zodPatterns.ipv4Cidr, check2.message, refs);
          }
          if (check2.version !== "v4") {
            addPattern(res, zodPatterns.ipv6Cidr, check2.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern(res, zodPatterns.emoji(), check2.message, refs);
          break;
        case "ulid": {
          addPattern(res, zodPatterns.ulid, check2.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat(res, "binary", check2.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              res.contentEncoding = "base64";
              break;
            }
            case "pattern:zod": {
              addPattern(res, zodPatterns.base64, check2.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern(res, zodPatterns.nanoid, check2.message, refs);
        }
        case "toLowerCase":
        case "toUpperCase":
        case "trim":
          break;
        default:
          /* @__PURE__ */ ((_2) => {})(check2);
      }
    }
  }
  return res;
}
function escapeLiteralCheckValue(literal3, refs) {
  return refs.patternStrategy === "escape"
    ? escapeNonAlphaNumeric(literal3)
    : literal3;
}
var ALPHA_NUMERIC = new Set(
  "ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789",
);
function escapeNonAlphaNumeric(source) {
  let result = "";
  for (let i2 = 0; i2 < source.length; i2++) {
    if (!ALPHA_NUMERIC.has(source[i2])) {
      result += "\\";
    }
    result += source[i2];
  }
  return result;
}
function addFormat(schema, value, message, refs) {
  var _a19;
  if (
    schema.format ||
    ((_a19 = schema.anyOf) == null ? void 0 : _a19.some((x) => x.format))
  ) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format,
      });
      delete schema.format;
    }
    schema.anyOf.push({
      format: value,
      ...(message &&
        refs.errorMessages && { errorMessage: { format: message } }),
    });
  } else {
    schema.format = value;
  }
}
function addPattern(schema, regex, message, refs) {
  var _a19;
  if (
    schema.pattern ||
    ((_a19 = schema.allOf) == null ? void 0 : _a19.some((x) => x.pattern))
  ) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern,
      });
      delete schema.pattern;
    }
    schema.allOf.push({
      pattern: stringifyRegExpWithFlags(regex, refs),
      ...(message &&
        refs.errorMessages && { errorMessage: { pattern: message } }),
    });
  } else {
    schema.pattern = stringifyRegExpWithFlags(regex, refs);
  }
}
function stringifyRegExpWithFlags(regex, refs) {
  var _a19;
  if (!refs.applyRegexFlags || !regex.flags) {
    return regex.source;
  }
  const flags = {
    i: regex.flags.includes("i"),
    // Case-insensitive
    m: regex.flags.includes("m"),
    // `^` and `$` matches adjacent to newline characters
    s: regex.flags.includes("s"),
    // `.` matches newlines
  };
  const source = flags.i ? regex.source.toLowerCase() : regex.source;
  let pattern = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i2 = 0; i2 < source.length; i2++) {
    if (isEscaped) {
      pattern += source[i2];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i2].match(/[a-z]/)) {
          if (inCharRange) {
            pattern += source[i2];
            pattern += `${source[i2 - 2]}-${source[i2]}`.toUpperCase();
            inCharRange = false;
          } else if (
            source[i2 + 1] === "-" &&
            ((_a19 = source[i2 + 2]) == null ? void 0 : _a19.match(/[a-z]/))
          ) {
            pattern += source[i2];
            inCharRange = true;
          } else {
            pattern += `${source[i2]}${source[i2].toUpperCase()}`;
          }
          continue;
        }
      } else if (source[i2].match(/[a-z]/)) {
        pattern += `[${source[i2]}${source[i2].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i2] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i2] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i2] === ".") {
      pattern += inCharGroup
        ? `${source[i2]}\r
`
        : `[${source[i2]}\r
]`;
      continue;
    }
    pattern += source[i2];
    if (source[i2] === "\\") {
      isEscaped = true;
    } else if (inCharGroup && source[i2] === "]") {
      inCharGroup = false;
    } else if (!inCharGroup && source[i2] === "[") {
      inCharGroup = true;
    }
  }
  try {
    new RegExp(pattern);
  } catch (e2) {
    console.warn(
      `Could not convert regex pattern at ${refs.currentPath.join(
        "/",
      )} to a flag-independent form! Falling back to the flag-ignorant source`,
    );
    return regex.source;
  }
  return pattern;
}
function parseRecordDef(def, refs) {
  var _a19, _b9, _c, _d, _e, _f;
  const schema = {
    type: "object",
    additionalProperties:
      (_a19 = parseDef(def.valueType._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalProperties"],
      })) != null
        ? _a19
        : refs.allowedAdditionalProperties,
  };
  if (
    ((_b9 = def.keyType) == null ? void 0 : _b9._def.typeName) ===
      ZodFirstPartyTypeKind2.ZodString &&
    ((_c = def.keyType._def.checks) == null ? void 0 : _c.length)
  ) {
    const { type, ...keyType } = parseStringDef(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType,
    };
  } else if (
    ((_d = def.keyType) == null ? void 0 : _d._def.typeName) ===
    ZodFirstPartyTypeKind2.ZodEnum
  ) {
    return {
      ...schema,
      propertyNames: {
        enum: def.keyType._def.values,
      },
    };
  } else if (
    ((_e = def.keyType) == null ? void 0 : _e._def.typeName) ===
      ZodFirstPartyTypeKind2.ZodBranded &&
    def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind2.ZodString &&
    ((_f = def.keyType._def.type._def.checks) == null ? void 0 : _f.length)
  ) {
    const { type, ...keyType } = parseBrandedDef(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType,
    };
  }
  return schema;
}
function parseMapDef(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef(def, refs);
  }
  const keys =
    parseDef(def.keyType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items", "items", "0"],
    }) || parseAnyDef();
  const values =
    parseDef(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items", "items", "1"],
    }) || parseAnyDef();
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2,
    },
  };
}
function parseNativeEnumDef(def) {
  const object4 = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object4[object4[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object4[key]);
  const parsedTypes = Array.from(
    new Set(actualValues.map((values) => typeof values)),
  );
  return {
    type:
      parsedTypes.length === 1
        ? parsedTypes[0] === "string"
          ? "string"
          : "number"
        : ["string", "number"],
    enum: actualValues,
  };
}
function parseNeverDef() {
  return { not: parseAnyDef() };
}
function parseNullDef() {
  return {
    type: "null",
  };
}
var primitiveMappings = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null",
};
function parseUnionDef(def, refs) {
  const options =
    def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (
    options.every(
      (x) =>
        x._def.typeName in primitiveMappings &&
        (!x._def.checks || !x._def.checks.length),
    )
  ) {
    const types = options.reduce((types2, x) => {
      const type = primitiveMappings[x._def.typeName];
      return type && !types2.includes(type) ? [...types2, type] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0],
    };
  } else if (
    options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)
  ) {
    const types = options.reduce((acc, x) => {
      const type = typeof x._def.value;
      switch (type) {
        case "string":
        case "number":
        case "boolean":
          return [...acc, type];
        case "bigint":
          return [...acc, "integer"];
        case "object":
          if (x._def.value === null) return [...acc, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return acc;
      }
    }, []);
    if (types.length === options.length) {
      const uniqueTypes = types.filter((x, i2, a2) => a2.indexOf(x) === i2);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce((acc, x) => {
          return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
        }, []),
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce(
        (acc, x) => [
          ...acc,
          ...x._def.values.filter((x2) => !acc.includes(x2)),
        ],
        [],
      ),
    };
  }
  return asAnyOf(def, refs);
}
var asAnyOf = (def, refs) => {
  const anyOf = (
    def.options instanceof Map ? Array.from(def.options.values()) : def.options
  )
    .map((x, i2) =>
      parseDef(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "anyOf", `${i2}`],
      }),
    )
    .filter(
      (x) =>
        !!x &&
        (!refs.strictUnions ||
          (typeof x === "object" && Object.keys(x).length > 0)),
    );
  return anyOf.length ? { anyOf } : void 0;
};
function parseNullableDef(def, refs) {
  if (
    ["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(
      def.innerType._def.typeName,
    ) &&
    (!def.innerType._def.checks || !def.innerType._def.checks.length)
  ) {
    return {
      type: [primitiveMappings[def.innerType._def.typeName], "null"],
    };
  }
  const base = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"],
  });
  return base && { anyOf: [base, { type: "null" }] };
}
function parseNumberDef(def) {
  const res = {
    type: "number",
  };
  if (!def.checks) return res;
  for (const check2 of def.checks) {
    switch (check2.kind) {
      case "int":
        res.type = "integer";
        break;
      case "min":
        if (check2.inclusive) {
          res.minimum = check2.value;
        } else {
          res.exclusiveMinimum = check2.value;
        }
        break;
      case "max":
        if (check2.inclusive) {
          res.maximum = check2.value;
        } else {
          res.exclusiveMaximum = check2.value;
        }
        break;
      case "multipleOf":
        res.multipleOf = check2.value;
        break;
    }
  }
  return res;
}
function parseObjectDef(def, refs) {
  const result = {
    type: "object",
    properties: {},
  };
  const required3 = [];
  const shape = def.shape();
  for (const propName in shape) {
    let propDef = shape[propName];
    if (propDef === void 0 || propDef._def === void 0) {
      continue;
    }
    const propOptional = safeIsOptional(propDef);
    const parsedDef = parseDef(propDef._def, {
      ...refs,
      currentPath: [...refs.currentPath, "properties", propName],
      propertyPath: [...refs.currentPath, "properties", propName],
    });
    if (parsedDef === void 0) {
      continue;
    }
    result.properties[propName] = parsedDef;
    if (!propOptional) {
      required3.push(propName);
    }
  }
  if (required3.length) {
    result.required = required3;
  }
  const additionalProperties = decideAdditionalProperties(def, refs);
  if (additionalProperties !== void 0) {
    result.additionalProperties = additionalProperties;
  }
  return result;
}
function decideAdditionalProperties(def, refs) {
  if (def.catchall._def.typeName !== "ZodNever") {
    return parseDef(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"],
    });
  }
  switch (def.unknownKeys) {
    case "passthrough":
      return refs.allowedAdditionalProperties;
    case "strict":
      return refs.rejectedAdditionalProperties;
    case "strip":
      return refs.removeAdditionalStrategy === "strict"
        ? refs.allowedAdditionalProperties
        : refs.rejectedAdditionalProperties;
  }
}
function safeIsOptional(schema) {
  try {
    return schema.isOptional();
  } catch (e2) {
    return true;
  }
}
var parseOptionalDef = (def, refs) => {
  var _a19;
  if (
    refs.currentPath.toString() ===
    ((_a19 = refs.propertyPath) == null ? void 0 : _a19.toString())
  ) {
    return parseDef(def.innerType._def, refs);
  }
  const innerSchema = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "1"],
  });
  return innerSchema
    ? { anyOf: [{ not: parseAnyDef() }, innerSchema] }
    : parseAnyDef();
};
var parsePipelineDef = (def, refs) => {
  if (refs.pipeStrategy === "input") {
    return parseDef(def.in._def, refs);
  } else if (refs.pipeStrategy === "output") {
    return parseDef(def.out._def, refs);
  }
  const a2 = parseDef(def.in._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", "0"],
  });
  const b2 = parseDef(def.out._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", a2 ? "1" : "0"],
  });
  return {
    allOf: [a2, b2].filter((x) => x !== void 0),
  };
};
function parsePromiseDef(def, refs) {
  return parseDef(def.type._def, refs);
}
function parseSetDef(def, refs) {
  const items = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"],
  });
  const schema = {
    type: "array",
    uniqueItems: true,
    items,
  };
  if (def.minSize) {
    schema.minItems = def.minSize.value;
  }
  if (def.maxSize) {
    schema.maxItems = def.maxSize.value;
  }
  return schema;
}
function parseTupleDef(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items
        .map((x, i2) =>
          parseDef(x._def, {
            ...refs,
            currentPath: [...refs.currentPath, "items", `${i2}`],
          }),
        )
        .reduce((acc, x) => (x === void 0 ? acc : [...acc, x]), []),
      additionalItems: parseDef(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"],
      }),
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items
        .map((x, i2) =>
          parseDef(x._def, {
            ...refs,
            currentPath: [...refs.currentPath, "items", `${i2}`],
          }),
        )
        .reduce((acc, x) => (x === void 0 ? acc : [...acc, x]), []),
    };
  }
}
function parseUndefinedDef() {
  return {
    not: parseAnyDef(),
  };
}
function parseUnknownDef() {
  return parseAnyDef();
}
var parseReadonlyDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
};
var selectParser = (def, typeName, refs) => {
  switch (typeName) {
    case ZodFirstPartyTypeKind2.ZodString:
      return parseStringDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodNumber:
      return parseNumberDef(def);
    case ZodFirstPartyTypeKind2.ZodObject:
      return parseObjectDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodBigInt:
      return parseBigintDef(def);
    case ZodFirstPartyTypeKind2.ZodBoolean:
      return parseBooleanDef();
    case ZodFirstPartyTypeKind2.ZodDate:
      return parseDateDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodUndefined:
      return parseUndefinedDef();
    case ZodFirstPartyTypeKind2.ZodNull:
      return parseNullDef();
    case ZodFirstPartyTypeKind2.ZodArray:
      return parseArrayDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodUnion:
    case ZodFirstPartyTypeKind2.ZodDiscriminatedUnion:
      return parseUnionDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodIntersection:
      return parseIntersectionDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodTuple:
      return parseTupleDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodRecord:
      return parseRecordDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodLiteral:
      return parseLiteralDef(def);
    case ZodFirstPartyTypeKind2.ZodEnum:
      return parseEnumDef(def);
    case ZodFirstPartyTypeKind2.ZodNativeEnum:
      return parseNativeEnumDef(def);
    case ZodFirstPartyTypeKind2.ZodNullable:
      return parseNullableDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodOptional:
      return parseOptionalDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodMap:
      return parseMapDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodSet:
      return parseSetDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodLazy:
      return () => def.getter()._def;
    case ZodFirstPartyTypeKind2.ZodPromise:
      return parsePromiseDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodNaN:
    case ZodFirstPartyTypeKind2.ZodNever:
      return parseNeverDef();
    case ZodFirstPartyTypeKind2.ZodEffects:
      return parseEffectsDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodAny:
      return parseAnyDef();
    case ZodFirstPartyTypeKind2.ZodUnknown:
      return parseUnknownDef();
    case ZodFirstPartyTypeKind2.ZodDefault:
      return parseDefaultDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodBranded:
      return parseBrandedDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodReadonly:
      return parseReadonlyDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodCatch:
      return parseCatchDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodPipeline:
      return parsePipelineDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodFunction:
    case ZodFirstPartyTypeKind2.ZodVoid:
    case ZodFirstPartyTypeKind2.ZodSymbol:
      return void 0;
    default:
      return /* @__PURE__ */ ((_2) => void 0)(typeName);
  }
};
function parseDef(def, refs, forceResolution = false) {
  var _a19;
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult =
      (_a19 = refs.override) == null
        ? void 0
        : _a19.call(refs, def, refs, seenItem, forceResolution);
    if (overrideResult !== ignoreOverride) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref(seenItem, refs);
    if (seenSchema !== void 0) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);
  const jsonSchema2 =
    typeof jsonSchemaOrGetter === "function"
      ? parseDef(jsonSchemaOrGetter(), refs)
      : jsonSchemaOrGetter;
  if (jsonSchema2) {
    addMeta(def, refs, jsonSchema2);
  }
  if (refs.postProcess) {
    const postProcessResult = refs.postProcess(jsonSchema2, def, refs);
    newItem.jsonSchema = jsonSchema2;
    return postProcessResult;
  }
  newItem.jsonSchema = jsonSchema2;
  return jsonSchema2;
}
var get$ref = (item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "relative":
      return { $ref: getRelativePath(refs.currentPath, item.path) };
    case "none":
    case "seen": {
      if (
        item.path.length < refs.currentPath.length &&
        item.path.every((value, index) => refs.currentPath[index] === value)
      ) {
        console.warn(
          `Recursive reference detected at ${refs.currentPath.join(
            "/",
          )}! Defaulting to any`,
        );
        return parseAnyDef();
      }
      return refs.$refStrategy === "seen" ? parseAnyDef() : void 0;
    }
  }
};
var addMeta = (def, refs, jsonSchema2) => {
  if (def.description) {
    jsonSchema2.description = def.description;
  }
  return jsonSchema2;
};
var getRefs = (options) => {
  const _options = getDefaultOptions(options);
  const currentPath =
    _options.name !== void 0
      ? [..._options.basePath, _options.definitionPath, _options.name]
      : _options.basePath;
  return {
    ..._options,
    currentPath,
    propertyPath: void 0,
    seen: new Map(
      Object.entries(_options.definitions).map(([name18, def]) => [
        def._def,
        {
          def: def._def,
          path: [..._options.basePath, _options.definitionPath, name18],
          // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
          jsonSchema: void 0,
        },
      ]),
    ),
  };
};
var zodToJsonSchema = (schema, options) => {
  var _a19;
  const refs = getRefs(options);
  let definitions =
    typeof options === "object" && options.definitions
      ? Object.entries(options.definitions).reduce((acc, [name25, schema2]) => {
          var _a25;
          return {
            ...acc,
            [name25]:
              (_a25 = parseDef(
                schema2._def,
                {
                  ...refs,
                  currentPath: [...refs.basePath, refs.definitionPath, name25],
                },
                true,
              )) != null
                ? _a25
                : parseAnyDef(),
          };
        }, {})
      : void 0;
  const name18 =
    typeof options === "string"
      ? options
      : (options == null ? void 0 : options.nameStrategy) === "title"
        ? void 0
        : options == null
          ? void 0
          : options.name;
  const main =
    (_a19 = parseDef(
      schema._def,
      name18 === void 0
        ? refs
        : {
            ...refs,
            currentPath: [...refs.basePath, refs.definitionPath, name18],
          },
      false,
    )) != null
      ? _a19
      : parseAnyDef();
  const title =
    typeof options === "object" &&
    options.name !== void 0 &&
    options.nameStrategy === "title"
      ? options.name
      : void 0;
  if (title !== void 0) {
    main.title = title;
  }
  const combined =
    name18 === void 0
      ? definitions
        ? {
            ...main,
            [refs.definitionPath]: definitions,
          }
        : main
      : {
          $ref: [
            ...(refs.$refStrategy === "relative" ? [] : refs.basePath),
            refs.definitionPath,
            name18,
          ].join("/"),
          [refs.definitionPath]: {
            ...definitions,
            [name18]: main,
          },
        };
  combined.$schema = "http://json-schema.org/draft-07/schema#";
  return combined;
};
var zod_to_json_schema_default = zodToJsonSchema;
function zod3Schema(zodSchema2, options) {
  var _a19;
  const useReferences =
    (_a19 = options == null ? void 0 : options.useReferences) != null
      ? _a19
      : false;
  return jsonSchema(
    zod_to_json_schema_default(zodSchema2, {
      $refStrategy: useReferences ? "root" : "none",
    }),
    {
      validate: async (value) => {
        const result = await zodSchema2.safeParseAsync(value);
        return result.success
          ? { success: true, value: result.data }
          : { success: false, error: result.error };
      },
    },
  );
}
function zod4Schema(zodSchema2, options) {
  var _a19;
  const useReferences =
    (_a19 = options == null ? void 0 : options.useReferences) != null
      ? _a19
      : false;
  const z4JSONSchema = toJSONSchema(zodSchema2, {
    target: "draft-7",
    io: "output",
    reused: useReferences ? "ref" : "inline",
  });
  return jsonSchema(z4JSONSchema, {
    validate: async (value) => {
      const result = await safeParseAsync2(zodSchema2, value);
      return result.success
        ? { success: true, value: result.data }
        : { success: false, error: result.error };
    },
  });
}
function isZod4Schema(zodSchema2) {
  return "_zod" in zodSchema2;
}
function zodSchema(zodSchema2, options) {
  if (isZod4Schema(zodSchema2)) {
    return zod4Schema(zodSchema2, options);
  } else {
    return zod3Schema(zodSchema2, options);
  }
}
var schemaSymbol = Symbol.for("vercel.ai.schema");
function jsonSchema(jsonSchema2, { validate } = {}) {
  return {
    [schemaSymbol]: true,
    _type: void 0,
    // should never be used directly
    [validatorSymbol]: true,
    jsonSchema: jsonSchema2,
    validate,
  };
}
function isSchema(value) {
  return (
    typeof value === "object" &&
    value !== null &&
    schemaSymbol in value &&
    value[schemaSymbol] === true &&
    "jsonSchema" in value &&
    "validate" in value
  );
}
function asSchema(schema) {
  return schema == null
    ? jsonSchema({
        properties: {},
        additionalProperties: false,
      })
    : isSchema(schema)
      ? schema
      : zodSchema(schema);
}
var { btoa: btoa2, atob: atob2 } = globalThis;
function convertBase64ToUint8Array(base64String) {
  const base64Url = base64String.replace(/-/g, "+").replace(/_/g, "/");
  const latin1string = atob2(base64Url);
  return Uint8Array.from(latin1string, (byte) => byte.codePointAt(0));
}
function convertUint8ArrayToBase64(array3) {
  let latin1string = "";
  for (let i2 = 0; i2 < array3.length; i2++) {
    latin1string += String.fromCodePoint(array3[i2]);
  }
  return btoa2(latin1string);
}
function withoutTrailingSlash(url2) {
  return url2 == null ? void 0 : url2.replace(/\/$/, "");
}
function isAsyncIterable(obj) {
  return obj != null && typeof obj[Symbol.asyncIterator] === "function";
}
async function* executeTool({ execute, input, options }) {
  const result = execute(input, options);
  if (isAsyncIterable(result)) {
    let lastOutput;
    for await (const output of result) {
      lastOutput = output;
      yield { type: "preliminary", output };
    }
    yield { type: "final", output: lastOutput };
  } else {
    yield { type: "final", output: await result };
  }
}

// node_modules/@ai-sdk/gateway/dist/index.mjs
var marker15 = "vercel.ai.gateway.error";
var symbol16 = Symbol.for(marker15);
var _a15;
var _b;
var GatewayError = class _GatewayError extends ((_b = Error),
(_a15 = symbol16),
_b) {
  constructor({ message, statusCode = 500, cause }) {
    super(message);
    this[_a15] = true;
    this.statusCode = statusCode;
    this.cause = cause;
  }
  /**
   * Checks if the given error is a Gateway Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is a Gateway Error, false otherwise.
   */
  static isInstance(error45) {
    return _GatewayError.hasMarker(error45);
  }
  static hasMarker(error45) {
    return (
      typeof error45 === "object" &&
      error45 !== null &&
      symbol16 in error45 &&
      error45[symbol16] === true
    );
  }
};
var name14 = "GatewayAuthenticationError";
var marker22 = `vercel.ai.gateway.error.${name14}`;
var symbol22 = Symbol.for(marker22);
var _a22;
var _b2;
var GatewayAuthenticationError = class _GatewayAuthenticationError extends ((_b2 =
  GatewayError),
(_a22 = symbol22),
_b2) {
  constructor({
    message = "Authentication failed",
    statusCode = 401,
    cause,
  } = {}) {
    super({ message, statusCode, cause });
    this[_a22] = true;
    this.name = name14;
    this.type = "authentication_error";
  }
  static isInstance(error45) {
    return GatewayError.hasMarker(error45) && symbol22 in error45;
  }
  /**
   * Creates a contextual error message when authentication fails
   */
  static createContextualError({
    apiKeyProvided,
    oidcTokenProvided,
    message = "Authentication failed",
    statusCode = 401,
    cause,
  }) {
    let contextualMessage;
    if (apiKeyProvided) {
      contextualMessage = `AI Gateway authentication failed: Invalid API key provided.

The token is expected to be provided via the 'apiKey' option or 'AI_GATEWAY_API_KEY' environment variable.`;
    } else if (oidcTokenProvided) {
      contextualMessage = `AI Gateway authentication failed: Invalid OIDC token provided.

The token is expected to be provided via the 'VERCEL_OIDC_TOKEN' environment variable. It expires every 12 hours.
- make sure your Vercel project settings have OIDC enabled
- if running locally with 'vercel dev', the token is automatically obtained and refreshed
- if running locally with your own dev server, run 'vercel env pull' to fetch the token
- in production/preview, the token is automatically obtained and refreshed

Alternative: Provide an API key via 'apiKey' option or 'AI_GATEWAY_API_KEY' environment variable.`;
    } else {
      contextualMessage = `AI Gateway authentication failed: No authentication provided.

Provide either an API key or OIDC token.

API key instructions:

The token is expected to be provided via the 'apiKey' option or 'AI_GATEWAY_API_KEY' environment variable.

OIDC token instructions:

The token is expected to be provided via the 'VERCEL_OIDC_TOKEN' environment variable. It expires every 12 hours.
- make sure your Vercel project settings have OIDC enabled
- if running locally with 'vercel dev', the token is automatically obtained and refreshed
- if running locally with your own dev server, run 'vercel env pull' to fetch the token
- in production/preview, the token is automatically obtained and refreshed`;
    }
    return new _GatewayAuthenticationError({
      message: contextualMessage,
      statusCode,
      cause,
    });
  }
};
var name22 = "GatewayInvalidRequestError";
var marker32 = `vercel.ai.gateway.error.${name22}`;
var symbol32 = Symbol.for(marker32);
var _a32;
var _b3;
var GatewayInvalidRequestError = class extends ((_b3 = GatewayError),
(_a32 = symbol32),
_b3) {
  constructor({ message = "Invalid request", statusCode = 400, cause } = {}) {
    super({ message, statusCode, cause });
    this[_a32] = true;
    this.name = name22;
    this.type = "invalid_request_error";
  }
  static isInstance(error45) {
    return GatewayError.hasMarker(error45) && symbol32 in error45;
  }
};
var name32 = "GatewayRateLimitError";
var marker42 = `vercel.ai.gateway.error.${name32}`;
var symbol42 = Symbol.for(marker42);
var _a42;
var _b4;
var GatewayRateLimitError = class extends ((_b4 = GatewayError),
(_a42 = symbol42),
_b4) {
  constructor({
    message = "Rate limit exceeded",
    statusCode = 429,
    cause,
  } = {}) {
    super({ message, statusCode, cause });
    this[_a42] = true;
    this.name = name32;
    this.type = "rate_limit_exceeded";
  }
  static isInstance(error45) {
    return GatewayError.hasMarker(error45) && symbol42 in error45;
  }
};
var name42 = "GatewayModelNotFoundError";
var marker52 = `vercel.ai.gateway.error.${name42}`;
var symbol52 = Symbol.for(marker52);
var modelNotFoundParamSchema = external_exports.object({
  modelId: external_exports.string(),
});
var _a52;
var _b5;
var GatewayModelNotFoundError = class extends ((_b5 = GatewayError),
(_a52 = symbol52),
_b5) {
  constructor({
    message = "Model not found",
    statusCode = 404,
    modelId,
    cause,
  } = {}) {
    super({ message, statusCode, cause });
    this[_a52] = true;
    this.name = name42;
    this.type = "model_not_found";
    this.modelId = modelId;
  }
  static isInstance(error45) {
    return GatewayError.hasMarker(error45) && symbol52 in error45;
  }
};
var name52 = "GatewayInternalServerError";
var marker62 = `vercel.ai.gateway.error.${name52}`;
var symbol62 = Symbol.for(marker62);
var _a62;
var _b6;
var GatewayInternalServerError = class extends ((_b6 = GatewayError),
(_a62 = symbol62),
_b6) {
  constructor({
    message = "Internal server error",
    statusCode = 500,
    cause,
  } = {}) {
    super({ message, statusCode, cause });
    this[_a62] = true;
    this.name = name52;
    this.type = "internal_server_error";
  }
  static isInstance(error45) {
    return GatewayError.hasMarker(error45) && symbol62 in error45;
  }
};
var name62 = "GatewayResponseError";
var marker72 = `vercel.ai.gateway.error.${name62}`;
var symbol72 = Symbol.for(marker72);
var _a72;
var _b7;
var GatewayResponseError = class extends ((_b7 = GatewayError),
(_a72 = symbol72),
_b7) {
  constructor({
    message = "Invalid response from Gateway",
    statusCode = 502,
    response,
    validationError,
    cause,
  } = {}) {
    super({ message, statusCode, cause });
    this[_a72] = true;
    this.name = name62;
    this.type = "response_error";
    this.response = response;
    this.validationError = validationError;
  }
  static isInstance(error45) {
    return GatewayError.hasMarker(error45) && symbol72 in error45;
  }
};
function createGatewayErrorFromResponse({
  response,
  statusCode,
  defaultMessage = "Gateway request failed",
  cause,
  authMethod,
}) {
  const parseResult = gatewayErrorResponseSchema.safeParse(response);
  if (!parseResult.success) {
    return new GatewayResponseError({
      message: `Invalid error response format: ${defaultMessage}`,
      statusCode,
      response,
      validationError: parseResult.error,
      cause,
    });
  }
  const validatedResponse = parseResult.data;
  const errorType = validatedResponse.error.type;
  const message = validatedResponse.error.message;
  switch (errorType) {
    case "authentication_error":
      return GatewayAuthenticationError.createContextualError({
        apiKeyProvided: authMethod === "api-key",
        oidcTokenProvided: authMethod === "oidc",
        statusCode,
        cause,
      });
    case "invalid_request_error":
      return new GatewayInvalidRequestError({ message, statusCode, cause });
    case "rate_limit_exceeded":
      return new GatewayRateLimitError({ message, statusCode, cause });
    case "model_not_found": {
      const modelResult = modelNotFoundParamSchema.safeParse(
        validatedResponse.error.param,
      );
      return new GatewayModelNotFoundError({
        message,
        statusCode,
        modelId: modelResult.success ? modelResult.data.modelId : void 0,
        cause,
      });
    }
    case "internal_server_error":
      return new GatewayInternalServerError({ message, statusCode, cause });
    default:
      return new GatewayInternalServerError({ message, statusCode, cause });
  }
}
var gatewayErrorResponseSchema = external_exports.object({
  error: external_exports.object({
    message: external_exports.string(),
    type: external_exports.string().nullish(),
    param: external_exports.unknown().nullish(),
    code: external_exports
      .union([external_exports.string(), external_exports.number()])
      .nullish(),
  }),
});
function asGatewayError(error45, authMethod) {
  var _a84;
  if (GatewayError.isInstance(error45)) {
    return error45;
  }
  if (APICallError.isInstance(error45)) {
    return createGatewayErrorFromResponse({
      response: extractApiCallResponse(error45),
      statusCode: (_a84 = error45.statusCode) != null ? _a84 : 500,
      defaultMessage: "Gateway request failed",
      cause: error45,
      authMethod,
    });
  }
  return createGatewayErrorFromResponse({
    response: {},
    statusCode: 500,
    defaultMessage:
      error45 instanceof Error
        ? `Gateway request failed: ${error45.message}`
        : "Unknown Gateway error",
    cause: error45,
    authMethod,
  });
}
function extractApiCallResponse(error45) {
  if (error45.data !== void 0) {
    return error45.data;
  }
  if (error45.responseBody != null) {
    try {
      return JSON.parse(error45.responseBody);
    } catch (e2) {
      return error45.responseBody;
    }
  }
  return {};
}
var GATEWAY_AUTH_METHOD_HEADER = "ai-gateway-auth-method";
function parseAuthMethod(headers) {
  const result = gatewayAuthMethodSchema.safeParse(
    headers[GATEWAY_AUTH_METHOD_HEADER],
  );
  return result.success ? result.data : void 0;
}
var gatewayAuthMethodSchema = external_exports.union([
  external_exports.literal("api-key"),
  external_exports.literal("oidc"),
]);
var GatewayFetchMetadata = class {
  constructor(config3) {
    this.config = config3;
  }
  async getAvailableModels() {
    try {
      const { value } = await getFromApi({
        url: `${this.config.baseURL}/config`,
        headers: await resolve(this.config.headers()),
        successfulResponseHandler: createJsonResponseHandler(
          gatewayFetchMetadataSchema,
        ),
        failedResponseHandler: createJsonErrorResponseHandler({
          errorSchema: external_exports.any(),
          errorToMessage: (data) => data,
        }),
        fetch: this.config.fetch,
      });
      return value;
    } catch (error45) {
      throw asGatewayError(error45);
    }
  }
  async getCredits() {
    try {
      const baseUrl = new URL(this.config.baseURL);
      const { value } = await getFromApi({
        url: `${baseUrl.origin}/v1/credits`,
        headers: await resolve(this.config.headers()),
        successfulResponseHandler:
          createJsonResponseHandler(gatewayCreditsSchema),
        failedResponseHandler: createJsonErrorResponseHandler({
          errorSchema: external_exports.any(),
          errorToMessage: (data) => data,
        }),
        fetch: this.config.fetch,
      });
      return value;
    } catch (error45) {
      throw asGatewayError(error45);
    }
  }
};
var gatewayLanguageModelSpecificationSchema = external_exports.object({
  specificationVersion: external_exports.literal("v2"),
  provider: external_exports.string(),
  modelId: external_exports.string(),
});
var gatewayLanguageModelPricingSchema = external_exports
  .object({
    input: external_exports.string(),
    output: external_exports.string(),
    input_cache_read: external_exports.string().nullish(),
    input_cache_write: external_exports.string().nullish(),
  })
  .transform(({ input, output, input_cache_read, input_cache_write }) => ({
    input,
    output,
    ...(input_cache_read ? { cachedInputTokens: input_cache_read } : {}),
    ...(input_cache_write
      ? { cacheCreationInputTokens: input_cache_write }
      : {}),
  }));
var gatewayLanguageModelEntrySchema = external_exports.object({
  id: external_exports.string(),
  name: external_exports.string(),
  description: external_exports.string().nullish(),
  pricing: gatewayLanguageModelPricingSchema.nullish(),
  specification: gatewayLanguageModelSpecificationSchema,
  modelType: external_exports
    .enum(["language", "embedding", "image"])
    .nullish(),
});
var gatewayFetchMetadataSchema = external_exports.object({
  models: external_exports.array(gatewayLanguageModelEntrySchema),
});
var gatewayCreditsSchema = external_exports
  .object({
    balance: external_exports.string(),
    total_used: external_exports.string(),
  })
  .transform(({ balance, total_used }) => ({
    balance,
    totalUsed: total_used,
  }));
var GatewayLanguageModel = class {
  constructor(modelId, config3) {
    this.modelId = modelId;
    this.config = config3;
    this.specificationVersion = "v2";
    this.supportedUrls = { "*/*": [/.*/] };
  }
  get provider() {
    return this.config.provider;
  }
  async getArgs(options) {
    const { abortSignal: _abortSignal, ...optionsWithoutSignal } = options;
    return {
      args: this.maybeEncodeFileParts(optionsWithoutSignal),
      warnings: [],
    };
  }
  async doGenerate(options) {
    const { args, warnings } = await this.getArgs(options);
    const { abortSignal } = options;
    const resolvedHeaders = await resolve(this.config.headers());
    try {
      const {
        responseHeaders,
        value: responseBody,
        rawValue: rawResponse,
      } = await postJsonToApi({
        url: this.getUrl(),
        headers: combineHeaders(
          resolvedHeaders,
          options.headers,
          this.getModelConfigHeaders(this.modelId, false),
          await resolve(this.config.o11yHeaders),
        ),
        body: args,
        successfulResponseHandler: createJsonResponseHandler(
          external_exports.any(),
        ),
        failedResponseHandler: createJsonErrorResponseHandler({
          errorSchema: external_exports.any(),
          errorToMessage: (data) => data,
        }),
        ...(abortSignal && { abortSignal }),
        fetch: this.config.fetch,
      });
      return {
        ...responseBody,
        request: { body: args },
        response: { headers: responseHeaders, body: rawResponse },
        warnings,
      };
    } catch (error45) {
      throw asGatewayError(error45, parseAuthMethod(resolvedHeaders));
    }
  }
  async doStream(options) {
    const { args, warnings } = await this.getArgs(options);
    const { abortSignal } = options;
    const resolvedHeaders = await resolve(this.config.headers());
    try {
      const { value: response, responseHeaders } = await postJsonToApi({
        url: this.getUrl(),
        headers: combineHeaders(
          resolvedHeaders,
          options.headers,
          this.getModelConfigHeaders(this.modelId, true),
          await resolve(this.config.o11yHeaders),
        ),
        body: args,
        successfulResponseHandler: createEventSourceResponseHandler(
          external_exports.any(),
        ),
        failedResponseHandler: createJsonErrorResponseHandler({
          errorSchema: external_exports.any(),
          errorToMessage: (data) => data,
        }),
        ...(abortSignal && { abortSignal }),
        fetch: this.config.fetch,
      });
      return {
        stream: response.pipeThrough(
          new TransformStream({
            start(controller) {
              if (warnings.length > 0) {
                controller.enqueue({ type: "stream-start", warnings });
              }
            },
            transform(chunk, controller) {
              if (chunk.success) {
                const streamPart = chunk.value;
                if (streamPart.type === "raw" && !options.includeRawChunks) {
                  return;
                }
                if (
                  streamPart.type === "response-metadata" &&
                  streamPart.timestamp &&
                  typeof streamPart.timestamp === "string"
                ) {
                  streamPart.timestamp = new Date(streamPart.timestamp);
                }
                controller.enqueue(streamPart);
              } else {
                controller.error(chunk.error);
              }
            },
          }),
        ),
        request: { body: args },
        response: { headers: responseHeaders },
      };
    } catch (error45) {
      throw asGatewayError(error45, parseAuthMethod(resolvedHeaders));
    }
  }
  isFilePart(part) {
    return (
      part && typeof part === "object" && "type" in part && part.type === "file"
    );
  }
  /**
   * Encodes file parts in the prompt to base64. Mutates the passed options
   * instance directly to avoid copying the file data.
   * @param options - The options to encode.
   * @returns The options with the file parts encoded.
   */
  maybeEncodeFileParts(options) {
    for (const message of options.prompt) {
      for (const part of message.content) {
        if (this.isFilePart(part)) {
          const filePart = part;
          if (filePart.data instanceof Uint8Array) {
            const buffer = Uint8Array.from(filePart.data);
            const base64Data = Buffer.from(buffer).toString("base64");
            filePart.data = new URL(
              `data:${filePart.mediaType || "application/octet-stream"};base64,${base64Data}`,
            );
          }
        }
      }
    }
    return options;
  }
  getUrl() {
    return `${this.config.baseURL}/language-model`;
  }
  getModelConfigHeaders(modelId, streaming) {
    return {
      "ai-language-model-specification-version": "2",
      "ai-language-model-id": modelId,
      "ai-language-model-streaming": String(streaming),
    };
  }
};
var GatewayEmbeddingModel = class {
  constructor(modelId, config3) {
    this.modelId = modelId;
    this.config = config3;
    this.specificationVersion = "v2";
    this.maxEmbeddingsPerCall = 2048;
    this.supportsParallelCalls = true;
  }
  get provider() {
    return this.config.provider;
  }
  async doEmbed({ values, headers, abortSignal, providerOptions }) {
    var _a84;
    const resolvedHeaders = await resolve(this.config.headers());
    try {
      const {
        responseHeaders,
        value: responseBody,
        rawValue,
      } = await postJsonToApi({
        url: this.getUrl(),
        headers: combineHeaders(
          resolvedHeaders,
          headers != null ? headers : {},
          this.getModelConfigHeaders(),
          await resolve(this.config.o11yHeaders),
        ),
        body: {
          input: values.length === 1 ? values[0] : values,
          ...(providerOptions ? { providerOptions } : {}),
        },
        successfulResponseHandler: createJsonResponseHandler(
          gatewayEmbeddingResponseSchema,
        ),
        failedResponseHandler: createJsonErrorResponseHandler({
          errorSchema: external_exports.any(),
          errorToMessage: (data) => data,
        }),
        ...(abortSignal && { abortSignal }),
        fetch: this.config.fetch,
      });
      return {
        embeddings: responseBody.embeddings,
        usage: (_a84 = responseBody.usage) != null ? _a84 : void 0,
        providerMetadata: responseBody.providerMetadata,
        response: { headers: responseHeaders, body: rawValue },
      };
    } catch (error45) {
      throw asGatewayError(error45, parseAuthMethod(resolvedHeaders));
    }
  }
  getUrl() {
    return `${this.config.baseURL}/embedding-model`;
  }
  getModelConfigHeaders() {
    return {
      "ai-embedding-model-specification-version": "2",
      "ai-model-id": this.modelId,
    };
  }
};
var gatewayEmbeddingResponseSchema = external_exports.object({
  embeddings: external_exports.array(
    external_exports.array(external_exports.number()),
  ),
  usage: external_exports
    .object({ tokens: external_exports.number() })
    .nullish(),
  providerMetadata: external_exports
    .record(
      external_exports.string(),
      external_exports.record(
        external_exports.string(),
        external_exports.unknown(),
      ),
    )
    .optional(),
});
async function getVercelOidcToken() {
  var _a84, _b82;
  const token =
    (_b82 =
      (_a84 = getContext().headers) == null
        ? void 0
        : _a84["x-vercel-oidc-token"]) != null
      ? _b82
      : process.env.VERCEL_OIDC_TOKEN;
  if (!token) {
    throw new GatewayAuthenticationError({
      message: "OIDC token not available",
      statusCode: 401,
    });
  }
  return token;
}
async function getVercelRequestId() {
  var _a84;
  return (_a84 = getContext().headers) == null ? void 0 : _a84["x-vercel-id"];
}
var SYMBOL_FOR_REQ_CONTEXT = Symbol.for("@vercel/request-context");
function getContext() {
  var _a84, _b82, _c;
  const fromSymbol = globalThis;
  return (_c =
    (_b82 =
      (_a84 = fromSymbol[SYMBOL_FOR_REQ_CONTEXT]) == null
        ? void 0
        : _a84.get) == null
      ? void 0
      : _b82.call(_a84)) != null
    ? _c
    : {};
}
var VERSION2 = true ? "1.0.29" : "0.0.0-test";
var AI_GATEWAY_PROTOCOL_VERSION = "0.0.1";
function createGatewayProvider(options = {}) {
  var _a84, _b82;
  let pendingMetadata = null;
  let metadataCache = null;
  const cacheRefreshMillis =
    (_a84 = options.metadataCacheRefreshMillis) != null ? _a84 : 1e3 * 60 * 5;
  let lastFetchTime = 0;
  const baseURL =
    (_b82 = withoutTrailingSlash(options.baseURL)) != null
      ? _b82
      : "https://ai-gateway.vercel.sh/v1/ai";
  const getHeaders = async () => {
    const auth2 = await getGatewayAuthToken(options);
    if (auth2) {
      return withUserAgentSuffix(
        {
          Authorization: `Bearer ${auth2.token}`,
          "ai-gateway-protocol-version": AI_GATEWAY_PROTOCOL_VERSION,
          [GATEWAY_AUTH_METHOD_HEADER]: auth2.authMethod,
          ...options.headers,
        },
        `ai-sdk/gateway/${VERSION2}`,
      );
    }
    throw GatewayAuthenticationError.createContextualError({
      apiKeyProvided: false,
      oidcTokenProvided: false,
      statusCode: 401,
    });
  };
  const createO11yHeaders = () => {
    const deploymentId = loadOptionalSetting({
      settingValue: void 0,
      environmentVariableName: "VERCEL_DEPLOYMENT_ID",
    });
    const environment = loadOptionalSetting({
      settingValue: void 0,
      environmentVariableName: "VERCEL_ENV",
    });
    const region = loadOptionalSetting({
      settingValue: void 0,
      environmentVariableName: "VERCEL_REGION",
    });
    return async () => {
      const requestId = await getVercelRequestId();
      return {
        ...(deploymentId && { "ai-o11y-deployment-id": deploymentId }),
        ...(environment && { "ai-o11y-environment": environment }),
        ...(region && { "ai-o11y-region": region }),
        ...(requestId && { "ai-o11y-request-id": requestId }),
      };
    };
  };
  const createLanguageModel = (modelId) => {
    return new GatewayLanguageModel(modelId, {
      provider: "gateway",
      baseURL,
      headers: getHeaders,
      fetch: options.fetch,
      o11yHeaders: createO11yHeaders(),
    });
  };
  const getAvailableModels = async () => {
    var _a94, _b9, _c;
    const now2 =
      (_c =
        (_b9 =
          (_a94 = options._internal) == null ? void 0 : _a94.currentDate) ==
        null
          ? void 0
          : _b9.call(_a94).getTime()) != null
        ? _c
        : Date.now();
    if (!pendingMetadata || now2 - lastFetchTime > cacheRefreshMillis) {
      lastFetchTime = now2;
      pendingMetadata = new GatewayFetchMetadata({
        baseURL,
        headers: getHeaders,
        fetch: options.fetch,
      })
        .getAvailableModels()
        .then((metadata) => {
          metadataCache = metadata;
          return metadata;
        })
        .catch(async (error45) => {
          throw asGatewayError(error45, parseAuthMethod(await getHeaders()));
        });
    }
    return metadataCache ? Promise.resolve(metadataCache) : pendingMetadata;
  };
  const getCredits = async () => {
    return new GatewayFetchMetadata({
      baseURL,
      headers: getHeaders,
      fetch: options.fetch,
    })
      .getCredits()
      .catch(async (error45) => {
        throw asGatewayError(error45, parseAuthMethod(await getHeaders()));
      });
  };
  const provider = function (modelId) {
    if (new.target) {
      throw new Error(
        "The Gateway Provider model function cannot be called with the new keyword.",
      );
    }
    return createLanguageModel(modelId);
  };
  provider.getAvailableModels = getAvailableModels;
  provider.getCredits = getCredits;
  provider.imageModel = (modelId) => {
    throw new NoSuchModelError({ modelId, modelType: "imageModel" });
  };
  provider.languageModel = createLanguageModel;
  provider.textEmbeddingModel = (modelId) => {
    return new GatewayEmbeddingModel(modelId, {
      provider: "gateway",
      baseURL,
      headers: getHeaders,
      fetch: options.fetch,
      o11yHeaders: createO11yHeaders(),
    });
  };
  return provider;
}
var gateway = createGatewayProvider();
async function getGatewayAuthToken(options) {
  const apiKey = loadOptionalSetting({
    settingValue: options.apiKey,
    environmentVariableName: "AI_GATEWAY_API_KEY",
  });
  if (apiKey) {
    return {
      token: apiKey,
      authMethod: "api-key",
    };
  }
  try {
    const oidcToken = await getVercelOidcToken();
    return {
      token: oidcToken,
      authMethod: "oidc",
    };
  } catch (e2) {
    return null;
  }
}

// node_modules/@opentelemetry/api/build/esm/platform/node/globalThis.js
var _globalThis = typeof globalThis === "object" ? globalThis : global;

// node_modules/@opentelemetry/api/build/esm/version.js
var VERSION3 = "1.9.0";

// node_modules/@opentelemetry/api/build/esm/internal/semver.js
var re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
function _makeCompatibilityCheck(ownVersion) {
  var acceptedVersions = /* @__PURE__ */ new Set([ownVersion]);
  var rejectedVersions = /* @__PURE__ */ new Set();
  var myVersionMatch = ownVersion.match(re);
  if (!myVersionMatch) {
    return function () {
      return false;
    };
  }
  var ownVersionParsed = {
    major: +myVersionMatch[1],
    minor: +myVersionMatch[2],
    patch: +myVersionMatch[3],
    prerelease: myVersionMatch[4],
  };
  if (ownVersionParsed.prerelease != null) {
    return function isExactmatch(globalVersion) {
      return globalVersion === ownVersion;
    };
  }
  function _reject(v2) {
    rejectedVersions.add(v2);
    return false;
  }
  function _accept(v2) {
    acceptedVersions.add(v2);
    return true;
  }
  return function isCompatible2(globalVersion) {
    if (acceptedVersions.has(globalVersion)) {
      return true;
    }
    if (rejectedVersions.has(globalVersion)) {
      return false;
    }
    var globalVersionMatch = globalVersion.match(re);
    if (!globalVersionMatch) {
      return _reject(globalVersion);
    }
    var globalVersionParsed = {
      major: +globalVersionMatch[1],
      minor: +globalVersionMatch[2],
      patch: +globalVersionMatch[3],
      prerelease: globalVersionMatch[4],
    };
    if (globalVersionParsed.prerelease != null) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major !== globalVersionParsed.major) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major === 0) {
      if (
        ownVersionParsed.minor === globalVersionParsed.minor &&
        ownVersionParsed.patch <= globalVersionParsed.patch
      ) {
        return _accept(globalVersion);
      }
      return _reject(globalVersion);
    }
    if (ownVersionParsed.minor <= globalVersionParsed.minor) {
      return _accept(globalVersion);
    }
    return _reject(globalVersion);
  };
}
var isCompatible = _makeCompatibilityCheck(VERSION3);

// node_modules/@opentelemetry/api/build/esm/internal/global-utils.js
var major = VERSION3.split(".")[0];
var GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for("opentelemetry.js.api." + major);
var _global = _globalThis;
function registerGlobal(type, instance, diag, allowOverride) {
  var _a19;
  if (allowOverride === void 0) {
    allowOverride = false;
  }
  var api = (_global[GLOBAL_OPENTELEMETRY_API_KEY] =
    (_a19 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a19 !== void 0
      ? _a19
      : {
          version: VERSION3,
        });
  if (!allowOverride && api[type]) {
    var err2 = new Error(
      "@opentelemetry/api: Attempted duplicate registration of API: " + type,
    );
    diag.error(err2.stack || err2.message);
    return false;
  }
  if (api.version !== VERSION3) {
    var err2 = new Error(
      "@opentelemetry/api: Registration of version v" +
        api.version +
        " for " +
        type +
        " does not match previously registered API v" +
        VERSION3,
    );
    diag.error(err2.stack || err2.message);
    return false;
  }
  api[type] = instance;
  diag.debug(
    "@opentelemetry/api: Registered a global for " +
      type +
      " v" +
      VERSION3 +
      ".",
  );
  return true;
}
function getGlobal(type) {
  var _a19, _b9;
  var globalVersion =
    (_a19 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a19 === void 0
      ? void 0
      : _a19.version;
  if (!globalVersion || !isCompatible(globalVersion)) {
    return;
  }
  return (_b9 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null ||
    _b9 === void 0
    ? void 0
    : _b9[type];
}
function unregisterGlobal(type, diag) {
  diag.debug(
    "@opentelemetry/api: Unregistering a global for " +
      type +
      " v" +
      VERSION3 +
      ".",
  );
  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
  if (api) {
    delete api[type];
  }
}

// node_modules/@opentelemetry/api/build/esm/diag/ComponentLogger.js
var __read = function (o2, n) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2) return o2;
  var i2 = m2.call(o2),
    r2,
    ar = [],
    e2;
  try {
    while ((n === void 0 || n-- > 0) && !(r2 = i2.next()).done)
      ar.push(r2.value);
  } catch (error45) {
    e2 = { error: error45 };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray = function (to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var DiagComponentLogger =
  /** @class */
  (function () {
    function DiagComponentLogger2(props) {
      this._namespace = props.namespace || "DiagComponentLogger";
    }
    DiagComponentLogger2.prototype.debug = function () {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("debug", this._namespace, args);
    };
    DiagComponentLogger2.prototype.error = function () {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("error", this._namespace, args);
    };
    DiagComponentLogger2.prototype.info = function () {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("info", this._namespace, args);
    };
    DiagComponentLogger2.prototype.warn = function () {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("warn", this._namespace, args);
    };
    DiagComponentLogger2.prototype.verbose = function () {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("verbose", this._namespace, args);
    };
    return DiagComponentLogger2;
  })();
function logProxy(funcName, namespace, args) {
  var logger = getGlobal("diag");
  if (!logger) {
    return;
  }
  args.unshift(namespace);
  return logger[funcName].apply(logger, __spreadArray([], __read(args), false));
}

// node_modules/@opentelemetry/api/build/esm/diag/types.js
var DiagLogLevel;
(function (DiagLogLevel2) {
  DiagLogLevel2[(DiagLogLevel2["NONE"] = 0)] = "NONE";
  DiagLogLevel2[(DiagLogLevel2["ERROR"] = 30)] = "ERROR";
  DiagLogLevel2[(DiagLogLevel2["WARN"] = 50)] = "WARN";
  DiagLogLevel2[(DiagLogLevel2["INFO"] = 60)] = "INFO";
  DiagLogLevel2[(DiagLogLevel2["DEBUG"] = 70)] = "DEBUG";
  DiagLogLevel2[(DiagLogLevel2["VERBOSE"] = 80)] = "VERBOSE";
  DiagLogLevel2[(DiagLogLevel2["ALL"] = 9999)] = "ALL";
})(DiagLogLevel || (DiagLogLevel = {}));

// node_modules/@opentelemetry/api/build/esm/diag/internal/logLevelLogger.js
function createLogLevelDiagLogger(maxLevel, logger) {
  if (maxLevel < DiagLogLevel.NONE) {
    maxLevel = DiagLogLevel.NONE;
  } else if (maxLevel > DiagLogLevel.ALL) {
    maxLevel = DiagLogLevel.ALL;
  }
  logger = logger || {};
  function _filterFunc(funcName, theLevel) {
    var theFunc = logger[funcName];
    if (typeof theFunc === "function" && maxLevel >= theLevel) {
      return theFunc.bind(logger);
    }
    return function () {};
  }
  return {
    error: _filterFunc("error", DiagLogLevel.ERROR),
    warn: _filterFunc("warn", DiagLogLevel.WARN),
    info: _filterFunc("info", DiagLogLevel.INFO),
    debug: _filterFunc("debug", DiagLogLevel.DEBUG),
    verbose: _filterFunc("verbose", DiagLogLevel.VERBOSE),
  };
}

// node_modules/@opentelemetry/api/build/esm/api/diag.js
var __read2 = function (o2, n) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2) return o2;
  var i2 = m2.call(o2),
    r2,
    ar = [],
    e2;
  try {
    while ((n === void 0 || n-- > 0) && !(r2 = i2.next()).done)
      ar.push(r2.value);
  } catch (error45) {
    e2 = { error: error45 };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray2 = function (to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME = "diag";
var DiagAPI =
  /** @class */
  (function () {
    function DiagAPI2() {
      function _logProxy(funcName) {
        return function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var logger = getGlobal("diag");
          if (!logger) return;
          return logger[funcName].apply(
            logger,
            __spreadArray2([], __read2(args), false),
          );
        };
      }
      var self = this;
      var setLogger = function (logger, optionsOrLogLevel) {
        var _a19, _b9, _c;
        if (optionsOrLogLevel === void 0) {
          optionsOrLogLevel = { logLevel: DiagLogLevel.INFO };
        }
        if (logger === self) {
          var err2 = new Error(
            "Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation",
          );
          self.error(
            (_a19 = err2.stack) !== null && _a19 !== void 0
              ? _a19
              : err2.message,
          );
          return false;
        }
        if (typeof optionsOrLogLevel === "number") {
          optionsOrLogLevel = {
            logLevel: optionsOrLogLevel,
          };
        }
        var oldLogger = getGlobal("diag");
        var newLogger = createLogLevelDiagLogger(
          (_b9 = optionsOrLogLevel.logLevel) !== null && _b9 !== void 0
            ? _b9
            : DiagLogLevel.INFO,
          logger,
        );
        if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
          var stack =
            (_c = new Error().stack) !== null && _c !== void 0
              ? _c
              : "<failed to generate stacktrace>";
          oldLogger.warn("Current logger will be overwritten from " + stack);
          newLogger.warn(
            "Current logger will overwrite one already registered from " +
              stack,
          );
        }
        return registerGlobal("diag", newLogger, self, true);
      };
      self.setLogger = setLogger;
      self.disable = function () {
        unregisterGlobal(API_NAME, self);
      };
      self.createComponentLogger = function (options) {
        return new DiagComponentLogger(options);
      };
      self.verbose = _logProxy("verbose");
      self.debug = _logProxy("debug");
      self.info = _logProxy("info");
      self.warn = _logProxy("warn");
      self.error = _logProxy("error");
    }
    DiagAPI2.instance = function () {
      if (!this._instance) {
        this._instance = new DiagAPI2();
      }
      return this._instance;
    };
    return DiagAPI2;
  })();

// node_modules/@opentelemetry/api/build/esm/context/context.js
function createContextKey(description) {
  return Symbol.for(description);
}
var BaseContext =
  /** @class */
  /* @__PURE__ */ (function () {
    function BaseContext2(parentContext) {
      var self = this;
      self._currentContext = parentContext
        ? new Map(parentContext)
        : /* @__PURE__ */ new Map();
      self.getValue = function (key) {
        return self._currentContext.get(key);
      };
      self.setValue = function (key, value) {
        var context = new BaseContext2(self._currentContext);
        context._currentContext.set(key, value);
        return context;
      };
      self.deleteValue = function (key) {
        var context = new BaseContext2(self._currentContext);
        context._currentContext.delete(key);
        return context;
      };
    }
    return BaseContext2;
  })();
var ROOT_CONTEXT = new BaseContext();

// node_modules/@opentelemetry/api/build/esm/context/NoopContextManager.js
var __read3 = function (o2, n) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2) return o2;
  var i2 = m2.call(o2),
    r2,
    ar = [],
    e2;
  try {
    while ((n === void 0 || n-- > 0) && !(r2 = i2.next()).done)
      ar.push(r2.value);
  } catch (error45) {
    e2 = { error: error45 };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray3 = function (to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var NoopContextManager =
  /** @class */
  (function () {
    function NoopContextManager2() {}
    NoopContextManager2.prototype.active = function () {
      return ROOT_CONTEXT;
    };
    NoopContextManager2.prototype.with = function (_context, fn, thisArg) {
      var args = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
      }
      return fn.call.apply(fn, __spreadArray3([thisArg], __read3(args), false));
    };
    NoopContextManager2.prototype.bind = function (_context, target) {
      return target;
    };
    NoopContextManager2.prototype.enable = function () {
      return this;
    };
    NoopContextManager2.prototype.disable = function () {
      return this;
    };
    return NoopContextManager2;
  })();

// node_modules/@opentelemetry/api/build/esm/api/context.js
var __read4 = function (o2, n) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2) return o2;
  var i2 = m2.call(o2),
    r2,
    ar = [],
    e2;
  try {
    while ((n === void 0 || n-- > 0) && !(r2 = i2.next()).done)
      ar.push(r2.value);
  } catch (error45) {
    e2 = { error: error45 };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
var __spreadArray4 = function (to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME2 = "context";
var NOOP_CONTEXT_MANAGER = new NoopContextManager();
var ContextAPI =
  /** @class */
  (function () {
    function ContextAPI2() {}
    ContextAPI2.getInstance = function () {
      if (!this._instance) {
        this._instance = new ContextAPI2();
      }
      return this._instance;
    };
    ContextAPI2.prototype.setGlobalContextManager = function (contextManager) {
      return registerGlobal(API_NAME2, contextManager, DiagAPI.instance());
    };
    ContextAPI2.prototype.active = function () {
      return this._getContextManager().active();
    };
    ContextAPI2.prototype.with = function (context, fn, thisArg) {
      var _a19;
      var args = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
      }
      return (_a19 = this._getContextManager()).with.apply(
        _a19,
        __spreadArray4([context, fn, thisArg], __read4(args), false),
      );
    };
    ContextAPI2.prototype.bind = function (context, target) {
      return this._getContextManager().bind(context, target);
    };
    ContextAPI2.prototype._getContextManager = function () {
      return getGlobal(API_NAME2) || NOOP_CONTEXT_MANAGER;
    };
    ContextAPI2.prototype.disable = function () {
      this._getContextManager().disable();
      unregisterGlobal(API_NAME2, DiagAPI.instance());
    };
    return ContextAPI2;
  })();

// node_modules/@opentelemetry/api/build/esm/trace/trace_flags.js
var TraceFlags;
(function (TraceFlags2) {
  TraceFlags2[(TraceFlags2["NONE"] = 0)] = "NONE";
  TraceFlags2[(TraceFlags2["SAMPLED"] = 1)] = "SAMPLED";
})(TraceFlags || (TraceFlags = {}));

// node_modules/@opentelemetry/api/build/esm/trace/invalid-span-constants.js
var INVALID_SPANID = "0000000000000000";
var INVALID_TRACEID = "00000000000000000000000000000000";
var INVALID_SPAN_CONTEXT = {
  traceId: INVALID_TRACEID,
  spanId: INVALID_SPANID,
  traceFlags: TraceFlags.NONE,
};

// node_modules/@opentelemetry/api/build/esm/trace/NonRecordingSpan.js
var NonRecordingSpan =
  /** @class */
  (function () {
    function NonRecordingSpan2(_spanContext) {
      if (_spanContext === void 0) {
        _spanContext = INVALID_SPAN_CONTEXT;
      }
      this._spanContext = _spanContext;
    }
    NonRecordingSpan2.prototype.spanContext = function () {
      return this._spanContext;
    };
    NonRecordingSpan2.prototype.setAttribute = function (_key, _value) {
      return this;
    };
    NonRecordingSpan2.prototype.setAttributes = function (_attributes) {
      return this;
    };
    NonRecordingSpan2.prototype.addEvent = function (_name, _attributes) {
      return this;
    };
    NonRecordingSpan2.prototype.addLink = function (_link) {
      return this;
    };
    NonRecordingSpan2.prototype.addLinks = function (_links) {
      return this;
    };
    NonRecordingSpan2.prototype.setStatus = function (_status) {
      return this;
    };
    NonRecordingSpan2.prototype.updateName = function (_name) {
      return this;
    };
    NonRecordingSpan2.prototype.end = function (_endTime) {};
    NonRecordingSpan2.prototype.isRecording = function () {
      return false;
    };
    NonRecordingSpan2.prototype.recordException = function (
      _exception,
      _time,
    ) {};
    return NonRecordingSpan2;
  })();

// node_modules/@opentelemetry/api/build/esm/trace/context-utils.js
var SPAN_KEY = createContextKey("OpenTelemetry Context Key SPAN");
function getSpan(context) {
  return context.getValue(SPAN_KEY) || void 0;
}
function getActiveSpan() {
  return getSpan(ContextAPI.getInstance().active());
}
function setSpan(context, span) {
  return context.setValue(SPAN_KEY, span);
}
function deleteSpan(context) {
  return context.deleteValue(SPAN_KEY);
}
function setSpanContext(context, spanContext) {
  return setSpan(context, new NonRecordingSpan(spanContext));
}
function getSpanContext(context) {
  var _a19;
  return (_a19 = getSpan(context)) === null || _a19 === void 0
    ? void 0
    : _a19.spanContext();
}

// node_modules/@opentelemetry/api/build/esm/trace/spancontext-utils.js
var VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
var VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
function isValidTraceId(traceId) {
  return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;
}
function isValidSpanId(spanId) {
  return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;
}
function isSpanContextValid(spanContext) {
  return (
    isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId)
  );
}
function wrapSpanContext(spanContext) {
  return new NonRecordingSpan(spanContext);
}

// node_modules/@opentelemetry/api/build/esm/trace/NoopTracer.js
var contextApi = ContextAPI.getInstance();
var NoopTracer =
  /** @class */
  (function () {
    function NoopTracer2() {}
    NoopTracer2.prototype.startSpan = function (name18, options, context) {
      if (context === void 0) {
        context = contextApi.active();
      }
      var root = Boolean(
        options === null || options === void 0 ? void 0 : options.root,
      );
      if (root) {
        return new NonRecordingSpan();
      }
      var parentFromContext = context && getSpanContext(context);
      if (
        isSpanContext(parentFromContext) &&
        isSpanContextValid(parentFromContext)
      ) {
        return new NonRecordingSpan(parentFromContext);
      } else {
        return new NonRecordingSpan();
      }
    };
    NoopTracer2.prototype.startActiveSpan = function (
      name18,
      arg2,
      arg3,
      arg4,
    ) {
      var opts;
      var ctx;
      var fn;
      if (arguments.length < 2) {
        return;
      } else if (arguments.length === 2) {
        fn = arg2;
      } else if (arguments.length === 3) {
        opts = arg2;
        fn = arg3;
      } else {
        opts = arg2;
        ctx = arg3;
        fn = arg4;
      }
      var parentContext =
        ctx !== null && ctx !== void 0 ? ctx : contextApi.active();
      var span = this.startSpan(name18, opts, parentContext);
      var contextWithSpanSet = setSpan(parentContext, span);
      return contextApi.with(contextWithSpanSet, fn, void 0, span);
    };
    return NoopTracer2;
  })();
function isSpanContext(spanContext) {
  return (
    typeof spanContext === "object" &&
    typeof spanContext["spanId"] === "string" &&
    typeof spanContext["traceId"] === "string" &&
    typeof spanContext["traceFlags"] === "number"
  );
}

// node_modules/@opentelemetry/api/build/esm/trace/ProxyTracer.js
var NOOP_TRACER = new NoopTracer();
var ProxyTracer =
  /** @class */
  (function () {
    function ProxyTracer2(_provider, name18, version3, options) {
      this._provider = _provider;
      this.name = name18;
      this.version = version3;
      this.options = options;
    }
    ProxyTracer2.prototype.startSpan = function (name18, options, context) {
      return this._getTracer().startSpan(name18, options, context);
    };
    ProxyTracer2.prototype.startActiveSpan = function (
      _name,
      _options,
      _context,
      _fn,
    ) {
      var tracer = this._getTracer();
      return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
    };
    ProxyTracer2.prototype._getTracer = function () {
      if (this._delegate) {
        return this._delegate;
      }
      var tracer = this._provider.getDelegateTracer(
        this.name,
        this.version,
        this.options,
      );
      if (!tracer) {
        return NOOP_TRACER;
      }
      this._delegate = tracer;
      return this._delegate;
    };
    return ProxyTracer2;
  })();

// node_modules/@opentelemetry/api/build/esm/trace/NoopTracerProvider.js
var NoopTracerProvider =
  /** @class */
  (function () {
    function NoopTracerProvider2() {}
    NoopTracerProvider2.prototype.getTracer = function (
      _name,
      _version,
      _options,
    ) {
      return new NoopTracer();
    };
    return NoopTracerProvider2;
  })();

// node_modules/@opentelemetry/api/build/esm/trace/ProxyTracerProvider.js
var NOOP_TRACER_PROVIDER = new NoopTracerProvider();
var ProxyTracerProvider =
  /** @class */
  (function () {
    function ProxyTracerProvider2() {}
    ProxyTracerProvider2.prototype.getTracer = function (
      name18,
      version3,
      options,
    ) {
      var _a19;
      return (_a19 = this.getDelegateTracer(name18, version3, options)) !==
        null && _a19 !== void 0
        ? _a19
        : new ProxyTracer(this, name18, version3, options);
    };
    ProxyTracerProvider2.prototype.getDelegate = function () {
      var _a19;
      return (_a19 = this._delegate) !== null && _a19 !== void 0
        ? _a19
        : NOOP_TRACER_PROVIDER;
    };
    ProxyTracerProvider2.prototype.setDelegate = function (delegate) {
      this._delegate = delegate;
    };
    ProxyTracerProvider2.prototype.getDelegateTracer = function (
      name18,
      version3,
      options,
    ) {
      var _a19;
      return (_a19 = this._delegate) === null || _a19 === void 0
        ? void 0
        : _a19.getTracer(name18, version3, options);
    };
    return ProxyTracerProvider2;
  })();

// node_modules/@opentelemetry/api/build/esm/trace/status.js
var SpanStatusCode;
(function (SpanStatusCode2) {
  SpanStatusCode2[(SpanStatusCode2["UNSET"] = 0)] = "UNSET";
  SpanStatusCode2[(SpanStatusCode2["OK"] = 1)] = "OK";
  SpanStatusCode2[(SpanStatusCode2["ERROR"] = 2)] = "ERROR";
})(SpanStatusCode || (SpanStatusCode = {}));

// node_modules/@opentelemetry/api/build/esm/api/trace.js
var API_NAME3 = "trace";
var TraceAPI =
  /** @class */
  (function () {
    function TraceAPI2() {
      this._proxyTracerProvider = new ProxyTracerProvider();
      this.wrapSpanContext = wrapSpanContext;
      this.isSpanContextValid = isSpanContextValid;
      this.deleteSpan = deleteSpan;
      this.getSpan = getSpan;
      this.getActiveSpan = getActiveSpan;
      this.getSpanContext = getSpanContext;
      this.setSpan = setSpan;
      this.setSpanContext = setSpanContext;
    }
    TraceAPI2.getInstance = function () {
      if (!this._instance) {
        this._instance = new TraceAPI2();
      }
      return this._instance;
    };
    TraceAPI2.prototype.setGlobalTracerProvider = function (provider) {
      var success2 = registerGlobal(
        API_NAME3,
        this._proxyTracerProvider,
        DiagAPI.instance(),
      );
      if (success2) {
        this._proxyTracerProvider.setDelegate(provider);
      }
      return success2;
    };
    TraceAPI2.prototype.getTracerProvider = function () {
      return getGlobal(API_NAME3) || this._proxyTracerProvider;
    };
    TraceAPI2.prototype.getTracer = function (name18, version3) {
      return this.getTracerProvider().getTracer(name18, version3);
    };
    TraceAPI2.prototype.disable = function () {
      unregisterGlobal(API_NAME3, DiagAPI.instance());
      this._proxyTracerProvider = new ProxyTracerProvider();
    };
    return TraceAPI2;
  })();

// node_modules/@opentelemetry/api/build/esm/trace-api.js
var trace = TraceAPI.getInstance();

// node_modules/ai/dist/index.mjs
var __defProp2 = Object.defineProperty;
var __export2 = (target, all) => {
  for (var name172 in all)
    __defProp2(target, name172, { get: all[name172], enumerable: true });
};
var name15 = "AI_NoOutputSpecifiedError";
var marker16 = `vercel.ai.error.${name15}`;
var symbol17 = Symbol.for(marker16);
var _a16;
var NoOutputSpecifiedError = class extends AISDKError {
  // used in isInstance
  constructor({ message = "No output specified." } = {}) {
    super({ name: name15, message });
    this[_a16] = true;
  }
  static isInstance(error45) {
    return AISDKError.hasMarker(error45, marker16);
  }
};
_a16 = symbol17;
function formatWarning(warning) {
  const prefix = "AI SDK Warning:";
  switch (warning.type) {
    case "unsupported-setting": {
      let message = `${prefix} The "${warning.setting}" setting is not supported by this model`;
      if (warning.details) {
        message += ` - ${warning.details}`;
      }
      return message;
    }
    case "unsupported-tool": {
      const toolName =
        "name" in warning.tool ? warning.tool.name : "unknown tool";
      let message = `${prefix} The tool "${toolName}" is not supported by this model`;
      if (warning.details) {
        message += ` - ${warning.details}`;
      }
      return message;
    }
    case "other": {
      return `${prefix} ${warning.message}`;
    }
    default: {
      return `${prefix} ${JSON.stringify(warning, null, 2)}`;
    }
  }
}
var FIRST_WARNING_INFO_MESSAGE =
  "AI SDK Warning System: To turn off warning logging, set the AI_SDK_LOG_WARNINGS global to false.";
var hasLoggedBefore = false;
var logWarnings = (warnings) => {
  if (warnings.length === 0) {
    return;
  }
  const logger = globalThis.AI_SDK_LOG_WARNINGS;
  if (logger === false) {
    return;
  }
  if (typeof logger === "function") {
    logger(warnings);
    return;
  }
  if (!hasLoggedBefore) {
    hasLoggedBefore = true;
    console.info(FIRST_WARNING_INFO_MESSAGE);
  }
  for (const warning of warnings) {
    console.warn(formatWarning(warning));
  }
};
var name23 = "AI_InvalidArgumentError";
var marker23 = `vercel.ai.error.${name23}`;
var symbol23 = Symbol.for(marker23);
var _a23;
var InvalidArgumentError2 = class extends AISDKError {
  constructor({ parameter, value, message }) {
    super({
      name: name23,
      message: `Invalid argument for parameter ${parameter}: ${message}`,
    });
    this[_a23] = true;
    this.parameter = parameter;
    this.value = value;
  }
  static isInstance(error45) {
    return AISDKError.hasMarker(error45, marker23);
  }
};
_a23 = symbol23;
var name33 = "AI_InvalidStreamPartError";
var marker33 = `vercel.ai.error.${name33}`;
var symbol33 = Symbol.for(marker33);
var _a33;
_a33 = symbol33;
var name43 = "AI_InvalidToolInputError";
var marker43 = `vercel.ai.error.${name43}`;
var symbol43 = Symbol.for(marker43);
var _a43;
var InvalidToolInputError = class extends AISDKError {
  constructor({
    toolInput,
    toolName,
    cause,
    message = `Invalid input for tool ${toolName}: ${getErrorMessage(cause)}`,
  }) {
    super({ name: name43, message, cause });
    this[_a43] = true;
    this.toolInput = toolInput;
    this.toolName = toolName;
  }
  static isInstance(error45) {
    return AISDKError.hasMarker(error45, marker43);
  }
};
_a43 = symbol43;
var name53 = "AI_MCPClientError";
var marker53 = `vercel.ai.error.${name53}`;
var symbol53 = Symbol.for(marker53);
var _a53;
_a53 = symbol53;
var name63 = "AI_NoImageGeneratedError";
var marker63 = `vercel.ai.error.${name63}`;
var symbol63 = Symbol.for(marker63);
var _a63;
_a63 = symbol63;
var name72 = "AI_NoObjectGeneratedError";
var marker73 = `vercel.ai.error.${name72}`;
var symbol73 = Symbol.for(marker73);
var _a73;
var NoObjectGeneratedError = class extends AISDKError {
  constructor({
    message = "No object generated.",
    cause,
    text: text2,
    response,
    usage,
    finishReason,
  }) {
    super({ name: name72, message, cause });
    this[_a73] = true;
    this.text = text2;
    this.response = response;
    this.usage = usage;
    this.finishReason = finishReason;
  }
  static isInstance(error45) {
    return AISDKError.hasMarker(error45, marker73);
  }
};
_a73 = symbol73;
var name82 = "AI_NoOutputGeneratedError";
var marker82 = `vercel.ai.error.${name82}`;
var symbol82 = Symbol.for(marker82);
var _a82;
var NoOutputGeneratedError = class extends AISDKError {
  // used in isInstance
  constructor({ message = "No output generated.", cause } = {}) {
    super({ name: name82, message, cause });
    this[_a82] = true;
  }
  static isInstance(error45) {
    return AISDKError.hasMarker(error45, marker82);
  }
};
_a82 = symbol82;
var name92 = "AI_NoSuchToolError";
var marker92 = `vercel.ai.error.${name92}`;
var symbol92 = Symbol.for(marker92);
var _a92;
var NoSuchToolError = class extends AISDKError {
  constructor({
    toolName,
    availableTools = void 0,
    message = `Model tried to call unavailable tool '${toolName}'. ${availableTools === void 0 ? "No tools are available." : `Available tools: ${availableTools.join(", ")}.`}`,
  }) {
    super({ name: name92, message });
    this[_a92] = true;
    this.toolName = toolName;
    this.availableTools = availableTools;
  }
  static isInstance(error45) {
    return AISDKError.hasMarker(error45, marker92);
  }
};
_a92 = symbol92;
var name102 = "AI_ToolCallRepairError";
var marker102 = `vercel.ai.error.${name102}`;
var symbol102 = Symbol.for(marker102);
var _a102;
var ToolCallRepairError = class extends AISDKError {
  constructor({
    cause,
    originalError,
    message = `Error repairing tool call: ${getErrorMessage(cause)}`,
  }) {
    super({ name: name102, message, cause });
    this[_a102] = true;
    this.originalError = originalError;
  }
  static isInstance(error45) {
    return AISDKError.hasMarker(error45, marker102);
  }
};
_a102 = symbol102;
var UnsupportedModelVersionError = class extends AISDKError {
  constructor(options) {
    super({
      name: "AI_UnsupportedModelVersionError",
      message: `Unsupported model version ${options.version} for provider "${options.provider}" and model "${options.modelId}". AI SDK 5 only supports models that implement specification version "v2".`,
    });
    this.version = options.version;
    this.provider = options.provider;
    this.modelId = options.modelId;
  }
};
var name112 = "AI_InvalidDataContentError";
var marker112 = `vercel.ai.error.${name112}`;
var symbol112 = Symbol.for(marker112);
var _a112;
_a112 = symbol112;
var name122 = "AI_InvalidMessageRoleError";
var marker122 = `vercel.ai.error.${name122}`;
var symbol122 = Symbol.for(marker122);
var _a122;
var InvalidMessageRoleError = class extends AISDKError {
  constructor({
    role,
    message = `Invalid message role: '${role}'. Must be one of: "system", "user", "assistant", "tool".`,
  }) {
    super({ name: name122, message });
    this[_a122] = true;
    this.role = role;
  }
  static isInstance(error45) {
    return AISDKError.hasMarker(error45, marker122);
  }
};
_a122 = symbol122;
var name132 = "AI_MessageConversionError";
var marker132 = `vercel.ai.error.${name132}`;
var symbol132 = Symbol.for(marker132);
var _a132;
var MessageConversionError = class extends AISDKError {
  constructor({ originalMessage, message }) {
    super({ name: name132, message });
    this[_a132] = true;
    this.originalMessage = originalMessage;
  }
  static isInstance(error45) {
    return AISDKError.hasMarker(error45, marker132);
  }
};
_a132 = symbol132;
var name142 = "AI_DownloadError";
var marker142 = `vercel.ai.error.${name142}`;
var symbol142 = Symbol.for(marker142);
var _a142;
var DownloadError = class extends AISDKError {
  constructor({
    url: url2,
    statusCode,
    statusText,
    cause,
    message = cause == null
      ? `Failed to download ${url2}: ${statusCode} ${statusText}`
      : `Failed to download ${url2}: ${cause}`,
  }) {
    super({ name: name142, message, cause });
    this[_a142] = true;
    this.url = url2;
    this.statusCode = statusCode;
    this.statusText = statusText;
  }
  static isInstance(error45) {
    return AISDKError.hasMarker(error45, marker142);
  }
};
_a142 = symbol142;
var name152 = "AI_RetryError";
var marker152 = `vercel.ai.error.${name152}`;
var symbol152 = Symbol.for(marker152);
var _a152;
var RetryError = class extends AISDKError {
  constructor({ message, reason, errors }) {
    super({ name: name152, message });
    this[_a152] = true;
    this.reason = reason;
    this.errors = errors;
    this.lastError = errors[errors.length - 1];
  }
  static isInstance(error45) {
    return AISDKError.hasMarker(error45, marker152);
  }
};
_a152 = symbol152;
function resolveLanguageModel(model) {
  if (typeof model !== "string") {
    if (model.specificationVersion !== "v2") {
      throw new UnsupportedModelVersionError({
        version: model.specificationVersion,
        provider: model.provider,
        modelId: model.modelId,
      });
    }
    return model;
  }
  return getGlobalProvider().languageModel(model);
}
function getGlobalProvider() {
  var _a172;
  return (_a172 = globalThis.AI_SDK_DEFAULT_PROVIDER) != null ? _a172 : gateway;
}
var imageMediaTypeSignatures = [
  {
    mediaType: "image/gif",
    bytesPrefix: [71, 73, 70],
    // GIF
  },
  {
    mediaType: "image/png",
    bytesPrefix: [137, 80, 78, 71],
    // PNG
  },
  {
    mediaType: "image/jpeg",
    bytesPrefix: [255, 216],
    // JPEG
  },
  {
    mediaType: "image/webp",
    bytesPrefix: [
      82,
      73,
      70,
      70,
      // "RIFF"
      null,
      null,
      null,
      null,
      // file size (variable)
      87,
      69,
      66,
      80,
      // "WEBP"
    ],
  },
  {
    mediaType: "image/bmp",
    bytesPrefix: [66, 77],
  },
  {
    mediaType: "image/tiff",
    bytesPrefix: [73, 73, 42, 0],
  },
  {
    mediaType: "image/tiff",
    bytesPrefix: [77, 77, 0, 42],
  },
  {
    mediaType: "image/avif",
    bytesPrefix: [0, 0, 0, 32, 102, 116, 121, 112, 97, 118, 105, 102],
  },
  {
    mediaType: "image/heic",
    bytesPrefix: [0, 0, 0, 32, 102, 116, 121, 112, 104, 101, 105, 99],
  },
];
var stripID3 = (data) => {
  const bytes =
    typeof data === "string" ? convertBase64ToUint8Array(data) : data;
  const id3Size =
    ((bytes[6] & 127) << 21) |
    ((bytes[7] & 127) << 14) |
    ((bytes[8] & 127) << 7) |
    (bytes[9] & 127);
  return bytes.slice(id3Size + 10);
};
function stripID3TagsIfPresent(data) {
  const hasId3 =
    (typeof data === "string" && data.startsWith("SUQz")) ||
    (typeof data !== "string" &&
      data.length > 10 &&
      data[0] === 73 && // 'I'
      data[1] === 68 && // 'D'
      data[2] === 51);
  return hasId3 ? stripID3(data) : data;
}
function detectMediaType({ data, signatures }) {
  const processedData = stripID3TagsIfPresent(data);
  const bytes =
    typeof processedData === "string"
      ? convertBase64ToUint8Array(
          processedData.substring(0, Math.min(processedData.length, 24)),
        )
      : processedData;
  for (const signature of signatures) {
    if (
      bytes.length >= signature.bytesPrefix.length &&
      signature.bytesPrefix.every(
        (byte, index) => byte === null || bytes[index] === byte,
      )
    ) {
      return signature.mediaType;
    }
  }
  return void 0;
}
var VERSION4 = true ? "5.0.52" : "0.0.0-test";
var download = async ({ url: url2 }) => {
  var _a172;
  const urlText = url2.toString();
  try {
    const response = await fetch(urlText, {
      headers: withUserAgentSuffix(
        {},
        `ai-sdk/${VERSION4}`,
        getRuntimeEnvironmentUserAgent(),
      ),
    });
    if (!response.ok) {
      throw new DownloadError({
        url: urlText,
        statusCode: response.status,
        statusText: response.statusText,
      });
    }
    return {
      data: new Uint8Array(await response.arrayBuffer()),
      mediaType:
        (_a172 = response.headers.get("content-type")) != null ? _a172 : void 0,
    };
  } catch (error45) {
    if (DownloadError.isInstance(error45)) {
      throw error45;
    }
    throw new DownloadError({ url: urlText, cause: error45 });
  }
};
var createDefaultDownloadFunction =
  (download2 = download) =>
  (requestedDownloads) =>
    Promise.all(
      requestedDownloads.map(async (requestedDownload) =>
        requestedDownload.isUrlSupportedByModel
          ? null
          : download2(requestedDownload),
      ),
    );
function splitDataUrl(dataUrl) {
  try {
    const [header, base64Content] = dataUrl.split(",");
    return {
      mediaType: header.split(";")[0].split(":")[1],
      base64Content,
    };
  } catch (error45) {
    return {
      mediaType: void 0,
      base64Content: void 0,
    };
  }
}
var dataContentSchema = external_exports.union([
  external_exports.string(),
  external_exports.instanceof(Uint8Array),
  external_exports.instanceof(ArrayBuffer),
  external_exports.custom(
    // Buffer might not be available in some environments such as CloudFlare:
    (value) => {
      var _a172, _b9;
      return (_b9 =
        (_a172 = globalThis.Buffer) == null ? void 0 : _a172.isBuffer(value)) !=
        null
        ? _b9
        : false;
    },
    { message: "Must be a Buffer" },
  ),
]);
function convertToLanguageModelV2DataContent(content) {
  if (content instanceof Uint8Array) {
    return { data: content, mediaType: void 0 };
  }
  if (content instanceof ArrayBuffer) {
    return { data: new Uint8Array(content), mediaType: void 0 };
  }
  if (typeof content === "string") {
    try {
      content = new URL(content);
    } catch (error45) {}
  }
  if (content instanceof URL && content.protocol === "data:") {
    const { mediaType: dataUrlMediaType, base64Content } = splitDataUrl(
      content.toString(),
    );
    if (dataUrlMediaType == null || base64Content == null) {
      throw new AISDKError({
        name: "InvalidDataContentError",
        message: `Invalid data URL format in content ${content.toString()}`,
      });
    }
    return { data: base64Content, mediaType: dataUrlMediaType };
  }
  return { data: content, mediaType: void 0 };
}
function convertDataContentToBase64String(content) {
  if (typeof content === "string") {
    return content;
  }
  if (content instanceof ArrayBuffer) {
    return convertUint8ArrayToBase64(new Uint8Array(content));
  }
  return convertUint8ArrayToBase64(content);
}
async function convertToLanguageModelPrompt({
  prompt,
  supportedUrls,
  download: download2 = createDefaultDownloadFunction(),
}) {
  const downloadedAssets = await downloadAssets(
    prompt.messages,
    download2,
    supportedUrls,
  );
  return [
    ...(prompt.system != null
      ? [{ role: "system", content: prompt.system }]
      : []),
    ...prompt.messages.map((message) =>
      convertToLanguageModelMessage({ message, downloadedAssets }),
    ),
  ];
}
function convertToLanguageModelMessage({ message, downloadedAssets }) {
  const role = message.role;
  switch (role) {
    case "system": {
      return {
        role: "system",
        content: message.content,
        providerOptions: message.providerOptions,
      };
    }
    case "user": {
      if (typeof message.content === "string") {
        return {
          role: "user",
          content: [{ type: "text", text: message.content }],
          providerOptions: message.providerOptions,
        };
      }
      return {
        role: "user",
        content: message.content
          .map((part) => convertPartToLanguageModelPart(part, downloadedAssets))
          .filter((part) => part.type !== "text" || part.text !== ""),
        providerOptions: message.providerOptions,
      };
    }
    case "assistant": {
      if (typeof message.content === "string") {
        return {
          role: "assistant",
          content: [{ type: "text", text: message.content }],
          providerOptions: message.providerOptions,
        };
      }
      return {
        role: "assistant",
        content: message.content
          .filter(
            // remove empty text parts (no text, and no provider options):
            (part) =>
              part.type !== "text" ||
              part.text !== "" ||
              part.providerOptions != null,
          )
          .map((part) => {
            const providerOptions = part.providerOptions;
            switch (part.type) {
              case "file": {
                const { data, mediaType } = convertToLanguageModelV2DataContent(
                  part.data,
                );
                return {
                  type: "file",
                  data,
                  filename: part.filename,
                  mediaType: mediaType != null ? mediaType : part.mediaType,
                  providerOptions,
                };
              }
              case "reasoning": {
                return {
                  type: "reasoning",
                  text: part.text,
                  providerOptions,
                };
              }
              case "text": {
                return {
                  type: "text",
                  text: part.text,
                  providerOptions,
                };
              }
              case "tool-call": {
                return {
                  type: "tool-call",
                  toolCallId: part.toolCallId,
                  toolName: part.toolName,
                  input: part.input,
                  providerExecuted: part.providerExecuted,
                  providerOptions,
                };
              }
              case "tool-result": {
                return {
                  type: "tool-result",
                  toolCallId: part.toolCallId,
                  toolName: part.toolName,
                  output: part.output,
                  providerOptions,
                };
              }
            }
          }),
        providerOptions: message.providerOptions,
      };
    }
    case "tool": {
      return {
        role: "tool",
        content: message.content.map((part) => ({
          type: "tool-result",
          toolCallId: part.toolCallId,
          toolName: part.toolName,
          output: part.output,
          providerOptions: part.providerOptions,
        })),
        providerOptions: message.providerOptions,
      };
    }
    default: {
      const _exhaustiveCheck = role;
      throw new InvalidMessageRoleError({ role: _exhaustiveCheck });
    }
  }
}
async function downloadAssets(messages, download2, supportedUrls) {
  const plannedDownloads = messages
    .filter((message) => message.role === "user")
    .map((message) => message.content)
    .filter((content) => Array.isArray(content))
    .flat()
    .filter((part) => part.type === "image" || part.type === "file")
    .map((part) => {
      var _a172;
      const mediaType =
        (_a172 = part.mediaType) != null
          ? _a172
          : part.type === "image"
            ? "image/*"
            : void 0;
      let data = part.type === "image" ? part.image : part.data;
      if (typeof data === "string") {
        try {
          data = new URL(data);
        } catch (ignored) {}
      }
      return { mediaType, data };
    })
    .filter((part) => part.data instanceof URL)
    .map((part) => ({
      url: part.data,
      isUrlSupportedByModel:
        part.mediaType != null &&
        isUrlSupported({
          url: part.data.toString(),
          mediaType: part.mediaType,
          supportedUrls,
        }),
    }));
  const downloadedFiles = await download2(plannedDownloads);
  return Object.fromEntries(
    downloadedFiles
      .map((file2, index) =>
        file2 == null
          ? null
          : [
              plannedDownloads[index].url.toString(),
              { data: file2.data, mediaType: file2.mediaType },
            ],
      )
      .filter((file2) => file2 != null),
  );
}
function convertPartToLanguageModelPart(part, downloadedAssets) {
  var _a172;
  if (part.type === "text") {
    return {
      type: "text",
      text: part.text,
      providerOptions: part.providerOptions,
    };
  }
  let originalData;
  const type = part.type;
  switch (type) {
    case "image":
      originalData = part.image;
      break;
    case "file":
      originalData = part.data;
      break;
    default:
      throw new Error(`Unsupported part type: ${type}`);
  }
  const { data: convertedData, mediaType: convertedMediaType } =
    convertToLanguageModelV2DataContent(originalData);
  let mediaType =
    convertedMediaType != null ? convertedMediaType : part.mediaType;
  let data = convertedData;
  if (data instanceof URL) {
    const downloadedFile = downloadedAssets[data.toString()];
    if (downloadedFile) {
      data = downloadedFile.data;
      mediaType != null ? mediaType : (mediaType = downloadedFile.mediaType);
    }
  }
  switch (type) {
    case "image": {
      if (data instanceof Uint8Array || typeof data === "string") {
        mediaType =
          (_a172 = detectMediaType({
            data,
            signatures: imageMediaTypeSignatures,
          })) != null
            ? _a172
            : mediaType;
      }
      return {
        type: "file",
        mediaType: mediaType != null ? mediaType : "image/*",
        // any image
        filename: void 0,
        data,
        providerOptions: part.providerOptions,
      };
    }
    case "file": {
      if (mediaType == null) {
        throw new Error(`Media type is missing for file part`);
      }
      return {
        type: "file",
        mediaType,
        filename: part.filename,
        data,
        providerOptions: part.providerOptions,
      };
    }
  }
}
function prepareCallSettings({
  maxOutputTokens,
  temperature,
  topP,
  topK,
  presencePenalty,
  frequencyPenalty,
  seed,
  stopSequences,
}) {
  if (maxOutputTokens != null) {
    if (!Number.isInteger(maxOutputTokens)) {
      throw new InvalidArgumentError2({
        parameter: "maxOutputTokens",
        value: maxOutputTokens,
        message: "maxOutputTokens must be an integer",
      });
    }
    if (maxOutputTokens < 1) {
      throw new InvalidArgumentError2({
        parameter: "maxOutputTokens",
        value: maxOutputTokens,
        message: "maxOutputTokens must be >= 1",
      });
    }
  }
  if (temperature != null) {
    if (typeof temperature !== "number") {
      throw new InvalidArgumentError2({
        parameter: "temperature",
        value: temperature,
        message: "temperature must be a number",
      });
    }
  }
  if (topP != null) {
    if (typeof topP !== "number") {
      throw new InvalidArgumentError2({
        parameter: "topP",
        value: topP,
        message: "topP must be a number",
      });
    }
  }
  if (topK != null) {
    if (typeof topK !== "number") {
      throw new InvalidArgumentError2({
        parameter: "topK",
        value: topK,
        message: "topK must be a number",
      });
    }
  }
  if (presencePenalty != null) {
    if (typeof presencePenalty !== "number") {
      throw new InvalidArgumentError2({
        parameter: "presencePenalty",
        value: presencePenalty,
        message: "presencePenalty must be a number",
      });
    }
  }
  if (frequencyPenalty != null) {
    if (typeof frequencyPenalty !== "number") {
      throw new InvalidArgumentError2({
        parameter: "frequencyPenalty",
        value: frequencyPenalty,
        message: "frequencyPenalty must be a number",
      });
    }
  }
  if (seed != null) {
    if (!Number.isInteger(seed)) {
      throw new InvalidArgumentError2({
        parameter: "seed",
        value: seed,
        message: "seed must be an integer",
      });
    }
  }
  return {
    maxOutputTokens,
    temperature,
    topP,
    topK,
    presencePenalty,
    frequencyPenalty,
    stopSequences,
    seed,
  };
}
function isNonEmptyObject(object22) {
  return object22 != null && Object.keys(object22).length > 0;
}
function prepareToolsAndToolChoice({ tools: tools4, toolChoice, activeTools }) {
  if (!isNonEmptyObject(tools4)) {
    return {
      tools: void 0,
      toolChoice: void 0,
    };
  }
  const filteredTools =
    activeTools != null
      ? Object.entries(tools4).filter(([name172]) =>
          activeTools.includes(name172),
        )
      : Object.entries(tools4);
  return {
    tools: filteredTools.map(([name172, tool3]) => {
      const toolType = tool3.type;
      switch (toolType) {
        case void 0:
        case "dynamic":
        case "function":
          return {
            type: "function",
            name: name172,
            description: tool3.description,
            inputSchema: asSchema(tool3.inputSchema).jsonSchema,
            providerOptions: tool3.providerOptions,
          };
        case "provider-defined":
          return {
            type: "provider-defined",
            name: name172,
            id: tool3.id,
            args: tool3.args,
          };
        default: {
          const exhaustiveCheck = toolType;
          throw new Error(`Unsupported tool type: ${exhaustiveCheck}`);
        }
      }
    }),
    toolChoice:
      toolChoice == null
        ? { type: "auto" }
        : typeof toolChoice === "string"
          ? { type: toolChoice }
          : { type: "tool", toolName: toolChoice.toolName },
  };
}
var jsonValueSchema = external_exports.lazy(() =>
  external_exports.union([
    external_exports.null(),
    external_exports.string(),
    external_exports.number(),
    external_exports.boolean(),
    external_exports.record(external_exports.string(), jsonValueSchema),
    external_exports.array(jsonValueSchema),
  ]),
);
var providerMetadataSchema = external_exports.record(
  external_exports.string(),
  external_exports.record(external_exports.string(), jsonValueSchema),
);
var textPartSchema = external_exports.object({
  type: external_exports.literal("text"),
  text: external_exports.string(),
  providerOptions: providerMetadataSchema.optional(),
});
var imagePartSchema = external_exports.object({
  type: external_exports.literal("image"),
  image: external_exports.union([
    dataContentSchema,
    external_exports.instanceof(URL),
  ]),
  mediaType: external_exports.string().optional(),
  providerOptions: providerMetadataSchema.optional(),
});
var filePartSchema = external_exports.object({
  type: external_exports.literal("file"),
  data: external_exports.union([
    dataContentSchema,
    external_exports.instanceof(URL),
  ]),
  filename: external_exports.string().optional(),
  mediaType: external_exports.string(),
  providerOptions: providerMetadataSchema.optional(),
});
var reasoningPartSchema = external_exports.object({
  type: external_exports.literal("reasoning"),
  text: external_exports.string(),
  providerOptions: providerMetadataSchema.optional(),
});
var toolCallPartSchema = external_exports.object({
  type: external_exports.literal("tool-call"),
  toolCallId: external_exports.string(),
  toolName: external_exports.string(),
  input: external_exports.unknown(),
  providerOptions: providerMetadataSchema.optional(),
  providerExecuted: external_exports.boolean().optional(),
});
var outputSchema = external_exports.discriminatedUnion("type", [
  external_exports.object({
    type: external_exports.literal("text"),
    value: external_exports.string(),
  }),
  external_exports.object({
    type: external_exports.literal("json"),
    value: jsonValueSchema,
  }),
  external_exports.object({
    type: external_exports.literal("error-text"),
    value: external_exports.string(),
  }),
  external_exports.object({
    type: external_exports.literal("error-json"),
    value: jsonValueSchema,
  }),
  external_exports.object({
    type: external_exports.literal("content"),
    value: external_exports.array(
      external_exports.union([
        external_exports.object({
          type: external_exports.literal("text"),
          text: external_exports.string(),
        }),
        external_exports.object({
          type: external_exports.literal("media"),
          data: external_exports.string(),
          mediaType: external_exports.string(),
        }),
      ]),
    ),
  }),
]);
var toolResultPartSchema = external_exports.object({
  type: external_exports.literal("tool-result"),
  toolCallId: external_exports.string(),
  toolName: external_exports.string(),
  output: outputSchema,
  providerOptions: providerMetadataSchema.optional(),
});
var systemModelMessageSchema = external_exports.object({
  role: external_exports.literal("system"),
  content: external_exports.string(),
  providerOptions: providerMetadataSchema.optional(),
});
var userModelMessageSchema = external_exports.object({
  role: external_exports.literal("user"),
  content: external_exports.union([
    external_exports.string(),
    external_exports.array(
      external_exports.union([textPartSchema, imagePartSchema, filePartSchema]),
    ),
  ]),
  providerOptions: providerMetadataSchema.optional(),
});
var assistantModelMessageSchema = external_exports.object({
  role: external_exports.literal("assistant"),
  content: external_exports.union([
    external_exports.string(),
    external_exports.array(
      external_exports.union([
        textPartSchema,
        filePartSchema,
        reasoningPartSchema,
        toolCallPartSchema,
        toolResultPartSchema,
      ]),
    ),
  ]),
  providerOptions: providerMetadataSchema.optional(),
});
var toolModelMessageSchema = external_exports.object({
  role: external_exports.literal("tool"),
  content: external_exports.array(toolResultPartSchema),
  providerOptions: providerMetadataSchema.optional(),
});
var modelMessageSchema = external_exports.union([
  systemModelMessageSchema,
  userModelMessageSchema,
  assistantModelMessageSchema,
  toolModelMessageSchema,
]);
async function standardizePrompt(prompt) {
  if (prompt.prompt == null && prompt.messages == null) {
    throw new InvalidPromptError({
      prompt,
      message: "prompt or messages must be defined",
    });
  }
  if (prompt.prompt != null && prompt.messages != null) {
    throw new InvalidPromptError({
      prompt,
      message: "prompt and messages cannot be defined at the same time",
    });
  }
  if (prompt.system != null && typeof prompt.system !== "string") {
    throw new InvalidPromptError({
      prompt,
      message: "system must be a string",
    });
  }
  let messages;
  if (prompt.prompt != null && typeof prompt.prompt === "string") {
    messages = [{ role: "user", content: prompt.prompt }];
  } else if (prompt.prompt != null && Array.isArray(prompt.prompt)) {
    messages = prompt.prompt;
  } else if (prompt.messages != null) {
    messages = prompt.messages;
  } else {
    throw new InvalidPromptError({
      prompt,
      message: "prompt or messages must be defined",
    });
  }
  if (messages.length === 0) {
    throw new InvalidPromptError({
      prompt,
      message: "messages must not be empty",
    });
  }
  const validationResult = await safeValidateTypes({
    value: messages,
    schema: external_exports.array(modelMessageSchema),
  });
  if (!validationResult.success) {
    throw new InvalidPromptError({
      prompt,
      message:
        "The messages must be a ModelMessage[]. If you have passed a UIMessage[], you can use convertToModelMessages to convert them.",
      cause: validationResult.error,
    });
  }
  return {
    messages,
    system: prompt.system,
  };
}
function wrapGatewayError(error45) {
  if (
    GatewayAuthenticationError.isInstance(error45) ||
    GatewayModelNotFoundError.isInstance(error45)
  ) {
    return new AISDKError({
      name: "GatewayError",
      message:
        "Vercel AI Gateway access failed. If you want to use AI SDK providers directly, use the providers, e.g. @ai-sdk/openai, or register a different global default provider.",
      cause: error45,
    });
  }
  return error45;
}
function assembleOperationName({ operationId, telemetry }) {
  return {
    // standardized operation and resource name:
    "operation.name": `${operationId}${(telemetry == null ? void 0 : telemetry.functionId) != null ? ` ${telemetry.functionId}` : ""}`,
    "resource.name": telemetry == null ? void 0 : telemetry.functionId,
    // detailed, AI SDK specific data:
    "ai.operationId": operationId,
    "ai.telemetry.functionId":
      telemetry == null ? void 0 : telemetry.functionId,
  };
}
function getBaseTelemetryAttributes({ model, settings, telemetry, headers }) {
  var _a172;
  return {
    "ai.model.provider": model.provider,
    "ai.model.id": model.modelId,
    // settings:
    ...Object.entries(settings).reduce((attributes, [key, value]) => {
      attributes[`ai.settings.${key}`] = value;
      return attributes;
    }, {}),
    // add metadata as attributes:
    ...Object.entries(
      (_a172 = telemetry == null ? void 0 : telemetry.metadata) != null
        ? _a172
        : {},
    ).reduce((attributes, [key, value]) => {
      attributes[`ai.telemetry.metadata.${key}`] = value;
      return attributes;
    }, {}),
    // request headers
    ...Object.entries(headers != null ? headers : {}).reduce(
      (attributes, [key, value]) => {
        if (value !== void 0) {
          attributes[`ai.request.headers.${key}`] = value;
        }
        return attributes;
      },
      {},
    ),
  };
}
var noopTracer = {
  startSpan() {
    return noopSpan;
  },
  startActiveSpan(name172, arg1, arg2, arg3) {
    if (typeof arg1 === "function") {
      return arg1(noopSpan);
    }
    if (typeof arg2 === "function") {
      return arg2(noopSpan);
    }
    if (typeof arg3 === "function") {
      return arg3(noopSpan);
    }
  },
};
var noopSpan = {
  spanContext() {
    return noopSpanContext;
  },
  setAttribute() {
    return this;
  },
  setAttributes() {
    return this;
  },
  addEvent() {
    return this;
  },
  addLink() {
    return this;
  },
  addLinks() {
    return this;
  },
  setStatus() {
    return this;
  },
  updateName() {
    return this;
  },
  end() {
    return this;
  },
  isRecording() {
    return false;
  },
  recordException() {
    return this;
  },
};
var noopSpanContext = {
  traceId: "",
  spanId: "",
  traceFlags: 0,
};
function getTracer({ isEnabled = false, tracer } = {}) {
  if (!isEnabled) {
    return noopTracer;
  }
  if (tracer) {
    return tracer;
  }
  return trace.getTracer("ai");
}
function recordSpan({
  name: name172,
  tracer,
  attributes,
  fn,
  endWhenDone = true,
}) {
  return tracer.startActiveSpan(name172, { attributes }, async (span) => {
    try {
      const result = await fn(span);
      if (endWhenDone) {
        span.end();
      }
      return result;
    } catch (error45) {
      try {
        recordErrorOnSpan(span, error45);
      } finally {
        span.end();
      }
      throw error45;
    }
  });
}
function recordErrorOnSpan(span, error45) {
  if (error45 instanceof Error) {
    span.recordException({
      name: error45.name,
      message: error45.message,
      stack: error45.stack,
    });
    span.setStatus({
      code: SpanStatusCode.ERROR,
      message: error45.message,
    });
  } else {
    span.setStatus({ code: SpanStatusCode.ERROR });
  }
}
function selectTelemetryAttributes({ telemetry, attributes }) {
  if ((telemetry == null ? void 0 : telemetry.isEnabled) !== true) {
    return {};
  }
  return Object.entries(attributes).reduce((attributes2, [key, value]) => {
    if (value == null) {
      return attributes2;
    }
    if (
      typeof value === "object" &&
      "input" in value &&
      typeof value.input === "function"
    ) {
      if ((telemetry == null ? void 0 : telemetry.recordInputs) === false) {
        return attributes2;
      }
      const result = value.input();
      return result == null ? attributes2 : { ...attributes2, [key]: result };
    }
    if (
      typeof value === "object" &&
      "output" in value &&
      typeof value.output === "function"
    ) {
      if ((telemetry == null ? void 0 : telemetry.recordOutputs) === false) {
        return attributes2;
      }
      const result = value.output();
      return result == null ? attributes2 : { ...attributes2, [key]: result };
    }
    return { ...attributes2, [key]: value };
  }, {});
}
function stringifyForTelemetry(prompt) {
  return JSON.stringify(
    prompt.map((message) => ({
      ...message,
      content:
        typeof message.content === "string"
          ? message.content
          : message.content.map((part) =>
              part.type === "file"
                ? {
                    ...part,
                    data:
                      part.data instanceof Uint8Array
                        ? convertDataContentToBase64String(part.data)
                        : part.data,
                  }
                : part,
            ),
    })),
  );
}
function addLanguageModelUsage(usage1, usage2) {
  return {
    inputTokens: addTokenCounts(usage1.inputTokens, usage2.inputTokens),
    outputTokens: addTokenCounts(usage1.outputTokens, usage2.outputTokens),
    totalTokens: addTokenCounts(usage1.totalTokens, usage2.totalTokens),
    reasoningTokens: addTokenCounts(
      usage1.reasoningTokens,
      usage2.reasoningTokens,
    ),
    cachedInputTokens: addTokenCounts(
      usage1.cachedInputTokens,
      usage2.cachedInputTokens,
    ),
  };
}
function addTokenCounts(tokenCount1, tokenCount2) {
  return tokenCount1 == null && tokenCount2 == null
    ? void 0
    : (tokenCount1 != null ? tokenCount1 : 0) +
        (tokenCount2 != null ? tokenCount2 : 0);
}
function asArray(value) {
  return value === void 0 ? [] : Array.isArray(value) ? value : [value];
}
function getRetryDelayInMs({ error: error45, exponentialBackoffDelay }) {
  const headers = error45.responseHeaders;
  if (!headers) return exponentialBackoffDelay;
  let ms;
  const retryAfterMs = headers["retry-after-ms"];
  if (retryAfterMs) {
    const timeoutMs = parseFloat(retryAfterMs);
    if (!Number.isNaN(timeoutMs)) {
      ms = timeoutMs;
    }
  }
  const retryAfter = headers["retry-after"];
  if (retryAfter && ms === void 0) {
    const timeoutSeconds = parseFloat(retryAfter);
    if (!Number.isNaN(timeoutSeconds)) {
      ms = timeoutSeconds * 1e3;
    } else {
      ms = Date.parse(retryAfter) - Date.now();
    }
  }
  if (
    ms != null &&
    !Number.isNaN(ms) &&
    0 <= ms &&
    (ms < 60 * 1e3 || ms < exponentialBackoffDelay)
  ) {
    return ms;
  }
  return exponentialBackoffDelay;
}
var retryWithExponentialBackoffRespectingRetryHeaders =
  ({
    maxRetries = 2,
    initialDelayInMs = 2e3,
    backoffFactor = 2,
    abortSignal,
  } = {}) =>
  async (f2) =>
    _retryWithExponentialBackoff(f2, {
      maxRetries,
      delayInMs: initialDelayInMs,
      backoffFactor,
      abortSignal,
    });
async function _retryWithExponentialBackoff(
  f2,
  { maxRetries, delayInMs, backoffFactor, abortSignal },
  errors = [],
) {
  try {
    return await f2();
  } catch (error45) {
    if (isAbortError(error45)) {
      throw error45;
    }
    if (maxRetries === 0) {
      throw error45;
    }
    const errorMessage = getErrorMessage2(error45);
    const newErrors = [...errors, error45];
    const tryNumber = newErrors.length;
    if (tryNumber > maxRetries) {
      throw new RetryError({
        message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,
        reason: "maxRetriesExceeded",
        errors: newErrors,
      });
    }
    if (
      error45 instanceof Error &&
      APICallError.isInstance(error45) &&
      error45.isRetryable === true &&
      tryNumber <= maxRetries
    ) {
      await delay(
        getRetryDelayInMs({
          error: error45,
          exponentialBackoffDelay: delayInMs,
        }),
        { abortSignal },
      );
      return _retryWithExponentialBackoff(
        f2,
        {
          maxRetries,
          delayInMs: backoffFactor * delayInMs,
          backoffFactor,
          abortSignal,
        },
        newErrors,
      );
    }
    if (tryNumber === 1) {
      throw error45;
    }
    throw new RetryError({
      message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,
      reason: "errorNotRetryable",
      errors: newErrors,
    });
  }
}
function prepareRetries({ maxRetries, abortSignal }) {
  if (maxRetries != null) {
    if (!Number.isInteger(maxRetries)) {
      throw new InvalidArgumentError2({
        parameter: "maxRetries",
        value: maxRetries,
        message: "maxRetries must be an integer",
      });
    }
    if (maxRetries < 0) {
      throw new InvalidArgumentError2({
        parameter: "maxRetries",
        value: maxRetries,
        message: "maxRetries must be >= 0",
      });
    }
  }
  const maxRetriesResult = maxRetries != null ? maxRetries : 2;
  return {
    maxRetries: maxRetriesResult,
    retry: retryWithExponentialBackoffRespectingRetryHeaders({
      maxRetries: maxRetriesResult,
      abortSignal,
    }),
  };
}
var DefaultGeneratedFile = class {
  constructor({ data, mediaType }) {
    const isUint8Array = data instanceof Uint8Array;
    this.base64Data = isUint8Array ? void 0 : data;
    this.uint8ArrayData = isUint8Array ? data : void 0;
    this.mediaType = mediaType;
  }
  // lazy conversion with caching to avoid unnecessary conversion overhead:
  get base64() {
    if (this.base64Data == null) {
      this.base64Data = convertUint8ArrayToBase64(this.uint8ArrayData);
    }
    return this.base64Data;
  }
  // lazy conversion with caching to avoid unnecessary conversion overhead:
  get uint8Array() {
    if (this.uint8ArrayData == null) {
      this.uint8ArrayData = convertBase64ToUint8Array(this.base64Data);
    }
    return this.uint8ArrayData;
  }
};
var DefaultGeneratedFileWithType = class extends DefaultGeneratedFile {
  constructor(options) {
    super(options);
    this.type = "file";
  }
};
async function parseToolCall({
  toolCall,
  tools: tools4,
  repairToolCall,
  system,
  messages,
}) {
  try {
    if (tools4 == null) {
      throw new NoSuchToolError({ toolName: toolCall.toolName });
    }
    try {
      return await doParseToolCall({ toolCall, tools: tools4 });
    } catch (error45) {
      if (
        repairToolCall == null ||
        !(
          NoSuchToolError.isInstance(error45) ||
          InvalidToolInputError.isInstance(error45)
        )
      ) {
        throw error45;
      }
      let repairedToolCall = null;
      try {
        repairedToolCall = await repairToolCall({
          toolCall,
          tools: tools4,
          inputSchema: ({ toolName }) => {
            const { inputSchema } = tools4[toolName];
            return asSchema(inputSchema).jsonSchema;
          },
          system,
          messages,
          error: error45,
        });
      } catch (repairError) {
        throw new ToolCallRepairError({
          cause: repairError,
          originalError: error45,
        });
      }
      if (repairedToolCall == null) {
        throw error45;
      }
      return await doParseToolCall({
        toolCall: repairedToolCall,
        tools: tools4,
      });
    }
  } catch (error45) {
    const parsedInput = await safeParseJSON({ text: toolCall.input });
    const input = parsedInput.success ? parsedInput.value : toolCall.input;
    return {
      type: "tool-call",
      toolCallId: toolCall.toolCallId,
      toolName: toolCall.toolName,
      input,
      dynamic: true,
      invalid: true,
      error: error45,
    };
  }
}
async function doParseToolCall({ toolCall, tools: tools4 }) {
  const toolName = toolCall.toolName;
  const tool3 = tools4[toolName];
  if (tool3 == null) {
    throw new NoSuchToolError({
      toolName: toolCall.toolName,
      availableTools: Object.keys(tools4),
    });
  }
  const schema = asSchema(tool3.inputSchema);
  const parseResult =
    toolCall.input.trim() === ""
      ? await safeValidateTypes({ value: {}, schema })
      : await safeParseJSON({ text: toolCall.input, schema });
  if (parseResult.success === false) {
    throw new InvalidToolInputError({
      toolName,
      toolInput: toolCall.input,
      cause: parseResult.error,
    });
  }
  return tool3.type === "dynamic"
    ? {
        type: "tool-call",
        toolCallId: toolCall.toolCallId,
        toolName: toolCall.toolName,
        input: parseResult.value,
        providerExecuted: toolCall.providerExecuted,
        providerMetadata: toolCall.providerMetadata,
        dynamic: true,
      }
    : {
        type: "tool-call",
        toolCallId: toolCall.toolCallId,
        toolName,
        input: parseResult.value,
        providerExecuted: toolCall.providerExecuted,
        providerMetadata: toolCall.providerMetadata,
      };
}
var DefaultStepResult = class {
  constructor({
    content,
    finishReason,
    usage,
    warnings,
    request: request2,
    response,
    providerMetadata,
  }) {
    this.content = content;
    this.finishReason = finishReason;
    this.usage = usage;
    this.warnings = warnings;
    this.request = request2;
    this.response = response;
    this.providerMetadata = providerMetadata;
  }
  get text() {
    return this.content
      .filter((part) => part.type === "text")
      .map((part) => part.text)
      .join("");
  }
  get reasoning() {
    return this.content.filter((part) => part.type === "reasoning");
  }
  get reasoningText() {
    return this.reasoning.length === 0
      ? void 0
      : this.reasoning.map((part) => part.text).join("");
  }
  get files() {
    return this.content
      .filter((part) => part.type === "file")
      .map((part) => part.file);
  }
  get sources() {
    return this.content.filter((part) => part.type === "source");
  }
  get toolCalls() {
    return this.content.filter((part) => part.type === "tool-call");
  }
  get staticToolCalls() {
    return this.toolCalls.filter((toolCall) => toolCall.dynamic !== true);
  }
  get dynamicToolCalls() {
    return this.toolCalls.filter((toolCall) => toolCall.dynamic === true);
  }
  get toolResults() {
    return this.content.filter((part) => part.type === "tool-result");
  }
  get staticToolResults() {
    return this.toolResults.filter((toolResult) => toolResult.dynamic !== true);
  }
  get dynamicToolResults() {
    return this.toolResults.filter((toolResult) => toolResult.dynamic === true);
  }
};
function stepCountIs(stepCount) {
  return ({ steps }) => steps.length === stepCount;
}
async function isStopConditionMet({ stopConditions, steps }) {
  return (
    await Promise.all(stopConditions.map((condition) => condition({ steps })))
  ).some((result) => result);
}
function createToolModelOutput({ output, tool: tool3, errorMode }) {
  if (errorMode === "text") {
    return { type: "error-text", value: getErrorMessage(output) };
  } else if (errorMode === "json") {
    return { type: "error-json", value: toJSONValue(output) };
  }
  if (tool3 == null ? void 0 : tool3.toModelOutput) {
    return tool3.toModelOutput(output);
  }
  return typeof output === "string"
    ? { type: "text", value: output }
    : { type: "json", value: toJSONValue(output) };
}
function toJSONValue(value) {
  return value === void 0 ? null : value;
}
function toResponseMessages({ content: inputContent, tools: tools4 }) {
  const responseMessages = [];
  const content = inputContent
    .filter((part) => part.type !== "source")
    .filter(
      (part) =>
        (part.type !== "tool-result" || part.providerExecuted) &&
        (part.type !== "tool-error" || part.providerExecuted),
    )
    .filter((part) => part.type !== "text" || part.text.length > 0)
    .map((part) => {
      switch (part.type) {
        case "text":
          return {
            type: "text",
            text: part.text,
            providerOptions: part.providerMetadata,
          };
        case "reasoning":
          return {
            type: "reasoning",
            text: part.text,
            providerOptions: part.providerMetadata,
          };
        case "file":
          return {
            type: "file",
            data: part.file.base64,
            mediaType: part.file.mediaType,
            providerOptions: part.providerMetadata,
          };
        case "tool-call":
          return {
            type: "tool-call",
            toolCallId: part.toolCallId,
            toolName: part.toolName,
            input: part.input,
            providerExecuted: part.providerExecuted,
            providerOptions: part.providerMetadata,
          };
        case "tool-result":
          return {
            type: "tool-result",
            toolCallId: part.toolCallId,
            toolName: part.toolName,
            output: createToolModelOutput({
              tool: tools4 == null ? void 0 : tools4[part.toolName],
              output: part.output,
              errorMode: "none",
            }),
            providerExecuted: true,
            providerOptions: part.providerMetadata,
          };
        case "tool-error":
          return {
            type: "tool-result",
            toolCallId: part.toolCallId,
            toolName: part.toolName,
            output: createToolModelOutput({
              tool: tools4 == null ? void 0 : tools4[part.toolName],
              output: part.error,
              errorMode: "json",
            }),
            providerOptions: part.providerMetadata,
          };
      }
    });
  if (content.length > 0) {
    responseMessages.push({
      role: "assistant",
      content,
    });
  }
  const toolResultContent = inputContent
    .filter((part) => part.type === "tool-result" || part.type === "tool-error")
    .filter((part) => !part.providerExecuted)
    .map((toolResult) => ({
      type: "tool-result",
      toolCallId: toolResult.toolCallId,
      toolName: toolResult.toolName,
      output: createToolModelOutput({
        tool: tools4 == null ? void 0 : tools4[toolResult.toolName],
        output:
          toolResult.type === "tool-result"
            ? toolResult.output
            : toolResult.error,
        errorMode: toolResult.type === "tool-error" ? "text" : "none",
      }),
    }));
  if (toolResultContent.length > 0) {
    responseMessages.push({
      role: "tool",
      content: toolResultContent,
    });
  }
  return responseMessages;
}
var originalGenerateId = createIdGenerator({
  prefix: "aitxt",
  size: 24,
});
function prepareHeaders(headers, defaultHeaders) {
  const responseHeaders = new Headers(headers != null ? headers : {});
  for (const [key, value] of Object.entries(defaultHeaders)) {
    if (!responseHeaders.has(key)) {
      responseHeaders.set(key, value);
    }
  }
  return responseHeaders;
}
function createTextStreamResponse({ status, statusText, headers, textStream }) {
  return new Response(textStream.pipeThrough(new TextEncoderStream()), {
    status: status != null ? status : 200,
    statusText,
    headers: prepareHeaders(headers, {
      "content-type": "text/plain; charset=utf-8",
    }),
  });
}
function writeToServerResponse({
  response,
  status,
  statusText,
  headers,
  stream,
}) {
  response.writeHead(status != null ? status : 200, statusText, headers);
  const reader = stream.getReader();
  const read = async () => {
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        response.write(value);
      }
    } catch (error45) {
      throw error45;
    } finally {
      response.end();
    }
  };
  read();
}
function pipeTextStreamToResponse({
  response,
  status,
  statusText,
  headers,
  textStream,
}) {
  writeToServerResponse({
    response,
    status,
    statusText,
    headers: Object.fromEntries(
      prepareHeaders(headers, {
        "content-type": "text/plain; charset=utf-8",
      }).entries(),
    ),
    stream: textStream.pipeThrough(new TextEncoderStream()),
  });
}
var JsonToSseTransformStream = class extends TransformStream {
  constructor() {
    super({
      transform(part, controller) {
        controller.enqueue(`data: ${JSON.stringify(part)}

`);
      },
      flush(controller) {
        controller.enqueue("data: [DONE]\n\n");
      },
    });
  }
};
var UI_MESSAGE_STREAM_HEADERS = {
  "content-type": "text/event-stream",
  "cache-control": "no-cache",
  connection: "keep-alive",
  "x-vercel-ai-ui-message-stream": "v1",
  "x-accel-buffering": "no",
  // disable nginx buffering
};
function createUIMessageStreamResponse({
  status,
  statusText,
  headers,
  stream,
  consumeSseStream,
}) {
  let sseStream = stream.pipeThrough(new JsonToSseTransformStream());
  if (consumeSseStream) {
    const [stream1, stream2] = sseStream.tee();
    sseStream = stream1;
    consumeSseStream({ stream: stream2 });
  }
  return new Response(sseStream.pipeThrough(new TextEncoderStream()), {
    status,
    statusText,
    headers: prepareHeaders(headers, UI_MESSAGE_STREAM_HEADERS),
  });
}
function getResponseUIMessageId({ originalMessages, responseMessageId }) {
  if (originalMessages == null) {
    return void 0;
  }
  const lastMessage = originalMessages[originalMessages.length - 1];
  return (lastMessage == null ? void 0 : lastMessage.role) === "assistant"
    ? lastMessage.id
    : typeof responseMessageId === "function"
      ? responseMessageId()
      : responseMessageId;
}
var uiMessageChunkSchema = external_exports.union([
  external_exports.strictObject({
    type: external_exports.literal("text-start"),
    id: external_exports.string(),
    providerMetadata: providerMetadataSchema.optional(),
  }),
  external_exports.strictObject({
    type: external_exports.literal("text-delta"),
    id: external_exports.string(),
    delta: external_exports.string(),
    providerMetadata: providerMetadataSchema.optional(),
  }),
  external_exports.strictObject({
    type: external_exports.literal("text-end"),
    id: external_exports.string(),
    providerMetadata: providerMetadataSchema.optional(),
  }),
  external_exports.strictObject({
    type: external_exports.literal("error"),
    errorText: external_exports.string(),
  }),
  external_exports.strictObject({
    type: external_exports.literal("tool-input-start"),
    toolCallId: external_exports.string(),
    toolName: external_exports.string(),
    providerExecuted: external_exports.boolean().optional(),
    dynamic: external_exports.boolean().optional(),
  }),
  external_exports.strictObject({
    type: external_exports.literal("tool-input-delta"),
    toolCallId: external_exports.string(),
    inputTextDelta: external_exports.string(),
  }),
  external_exports.strictObject({
    type: external_exports.literal("tool-input-available"),
    toolCallId: external_exports.string(),
    toolName: external_exports.string(),
    input: external_exports.unknown(),
    providerExecuted: external_exports.boolean().optional(),
    providerMetadata: providerMetadataSchema.optional(),
    dynamic: external_exports.boolean().optional(),
  }),
  external_exports.strictObject({
    type: external_exports.literal("tool-input-error"),
    toolCallId: external_exports.string(),
    toolName: external_exports.string(),
    input: external_exports.unknown(),
    providerExecuted: external_exports.boolean().optional(),
    providerMetadata: providerMetadataSchema.optional(),
    dynamic: external_exports.boolean().optional(),
    errorText: external_exports.string(),
  }),
  external_exports.strictObject({
    type: external_exports.literal("tool-output-available"),
    toolCallId: external_exports.string(),
    output: external_exports.unknown(),
    providerExecuted: external_exports.boolean().optional(),
    dynamic: external_exports.boolean().optional(),
    preliminary: external_exports.boolean().optional(),
  }),
  external_exports.strictObject({
    type: external_exports.literal("tool-output-error"),
    toolCallId: external_exports.string(),
    errorText: external_exports.string(),
    providerExecuted: external_exports.boolean().optional(),
    dynamic: external_exports.boolean().optional(),
  }),
  external_exports.strictObject({
    type: external_exports.literal("reasoning-start"),
    id: external_exports.string(),
    providerMetadata: providerMetadataSchema.optional(),
  }),
  external_exports.strictObject({
    type: external_exports.literal("reasoning-delta"),
    id: external_exports.string(),
    delta: external_exports.string(),
    providerMetadata: providerMetadataSchema.optional(),
  }),
  external_exports.strictObject({
    type: external_exports.literal("reasoning-end"),
    id: external_exports.string(),
    providerMetadata: providerMetadataSchema.optional(),
  }),
  external_exports.strictObject({
    type: external_exports.literal("source-url"),
    sourceId: external_exports.string(),
    url: external_exports.string(),
    title: external_exports.string().optional(),
    providerMetadata: providerMetadataSchema.optional(),
  }),
  external_exports.strictObject({
    type: external_exports.literal("source-document"),
    sourceId: external_exports.string(),
    mediaType: external_exports.string(),
    title: external_exports.string(),
    filename: external_exports.string().optional(),
    providerMetadata: providerMetadataSchema.optional(),
  }),
  external_exports.strictObject({
    type: external_exports.literal("file"),
    url: external_exports.string(),
    mediaType: external_exports.string(),
    providerMetadata: providerMetadataSchema.optional(),
  }),
  external_exports.strictObject({
    type: external_exports.custom(
      (value) => typeof value === "string" && value.startsWith("data-"),
      { message: 'Type must start with "data-"' },
    ),
    id: external_exports.string().optional(),
    data: external_exports.unknown(),
    transient: external_exports.boolean().optional(),
  }),
  external_exports.strictObject({
    type: external_exports.literal("start-step"),
  }),
  external_exports.strictObject({
    type: external_exports.literal("finish-step"),
  }),
  external_exports.strictObject({
    type: external_exports.literal("start"),
    messageId: external_exports.string().optional(),
    messageMetadata: external_exports.unknown().optional(),
  }),
  external_exports.strictObject({
    type: external_exports.literal("finish"),
    messageMetadata: external_exports.unknown().optional(),
  }),
  external_exports.strictObject({
    type: external_exports.literal("abort"),
  }),
  external_exports.strictObject({
    type: external_exports.literal("message-metadata"),
    messageMetadata: external_exports.unknown(),
  }),
]);
function isDataUIMessageChunk(chunk) {
  return chunk.type.startsWith("data-");
}
function mergeObjects(base, overrides) {
  if (base === void 0 && overrides === void 0) {
    return void 0;
  }
  if (base === void 0) {
    return overrides;
  }
  if (overrides === void 0) {
    return base;
  }
  const result = { ...base };
  for (const key in overrides) {
    if (Object.prototype.hasOwnProperty.call(overrides, key)) {
      const overridesValue = overrides[key];
      if (overridesValue === void 0) continue;
      const baseValue = key in base ? base[key] : void 0;
      const isSourceObject =
        overridesValue !== null &&
        typeof overridesValue === "object" &&
        !Array.isArray(overridesValue) &&
        !(overridesValue instanceof Date) &&
        !(overridesValue instanceof RegExp);
      const isTargetObject =
        baseValue !== null &&
        baseValue !== void 0 &&
        typeof baseValue === "object" &&
        !Array.isArray(baseValue) &&
        !(baseValue instanceof Date) &&
        !(baseValue instanceof RegExp);
      if (isSourceObject && isTargetObject) {
        result[key] = mergeObjects(baseValue, overridesValue);
      } else {
        result[key] = overridesValue;
      }
    }
  }
  return result;
}
function fixJson(input) {
  const stack = ["ROOT"];
  let lastValidIndex = -1;
  let literalStart = null;
  function processValueStart(char, i2, swapState) {
    {
      switch (char) {
        case '"': {
          lastValidIndex = i2;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_STRING");
          break;
        }
        case "f":
        case "t":
        case "n": {
          lastValidIndex = i2;
          literalStart = i2;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_LITERAL");
          break;
        }
        case "-": {
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_NUMBER");
          break;
        }
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9": {
          lastValidIndex = i2;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_NUMBER");
          break;
        }
        case "{": {
          lastValidIndex = i2;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_OBJECT_START");
          break;
        }
        case "[": {
          lastValidIndex = i2;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_ARRAY_START");
          break;
        }
      }
    }
  }
  function processAfterObjectValue(char, i2) {
    switch (char) {
      case ",": {
        stack.pop();
        stack.push("INSIDE_OBJECT_AFTER_COMMA");
        break;
      }
      case "}": {
        lastValidIndex = i2;
        stack.pop();
        break;
      }
    }
  }
  function processAfterArrayValue(char, i2) {
    switch (char) {
      case ",": {
        stack.pop();
        stack.push("INSIDE_ARRAY_AFTER_COMMA");
        break;
      }
      case "]": {
        lastValidIndex = i2;
        stack.pop();
        break;
      }
    }
  }
  for (let i2 = 0; i2 < input.length; i2++) {
    const char = input[i2];
    const currentState = stack[stack.length - 1];
    switch (currentState) {
      case "ROOT":
        processValueStart(char, i2, "FINISH");
        break;
      case "INSIDE_OBJECT_START": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_KEY");
            break;
          }
          case "}": {
            lastValidIndex = i2;
            stack.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_COMMA": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_KEY": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_AFTER_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_KEY": {
        switch (char) {
          case ":": {
            stack.pop();
            stack.push("INSIDE_OBJECT_BEFORE_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_BEFORE_VALUE": {
        processValueStart(char, i2, "INSIDE_OBJECT_AFTER_VALUE");
        break;
      }
      case "INSIDE_OBJECT_AFTER_VALUE": {
        processAfterObjectValue(char, i2);
        break;
      }
      case "INSIDE_STRING": {
        switch (char) {
          case '"': {
            stack.pop();
            lastValidIndex = i2;
            break;
          }
          case "\\": {
            stack.push("INSIDE_STRING_ESCAPE");
            break;
          }
          default: {
            lastValidIndex = i2;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_START": {
        switch (char) {
          case "]": {
            lastValidIndex = i2;
            stack.pop();
            break;
          }
          default: {
            lastValidIndex = i2;
            processValueStart(char, i2, "INSIDE_ARRAY_AFTER_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_VALUE": {
        switch (char) {
          case ",": {
            stack.pop();
            stack.push("INSIDE_ARRAY_AFTER_COMMA");
            break;
          }
          case "]": {
            lastValidIndex = i2;
            stack.pop();
            break;
          }
          default: {
            lastValidIndex = i2;
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_COMMA": {
        processValueStart(char, i2, "INSIDE_ARRAY_AFTER_VALUE");
        break;
      }
      case "INSIDE_STRING_ESCAPE": {
        stack.pop();
        lastValidIndex = i2;
        break;
      }
      case "INSIDE_NUMBER": {
        switch (char) {
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9": {
            lastValidIndex = i2;
            break;
          }
          case "e":
          case "E":
          case "-":
          case ".": {
            break;
          }
          case ",": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
              processAfterArrayValue(char, i2);
            }
            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
              processAfterObjectValue(char, i2);
            }
            break;
          }
          case "}": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
              processAfterObjectValue(char, i2);
            }
            break;
          }
          case "]": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
              processAfterArrayValue(char, i2);
            }
            break;
          }
          default: {
            stack.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_LITERAL": {
        const partialLiteral = input.substring(literalStart, i2 + 1);
        if (
          !"false".startsWith(partialLiteral) &&
          !"true".startsWith(partialLiteral) &&
          !"null".startsWith(partialLiteral)
        ) {
          stack.pop();
          if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
            processAfterObjectValue(char, i2);
          } else if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
            processAfterArrayValue(char, i2);
          }
        } else {
          lastValidIndex = i2;
        }
        break;
      }
    }
  }
  let result = input.slice(0, lastValidIndex + 1);
  for (let i2 = stack.length - 1; i2 >= 0; i2--) {
    const state = stack[i2];
    switch (state) {
      case "INSIDE_STRING": {
        result += '"';
        break;
      }
      case "INSIDE_OBJECT_KEY":
      case "INSIDE_OBJECT_AFTER_KEY":
      case "INSIDE_OBJECT_AFTER_COMMA":
      case "INSIDE_OBJECT_START":
      case "INSIDE_OBJECT_BEFORE_VALUE":
      case "INSIDE_OBJECT_AFTER_VALUE": {
        result += "}";
        break;
      }
      case "INSIDE_ARRAY_START":
      case "INSIDE_ARRAY_AFTER_COMMA":
      case "INSIDE_ARRAY_AFTER_VALUE": {
        result += "]";
        break;
      }
      case "INSIDE_LITERAL": {
        const partialLiteral = input.substring(literalStart, input.length);
        if ("true".startsWith(partialLiteral)) {
          result += "true".slice(partialLiteral.length);
        } else if ("false".startsWith(partialLiteral)) {
          result += "false".slice(partialLiteral.length);
        } else if ("null".startsWith(partialLiteral)) {
          result += "null".slice(partialLiteral.length);
        }
      }
    }
  }
  return result;
}
async function parsePartialJson(jsonText) {
  if (jsonText === void 0) {
    return { value: void 0, state: "undefined-input" };
  }
  let result = await safeParseJSON({ text: jsonText });
  if (result.success) {
    return { value: result.value, state: "successful-parse" };
  }
  result = await safeParseJSON({ text: fixJson(jsonText) });
  if (result.success) {
    return { value: result.value, state: "repaired-parse" };
  }
  return { value: void 0, state: "failed-parse" };
}
function isToolUIPart(part) {
  return part.type.startsWith("tool-");
}
function isDynamicToolUIPart(part) {
  return part.type === "dynamic-tool";
}
function isToolOrDynamicToolUIPart(part) {
  return isToolUIPart(part) || isDynamicToolUIPart(part);
}
function getToolName(part) {
  return part.type.split("-").slice(1).join("-");
}
function createStreamingUIMessageState({ lastMessage, messageId }) {
  return {
    message:
      (lastMessage == null ? void 0 : lastMessage.role) === "assistant"
        ? lastMessage
        : {
            id: messageId,
            metadata: void 0,
            role: "assistant",
            parts: [],
          },
    activeTextParts: {},
    activeReasoningParts: {},
    partialToolCalls: {},
  };
}
function processUIMessageStream({
  stream,
  messageMetadataSchema,
  dataPartSchemas,
  runUpdateMessageJob,
  onError,
  onToolCall,
  onData,
}) {
  return stream.pipeThrough(
    new TransformStream({
      async transform(chunk, controller) {
        await runUpdateMessageJob(async ({ state, write }) => {
          var _a172, _b9, _c, _d;
          function getToolInvocation(toolCallId) {
            const toolInvocations = state.message.parts.filter(isToolUIPart);
            const toolInvocation = toolInvocations.find(
              (invocation) => invocation.toolCallId === toolCallId,
            );
            if (toolInvocation == null) {
              throw new Error(
                "tool-output-error must be preceded by a tool-input-available",
              );
            }
            return toolInvocation;
          }
          function getDynamicToolInvocation(toolCallId) {
            const toolInvocations = state.message.parts.filter(
              (part) => part.type === "dynamic-tool",
            );
            const toolInvocation = toolInvocations.find(
              (invocation) => invocation.toolCallId === toolCallId,
            );
            if (toolInvocation == null) {
              throw new Error(
                "tool-output-error must be preceded by a tool-input-available",
              );
            }
            return toolInvocation;
          }
          function updateToolPart(options) {
            var _a182;
            const part = state.message.parts.find(
              (part2) =>
                isToolUIPart(part2) && part2.toolCallId === options.toolCallId,
            );
            const anyOptions = options;
            const anyPart = part;
            if (part != null) {
              part.state = options.state;
              anyPart.input = anyOptions.input;
              anyPart.output = anyOptions.output;
              anyPart.errorText = anyOptions.errorText;
              anyPart.rawInput = anyOptions.rawInput;
              anyPart.preliminary = anyOptions.preliminary;
              anyPart.providerExecuted =
                (_a182 = anyOptions.providerExecuted) != null
                  ? _a182
                  : part.providerExecuted;
              if (
                anyOptions.providerMetadata != null &&
                part.state === "input-available"
              ) {
                part.callProviderMetadata = anyOptions.providerMetadata;
              }
            } else {
              state.message.parts.push({
                type: `tool-${options.toolName}`,
                toolCallId: options.toolCallId,
                state: options.state,
                input: anyOptions.input,
                output: anyOptions.output,
                rawInput: anyOptions.rawInput,
                errorText: anyOptions.errorText,
                providerExecuted: anyOptions.providerExecuted,
                preliminary: anyOptions.preliminary,
                ...(anyOptions.providerMetadata != null
                  ? { callProviderMetadata: anyOptions.providerMetadata }
                  : {}),
              });
            }
          }
          function updateDynamicToolPart(options) {
            var _a182;
            const part = state.message.parts.find(
              (part2) =>
                part2.type === "dynamic-tool" &&
                part2.toolCallId === options.toolCallId,
            );
            const anyOptions = options;
            const anyPart = part;
            if (part != null) {
              part.state = options.state;
              anyPart.toolName = options.toolName;
              anyPart.input = anyOptions.input;
              anyPart.output = anyOptions.output;
              anyPart.errorText = anyOptions.errorText;
              anyPart.rawInput =
                (_a182 = anyOptions.rawInput) != null
                  ? _a182
                  : anyPart.rawInput;
              anyPart.preliminary = anyOptions.preliminary;
              if (
                anyOptions.providerMetadata != null &&
                part.state === "input-available"
              ) {
                part.callProviderMetadata = anyOptions.providerMetadata;
              }
            } else {
              state.message.parts.push({
                type: "dynamic-tool",
                toolName: options.toolName,
                toolCallId: options.toolCallId,
                state: options.state,
                input: anyOptions.input,
                output: anyOptions.output,
                errorText: anyOptions.errorText,
                preliminary: anyOptions.preliminary,
                ...(anyOptions.providerMetadata != null
                  ? { callProviderMetadata: anyOptions.providerMetadata }
                  : {}),
              });
            }
          }
          async function updateMessageMetadata(metadata) {
            if (metadata != null) {
              const mergedMetadata =
                state.message.metadata != null
                  ? mergeObjects(state.message.metadata, metadata)
                  : metadata;
              if (messageMetadataSchema != null) {
                await validateTypes({
                  value: mergedMetadata,
                  schema: messageMetadataSchema,
                });
              }
              state.message.metadata = mergedMetadata;
            }
          }
          switch (chunk.type) {
            case "text-start": {
              const textPart = {
                type: "text",
                text: "",
                providerMetadata: chunk.providerMetadata,
                state: "streaming",
              };
              state.activeTextParts[chunk.id] = textPart;
              state.message.parts.push(textPart);
              write();
              break;
            }
            case "text-delta": {
              const textPart = state.activeTextParts[chunk.id];
              textPart.text += chunk.delta;
              textPart.providerMetadata =
                (_a172 = chunk.providerMetadata) != null
                  ? _a172
                  : textPart.providerMetadata;
              write();
              break;
            }
            case "text-end": {
              const textPart = state.activeTextParts[chunk.id];
              textPart.state = "done";
              textPart.providerMetadata =
                (_b9 = chunk.providerMetadata) != null
                  ? _b9
                  : textPart.providerMetadata;
              delete state.activeTextParts[chunk.id];
              write();
              break;
            }
            case "reasoning-start": {
              const reasoningPart = {
                type: "reasoning",
                text: "",
                providerMetadata: chunk.providerMetadata,
                state: "streaming",
              };
              state.activeReasoningParts[chunk.id] = reasoningPart;
              state.message.parts.push(reasoningPart);
              write();
              break;
            }
            case "reasoning-delta": {
              const reasoningPart = state.activeReasoningParts[chunk.id];
              reasoningPart.text += chunk.delta;
              reasoningPart.providerMetadata =
                (_c = chunk.providerMetadata) != null
                  ? _c
                  : reasoningPart.providerMetadata;
              write();
              break;
            }
            case "reasoning-end": {
              const reasoningPart = state.activeReasoningParts[chunk.id];
              reasoningPart.providerMetadata =
                (_d = chunk.providerMetadata) != null
                  ? _d
                  : reasoningPart.providerMetadata;
              reasoningPart.state = "done";
              delete state.activeReasoningParts[chunk.id];
              write();
              break;
            }
            case "file": {
              state.message.parts.push({
                type: "file",
                mediaType: chunk.mediaType,
                url: chunk.url,
              });
              write();
              break;
            }
            case "source-url": {
              state.message.parts.push({
                type: "source-url",
                sourceId: chunk.sourceId,
                url: chunk.url,
                title: chunk.title,
                providerMetadata: chunk.providerMetadata,
              });
              write();
              break;
            }
            case "source-document": {
              state.message.parts.push({
                type: "source-document",
                sourceId: chunk.sourceId,
                mediaType: chunk.mediaType,
                title: chunk.title,
                filename: chunk.filename,
                providerMetadata: chunk.providerMetadata,
              });
              write();
              break;
            }
            case "tool-input-start": {
              const toolInvocations = state.message.parts.filter(isToolUIPart);
              state.partialToolCalls[chunk.toolCallId] = {
                text: "",
                toolName: chunk.toolName,
                index: toolInvocations.length,
                dynamic: chunk.dynamic,
              };
              if (chunk.dynamic) {
                updateDynamicToolPart({
                  toolCallId: chunk.toolCallId,
                  toolName: chunk.toolName,
                  state: "input-streaming",
                  input: void 0,
                });
              } else {
                updateToolPart({
                  toolCallId: chunk.toolCallId,
                  toolName: chunk.toolName,
                  state: "input-streaming",
                  input: void 0,
                  providerExecuted: chunk.providerExecuted,
                });
              }
              write();
              break;
            }
            case "tool-input-delta": {
              const partialToolCall = state.partialToolCalls[chunk.toolCallId];
              partialToolCall.text += chunk.inputTextDelta;
              const { value: partialArgs } = await parsePartialJson(
                partialToolCall.text,
              );
              if (partialToolCall.dynamic) {
                updateDynamicToolPart({
                  toolCallId: chunk.toolCallId,
                  toolName: partialToolCall.toolName,
                  state: "input-streaming",
                  input: partialArgs,
                });
              } else {
                updateToolPart({
                  toolCallId: chunk.toolCallId,
                  toolName: partialToolCall.toolName,
                  state: "input-streaming",
                  input: partialArgs,
                });
              }
              write();
              break;
            }
            case "tool-input-available": {
              if (chunk.dynamic) {
                updateDynamicToolPart({
                  toolCallId: chunk.toolCallId,
                  toolName: chunk.toolName,
                  state: "input-available",
                  input: chunk.input,
                  providerMetadata: chunk.providerMetadata,
                });
              } else {
                updateToolPart({
                  toolCallId: chunk.toolCallId,
                  toolName: chunk.toolName,
                  state: "input-available",
                  input: chunk.input,
                  providerExecuted: chunk.providerExecuted,
                  providerMetadata: chunk.providerMetadata,
                });
              }
              write();
              if (onToolCall && !chunk.providerExecuted) {
                await onToolCall({
                  toolCall: chunk,
                });
              }
              break;
            }
            case "tool-input-error": {
              if (chunk.dynamic) {
                updateDynamicToolPart({
                  toolCallId: chunk.toolCallId,
                  toolName: chunk.toolName,
                  state: "output-error",
                  input: chunk.input,
                  errorText: chunk.errorText,
                  providerMetadata: chunk.providerMetadata,
                });
              } else {
                updateToolPart({
                  toolCallId: chunk.toolCallId,
                  toolName: chunk.toolName,
                  state: "output-error",
                  input: void 0,
                  rawInput: chunk.input,
                  errorText: chunk.errorText,
                  providerExecuted: chunk.providerExecuted,
                  providerMetadata: chunk.providerMetadata,
                });
              }
              write();
              break;
            }
            case "tool-output-available": {
              if (chunk.dynamic) {
                const toolInvocation = getDynamicToolInvocation(
                  chunk.toolCallId,
                );
                updateDynamicToolPart({
                  toolCallId: chunk.toolCallId,
                  toolName: toolInvocation.toolName,
                  state: "output-available",
                  input: toolInvocation.input,
                  output: chunk.output,
                  preliminary: chunk.preliminary,
                });
              } else {
                const toolInvocation = getToolInvocation(chunk.toolCallId);
                updateToolPart({
                  toolCallId: chunk.toolCallId,
                  toolName: getToolName(toolInvocation),
                  state: "output-available",
                  input: toolInvocation.input,
                  output: chunk.output,
                  providerExecuted: chunk.providerExecuted,
                  preliminary: chunk.preliminary,
                });
              }
              write();
              break;
            }
            case "tool-output-error": {
              if (chunk.dynamic) {
                const toolInvocation = getDynamicToolInvocation(
                  chunk.toolCallId,
                );
                updateDynamicToolPart({
                  toolCallId: chunk.toolCallId,
                  toolName: toolInvocation.toolName,
                  state: "output-error",
                  input: toolInvocation.input,
                  errorText: chunk.errorText,
                });
              } else {
                const toolInvocation = getToolInvocation(chunk.toolCallId);
                updateToolPart({
                  toolCallId: chunk.toolCallId,
                  toolName: getToolName(toolInvocation),
                  state: "output-error",
                  input: toolInvocation.input,
                  rawInput: toolInvocation.rawInput,
                  errorText: chunk.errorText,
                });
              }
              write();
              break;
            }
            case "start-step": {
              state.message.parts.push({ type: "step-start" });
              break;
            }
            case "finish-step": {
              state.activeTextParts = {};
              state.activeReasoningParts = {};
              break;
            }
            case "start": {
              if (chunk.messageId != null) {
                state.message.id = chunk.messageId;
              }
              await updateMessageMetadata(chunk.messageMetadata);
              if (chunk.messageId != null || chunk.messageMetadata != null) {
                write();
              }
              break;
            }
            case "finish": {
              await updateMessageMetadata(chunk.messageMetadata);
              if (chunk.messageMetadata != null) {
                write();
              }
              break;
            }
            case "message-metadata": {
              await updateMessageMetadata(chunk.messageMetadata);
              if (chunk.messageMetadata != null) {
                write();
              }
              break;
            }
            case "error": {
              onError == null ? void 0 : onError(new Error(chunk.errorText));
              break;
            }
            default: {
              if (isDataUIMessageChunk(chunk)) {
                if (
                  (dataPartSchemas == null
                    ? void 0
                    : dataPartSchemas[chunk.type]) != null
                ) {
                  await validateTypes({
                    value: chunk.data,
                    schema: dataPartSchemas[chunk.type],
                  });
                }
                const dataChunk = chunk;
                if (dataChunk.transient) {
                  onData == null ? void 0 : onData(dataChunk);
                  break;
                }
                const existingUIPart =
                  dataChunk.id != null
                    ? state.message.parts.find(
                        (chunkArg) =>
                          dataChunk.type === chunkArg.type &&
                          dataChunk.id === chunkArg.id,
                      )
                    : void 0;
                if (existingUIPart != null) {
                  existingUIPart.data = dataChunk.data;
                } else {
                  state.message.parts.push(dataChunk);
                }
                onData == null ? void 0 : onData(dataChunk);
                write();
              }
            }
          }
          controller.enqueue(chunk);
        });
      },
    }),
  );
}
function handleUIMessageStreamFinish({
  messageId,
  originalMessages = [],
  onFinish,
  onError,
  stream,
}) {
  let lastMessage =
    originalMessages == null
      ? void 0
      : originalMessages[originalMessages.length - 1];
  if ((lastMessage == null ? void 0 : lastMessage.role) !== "assistant") {
    lastMessage = void 0;
  } else {
    messageId = lastMessage.id;
  }
  let isAborted2 = false;
  const idInjectedStream = stream.pipeThrough(
    new TransformStream({
      transform(chunk, controller) {
        if (chunk.type === "start") {
          const startChunk = chunk;
          if (startChunk.messageId == null && messageId != null) {
            startChunk.messageId = messageId;
          }
        }
        if (chunk.type === "abort") {
          isAborted2 = true;
        }
        controller.enqueue(chunk);
      },
    }),
  );
  if (onFinish == null) {
    return idInjectedStream;
  }
  const state = createStreamingUIMessageState({
    lastMessage: lastMessage ? structuredClone(lastMessage) : void 0,
    messageId: messageId != null ? messageId : "",
    // will be overridden by the stream
  });
  const runUpdateMessageJob = async (job) => {
    await job({ state, write: () => {} });
  };
  let finishCalled = false;
  const callOnFinish = async () => {
    if (finishCalled || !onFinish) {
      return;
    }
    finishCalled = true;
    const isContinuation =
      state.message.id === (lastMessage == null ? void 0 : lastMessage.id);
    await onFinish({
      isAborted: isAborted2,
      isContinuation,
      responseMessage: state.message,
      messages: [
        ...(isContinuation ? originalMessages.slice(0, -1) : originalMessages),
        state.message,
      ],
    });
  };
  return processUIMessageStream({
    stream: idInjectedStream,
    runUpdateMessageJob,
    onError,
  }).pipeThrough(
    new TransformStream({
      transform(chunk, controller) {
        controller.enqueue(chunk);
      },
      // @ts-expect-error cancel is still new and missing from types https://developer.mozilla.org/en-US/docs/Web/API/TransformStream#browser_compatibility
      async cancel() {
        await callOnFinish();
      },
      async flush() {
        await callOnFinish();
      },
    }),
  );
}
function pipeUIMessageStreamToResponse({
  response,
  status,
  statusText,
  headers,
  stream,
  consumeSseStream,
}) {
  let sseStream = stream.pipeThrough(new JsonToSseTransformStream());
  if (consumeSseStream) {
    const [stream1, stream2] = sseStream.tee();
    sseStream = stream1;
    consumeSseStream({ stream: stream2 });
  }
  writeToServerResponse({
    response,
    status,
    statusText,
    headers: Object.fromEntries(
      prepareHeaders(headers, UI_MESSAGE_STREAM_HEADERS).entries(),
    ),
    stream: sseStream.pipeThrough(new TextEncoderStream()),
  });
}
function createAsyncIterableStream(source) {
  const stream = source.pipeThrough(new TransformStream());
  stream[Symbol.asyncIterator] = function () {
    const reader = this.getReader();
    let finished = false;
    async function cleanup(cancelStream) {
      var _a172;
      finished = true;
      try {
        if (cancelStream) {
          await ((_a172 = reader.cancel) == null ? void 0 : _a172.call(reader));
        }
      } finally {
        try {
          reader.releaseLock();
        } catch (e2) {}
      }
    }
    return {
      /**
       * Reads the next chunk from the stream.
       * @returns A promise resolving to the next IteratorResult.
       */
      async next() {
        if (finished) {
          return { done: true, value: void 0 };
        }
        const { done, value } = await reader.read();
        if (done) {
          await cleanup(true);
          return { done: true, value: void 0 };
        }
        return { done: false, value };
      },
      /**
       * Called on early exit (e.g., break from for-await).
       * Ensures the stream is cancelled and resources are released.
       * @returns A promise resolving to a completed IteratorResult.
       */
      async return() {
        await cleanup(true);
        return { done: true, value: void 0 };
      },
      /**
       * Called on early exit with error.
       * Ensures the stream is cancelled and resources are released, then rethrows the error.
       * @param err The error to throw.
       * @returns A promise that rejects with the provided error.
       */
      async throw(err2) {
        await cleanup(true);
        throw err2;
      },
    };
  };
  return stream;
}
async function consumeStream({ stream, onError }) {
  const reader = stream.getReader();
  try {
    while (true) {
      const { done } = await reader.read();
      if (done) break;
    }
  } catch (error45) {
    onError == null ? void 0 : onError(error45);
  } finally {
    reader.releaseLock();
  }
}
function createResolvablePromise() {
  let resolve2;
  let reject;
  const promise2 = new Promise((res, rej) => {
    resolve2 = res;
    reject = rej;
  });
  return {
    promise: promise2,
    resolve: resolve2,
    reject,
  };
}
function createStitchableStream() {
  let innerStreamReaders = [];
  let controller = null;
  let isClosed = false;
  let waitForNewStream = createResolvablePromise();
  const terminate = () => {
    isClosed = true;
    waitForNewStream.resolve();
    innerStreamReaders.forEach((reader) => reader.cancel());
    innerStreamReaders = [];
    controller == null ? void 0 : controller.close();
  };
  const processPull = async () => {
    if (isClosed && innerStreamReaders.length === 0) {
      controller == null ? void 0 : controller.close();
      return;
    }
    if (innerStreamReaders.length === 0) {
      waitForNewStream = createResolvablePromise();
      await waitForNewStream.promise;
      return processPull();
    }
    try {
      const { value, done } = await innerStreamReaders[0].read();
      if (done) {
        innerStreamReaders.shift();
        if (innerStreamReaders.length > 0) {
          await processPull();
        } else if (isClosed) {
          controller == null ? void 0 : controller.close();
        }
      } else {
        controller == null ? void 0 : controller.enqueue(value);
      }
    } catch (error45) {
      controller == null ? void 0 : controller.error(error45);
      innerStreamReaders.shift();
      terminate();
    }
  };
  return {
    stream: new ReadableStream({
      start(controllerParam) {
        controller = controllerParam;
      },
      pull: processPull,
      async cancel() {
        for (const reader of innerStreamReaders) {
          await reader.cancel();
        }
        innerStreamReaders = [];
        isClosed = true;
      },
    }),
    addStream: (innerStream) => {
      if (isClosed) {
        throw new Error("Cannot add inner stream: outer stream is closed");
      }
      innerStreamReaders.push(innerStream.getReader());
      waitForNewStream.resolve();
    },
    /**
     * Gracefully close the outer stream. This will let the inner streams
     * finish processing and then close the outer stream.
     */
    close: () => {
      isClosed = true;
      waitForNewStream.resolve();
      if (innerStreamReaders.length === 0) {
        controller == null ? void 0 : controller.close();
      }
    },
    /**
     * Immediately close the outer stream. This will cancel all inner streams
     * and close the outer stream.
     */
    terminate,
  };
}
var DelayedPromise = class {
  constructor() {
    this.status = { type: "pending" };
    this._resolve = void 0;
    this._reject = void 0;
  }
  get promise() {
    if (this._promise) {
      return this._promise;
    }
    this._promise = new Promise((resolve2, reject) => {
      if (this.status.type === "resolved") {
        resolve2(this.status.value);
      } else if (this.status.type === "rejected") {
        reject(this.status.error);
      }
      this._resolve = resolve2;
      this._reject = reject;
    });
    return this._promise;
  }
  resolve(value) {
    var _a172;
    this.status = { type: "resolved", value };
    if (this._promise) {
      (_a172 = this._resolve) == null ? void 0 : _a172.call(this, value);
    }
  }
  reject(error45) {
    var _a172;
    this.status = { type: "rejected", error: error45 };
    if (this._promise) {
      (_a172 = this._reject) == null ? void 0 : _a172.call(this, error45);
    }
  }
};
function now() {
  var _a172, _b9;
  return (_b9 =
    (_a172 = globalThis == null ? void 0 : globalThis.performance) == null
      ? void 0
      : _a172.now()) != null
    ? _b9
    : Date.now();
}
function runToolsTransformation({
  tools: tools4,
  generatorStream,
  tracer,
  telemetry,
  system,
  messages,
  abortSignal,
  repairToolCall,
  experimental_context,
}) {
  let toolResultsStreamController = null;
  const toolResultsStream = new ReadableStream({
    start(controller) {
      toolResultsStreamController = controller;
    },
  });
  const outstandingToolResults = /* @__PURE__ */ new Set();
  const toolInputs = /* @__PURE__ */ new Map();
  let canClose = false;
  let finishChunk = void 0;
  function attemptClose() {
    if (canClose && outstandingToolResults.size === 0) {
      if (finishChunk != null) {
        toolResultsStreamController.enqueue(finishChunk);
      }
      toolResultsStreamController.close();
    }
  }
  const forwardStream = new TransformStream({
    async transform(chunk, controller) {
      const chunkType = chunk.type;
      switch (chunkType) {
        case "stream-start":
        case "text-start":
        case "text-delta":
        case "text-end":
        case "reasoning-start":
        case "reasoning-delta":
        case "reasoning-end":
        case "tool-input-start":
        case "tool-input-delta":
        case "tool-input-end":
        case "source":
        case "response-metadata":
        case "error":
        case "raw": {
          controller.enqueue(chunk);
          break;
        }
        case "file": {
          controller.enqueue({
            type: "file",
            file: new DefaultGeneratedFileWithType({
              data: chunk.data,
              mediaType: chunk.mediaType,
            }),
          });
          break;
        }
        case "finish": {
          finishChunk = {
            type: "finish",
            finishReason: chunk.finishReason,
            usage: chunk.usage,
            providerMetadata: chunk.providerMetadata,
          };
          break;
        }
        case "tool-call": {
          try {
            const toolCall = await parseToolCall({
              toolCall: chunk,
              tools: tools4,
              repairToolCall,
              system,
              messages,
            });
            controller.enqueue(toolCall);
            if (toolCall.invalid) {
              toolResultsStreamController.enqueue({
                type: "tool-error",
                toolCallId: toolCall.toolCallId,
                toolName: toolCall.toolName,
                input: toolCall.input,
                error: getErrorMessage2(toolCall.error),
                dynamic: true,
              });
              break;
            }
            const tool3 = tools4[toolCall.toolName];
            toolInputs.set(toolCall.toolCallId, toolCall.input);
            if (tool3.onInputAvailable != null) {
              await tool3.onInputAvailable({
                input: toolCall.input,
                toolCallId: toolCall.toolCallId,
                messages,
                abortSignal,
                experimental_context,
              });
            }
            if (tool3.execute != null && toolCall.providerExecuted !== true) {
              const toolExecutionId = generateId();
              outstandingToolResults.add(toolExecutionId);
              recordSpan({
                name: "ai.toolCall",
                attributes: selectTelemetryAttributes({
                  telemetry,
                  attributes: {
                    ...assembleOperationName({
                      operationId: "ai.toolCall",
                      telemetry,
                    }),
                    "ai.toolCall.name": toolCall.toolName,
                    "ai.toolCall.id": toolCall.toolCallId,
                    "ai.toolCall.args": {
                      output: () => JSON.stringify(toolCall.input),
                    },
                  },
                }),
                tracer,
                fn: async (span) => {
                  let output;
                  try {
                    const stream = executeTool({
                      execute: tool3.execute.bind(tool3),
                      input: toolCall.input,
                      options: {
                        toolCallId: toolCall.toolCallId,
                        messages,
                        abortSignal,
                        experimental_context,
                      },
                    });
                    for await (const part of stream) {
                      toolResultsStreamController.enqueue({
                        ...toolCall,
                        type: "tool-result",
                        output: part.output,
                        ...(part.type === "preliminary" && {
                          preliminary: true,
                        }),
                      });
                      if (part.type === "final") {
                        output = part.output;
                      }
                    }
                  } catch (error45) {
                    recordErrorOnSpan(span, error45);
                    toolResultsStreamController.enqueue({
                      ...toolCall,
                      type: "tool-error",
                      error: error45,
                    });
                    outstandingToolResults.delete(toolExecutionId);
                    attemptClose();
                    return;
                  }
                  outstandingToolResults.delete(toolExecutionId);
                  attemptClose();
                  try {
                    span.setAttributes(
                      selectTelemetryAttributes({
                        telemetry,
                        attributes: {
                          "ai.toolCall.result": {
                            output: () => JSON.stringify(output),
                          },
                        },
                      }),
                    );
                  } catch (ignored) {}
                },
              });
            }
          } catch (error45) {
            toolResultsStreamController.enqueue({
              type: "error",
              error: error45,
            });
          }
          break;
        }
        case "tool-result": {
          const toolName = chunk.toolName;
          if (chunk.isError) {
            toolResultsStreamController.enqueue({
              type: "tool-error",
              toolCallId: chunk.toolCallId,
              toolName,
              input: toolInputs.get(chunk.toolCallId),
              providerExecuted: chunk.providerExecuted,
              error: chunk.result,
            });
          } else {
            controller.enqueue({
              type: "tool-result",
              toolCallId: chunk.toolCallId,
              toolName,
              input: toolInputs.get(chunk.toolCallId),
              output: chunk.result,
              providerExecuted: chunk.providerExecuted,
            });
          }
          break;
        }
        default: {
          const _exhaustiveCheck = chunkType;
          throw new Error(`Unhandled chunk type: ${_exhaustiveCheck}`);
        }
      }
    },
    flush() {
      canClose = true;
      attemptClose();
    },
  });
  return new ReadableStream({
    async start(controller) {
      return Promise.all([
        generatorStream.pipeThrough(forwardStream).pipeTo(
          new WritableStream({
            write(chunk) {
              controller.enqueue(chunk);
            },
            close() {},
          }),
        ),
        toolResultsStream.pipeTo(
          new WritableStream({
            write(chunk) {
              controller.enqueue(chunk);
            },
            close() {
              controller.close();
            },
          }),
        ),
      ]);
    },
  });
}
var originalGenerateId2 = createIdGenerator({
  prefix: "aitxt",
  size: 24,
});
function streamText({
  model,
  tools: tools4,
  toolChoice,
  system,
  prompt,
  messages,
  maxRetries,
  abortSignal,
  headers,
  stopWhen = stepCountIs(1),
  experimental_output: output,
  experimental_telemetry: telemetry,
  prepareStep,
  providerOptions,
  experimental_activeTools,
  activeTools = experimental_activeTools,
  experimental_repairToolCall: repairToolCall,
  experimental_transform: transform3,
  experimental_download: download2,
  includeRawChunks = false,
  onChunk,
  onError = ({ error: error45 }) => {
    console.error(error45);
  },
  onFinish,
  onAbort,
  onStepFinish,
  experimental_context,
  _internal: {
    now: now2 = now,
    generateId: generateId3 = originalGenerateId2,
    currentDate = () => /* @__PURE__ */ new Date(),
  } = {},
  ...settings
}) {
  return new DefaultStreamTextResult({
    model: resolveLanguageModel(model),
    telemetry,
    headers,
    settings,
    maxRetries,
    abortSignal,
    system,
    prompt,
    messages,
    tools: tools4,
    toolChoice,
    transforms: asArray(transform3),
    activeTools,
    repairToolCall,
    stopConditions: asArray(stopWhen),
    output,
    providerOptions,
    prepareStep,
    includeRawChunks,
    onChunk,
    onError,
    onFinish,
    onAbort,
    onStepFinish,
    now: now2,
    currentDate,
    generateId: generateId3,
    experimental_context,
    download: download2,
  });
}
function createOutputTransformStream(output) {
  if (!output) {
    return new TransformStream({
      transform(chunk, controller) {
        controller.enqueue({ part: chunk, partialOutput: void 0 });
      },
    });
  }
  let firstTextChunkId = void 0;
  let text2 = "";
  let textChunk = "";
  let lastPublishedJson = "";
  function publishTextChunk({ controller, partialOutput = void 0 }) {
    controller.enqueue({
      part: {
        type: "text-delta",
        id: firstTextChunkId,
        text: textChunk,
      },
      partialOutput,
    });
    textChunk = "";
  }
  return new TransformStream({
    async transform(chunk, controller) {
      if (chunk.type === "finish-step" && textChunk.length > 0) {
        publishTextChunk({ controller });
      }
      if (
        chunk.type !== "text-delta" &&
        chunk.type !== "text-start" &&
        chunk.type !== "text-end"
      ) {
        controller.enqueue({ part: chunk, partialOutput: void 0 });
        return;
      }
      if (firstTextChunkId == null) {
        firstTextChunkId = chunk.id;
      } else if (chunk.id !== firstTextChunkId) {
        controller.enqueue({ part: chunk, partialOutput: void 0 });
        return;
      }
      if (chunk.type === "text-start") {
        controller.enqueue({ part: chunk, partialOutput: void 0 });
        return;
      }
      if (chunk.type === "text-end") {
        if (textChunk.length > 0) {
          publishTextChunk({ controller });
        }
        controller.enqueue({ part: chunk, partialOutput: void 0 });
        return;
      }
      text2 += chunk.text;
      textChunk += chunk.text;
      const result = await output.parsePartial({ text: text2 });
      if (result != null) {
        const currentJson = JSON.stringify(result.partial);
        if (currentJson !== lastPublishedJson) {
          publishTextChunk({ controller, partialOutput: result.partial });
          lastPublishedJson = currentJson;
        }
      }
    },
  });
}
var DefaultStreamTextResult = class {
  constructor({
    model,
    telemetry,
    headers,
    settings,
    maxRetries: maxRetriesArg,
    abortSignal,
    system,
    prompt,
    messages,
    tools: tools4,
    toolChoice,
    transforms,
    activeTools,
    repairToolCall,
    stopConditions,
    output,
    providerOptions,
    prepareStep,
    includeRawChunks,
    now: now2,
    currentDate,
    generateId: generateId3,
    onChunk,
    onError,
    onFinish,
    onAbort,
    onStepFinish,
    experimental_context,
    download: download2,
  }) {
    this._totalUsage = new DelayedPromise();
    this._finishReason = new DelayedPromise();
    this._steps = new DelayedPromise();
    this.output = output;
    this.includeRawChunks = includeRawChunks;
    this.tools = tools4;
    let stepFinish;
    let recordedContent = [];
    const recordedResponseMessages = [];
    let recordedFinishReason = void 0;
    let recordedTotalUsage = void 0;
    let recordedRequest = {};
    let recordedWarnings = [];
    const recordedSteps = [];
    let rootSpan;
    let activeTextContent = {};
    let activeReasoningContent = {};
    const eventProcessor = new TransformStream({
      async transform(chunk, controller) {
        var _a172, _b9, _c;
        controller.enqueue(chunk);
        const { part } = chunk;
        if (
          part.type === "text-delta" ||
          part.type === "reasoning-delta" ||
          part.type === "source" ||
          part.type === "tool-call" ||
          part.type === "tool-result" ||
          part.type === "tool-input-start" ||
          part.type === "tool-input-delta" ||
          part.type === "raw"
        ) {
          await (onChunk == null ? void 0 : onChunk({ chunk: part }));
        }
        if (part.type === "error") {
          await onError({ error: wrapGatewayError(part.error) });
        }
        if (part.type === "text-start") {
          activeTextContent[part.id] = {
            type: "text",
            text: "",
            providerMetadata: part.providerMetadata,
          };
          recordedContent.push(activeTextContent[part.id]);
        }
        if (part.type === "text-delta") {
          const activeText = activeTextContent[part.id];
          if (activeText == null) {
            controller.enqueue({
              part: {
                type: "error",
                error: `text part ${part.id} not found`,
              },
              partialOutput: void 0,
            });
            return;
          }
          activeText.text += part.text;
          activeText.providerMetadata =
            (_a172 = part.providerMetadata) != null
              ? _a172
              : activeText.providerMetadata;
        }
        if (part.type === "text-end") {
          delete activeTextContent[part.id];
        }
        if (part.type === "reasoning-start") {
          activeReasoningContent[part.id] = {
            type: "reasoning",
            text: "",
            providerMetadata: part.providerMetadata,
          };
          recordedContent.push(activeReasoningContent[part.id]);
        }
        if (part.type === "reasoning-delta") {
          const activeReasoning = activeReasoningContent[part.id];
          if (activeReasoning == null) {
            controller.enqueue({
              part: {
                type: "error",
                error: `reasoning part ${part.id} not found`,
              },
              partialOutput: void 0,
            });
            return;
          }
          activeReasoning.text += part.text;
          activeReasoning.providerMetadata =
            (_b9 = part.providerMetadata) != null
              ? _b9
              : activeReasoning.providerMetadata;
        }
        if (part.type === "reasoning-end") {
          const activeReasoning = activeReasoningContent[part.id];
          if (activeReasoning == null) {
            controller.enqueue({
              part: {
                type: "error",
                error: `reasoning part ${part.id} not found`,
              },
              partialOutput: void 0,
            });
            return;
          }
          activeReasoning.providerMetadata =
            (_c = part.providerMetadata) != null
              ? _c
              : activeReasoning.providerMetadata;
          delete activeReasoningContent[part.id];
        }
        if (part.type === "file") {
          recordedContent.push({ type: "file", file: part.file });
        }
        if (part.type === "source") {
          recordedContent.push(part);
        }
        if (part.type === "tool-call") {
          recordedContent.push(part);
        }
        if (part.type === "tool-result" && !part.preliminary) {
          recordedContent.push(part);
        }
        if (part.type === "tool-error") {
          recordedContent.push(part);
        }
        if (part.type === "start-step") {
          recordedRequest = part.request;
          recordedWarnings = part.warnings;
        }
        if (part.type === "finish-step") {
          const stepMessages = toResponseMessages({
            content: recordedContent,
            tools: tools4,
          });
          const currentStepResult = new DefaultStepResult({
            content: recordedContent,
            finishReason: part.finishReason,
            usage: part.usage,
            warnings: recordedWarnings,
            request: recordedRequest,
            response: {
              ...part.response,
              messages: [...recordedResponseMessages, ...stepMessages],
            },
            providerMetadata: part.providerMetadata,
          });
          await (onStepFinish == null
            ? void 0
            : onStepFinish(currentStepResult));
          logWarnings(recordedWarnings);
          recordedSteps.push(currentStepResult);
          recordedContent = [];
          activeReasoningContent = {};
          activeTextContent = {};
          recordedResponseMessages.push(...stepMessages);
          stepFinish.resolve();
        }
        if (part.type === "finish") {
          recordedTotalUsage = part.totalUsage;
          recordedFinishReason = part.finishReason;
        }
      },
      async flush(controller) {
        try {
          if (recordedSteps.length === 0) {
            const error45 = new NoOutputGeneratedError({
              message: "No output generated. Check the stream for errors.",
            });
            self._finishReason.reject(error45);
            self._totalUsage.reject(error45);
            self._steps.reject(error45);
            return;
          }
          const finishReason =
            recordedFinishReason != null ? recordedFinishReason : "unknown";
          const totalUsage =
            recordedTotalUsage != null
              ? recordedTotalUsage
              : {
                  inputTokens: void 0,
                  outputTokens: void 0,
                  totalTokens: void 0,
                };
          self._finishReason.resolve(finishReason);
          self._totalUsage.resolve(totalUsage);
          self._steps.resolve(recordedSteps);
          const finalStep = recordedSteps[recordedSteps.length - 1];
          await (onFinish == null
            ? void 0
            : onFinish({
                finishReason,
                totalUsage,
                usage: finalStep.usage,
                content: finalStep.content,
                text: finalStep.text,
                reasoningText: finalStep.reasoningText,
                reasoning: finalStep.reasoning,
                files: finalStep.files,
                sources: finalStep.sources,
                toolCalls: finalStep.toolCalls,
                staticToolCalls: finalStep.staticToolCalls,
                dynamicToolCalls: finalStep.dynamicToolCalls,
                toolResults: finalStep.toolResults,
                staticToolResults: finalStep.staticToolResults,
                dynamicToolResults: finalStep.dynamicToolResults,
                request: finalStep.request,
                response: finalStep.response,
                warnings: finalStep.warnings,
                providerMetadata: finalStep.providerMetadata,
                steps: recordedSteps,
              }));
          rootSpan.setAttributes(
            selectTelemetryAttributes({
              telemetry,
              attributes: {
                "ai.response.finishReason": finishReason,
                "ai.response.text": { output: () => finalStep.text },
                "ai.response.toolCalls": {
                  output: () => {
                    var _a172;
                    return (
                      (_a172 = finalStep.toolCalls) == null
                        ? void 0
                        : _a172.length
                    )
                      ? JSON.stringify(finalStep.toolCalls)
                      : void 0;
                  },
                },
                "ai.response.providerMetadata": JSON.stringify(
                  finalStep.providerMetadata,
                ),
                "ai.usage.inputTokens": totalUsage.inputTokens,
                "ai.usage.outputTokens": totalUsage.outputTokens,
                "ai.usage.totalTokens": totalUsage.totalTokens,
                "ai.usage.reasoningTokens": totalUsage.reasoningTokens,
                "ai.usage.cachedInputTokens": totalUsage.cachedInputTokens,
              },
            }),
          );
        } catch (error45) {
          controller.error(error45);
        } finally {
          rootSpan.end();
        }
      },
    });
    const stitchableStream = createStitchableStream();
    this.addStream = stitchableStream.addStream;
    this.closeStream = stitchableStream.close;
    const reader = stitchableStream.stream.getReader();
    let stream = new ReadableStream({
      async start(controller) {
        controller.enqueue({ type: "start" });
      },
      async pull(controller) {
        function abort() {
          onAbort == null ? void 0 : onAbort({ steps: recordedSteps });
          controller.enqueue({ type: "abort" });
          controller.close();
        }
        try {
          const { done, value } = await reader.read();
          if (done) {
            controller.close();
            return;
          }
          if (abortSignal == null ? void 0 : abortSignal.aborted) {
            abort();
            return;
          }
          controller.enqueue(value);
        } catch (error45) {
          if (
            isAbortError(error45) &&
            (abortSignal == null ? void 0 : abortSignal.aborted)
          ) {
            abort();
          } else {
            controller.error(error45);
          }
        }
      },
      cancel(reason) {
        return stitchableStream.stream.cancel(reason);
      },
    });
    for (const transform3 of transforms) {
      stream = stream.pipeThrough(
        transform3({
          tools: tools4,
          stopStream() {
            stitchableStream.terminate();
          },
        }),
      );
    }
    this.baseStream = stream
      .pipeThrough(createOutputTransformStream(output))
      .pipeThrough(eventProcessor);
    const { maxRetries, retry } = prepareRetries({
      maxRetries: maxRetriesArg,
      abortSignal,
    });
    const tracer = getTracer(telemetry);
    const callSettings = prepareCallSettings(settings);
    const baseTelemetryAttributes = getBaseTelemetryAttributes({
      model,
      telemetry,
      headers,
      settings: { ...callSettings, maxRetries },
    });
    const self = this;
    recordSpan({
      name: "ai.streamText",
      attributes: selectTelemetryAttributes({
        telemetry,
        attributes: {
          ...assembleOperationName({ operationId: "ai.streamText", telemetry }),
          ...baseTelemetryAttributes,
          // specific settings that only make sense on the outer level:
          "ai.prompt": {
            input: () => JSON.stringify({ system, prompt, messages }),
          },
        },
      }),
      tracer,
      endWhenDone: false,
      fn: async (rootSpanArg) => {
        rootSpan = rootSpanArg;
        async function streamStep({ currentStep, responseMessages, usage }) {
          var _a172, _b9, _c, _d, _e;
          const includeRawChunks2 = self.includeRawChunks;
          stepFinish = new DelayedPromise();
          const initialPrompt = await standardizePrompt({
            system,
            prompt,
            messages,
          });
          const stepInputMessages = [
            ...initialPrompt.messages,
            ...responseMessages,
          ];
          const prepareStepResult = await (prepareStep == null
            ? void 0
            : prepareStep({
                model,
                steps: recordedSteps,
                stepNumber: recordedSteps.length,
                messages: stepInputMessages,
              }));
          const promptMessages = await convertToLanguageModelPrompt({
            prompt: {
              system:
                (_a172 =
                  prepareStepResult == null
                    ? void 0
                    : prepareStepResult.system) != null
                  ? _a172
                  : initialPrompt.system,
              messages:
                (_b9 =
                  prepareStepResult == null
                    ? void 0
                    : prepareStepResult.messages) != null
                  ? _b9
                  : stepInputMessages,
            },
            supportedUrls: await model.supportedUrls,
            download: download2,
          });
          const stepModel = resolveLanguageModel(
            (_c =
              prepareStepResult == null ? void 0 : prepareStepResult.model) !=
              null
              ? _c
              : model,
          );
          const { toolChoice: stepToolChoice, tools: stepTools } =
            prepareToolsAndToolChoice({
              tools: tools4,
              toolChoice:
                (_d =
                  prepareStepResult == null
                    ? void 0
                    : prepareStepResult.toolChoice) != null
                  ? _d
                  : toolChoice,
              activeTools:
                (_e =
                  prepareStepResult == null
                    ? void 0
                    : prepareStepResult.activeTools) != null
                  ? _e
                  : activeTools,
            });
          const {
            result: { stream: stream2, response, request: request2 },
            doStreamSpan,
            startTimestampMs,
          } = await retry(() =>
            recordSpan({
              name: "ai.streamText.doStream",
              attributes: selectTelemetryAttributes({
                telemetry,
                attributes: {
                  ...assembleOperationName({
                    operationId: "ai.streamText.doStream",
                    telemetry,
                  }),
                  ...baseTelemetryAttributes,
                  // model:
                  "ai.model.provider": stepModel.provider,
                  "ai.model.id": stepModel.modelId,
                  // prompt:
                  "ai.prompt.messages": {
                    input: () => stringifyForTelemetry(promptMessages),
                  },
                  "ai.prompt.tools": {
                    // convert the language model level tools:
                    input: () =>
                      stepTools == null
                        ? void 0
                        : stepTools.map((tool3) => JSON.stringify(tool3)),
                  },
                  "ai.prompt.toolChoice": {
                    input: () =>
                      stepToolChoice != null
                        ? JSON.stringify(stepToolChoice)
                        : void 0,
                  },
                  // standardized gen-ai llm span attributes:
                  "gen_ai.system": stepModel.provider,
                  "gen_ai.request.model": stepModel.modelId,
                  "gen_ai.request.frequency_penalty":
                    callSettings.frequencyPenalty,
                  "gen_ai.request.max_tokens": callSettings.maxOutputTokens,
                  "gen_ai.request.presence_penalty":
                    callSettings.presencePenalty,
                  "gen_ai.request.stop_sequences": callSettings.stopSequences,
                  "gen_ai.request.temperature": callSettings.temperature,
                  "gen_ai.request.top_k": callSettings.topK,
                  "gen_ai.request.top_p": callSettings.topP,
                },
              }),
              tracer,
              endWhenDone: false,
              fn: async (doStreamSpan2) => {
                return {
                  startTimestampMs: now2(),
                  // get before the call
                  doStreamSpan: doStreamSpan2,
                  result: await stepModel.doStream({
                    ...callSettings,
                    tools: stepTools,
                    toolChoice: stepToolChoice,
                    responseFormat:
                      output == null ? void 0 : output.responseFormat,
                    prompt: promptMessages,
                    providerOptions,
                    abortSignal,
                    headers,
                    includeRawChunks: includeRawChunks2,
                  }),
                };
              },
            }),
          );
          const streamWithToolResults = runToolsTransformation({
            tools: tools4,
            generatorStream: stream2,
            tracer,
            telemetry,
            system,
            messages: stepInputMessages,
            repairToolCall,
            abortSignal,
            experimental_context,
          });
          const stepRequest = request2 != null ? request2 : {};
          const stepToolCalls = [];
          const stepToolOutputs = [];
          let warnings;
          const activeToolCallToolNames = {};
          let stepFinishReason = "unknown";
          let stepUsage = {
            inputTokens: void 0,
            outputTokens: void 0,
            totalTokens: void 0,
          };
          let stepProviderMetadata;
          let stepFirstChunk = true;
          let stepResponse = {
            id: generateId3(),
            timestamp: currentDate(),
            modelId: model.modelId,
          };
          let activeText = "";
          self.addStream(
            streamWithToolResults.pipeThrough(
              new TransformStream({
                async transform(chunk, controller) {
                  var _a182, _b22, _c2, _d2;
                  if (chunk.type === "stream-start") {
                    warnings = chunk.warnings;
                    return;
                  }
                  if (stepFirstChunk) {
                    const msToFirstChunk = now2() - startTimestampMs;
                    stepFirstChunk = false;
                    doStreamSpan.addEvent("ai.stream.firstChunk", {
                      "ai.response.msToFirstChunk": msToFirstChunk,
                    });
                    doStreamSpan.setAttributes({
                      "ai.response.msToFirstChunk": msToFirstChunk,
                    });
                    controller.enqueue({
                      type: "start-step",
                      request: stepRequest,
                      warnings: warnings != null ? warnings : [],
                    });
                  }
                  const chunkType = chunk.type;
                  switch (chunkType) {
                    case "text-start":
                    case "text-end": {
                      controller.enqueue(chunk);
                      break;
                    }
                    case "text-delta": {
                      if (chunk.delta.length > 0) {
                        controller.enqueue({
                          type: "text-delta",
                          id: chunk.id,
                          text: chunk.delta,
                          providerMetadata: chunk.providerMetadata,
                        });
                        activeText += chunk.delta;
                      }
                      break;
                    }
                    case "reasoning-start":
                    case "reasoning-end": {
                      controller.enqueue(chunk);
                      break;
                    }
                    case "reasoning-delta": {
                      controller.enqueue({
                        type: "reasoning-delta",
                        id: chunk.id,
                        text: chunk.delta,
                        providerMetadata: chunk.providerMetadata,
                      });
                      break;
                    }
                    case "tool-call": {
                      controller.enqueue(chunk);
                      stepToolCalls.push(chunk);
                      break;
                    }
                    case "tool-result": {
                      controller.enqueue(chunk);
                      if (!chunk.preliminary) {
                        stepToolOutputs.push(chunk);
                      }
                      break;
                    }
                    case "tool-error": {
                      controller.enqueue(chunk);
                      stepToolOutputs.push(chunk);
                      break;
                    }
                    case "response-metadata": {
                      stepResponse = {
                        id:
                          (_a182 = chunk.id) != null ? _a182 : stepResponse.id,
                        timestamp:
                          (_b22 = chunk.timestamp) != null
                            ? _b22
                            : stepResponse.timestamp,
                        modelId:
                          (_c2 = chunk.modelId) != null
                            ? _c2
                            : stepResponse.modelId,
                      };
                      break;
                    }
                    case "finish": {
                      stepUsage = chunk.usage;
                      stepFinishReason = chunk.finishReason;
                      stepProviderMetadata = chunk.providerMetadata;
                      const msToFinish = now2() - startTimestampMs;
                      doStreamSpan.addEvent("ai.stream.finish");
                      doStreamSpan.setAttributes({
                        "ai.response.msToFinish": msToFinish,
                        "ai.response.avgOutputTokensPerSecond":
                          (1e3 *
                            ((_d2 = stepUsage.outputTokens) != null
                              ? _d2
                              : 0)) /
                          msToFinish,
                      });
                      break;
                    }
                    case "file": {
                      controller.enqueue(chunk);
                      break;
                    }
                    case "source": {
                      controller.enqueue(chunk);
                      break;
                    }
                    case "tool-input-start": {
                      activeToolCallToolNames[chunk.id] = chunk.toolName;
                      const tool3 =
                        tools4 == null ? void 0 : tools4[chunk.toolName];
                      if (
                        (tool3 == null ? void 0 : tool3.onInputStart) != null
                      ) {
                        await tool3.onInputStart({
                          toolCallId: chunk.id,
                          messages: stepInputMessages,
                          abortSignal,
                          experimental_context,
                        });
                      }
                      controller.enqueue({
                        ...chunk,
                        dynamic:
                          (tool3 == null ? void 0 : tool3.type) === "dynamic",
                      });
                      break;
                    }
                    case "tool-input-end": {
                      delete activeToolCallToolNames[chunk.id];
                      controller.enqueue(chunk);
                      break;
                    }
                    case "tool-input-delta": {
                      const toolName = activeToolCallToolNames[chunk.id];
                      const tool3 = tools4 == null ? void 0 : tools4[toolName];
                      if (
                        (tool3 == null ? void 0 : tool3.onInputDelta) != null
                      ) {
                        await tool3.onInputDelta({
                          inputTextDelta: chunk.delta,
                          toolCallId: chunk.id,
                          messages: stepInputMessages,
                          abortSignal,
                          experimental_context,
                        });
                      }
                      controller.enqueue(chunk);
                      break;
                    }
                    case "error": {
                      controller.enqueue(chunk);
                      stepFinishReason = "error";
                      break;
                    }
                    case "raw": {
                      if (includeRawChunks2) {
                        controller.enqueue(chunk);
                      }
                      break;
                    }
                    default: {
                      const exhaustiveCheck = chunkType;
                      throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);
                    }
                  }
                },
                // invoke onFinish callback and resolve toolResults promise when the stream is about to close:
                async flush(controller) {
                  const stepToolCallsJson =
                    stepToolCalls.length > 0
                      ? JSON.stringify(stepToolCalls)
                      : void 0;
                  try {
                    doStreamSpan.setAttributes(
                      selectTelemetryAttributes({
                        telemetry,
                        attributes: {
                          "ai.response.finishReason": stepFinishReason,
                          "ai.response.text": {
                            output: () => activeText,
                          },
                          "ai.response.toolCalls": {
                            output: () => stepToolCallsJson,
                          },
                          "ai.response.id": stepResponse.id,
                          "ai.response.model": stepResponse.modelId,
                          "ai.response.timestamp":
                            stepResponse.timestamp.toISOString(),
                          "ai.response.providerMetadata":
                            JSON.stringify(stepProviderMetadata),
                          "ai.usage.inputTokens": stepUsage.inputTokens,
                          "ai.usage.outputTokens": stepUsage.outputTokens,
                          "ai.usage.totalTokens": stepUsage.totalTokens,
                          "ai.usage.reasoningTokens": stepUsage.reasoningTokens,
                          "ai.usage.cachedInputTokens":
                            stepUsage.cachedInputTokens,
                          // standardized gen-ai llm span attributes:
                          "gen_ai.response.finish_reasons": [stepFinishReason],
                          "gen_ai.response.id": stepResponse.id,
                          "gen_ai.response.model": stepResponse.modelId,
                          "gen_ai.usage.input_tokens": stepUsage.inputTokens,
                          "gen_ai.usage.output_tokens": stepUsage.outputTokens,
                        },
                      }),
                    );
                  } catch (error45) {
                  } finally {
                    doStreamSpan.end();
                  }
                  controller.enqueue({
                    type: "finish-step",
                    finishReason: stepFinishReason,
                    usage: stepUsage,
                    providerMetadata: stepProviderMetadata,
                    response: {
                      ...stepResponse,
                      headers: response == null ? void 0 : response.headers,
                    },
                  });
                  const combinedUsage = addLanguageModelUsage(usage, stepUsage);
                  await stepFinish.promise;
                  const clientToolCalls = stepToolCalls.filter(
                    (toolCall) => toolCall.providerExecuted !== true,
                  );
                  const clientToolOutputs = stepToolOutputs.filter(
                    (toolOutput) => toolOutput.providerExecuted !== true,
                  );
                  if (
                    clientToolCalls.length > 0 && // all current tool calls have outputs (incl. execution errors):
                    clientToolOutputs.length === clientToolCalls.length && // continue until a stop condition is met:
                    !(await isStopConditionMet({
                      stopConditions,
                      steps: recordedSteps,
                    }))
                  ) {
                    responseMessages.push(
                      ...toResponseMessages({
                        content:
                          // use transformed content to create the messages for the next step:
                          recordedSteps[recordedSteps.length - 1].content,
                        tools: tools4,
                      }),
                    );
                    try {
                      await streamStep({
                        currentStep: currentStep + 1,
                        responseMessages,
                        usage: combinedUsage,
                      });
                    } catch (error45) {
                      controller.enqueue({
                        type: "error",
                        error: error45,
                      });
                      self.closeStream();
                    }
                  } else {
                    controller.enqueue({
                      type: "finish",
                      finishReason: stepFinishReason,
                      totalUsage: combinedUsage,
                    });
                    self.closeStream();
                  }
                },
              }),
            ),
          );
        }
        await streamStep({
          currentStep: 0,
          responseMessages: [],
          usage: {
            inputTokens: void 0,
            outputTokens: void 0,
            totalTokens: void 0,
          },
        });
      },
    }).catch((error45) => {
      self.addStream(
        new ReadableStream({
          start(controller) {
            controller.enqueue({ type: "error", error: error45 });
            controller.close();
          },
        }),
      );
      self.closeStream();
    });
  }
  get steps() {
    this.consumeStream();
    return this._steps.promise;
  }
  get finalStep() {
    return this.steps.then((steps) => steps[steps.length - 1]);
  }
  get content() {
    return this.finalStep.then((step) => step.content);
  }
  get warnings() {
    return this.finalStep.then((step) => step.warnings);
  }
  get providerMetadata() {
    return this.finalStep.then((step) => step.providerMetadata);
  }
  get text() {
    return this.finalStep.then((step) => step.text);
  }
  get reasoningText() {
    return this.finalStep.then((step) => step.reasoningText);
  }
  get reasoning() {
    return this.finalStep.then((step) => step.reasoning);
  }
  get sources() {
    return this.finalStep.then((step) => step.sources);
  }
  get files() {
    return this.finalStep.then((step) => step.files);
  }
  get toolCalls() {
    return this.finalStep.then((step) => step.toolCalls);
  }
  get staticToolCalls() {
    return this.finalStep.then((step) => step.staticToolCalls);
  }
  get dynamicToolCalls() {
    return this.finalStep.then((step) => step.dynamicToolCalls);
  }
  get toolResults() {
    return this.finalStep.then((step) => step.toolResults);
  }
  get staticToolResults() {
    return this.finalStep.then((step) => step.staticToolResults);
  }
  get dynamicToolResults() {
    return this.finalStep.then((step) => step.dynamicToolResults);
  }
  get usage() {
    return this.finalStep.then((step) => step.usage);
  }
  get request() {
    return this.finalStep.then((step) => step.request);
  }
  get response() {
    return this.finalStep.then((step) => step.response);
  }
  get totalUsage() {
    this.consumeStream();
    return this._totalUsage.promise;
  }
  get finishReason() {
    this.consumeStream();
    return this._finishReason.promise;
  }
  /**
  Split out a new stream from the original stream.
  The original stream is replaced to allow for further splitting,
  since we do not know how many times the stream will be split.
  
  Note: this leads to buffering the stream content on the server.
  However, the LLM results are expected to be small enough to not cause issues.
     */
  teeStream() {
    const [stream1, stream2] = this.baseStream.tee();
    this.baseStream = stream2;
    return stream1;
  }
  get textStream() {
    return createAsyncIterableStream(
      this.teeStream().pipeThrough(
        new TransformStream({
          transform({ part }, controller) {
            if (part.type === "text-delta") {
              controller.enqueue(part.text);
            }
          },
        }),
      ),
    );
  }
  get fullStream() {
    return createAsyncIterableStream(
      this.teeStream().pipeThrough(
        new TransformStream({
          transform({ part }, controller) {
            controller.enqueue(part);
          },
        }),
      ),
    );
  }
  async consumeStream(options) {
    var _a172;
    try {
      await consumeStream({
        stream: this.fullStream,
        onError: options == null ? void 0 : options.onError,
      });
    } catch (error45) {
      (_a172 = options == null ? void 0 : options.onError) == null
        ? void 0
        : _a172.call(options, error45);
    }
  }
  get experimental_partialOutputStream() {
    if (this.output == null) {
      throw new NoOutputSpecifiedError();
    }
    return createAsyncIterableStream(
      this.teeStream().pipeThrough(
        new TransformStream({
          transform({ partialOutput }, controller) {
            if (partialOutput != null) {
              controller.enqueue(partialOutput);
            }
          },
        }),
      ),
    );
  }
  toUIMessageStream({
    originalMessages,
    generateMessageId,
    onFinish,
    messageMetadata,
    sendReasoning = true,
    sendSources = false,
    sendStart = true,
    sendFinish = true,
    onError = getErrorMessage,
  } = {}) {
    const responseMessageId =
      generateMessageId != null
        ? getResponseUIMessageId({
            originalMessages,
            responseMessageId: generateMessageId,
          })
        : void 0;
    const toolNamesByCallId = {};
    const isDynamic = (toolCallId) => {
      var _a172, _b9;
      const toolName = toolNamesByCallId[toolCallId];
      const dynamic =
        ((_b9 = (_a172 = this.tools) == null ? void 0 : _a172[toolName]) == null
          ? void 0
          : _b9.type) === "dynamic";
      return dynamic ? true : void 0;
    };
    const baseStream = this.fullStream.pipeThrough(
      new TransformStream({
        transform: async (part, controller) => {
          const messageMetadataValue =
            messageMetadata == null ? void 0 : messageMetadata({ part });
          const partType = part.type;
          switch (partType) {
            case "text-start": {
              controller.enqueue({
                type: "text-start",
                id: part.id,
                ...(part.providerMetadata != null
                  ? { providerMetadata: part.providerMetadata }
                  : {}),
              });
              break;
            }
            case "text-delta": {
              controller.enqueue({
                type: "text-delta",
                id: part.id,
                delta: part.text,
                ...(part.providerMetadata != null
                  ? { providerMetadata: part.providerMetadata }
                  : {}),
              });
              break;
            }
            case "text-end": {
              controller.enqueue({
                type: "text-end",
                id: part.id,
                ...(part.providerMetadata != null
                  ? { providerMetadata: part.providerMetadata }
                  : {}),
              });
              break;
            }
            case "reasoning-start": {
              controller.enqueue({
                type: "reasoning-start",
                id: part.id,
                ...(part.providerMetadata != null
                  ? { providerMetadata: part.providerMetadata }
                  : {}),
              });
              break;
            }
            case "reasoning-delta": {
              if (sendReasoning) {
                controller.enqueue({
                  type: "reasoning-delta",
                  id: part.id,
                  delta: part.text,
                  ...(part.providerMetadata != null
                    ? { providerMetadata: part.providerMetadata }
                    : {}),
                });
              }
              break;
            }
            case "reasoning-end": {
              controller.enqueue({
                type: "reasoning-end",
                id: part.id,
                ...(part.providerMetadata != null
                  ? { providerMetadata: part.providerMetadata }
                  : {}),
              });
              break;
            }
            case "file": {
              controller.enqueue({
                type: "file",
                mediaType: part.file.mediaType,
                url: `data:${part.file.mediaType};base64,${part.file.base64}`,
              });
              break;
            }
            case "source": {
              if (sendSources && part.sourceType === "url") {
                controller.enqueue({
                  type: "source-url",
                  sourceId: part.id,
                  url: part.url,
                  title: part.title,
                  ...(part.providerMetadata != null
                    ? { providerMetadata: part.providerMetadata }
                    : {}),
                });
              }
              if (sendSources && part.sourceType === "document") {
                controller.enqueue({
                  type: "source-document",
                  sourceId: part.id,
                  mediaType: part.mediaType,
                  title: part.title,
                  filename: part.filename,
                  ...(part.providerMetadata != null
                    ? { providerMetadata: part.providerMetadata }
                    : {}),
                });
              }
              break;
            }
            case "tool-input-start": {
              toolNamesByCallId[part.id] = part.toolName;
              const dynamic = isDynamic(part.id);
              controller.enqueue({
                type: "tool-input-start",
                toolCallId: part.id,
                toolName: part.toolName,
                ...(part.providerExecuted != null
                  ? { providerExecuted: part.providerExecuted }
                  : {}),
                ...(dynamic != null ? { dynamic } : {}),
              });
              break;
            }
            case "tool-input-delta": {
              controller.enqueue({
                type: "tool-input-delta",
                toolCallId: part.id,
                inputTextDelta: part.delta,
              });
              break;
            }
            case "tool-call": {
              toolNamesByCallId[part.toolCallId] = part.toolName;
              const dynamic = isDynamic(part.toolCallId);
              if (part.invalid) {
                controller.enqueue({
                  type: "tool-input-error",
                  toolCallId: part.toolCallId,
                  toolName: part.toolName,
                  input: part.input,
                  ...(part.providerExecuted != null
                    ? { providerExecuted: part.providerExecuted }
                    : {}),
                  ...(part.providerMetadata != null
                    ? { providerMetadata: part.providerMetadata }
                    : {}),
                  ...(dynamic != null ? { dynamic } : {}),
                  errorText: onError(part.error),
                });
              } else {
                controller.enqueue({
                  type: "tool-input-available",
                  toolCallId: part.toolCallId,
                  toolName: part.toolName,
                  input: part.input,
                  ...(part.providerExecuted != null
                    ? { providerExecuted: part.providerExecuted }
                    : {}),
                  ...(part.providerMetadata != null
                    ? { providerMetadata: part.providerMetadata }
                    : {}),
                  ...(dynamic != null ? { dynamic } : {}),
                });
              }
              break;
            }
            case "tool-result": {
              const dynamic = isDynamic(part.toolCallId);
              controller.enqueue({
                type: "tool-output-available",
                toolCallId: part.toolCallId,
                output: part.output,
                ...(part.providerExecuted != null
                  ? { providerExecuted: part.providerExecuted }
                  : {}),
                ...(part.preliminary != null
                  ? { preliminary: part.preliminary }
                  : {}),
                ...(dynamic != null ? { dynamic } : {}),
              });
              break;
            }
            case "tool-error": {
              const dynamic = isDynamic(part.toolCallId);
              controller.enqueue({
                type: "tool-output-error",
                toolCallId: part.toolCallId,
                errorText: onError(part.error),
                ...(part.providerExecuted != null
                  ? { providerExecuted: part.providerExecuted }
                  : {}),
                ...(dynamic != null ? { dynamic } : {}),
              });
              break;
            }
            case "error": {
              controller.enqueue({
                type: "error",
                errorText: onError(part.error),
              });
              break;
            }
            case "start-step": {
              controller.enqueue({ type: "start-step" });
              break;
            }
            case "finish-step": {
              controller.enqueue({ type: "finish-step" });
              break;
            }
            case "start": {
              if (sendStart) {
                controller.enqueue({
                  type: "start",
                  ...(messageMetadataValue != null
                    ? { messageMetadata: messageMetadataValue }
                    : {}),
                  ...(responseMessageId != null
                    ? { messageId: responseMessageId }
                    : {}),
                });
              }
              break;
            }
            case "finish": {
              if (sendFinish) {
                controller.enqueue({
                  type: "finish",
                  ...(messageMetadataValue != null
                    ? { messageMetadata: messageMetadataValue }
                    : {}),
                });
              }
              break;
            }
            case "abort": {
              controller.enqueue(part);
              break;
            }
            case "tool-input-end": {
              break;
            }
            case "raw": {
              break;
            }
            default: {
              const exhaustiveCheck = partType;
              throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);
            }
          }
          if (
            messageMetadataValue != null &&
            partType !== "start" &&
            partType !== "finish"
          ) {
            controller.enqueue({
              type: "message-metadata",
              messageMetadata: messageMetadataValue,
            });
          }
        },
      }),
    );
    return createAsyncIterableStream(
      handleUIMessageStreamFinish({
        stream: baseStream,
        messageId:
          responseMessageId != null
            ? responseMessageId
            : generateMessageId == null
              ? void 0
              : generateMessageId(),
        originalMessages,
        onFinish,
        onError,
      }),
    );
  }
  pipeUIMessageStreamToResponse(
    response,
    {
      originalMessages,
      generateMessageId,
      onFinish,
      messageMetadata,
      sendReasoning,
      sendSources,
      sendFinish,
      sendStart,
      onError,
      ...init
    } = {},
  ) {
    pipeUIMessageStreamToResponse({
      response,
      stream: this.toUIMessageStream({
        originalMessages,
        generateMessageId,
        onFinish,
        messageMetadata,
        sendReasoning,
        sendSources,
        sendFinish,
        sendStart,
        onError,
      }),
      ...init,
    });
  }
  pipeTextStreamToResponse(response, init) {
    pipeTextStreamToResponse({
      response,
      textStream: this.textStream,
      ...init,
    });
  }
  toUIMessageStreamResponse({
    originalMessages,
    generateMessageId,
    onFinish,
    messageMetadata,
    sendReasoning,
    sendSources,
    sendFinish,
    sendStart,
    onError,
    ...init
  } = {}) {
    return createUIMessageStreamResponse({
      stream: this.toUIMessageStream({
        originalMessages,
        generateMessageId,
        onFinish,
        messageMetadata,
        sendReasoning,
        sendSources,
        sendFinish,
        sendStart,
        onError,
      }),
      ...init,
    });
  }
  toTextStreamResponse(init) {
    return createTextStreamResponse({
      textStream: this.textStream,
      ...init,
    });
  }
};
function convertToModelMessages(messages, options) {
  const modelMessages = [];
  if (options == null ? void 0 : options.ignoreIncompleteToolCalls) {
    messages = messages.map((message) => ({
      ...message,
      parts: message.parts.filter(
        (part) =>
          !isToolOrDynamicToolUIPart(part) ||
          (part.state !== "input-streaming" &&
            part.state !== "input-available"),
      ),
    }));
  }
  for (const message of messages) {
    switch (message.role) {
      case "system": {
        const textParts = message.parts.filter((part) => part.type === "text");
        const providerMetadata = textParts.reduce((acc, part) => {
          if (part.providerMetadata != null) {
            return { ...acc, ...part.providerMetadata };
          }
          return acc;
        }, {});
        modelMessages.push({
          role: "system",
          content: textParts.map((part) => part.text).join(""),
          ...(Object.keys(providerMetadata).length > 0
            ? { providerOptions: providerMetadata }
            : {}),
        });
        break;
      }
      case "user": {
        modelMessages.push({
          role: "user",
          content: message.parts
            .filter((part) => part.type === "text" || part.type === "file")
            .map((part) => {
              switch (part.type) {
                case "text":
                  return {
                    type: "text",
                    text: part.text,
                    ...(part.providerMetadata != null
                      ? { providerOptions: part.providerMetadata }
                      : {}),
                  };
                case "file":
                  return {
                    type: "file",
                    mediaType: part.mediaType,
                    filename: part.filename,
                    data: part.url,
                    ...(part.providerMetadata != null
                      ? { providerOptions: part.providerMetadata }
                      : {}),
                  };
                default:
                  return part;
              }
            }),
        });
        break;
      }
      case "assistant": {
        if (message.parts != null) {
          let processBlock2 = function () {
            var _a172, _b9;
            if (block.length === 0) {
              return;
            }
            const content = [];
            for (const part of block) {
              if (part.type === "text") {
                content.push({
                  type: "text",
                  text: part.text,
                  ...(part.providerMetadata != null
                    ? { providerOptions: part.providerMetadata }
                    : {}),
                });
              } else if (part.type === "file") {
                content.push({
                  type: "file",
                  mediaType: part.mediaType,
                  filename: part.filename,
                  data: part.url,
                });
              } else if (part.type === "reasoning") {
                content.push({
                  type: "reasoning",
                  text: part.text,
                  providerOptions: part.providerMetadata,
                });
              } else if (part.type === "dynamic-tool") {
                const toolName = part.toolName;
                if (part.state !== "input-streaming") {
                  content.push({
                    type: "tool-call",
                    toolCallId: part.toolCallId,
                    toolName,
                    input: part.input,
                    ...(part.callProviderMetadata != null
                      ? { providerOptions: part.callProviderMetadata }
                      : {}),
                  });
                }
              } else if (isToolUIPart(part)) {
                const toolName = getToolName(part);
                if (part.state !== "input-streaming") {
                  content.push({
                    type: "tool-call",
                    toolCallId: part.toolCallId,
                    toolName,
                    input:
                      part.state === "output-error"
                        ? (_a172 = part.input) != null
                          ? _a172
                          : part.rawInput
                        : part.input,
                    providerExecuted: part.providerExecuted,
                    ...(part.callProviderMetadata != null
                      ? { providerOptions: part.callProviderMetadata }
                      : {}),
                  });
                  if (
                    part.providerExecuted === true &&
                    (part.state === "output-available" ||
                      part.state === "output-error")
                  ) {
                    content.push({
                      type: "tool-result",
                      toolCallId: part.toolCallId,
                      toolName,
                      output: createToolModelOutput({
                        output:
                          part.state === "output-error"
                            ? part.errorText
                            : part.output,
                        tool:
                          (_b9 = options == null ? void 0 : options.tools) ==
                          null
                            ? void 0
                            : _b9[toolName],
                        errorMode:
                          part.state === "output-error" ? "json" : "none",
                      }),
                    });
                  }
                }
              } else {
                const _exhaustiveCheck = part;
                throw new Error(`Unsupported part: ${_exhaustiveCheck}`);
              }
            }
            modelMessages.push({
              role: "assistant",
              content,
            });
            const toolParts = block.filter(
              (part) =>
                (isToolUIPart(part) && part.providerExecuted !== true) ||
                part.type === "dynamic-tool",
            );
            if (toolParts.length > 0) {
              modelMessages.push({
                role: "tool",
                content: toolParts
                  .map((toolPart) => {
                    var _a182;
                    switch (toolPart.state) {
                      case "output-error":
                      case "output-available": {
                        const toolName =
                          toolPart.type === "dynamic-tool"
                            ? toolPart.toolName
                            : getToolName(toolPart);
                        return {
                          type: "tool-result",
                          toolCallId: toolPart.toolCallId,
                          toolName,
                          output: createToolModelOutput({
                            output:
                              toolPart.state === "output-error"
                                ? toolPart.errorText
                                : toolPart.output,
                            tool:
                              (_a182 =
                                options == null ? void 0 : options.tools) ==
                              null
                                ? void 0
                                : _a182[toolName],
                            errorMode:
                              toolPart.state === "output-error"
                                ? "text"
                                : "none",
                          }),
                        };
                      }
                      default: {
                        return null;
                      }
                    }
                  })
                  .filter((output) => output != null),
              });
            }
            block = [];
          };
          var processBlock = processBlock2;
          let block = [];
          for (const part of message.parts) {
            if (
              part.type === "text" ||
              part.type === "reasoning" ||
              part.type === "file" ||
              part.type === "dynamic-tool" ||
              isToolUIPart(part)
            ) {
              block.push(part);
            } else if (part.type === "step-start") {
              processBlock2();
            }
          }
          processBlock2();
          break;
        }
        break;
      }
      default: {
        const _exhaustiveCheck = message.role;
        throw new MessageConversionError({
          originalMessage: message,
          message: `Unsupported role: ${_exhaustiveCheck}`,
        });
      }
    }
  }
  return modelMessages;
}
var originalGenerateId3 = createIdGenerator({ prefix: "aiobj", size: 24 });
var originalGenerateId4 = createIdGenerator({ prefix: "aiobj", size: 24 });
var output_exports = {};
__export2(output_exports, {
  object: () => object2,
  text: () => text,
});
var text = () => ({
  type: "text",
  responseFormat: { type: "text" },
  async parsePartial({ text: text2 }) {
    return { partial: text2 };
  },
  async parseOutput({ text: text2 }) {
    return text2;
  },
});
var object2 = ({ schema: inputSchema }) => {
  const schema = asSchema(inputSchema);
  return {
    type: "object",
    responseFormat: {
      type: "json",
      schema: schema.jsonSchema,
    },
    async parsePartial({ text: text2 }) {
      const result = await parsePartialJson(text2);
      switch (result.state) {
        case "failed-parse":
        case "undefined-input":
          return void 0;
        case "repaired-parse":
        case "successful-parse":
          return {
            // Note: currently no validation of partial results:
            partial: result.value,
          };
        default: {
          const _exhaustiveCheck = result.state;
          throw new Error(`Unsupported parse state: ${_exhaustiveCheck}`);
        }
      }
    },
    async parseOutput({ text: text2 }, context) {
      const parseResult = await safeParseJSON({ text: text2 });
      if (!parseResult.success) {
        throw new NoObjectGeneratedError({
          message: "No object generated: could not parse the response.",
          cause: parseResult.error,
          text: text2,
          response: context.response,
          usage: context.usage,
          finishReason: context.finishReason,
        });
      }
      const validationResult = await safeValidateTypes({
        value: parseResult.value,
        schema,
      });
      if (!validationResult.success) {
        throw new NoObjectGeneratedError({
          message: "No object generated: response did not match schema.",
          cause: validationResult.error,
          text: text2,
          response: context.response,
          usage: context.usage,
          finishReason: context.finishReason,
        });
      }
      return validationResult.value;
    },
  };
};
var CHUNKING_REGEXPS = {
  word: /\S+\s+/m,
  line: /\n+/m,
};
function smoothStream({
  delayInMs = 10,
  chunking = "word",
  _internal: { delay: delay2 = delay } = {},
} = {}) {
  let detectChunk;
  if (typeof chunking === "function") {
    detectChunk = (buffer) => {
      const match = chunking(buffer);
      if (match == null) {
        return null;
      }
      if (!match.length) {
        throw new Error(`Chunking function must return a non-empty string.`);
      }
      if (!buffer.startsWith(match)) {
        throw new Error(
          `Chunking function must return a match that is a prefix of the buffer. Received: "${match}" expected to start with "${buffer}"`,
        );
      }
      return match;
    };
  } else {
    const chunkingRegex =
      typeof chunking === "string" ? CHUNKING_REGEXPS[chunking] : chunking;
    if (chunkingRegex == null) {
      throw new InvalidArgumentError({
        argument: "chunking",
        message: `Chunking must be "word" or "line" or a RegExp. Received: ${chunking}`,
      });
    }
    detectChunk = (buffer) => {
      const match = chunkingRegex.exec(buffer);
      if (!match) {
        return null;
      }
      return buffer.slice(0, match.index) + (match == null ? void 0 : match[0]);
    };
  }
  return () => {
    let buffer = "";
    let id = "";
    return new TransformStream({
      async transform(chunk, controller) {
        if (chunk.type !== "text-delta") {
          if (buffer.length > 0) {
            controller.enqueue({ type: "text-delta", text: buffer, id });
            buffer = "";
          }
          controller.enqueue(chunk);
          return;
        }
        if (chunk.id !== id && buffer.length > 0) {
          controller.enqueue({ type: "text-delta", text: buffer, id });
          buffer = "";
        }
        buffer += chunk.text;
        id = chunk.id;
        let match;
        while ((match = detectChunk(buffer)) != null) {
          controller.enqueue({ type: "text-delta", text: match, id });
          buffer = buffer.slice(match.length);
          await delay2(delayInMs);
        }
      },
    });
  };
}
var name16 = "AI_NoSuchProviderError";
var marker162 = `vercel.ai.error.${name16}`;
var symbol162 = Symbol.for(marker162);
var _a162;
_a162 = symbol162;
var ClientOrServerImplementationSchema = external_exports.looseObject({
  name: external_exports.string(),
  version: external_exports.string(),
});
var BaseParamsSchema = external_exports.looseObject({
  _meta: external_exports.optional(external_exports.object({}).loose()),
});
var ResultSchema = BaseParamsSchema;
var RequestSchema = external_exports.object({
  method: external_exports.string(),
  params: external_exports.optional(BaseParamsSchema),
});
var ServerCapabilitiesSchema = external_exports.looseObject({
  experimental: external_exports.optional(external_exports.object({}).loose()),
  logging: external_exports.optional(external_exports.object({}).loose()),
  prompts: external_exports.optional(
    external_exports.looseObject({
      listChanged: external_exports.optional(external_exports.boolean()),
    }),
  ),
  resources: external_exports.optional(
    external_exports.looseObject({
      subscribe: external_exports.optional(external_exports.boolean()),
      listChanged: external_exports.optional(external_exports.boolean()),
    }),
  ),
  tools: external_exports.optional(
    external_exports.looseObject({
      listChanged: external_exports.optional(external_exports.boolean()),
    }),
  ),
});
var InitializeResultSchema = ResultSchema.extend({
  protocolVersion: external_exports.string(),
  capabilities: ServerCapabilitiesSchema,
  serverInfo: ClientOrServerImplementationSchema,
  instructions: external_exports.optional(external_exports.string()),
});
var PaginatedResultSchema = ResultSchema.extend({
  nextCursor: external_exports.optional(external_exports.string()),
});
var ToolSchema = external_exports
  .object({
    name: external_exports.string(),
    description: external_exports.optional(external_exports.string()),
    inputSchema: external_exports
      .object({
        type: external_exports.literal("object"),
        properties: external_exports.optional(
          external_exports.object({}).loose(),
        ),
      })
      .loose(),
  })
  .loose();
var ListToolsResultSchema = PaginatedResultSchema.extend({
  tools: external_exports.array(ToolSchema),
});
var TextContentSchema = external_exports
  .object({
    type: external_exports.literal("text"),
    text: external_exports.string(),
  })
  .loose();
var ImageContentSchema = external_exports
  .object({
    type: external_exports.literal("image"),
    data: external_exports.base64(),
    mimeType: external_exports.string(),
  })
  .loose();
var ResourceContentsSchema = external_exports
  .object({
    /**
     * The URI of this resource.
     */
    uri: external_exports.string(),
    /**
     * The MIME type of this resource, if known.
     */
    mimeType: external_exports.optional(external_exports.string()),
  })
  .loose();
var TextResourceContentsSchema = ResourceContentsSchema.extend({
  text: external_exports.string(),
});
var BlobResourceContentsSchema = ResourceContentsSchema.extend({
  blob: external_exports.base64(),
});
var EmbeddedResourceSchema = external_exports
  .object({
    type: external_exports.literal("resource"),
    resource: external_exports.union([
      TextResourceContentsSchema,
      BlobResourceContentsSchema,
    ]),
  })
  .loose();
var CallToolResultSchema = ResultSchema.extend({
  content: external_exports.array(
    external_exports.union([
      TextContentSchema,
      ImageContentSchema,
      EmbeddedResourceSchema,
    ]),
  ),
  isError: external_exports.boolean().default(false).optional(),
}).or(
  ResultSchema.extend({
    toolResult: external_exports.unknown(),
  }),
);
var JSONRPC_VERSION = "2.0";
var JSONRPCRequestSchema = external_exports
  .object({
    jsonrpc: external_exports.literal(JSONRPC_VERSION),
    id: external_exports.union([
      external_exports.string(),
      external_exports.number().int(),
    ]),
  })
  .merge(RequestSchema)
  .strict();
var JSONRPCResponseSchema = external_exports
  .object({
    jsonrpc: external_exports.literal(JSONRPC_VERSION),
    id: external_exports.union([
      external_exports.string(),
      external_exports.number().int(),
    ]),
    result: ResultSchema,
  })
  .strict();
var JSONRPCErrorSchema = external_exports
  .object({
    jsonrpc: external_exports.literal(JSONRPC_VERSION),
    id: external_exports.union([
      external_exports.string(),
      external_exports.number().int(),
    ]),
    error: external_exports.object({
      code: external_exports.number().int(),
      message: external_exports.string(),
      data: external_exports.optional(external_exports.unknown()),
    }),
  })
  .strict();
var JSONRPCNotificationSchema = external_exports
  .object({
    jsonrpc: external_exports.literal(JSONRPC_VERSION),
  })
  .merge(
    external_exports.object({
      method: external_exports.string(),
      params: external_exports.optional(BaseParamsSchema),
    }),
  )
  .strict();
var JSONRPCMessageSchema = external_exports.union([
  JSONRPCRequestSchema,
  JSONRPCNotificationSchema,
  JSONRPCResponseSchema,
  JSONRPCErrorSchema,
]);
var textUIPartSchema = external_exports.object({
  type: external_exports.literal("text"),
  text: external_exports.string(),
  state: external_exports.enum(["streaming", "done"]).optional(),
  providerMetadata: providerMetadataSchema.optional(),
});
var reasoningUIPartSchema = external_exports.object({
  type: external_exports.literal("reasoning"),
  text: external_exports.string(),
  state: external_exports.enum(["streaming", "done"]).optional(),
  providerMetadata: providerMetadataSchema.optional(),
});
var sourceUrlUIPartSchema = external_exports.object({
  type: external_exports.literal("source-url"),
  sourceId: external_exports.string(),
  url: external_exports.string(),
  title: external_exports.string().optional(),
  providerMetadata: providerMetadataSchema.optional(),
});
var sourceDocumentUIPartSchema = external_exports.object({
  type: external_exports.literal("source-document"),
  sourceId: external_exports.string(),
  mediaType: external_exports.string(),
  title: external_exports.string(),
  filename: external_exports.string().optional(),
  providerMetadata: providerMetadataSchema.optional(),
});
var fileUIPartSchema = external_exports.object({
  type: external_exports.literal("file"),
  mediaType: external_exports.string(),
  filename: external_exports.string().optional(),
  url: external_exports.string(),
  providerMetadata: providerMetadataSchema.optional(),
});
var stepStartUIPartSchema = external_exports.object({
  type: external_exports.literal("step-start"),
});
var dataUIPartSchema = external_exports.object({
  type: external_exports.string().startsWith("data-"),
  id: external_exports.string().optional(),
  data: external_exports.unknown(),
});
var dynamicToolUIPartSchemas = [
  external_exports.object({
    type: external_exports.literal("dynamic-tool"),
    toolName: external_exports.string(),
    toolCallId: external_exports.string(),
    state: external_exports.literal("input-streaming"),
    input: external_exports.unknown().optional(),
    output: external_exports.never().optional(),
    errorText: external_exports.never().optional(),
  }),
  external_exports.object({
    type: external_exports.literal("dynamic-tool"),
    toolName: external_exports.string(),
    toolCallId: external_exports.string(),
    state: external_exports.literal("input-available"),
    input: external_exports.unknown(),
    output: external_exports.never().optional(),
    errorText: external_exports.never().optional(),
    callProviderMetadata: providerMetadataSchema.optional(),
  }),
  external_exports.object({
    type: external_exports.literal("dynamic-tool"),
    toolName: external_exports.string(),
    toolCallId: external_exports.string(),
    state: external_exports.literal("output-available"),
    input: external_exports.unknown(),
    output: external_exports.unknown(),
    errorText: external_exports.never().optional(),
    callProviderMetadata: providerMetadataSchema.optional(),
    preliminary: external_exports.boolean().optional(),
  }),
  external_exports.object({
    type: external_exports.literal("dynamic-tool"),
    toolName: external_exports.string(),
    toolCallId: external_exports.string(),
    state: external_exports.literal("output-error"),
    input: external_exports.unknown(),
    output: external_exports.never().optional(),
    errorText: external_exports.string(),
    callProviderMetadata: providerMetadataSchema.optional(),
  }),
];
var toolUIPartSchemas = [
  external_exports.object({
    type: external_exports.string().startsWith("tool-"),
    toolCallId: external_exports.string(),
    state: external_exports.literal("input-streaming"),
    providerExecuted: external_exports.boolean().optional(),
    input: external_exports.unknown().optional(),
    output: external_exports.never().optional(),
    errorText: external_exports.never().optional(),
  }),
  external_exports.object({
    type: external_exports.string().startsWith("tool-"),
    toolCallId: external_exports.string(),
    state: external_exports.literal("input-available"),
    providerExecuted: external_exports.boolean().optional(),
    input: external_exports.unknown(),
    output: external_exports.never().optional(),
    errorText: external_exports.never().optional(),
    callProviderMetadata: providerMetadataSchema.optional(),
  }),
  external_exports.object({
    type: external_exports.string().startsWith("tool-"),
    toolCallId: external_exports.string(),
    state: external_exports.literal("output-available"),
    providerExecuted: external_exports.boolean().optional(),
    input: external_exports.unknown(),
    output: external_exports.unknown(),
    errorText: external_exports.never().optional(),
    callProviderMetadata: providerMetadataSchema.optional(),
    preliminary: external_exports.boolean().optional(),
  }),
  external_exports.object({
    type: external_exports.string().startsWith("tool-"),
    toolCallId: external_exports.string(),
    state: external_exports.literal("output-error"),
    providerExecuted: external_exports.boolean().optional(),
    input: external_exports.unknown(),
    output: external_exports.never().optional(),
    errorText: external_exports.string(),
    callProviderMetadata: providerMetadataSchema.optional(),
  }),
];
var uiMessageSchema = external_exports.object({
  id: external_exports.string(),
  role: external_exports.enum(["system", "user", "assistant"]),
  metadata: external_exports.unknown().optional(),
  parts: external_exports.array(
    external_exports.union([
      textUIPartSchema,
      reasoningUIPartSchema,
      sourceUrlUIPartSchema,
      sourceDocumentUIPartSchema,
      fileUIPartSchema,
      stepStartUIPartSchema,
      dataUIPartSchema,
      ...dynamicToolUIPartSchemas,
      ...toolUIPartSchemas,
    ]),
  ),
});

// ai-telemetry-wrapper:ai
function streamText2(options) {
  if (!options || !options.experimental_telemetry) {
    return streamText({
      ...options,
      experimental_telemetry: { isEnabled: true },
    });
  }
  return streamText(options);
}

// node_modules/blink/dist/cookie-CyZUsiHM.js
var t = `BLINK_API_SERVER_URL`;
var S = (e2, t2, n = {}) => {
  let r2 = `${e2}=${t2}`;
  if (e2.startsWith(`__Secure-`) && !n.secure)
    throw Error(`__Secure- Cookie must have Secure attributes`);
  if (e2.startsWith(`__Host-`)) {
    if (!n.secure) throw Error(`__Host- Cookie must have Secure attributes`);
    if (n.path !== `/`)
      throw Error(`__Host- Cookie must have Path attributes with "/"`);
    if (n.domain) throw Error(`__Host- Cookie must not have Domain attributes`);
  }
  if (n && typeof n.maxAge == `number` && n.maxAge >= 0) {
    if (n.maxAge > 3456e4)
      throw Error(
        `Cookies Max-Age SHOULD NOT be greater than 400 days (34560000 seconds) in duration.`,
      );
    r2 += `; Max-Age=${n.maxAge | 0}`;
  }
  if (
    (n.domain && n.prefix !== `host` && (r2 += `; Domain=${n.domain}`),
    n.path && (r2 += `; Path=${n.path}`),
    n.expires)
  ) {
    if (n.expires.getTime() - Date.now() > 3456e7)
      throw Error(
        `Cookies Expires SHOULD NOT be greater than 400 days (34560000 seconds) in the future.`,
      );
    r2 += `; Expires=${n.expires.toUTCString()}`;
  }
  if (
    (n.httpOnly && (r2 += `; HttpOnly`),
    n.secure && (r2 += `; Secure`),
    n.sameSite &&
      (r2 += `; SameSite=${n.sameSite.charAt(0).toUpperCase() + n.sameSite.slice(1)}`),
    n.priority &&
      (r2 += `; Priority=${n.priority.charAt(0).toUpperCase() + n.priority.slice(1)}`),
    n.partitioned)
  ) {
    if (!n.secure)
      throw Error(`Partitioned Cookie must have Secure attributes`);
    r2 += `; Partitioned`;
  }
  return r2;
};
var C = (e2, t2, n) => ((t2 = encodeURIComponent(t2)), S(e2, t2, n));

// node_modules/blink/dist/api/index.js
import r from "util";
var i = (e2, t2) => (
  (e2 = e2.replace(/\/+$/, ``)),
  (e2 += `/`),
  (t2 = t2.replace(/^\/+/, ``)),
  e2 + t2
);
var a = (e2, t2) => {
  for (let [n, r2] of Object.entries(t2)) {
    let t3 = RegExp(`/:` + n + `(?:{[^/]+})?\\??`);
    e2 = e2.replace(t3, r2 ? `/${r2}` : ``);
  }
  return e2;
};
var o = (e2) => {
  let t2 = new URLSearchParams();
  for (let [n, r2] of Object.entries(e2)) {
    if (r2 === void 0) continue;
    if (Array.isArray(r2)) for (let e3 of r2) t2.append(n, e3);
    else t2.set(n, r2);
  }
  return t2;
};
var s = (e2, t2) => {
  switch (t2) {
    case `ws`:
      return e2.replace(/^http/, `ws`);
    case `http`:
      return e2.replace(/^ws/, `http`);
  }
};
var c = (e2) =>
  /^https?:\/\/[^\/]+?\/index(?=\?|$)/.test(e2)
    ? e2.replace(/\/index(?=\?|$)/, `/`)
    : e2.replace(/\/index(?=\?|$)/, ``);
function l(e2) {
  return typeof e2 == `object` && !!e2 && !Array.isArray(e2);
}
function u(e2, t2) {
  if (!l(e2) && !l(t2)) return t2;
  let n = { ...e2 };
  for (let e3 in t2) {
    let r2 = t2[e3];
    l(n[e3]) && l(r2) ? (n[e3] = u(n[e3], r2)) : (n[e3] = r2);
  }
  return n;
}
var d = (e2, t2) => {
  let n = new Proxy(() => {}, {
    get(n2, r2) {
      if (!(typeof r2 != `string` || r2 === `then`)) return d(e2, [...t2, r2]);
    },
    apply(n2, r2, i2) {
      return e2({ path: t2, args: i2 });
    },
  });
  return n;
};
var f = class {
  url;
  method;
  queryParams = void 0;
  pathParams = {};
  rBody;
  cType = void 0;
  constructor(e2, t2) {
    ((this.url = e2), (this.method = t2));
  }
  fetch = async (e2, t2) => {
    if (e2) {
      if ((e2.query && (this.queryParams = o(e2.query)), e2.form)) {
        let t3 = new FormData();
        for (let [n, r3] of Object.entries(e2.form))
          if (Array.isArray(r3)) for (let e3 of r3) t3.append(n, e3);
          else t3.append(n, r3);
        this.rBody = t3;
      }
      (e2.json &&
        ((this.rBody = JSON.stringify(e2.json)),
        (this.cType = `application/json`)),
        e2.param && (this.pathParams = e2.param));
    }
    let r2 = this.method.toUpperCase(),
      i2 = {
        ...e2?.header,
        ...(typeof t2?.headers == `function`
          ? await t2.headers()
          : t2?.headers),
      };
    if (e2?.cookie) {
      let t3 = [];
      for (let [r3, i3] of Object.entries(e2.cookie))
        t3.push(C(r3, i3, { path: `/` }));
      i2.Cookie = t3.join(`,`);
    }
    this.cType && (i2[`Content-Type`] = this.cType);
    let s2 = new Headers(i2 ?? void 0),
      l2 = this.url;
    ((l2 = c(l2)),
      (l2 = a(l2, this.pathParams)),
      this.queryParams && (l2 = l2 + `?` + this.queryParams.toString()),
      (r2 = this.method.toUpperCase()));
    let u2 = !(r2 === `GET` || r2 === `HEAD`);
    return (t2?.fetch || fetch)(l2, {
      body: u2 ? this.rBody : void 0,
      method: r2,
      headers: s2,
      ...t2?.init,
    });
  };
};
var p = (e2, t2) =>
  d(function n(r2) {
    let l2 = [...r2.path],
      d2 = l2.slice(-3).reverse();
    if (d2[0] === `toString`)
      return d2[1] === `name` ? d2[2] || `` : n.toString();
    if (d2[0] === `valueOf`) return d2[1] === `name` ? d2[2] || `` : n;
    let p2 = ``;
    if (/^\$/.test(d2[0])) {
      let e3 = l2.pop();
      e3 && (p2 = e3.replace(/^\$/, ``));
    }
    let m2 = l2.join(`/`),
      h2 = i(e2, m2);
    if (p2 === `url`) {
      let e3 = h2;
      return (
        r2.args[0] &&
          (r2.args[0].param && (e3 = a(h2, r2.args[0].param)),
          r2.args[0].query && (e3 = e3 + `?` + o(r2.args[0].query).toString())),
        (e3 = c(e3)),
        new URL(e3)
      );
    }
    if (p2 === `ws`) {
      let e3 = s(
          r2.args[0] && r2.args[0].param ? a(h2, r2.args[0].param) : h2,
          `ws`,
        ),
        n2 = new URL(e3),
        i2 = r2.args[0]?.query;
      i2 &&
        Object.entries(i2).forEach(([e4, t3]) => {
          Array.isArray(t3)
            ? t3.forEach((t4) => n2.searchParams.append(e4, t4))
            : n2.searchParams.set(e4, t3);
        });
      let o2 = (...e4) =>
        t2?.webSocket !== void 0 && typeof t2.webSocket == `function`
          ? t2.webSocket(...e4)
          : new WebSocket(...e4);
      return o2(n2.toString());
    }
    let g2 = new f(h2, p2);
    if (p2) {
      t2 ??= {};
      let e3 = u(t2, { ...r2.args[1] });
      return g2.fetch(r2.args[0], e3);
    }
    return g2;
  }, []);
var m = process.env[t];
var h = p(m ?? ``, {
  fetch: m
    ? void 0
    : async () => {
        throw (
          console.warn(
            `Your code is attempting to use the Blink API server, but no API server is configured for this Blink agent.`,
          ),
          Error(
            `No API server is configured for this Blink agent. External APIs are not available.`,
          )
        );
      },
});
var g = Object.freeze({
  upsert: async (e2) => {
    let t2 = await h.chat[`:id`].$post({ param: { id: e2 } });
    if (t2.status !== 200) {
      let e3 = await t2.json();
      throw Error(e3.error);
    }
    return { id: e2 };
  },
  message: async (e2, t2, n) => {
    let r2 = await h.chat[`:id`].sendMessages.$post({
      param: { id: e2 },
      json: { messages: [t2], behavior: n?.behavior ?? `enqueue` },
    });
    if (r2.status !== 204) {
      let e3 = await r2.json();
      throw Error(e3.error);
    }
  },
});
var _ = Object.freeze({
  kv: Object.freeze({
    get: async (e2) => {
      let t2 = await h.storage.kv[`:key`].$get({ param: { key: e2 } });
      if (t2.status !== 200) {
        let e3 = await t2.json();
        throw Error(e3.error);
      }
      let n = await t2.json();
      return n.value;
    },
    set: async (e2, t2) => {
      let n = await h.storage.kv[`:key`].$post({
        param: { key: e2 },
        json: { value: t2 },
      });
      if (n.status !== 204) {
        let e3 = await n.json();
        throw Error(e3.error);
      }
    },
    del: async (e2) => {
      let t2 = await h.storage.kv[`:key`].$delete({ param: { key: e2 } });
      if (t2.status !== 204) {
        let e3 = await t2.json();
        throw Error(e3.error);
      }
    },
  }),
});
var v = {
  with(e2, t2) {
    let n = {};
    for (let r2 of Object.keys(e2)) {
      let i2 = e2[r2];
      n[r2] = i2.with(t2);
    }
    return n;
  },
  prefix(e2, t2) {
    let n = {};
    for (let [r2, i2] of Object.entries(e2)) n[`${t2}${r2}`] = i2;
    return n;
  },
};
function y(e2) {
  return {
    version: `v0`,
    supportsRequests: e2.onRequest !== void 0,
    fetch: async (t2) => {
      let n = new URL(t2.url);
      if (n.pathname.startsWith(`/_agent/`))
        switch (n.pathname) {
          case `/_agent/send-messages`:
            return b(t2, e2);
          case `/_agent/health`:
            return new Response(`OK`, { status: 200 });
          default:
            return new Response(`Not found`, { status: 404 });
        }
      if (e2.onRequest) {
        let n2;
        try {
          n2 = await e2.onRequest(t2);
        } catch (e3) {
          return new Response(JSON.stringify({ error: r.inspect(e3) }), {
            status: 500,
          });
        }
        if (n2) return n2;
      }
      return new Response(`Not found`, { status: 404 });
    },
  };
}
async function b(e2, t2) {
  if (e2.method !== `POST`)
    return new Response(`Method not allowed`, { status: 405 });
  let n;
  try {
    n = await e2.json();
  } catch {
    return new Response(`Invalid request`, { status: 400 });
  }
  let i2;
  try {
    i2 = await t2.sendMessages({ messages: n.messages, chat: n.chat });
  } catch (e3) {
    return new Response(JSON.stringify({ error: r.inspect(e3) }), {
      status: 500,
    });
  }
  if (i2 instanceof Response) return i2;
  let a2;
  if (i2 instanceof ReadableStream) a2 = i2;
  else {
    if (typeof i2 != `object` || !(`toUIMessageStream` in i2))
      throw Error(
        `The agent must return a "Response", "ReadableStream", or "toUIMessageStream" function.`,
      );
    a2 = i2.toUIMessageStream();
  }
  return new Response(
    a2
      .pipeThrough(
        new TransformStream({
          transform(e3, t3) {
            t3.enqueue(`data: ${JSON.stringify(e3)}

`);
          },
          flush(e3) {
            e3.enqueue(`data: [DONE]

`);
          },
        }),
      )
      .pipeThrough(new TextEncoderStream()),
    {
      headers: {
        "content-type": `text/event-stream`,
        "cache-control": `no-cache, no-transform`,
        connection: `keep-alive`,
        "x-vercel-ai-ui-message-stream": `v1`,
        "x-accel-buffering": `no`,
      },
    },
  );
}
var S2 = { agent: y, chat: g, storage: _, tools: v };

// agent.ts
var import_fast_xml_parser = __toESM(require_fxp(), 1);
var import_node_html_parser = __toESM(require_dist(), 1);

// node_modules/@blink-sdk/github/dist/index.js
import { createRequire } from "node:module";

// node_modules/universal-user-agent/index.js
function getUserAgent() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }
  if (typeof process === "object" && process.version !== void 0) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }
  return "<environment undetectable>";
}

// node_modules/before-after-hook/lib/register.js
function register(state, name18, method, options) {
  if (typeof method !== "function") {
    throw new Error("method for before hook must be a function");
  }
  if (!options) {
    options = {};
  }
  if (Array.isArray(name18)) {
    return name18.reverse().reduce((callback, name19) => {
      return register.bind(null, state, name19, callback, options);
    }, method)();
  }
  return Promise.resolve().then(() => {
    if (!state.registry[name18]) {
      return method(options);
    }
    return state.registry[name18].reduce((method2, registered) => {
      return registered.hook.bind(null, method2, options);
    }, method)();
  });
}

// node_modules/before-after-hook/lib/add.js
function addHook(state, kind, name18, hook2) {
  const orig = hook2;
  if (!state.registry[name18]) {
    state.registry[name18] = [];
  }
  if (kind === "before") {
    hook2 = (method, options) => {
      return Promise.resolve()
        .then(orig.bind(null, options))
        .then(method.bind(null, options));
    };
  }
  if (kind === "after") {
    hook2 = (method, options) => {
      let result;
      return Promise.resolve()
        .then(method.bind(null, options))
        .then((result_) => {
          result = result_;
          return orig(result, options);
        })
        .then(() => {
          return result;
        });
    };
  }
  if (kind === "error") {
    hook2 = (method, options) => {
      return Promise.resolve()
        .then(method.bind(null, options))
        .catch((error45) => {
          return orig(error45, options);
        });
    };
  }
  state.registry[name18].push({
    hook: hook2,
    orig,
  });
}

// node_modules/before-after-hook/lib/remove.js
function removeHook(state, name18, method) {
  if (!state.registry[name18]) {
    return;
  }
  const index = state.registry[name18]
    .map((registered) => {
      return registered.orig;
    })
    .indexOf(method);
  if (index === -1) {
    return;
  }
  state.registry[name18].splice(index, 1);
}

// node_modules/before-after-hook/index.js
var bind = Function.bind;
var bindable = bind.bind(bind);
function bindApi(hook2, state, name18) {
  const removeHookRef = bindable(removeHook, null).apply(
    null,
    name18 ? [state, name18] : [state],
  );
  hook2.api = { remove: removeHookRef };
  hook2.remove = removeHookRef;
  ["before", "error", "after", "wrap"].forEach((kind) => {
    const args = name18 ? [state, kind, name18] : [state, kind];
    hook2[kind] = hook2.api[kind] = bindable(addHook, null).apply(null, args);
  });
}
function Singular() {
  const singularHookName = Symbol("Singular");
  const singularHookState = {
    registry: {},
  };
  const singularHook = register.bind(null, singularHookState, singularHookName);
  bindApi(singularHook, singularHookState, singularHookName);
  return singularHook;
}
function Collection() {
  const state = {
    registry: {},
  };
  const hook2 = register.bind(null, state);
  bindApi(hook2, state);
  return hook2;
}
var before_after_hook_default = { Singular, Collection };

// node_modules/@octokit/endpoint/dist-bundle/index.js
var VERSION5 = "0.0.0-development";
var userAgent = `octokit-endpoint.js/${VERSION5} ${getUserAgent()}`;
var DEFAULTS = {
  method: "GET",
  baseUrl: "https://api.github.com",
  headers: {
    accept: "application/vnd.github.v3+json",
    "user-agent": userAgent,
  },
  mediaType: {
    format: "",
  },
};
function lowercaseKeys(object4) {
  if (!object4) {
    return {};
  }
  return Object.keys(object4).reduce((newObj, key) => {
    newObj[key.toLowerCase()] = object4[key];
    return newObj;
  }, {});
}
function isPlainObject2(value) {
  if (typeof value !== "object" || value === null) return false;
  if (Object.prototype.toString.call(value) !== "[object Object]") return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null) return true;
  const Ctor =
    Object.prototype.hasOwnProperty.call(proto, "constructor") &&
    proto.constructor;
  return (
    typeof Ctor === "function" &&
    Ctor instanceof Ctor &&
    Function.prototype.call(Ctor) === Function.prototype.call(value)
  );
}
function mergeDeep(defaults, options) {
  const result = Object.assign({}, defaults);
  Object.keys(options).forEach((key) => {
    if (isPlainObject2(options[key])) {
      if (!(key in defaults)) Object.assign(result, { [key]: options[key] });
      else result[key] = mergeDeep(defaults[key], options[key]);
    } else {
      Object.assign(result, { [key]: options[key] });
    }
  });
  return result;
}
function removeUndefinedProperties(obj) {
  for (const key in obj) {
    if (obj[key] === void 0) {
      delete obj[key];
    }
  }
  return obj;
}
function merge2(defaults, route, options) {
  if (typeof route === "string") {
    let [method, url2] = route.split(" ");
    options = Object.assign(
      url2 ? { method, url: url2 } : { url: method },
      options,
    );
  } else {
    options = Object.assign({}, route);
  }
  options.headers = lowercaseKeys(options.headers);
  removeUndefinedProperties(options);
  removeUndefinedProperties(options.headers);
  const mergedOptions = mergeDeep(defaults || {}, options);
  if (options.url === "/graphql") {
    if (defaults && defaults.mediaType.previews?.length) {
      mergedOptions.mediaType.previews = defaults.mediaType.previews
        .filter(
          (preview) => !mergedOptions.mediaType.previews.includes(preview),
        )
        .concat(mergedOptions.mediaType.previews);
    }
    mergedOptions.mediaType.previews = (
      mergedOptions.mediaType.previews || []
    ).map((preview) => preview.replace(/-preview/, ""));
  }
  return mergedOptions;
}
function addQueryParameters(url2, parameters) {
  const separator = /\?/.test(url2) ? "&" : "?";
  const names = Object.keys(parameters);
  if (names.length === 0) {
    return url2;
  }
  return (
    url2 +
    separator +
    names
      .map((name18) => {
        if (name18 === "q") {
          return (
            "q=" + parameters.q.split("+").map(encodeURIComponent).join("+")
          );
        }
        return `${name18}=${encodeURIComponent(parameters[name18])}`;
      })
      .join("&")
  );
}
var urlVariableRegex = /\{[^{}}]+\}/g;
function removeNonChars(variableName) {
  return variableName.replace(/(?:^\W+)|(?:(?<!\W)\W+$)/g, "").split(/,/);
}
function extractUrlVariableNames(url2) {
  const matches = url2.match(urlVariableRegex);
  if (!matches) {
    return [];
  }
  return matches.map(removeNonChars).reduce((a2, b2) => a2.concat(b2), []);
}
function omit2(object4, keysToOmit) {
  const result = { __proto__: null };
  for (const key of Object.keys(object4)) {
    if (keysToOmit.indexOf(key) === -1) {
      result[key] = object4[key];
    }
  }
  return result;
}
function encodeReserved(str) {
  return str
    .split(/(%[0-9A-Fa-f]{2})/g)
    .map(function (part) {
      if (!/%[0-9A-Fa-f]/.test(part)) {
        part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
      }
      return part;
    })
    .join("");
}
function encodeUnreserved(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function (c2) {
    return "%" + c2.charCodeAt(0).toString(16).toUpperCase();
  });
}
function encodeValue(operator, value, key) {
  value =
    operator === "+" || operator === "#"
      ? encodeReserved(value)
      : encodeUnreserved(value);
  if (key) {
    return encodeUnreserved(key) + "=" + value;
  } else {
    return value;
  }
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isKeyOperator(operator) {
  return operator === ";" || operator === "&" || operator === "?";
}
function getValues(context, operator, key, modifier) {
  var value = context[key],
    result = [];
  if (isDefined(value) && value !== "") {
    if (
      typeof value === "string" ||
      typeof value === "number" ||
      typeof value === "boolean"
    ) {
      value = value.toString();
      if (modifier && modifier !== "*") {
        value = value.substring(0, parseInt(modifier, 10));
      }
      result.push(
        encodeValue(operator, value, isKeyOperator(operator) ? key : ""),
      );
    } else {
      if (modifier === "*") {
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function (value2) {
            result.push(
              encodeValue(operator, value2, isKeyOperator(operator) ? key : ""),
            );
          });
        } else {
          Object.keys(value).forEach(function (k) {
            if (isDefined(value[k])) {
              result.push(encodeValue(operator, value[k], k));
            }
          });
        }
      } else {
        const tmp = [];
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function (value2) {
            tmp.push(encodeValue(operator, value2));
          });
        } else {
          Object.keys(value).forEach(function (k) {
            if (isDefined(value[k])) {
              tmp.push(encodeUnreserved(k));
              tmp.push(encodeValue(operator, value[k].toString()));
            }
          });
        }
        if (isKeyOperator(operator)) {
          result.push(encodeUnreserved(key) + "=" + tmp.join(","));
        } else if (tmp.length !== 0) {
          result.push(tmp.join(","));
        }
      }
    }
  } else {
    if (operator === ";") {
      if (isDefined(value)) {
        result.push(encodeUnreserved(key));
      }
    } else if (value === "" && (operator === "&" || operator === "?")) {
      result.push(encodeUnreserved(key) + "=");
    } else if (value === "") {
      result.push("");
    }
  }
  return result;
}
function parseUrl(template) {
  return {
    expand: expand.bind(null, template),
  };
}
function expand(template, context) {
  var operators = ["+", "#", ".", "/", ";", "?", "&"];
  template = template.replace(
    /\{([^\{\}]+)\}|([^\{\}]+)/g,
    function (_2, expression, literal3) {
      if (expression) {
        let operator = "";
        const values = [];
        if (operators.indexOf(expression.charAt(0)) !== -1) {
          operator = expression.charAt(0);
          expression = expression.substr(1);
        }
        expression.split(/,/g).forEach(function (variable) {
          var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
          values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
        });
        if (operator && operator !== "+") {
          var separator = ",";
          if (operator === "?") {
            separator = "&";
          } else if (operator !== "#") {
            separator = operator;
          }
          return (values.length !== 0 ? operator : "") + values.join(separator);
        } else {
          return values.join(",");
        }
      } else {
        return encodeReserved(literal3);
      }
    },
  );
  if (template === "/") {
    return template;
  } else {
    return template.replace(/\/$/, "");
  }
}
function parse4(options) {
  let method = options.method.toUpperCase();
  let url2 = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
  let headers = Object.assign({}, options.headers);
  let body;
  let parameters = omit2(options, [
    "method",
    "baseUrl",
    "url",
    "headers",
    "request",
    "mediaType",
  ]);
  const urlVariableNames = extractUrlVariableNames(url2);
  url2 = parseUrl(url2).expand(parameters);
  if (!/^http/.test(url2)) {
    url2 = options.baseUrl + url2;
  }
  const omittedParameters = Object.keys(options)
    .filter((option) => urlVariableNames.includes(option))
    .concat("baseUrl");
  const remainingParameters = omit2(parameters, omittedParameters);
  const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
  if (!isBinaryRequest) {
    if (options.mediaType.format) {
      headers.accept = headers.accept
        .split(/,/)
        .map((format) =>
          format.replace(
            /application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/,
            `application/vnd$1$2.${options.mediaType.format}`,
          ),
        )
        .join(",");
    }
    if (url2.endsWith("/graphql")) {
      if (options.mediaType.previews?.length) {
        const previewsFromAcceptHeader =
          headers.accept.match(/(?<![\w-])[\w-]+(?=-preview)/g) || [];
        headers.accept = previewsFromAcceptHeader
          .concat(options.mediaType.previews)
          .map((preview) => {
            const format = options.mediaType.format
              ? `.${options.mediaType.format}`
              : "+json";
            return `application/vnd.github.${preview}-preview${format}`;
          })
          .join(",");
      }
    }
  }
  if (["GET", "HEAD"].includes(method)) {
    url2 = addQueryParameters(url2, remainingParameters);
  } else {
    if ("data" in remainingParameters) {
      body = remainingParameters.data;
    } else {
      if (Object.keys(remainingParameters).length) {
        body = remainingParameters;
      }
    }
  }
  if (!headers["content-type"] && typeof body !== "undefined") {
    headers["content-type"] = "application/json; charset=utf-8";
  }
  if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
    body = "";
  }
  return Object.assign(
    { method, url: url2, headers },
    typeof body !== "undefined" ? { body } : null,
    options.request ? { request: options.request } : null,
  );
}
function endpointWithDefaults(defaults, route, options) {
  return parse4(merge2(defaults, route, options));
}
function withDefaults(oldDefaults, newDefaults) {
  const DEFAULTS2 = merge2(oldDefaults, newDefaults);
  const endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);
  return Object.assign(endpoint2, {
    DEFAULTS: DEFAULTS2,
    defaults: withDefaults.bind(null, DEFAULTS2),
    merge: merge2.bind(null, DEFAULTS2),
    parse: parse4,
  });
}
var endpoint = withDefaults(null, DEFAULTS);

// node_modules/@octokit/request/dist-bundle/index.js
var import_fast_content_type_parse = __toESM(
  require_fast_content_type_parse(),
  1,
);

// node_modules/@octokit/request-error/dist-src/index.js
var RequestError = class extends Error {
  name;
  /**
   * http status code
   */
  status;
  /**
   * Request options that lead to the error.
   */
  request;
  /**
   * Response object if a response was received
   */
  response;
  constructor(message, statusCode, options) {
    super(message);
    this.name = "HttpError";
    this.status = Number.parseInt(statusCode);
    if (Number.isNaN(this.status)) {
      this.status = 0;
    }
    if ("response" in options) {
      this.response = options.response;
    }
    const requestCopy = Object.assign({}, options.request);
    if (options.request.headers.authorization) {
      requestCopy.headers = Object.assign({}, options.request.headers, {
        authorization: options.request.headers.authorization.replace(
          /(?<! ) .*$/,
          " [REDACTED]",
        ),
      });
    }
    requestCopy.url = requestCopy.url
      .replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]")
      .replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
    this.request = requestCopy;
  }
};

// node_modules/@octokit/request/dist-bundle/index.js
var VERSION6 = "10.0.3";
var defaults_default = {
  headers: {
    "user-agent": `octokit-request.js/${VERSION6} ${getUserAgent()}`,
  },
};
function isPlainObject3(value) {
  if (typeof value !== "object" || value === null) return false;
  if (Object.prototype.toString.call(value) !== "[object Object]") return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null) return true;
  const Ctor =
    Object.prototype.hasOwnProperty.call(proto, "constructor") &&
    proto.constructor;
  return (
    typeof Ctor === "function" &&
    Ctor instanceof Ctor &&
    Function.prototype.call(Ctor) === Function.prototype.call(value)
  );
}
async function fetchWrapper(requestOptions) {
  const fetch2 = requestOptions.request?.fetch || globalThis.fetch;
  if (!fetch2) {
    throw new Error(
      "fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing",
    );
  }
  const log = requestOptions.request?.log || console;
  const parseSuccessResponseBody =
    requestOptions.request?.parseSuccessResponseBody !== false;
  const body =
    isPlainObject3(requestOptions.body) || Array.isArray(requestOptions.body)
      ? JSON.stringify(requestOptions.body)
      : requestOptions.body;
  const requestHeaders = Object.fromEntries(
    Object.entries(requestOptions.headers).map(([name18, value]) => [
      name18,
      String(value),
    ]),
  );
  let fetchResponse;
  try {
    fetchResponse = await fetch2(requestOptions.url, {
      method: requestOptions.method,
      body,
      redirect: requestOptions.request?.redirect,
      headers: requestHeaders,
      signal: requestOptions.request?.signal,
      // duplex must be set if request.body is ReadableStream or Async Iterables.
      // See https://fetch.spec.whatwg.org/#dom-requestinit-duplex.
      ...(requestOptions.body && { duplex: "half" }),
    });
  } catch (error45) {
    let message = "Unknown Error";
    if (error45 instanceof Error) {
      if (error45.name === "AbortError") {
        error45.status = 500;
        throw error45;
      }
      message = error45.message;
      if (error45.name === "TypeError" && "cause" in error45) {
        if (error45.cause instanceof Error) {
          message = error45.cause.message;
        } else if (typeof error45.cause === "string") {
          message = error45.cause;
        }
      }
    }
    const requestError = new RequestError(message, 500, {
      request: requestOptions,
    });
    requestError.cause = error45;
    throw requestError;
  }
  const status = fetchResponse.status;
  const url2 = fetchResponse.url;
  const responseHeaders = {};
  for (const [key, value] of fetchResponse.headers) {
    responseHeaders[key] = value;
  }
  const octokitResponse = {
    url: url2,
    status,
    headers: responseHeaders,
    data: "",
  };
  if ("deprecation" in responseHeaders) {
    const matches =
      responseHeaders.link &&
      responseHeaders.link.match(/<([^<>]+)>; rel="deprecation"/);
    const deprecationLink = matches && matches.pop();
    log.warn(
      `[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${responseHeaders.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`,
    );
  }
  if (status === 204 || status === 205) {
    return octokitResponse;
  }
  if (requestOptions.method === "HEAD") {
    if (status < 400) {
      return octokitResponse;
    }
    throw new RequestError(fetchResponse.statusText, status, {
      response: octokitResponse,
      request: requestOptions,
    });
  }
  if (status === 304) {
    octokitResponse.data = await getResponseData(fetchResponse);
    throw new RequestError("Not modified", status, {
      response: octokitResponse,
      request: requestOptions,
    });
  }
  if (status >= 400) {
    octokitResponse.data = await getResponseData(fetchResponse);
    throw new RequestError(toErrorMessage(octokitResponse.data), status, {
      response: octokitResponse,
      request: requestOptions,
    });
  }
  octokitResponse.data = parseSuccessResponseBody
    ? await getResponseData(fetchResponse)
    : fetchResponse.body;
  return octokitResponse;
}
async function getResponseData(response) {
  const contentType = response.headers.get("content-type");
  if (!contentType) {
    return response.text().catch(() => "");
  }
  const mimetype = (0, import_fast_content_type_parse.safeParse)(contentType);
  if (isJSONResponse(mimetype)) {
    let text2 = "";
    try {
      text2 = await response.text();
      return JSON.parse(text2);
    } catch (err2) {
      return text2;
    }
  } else if (
    mimetype.type.startsWith("text/") ||
    mimetype.parameters.charset?.toLowerCase() === "utf-8"
  ) {
    return response.text().catch(() => "");
  } else {
    return response.arrayBuffer().catch(() => new ArrayBuffer(0));
  }
}
function isJSONResponse(mimetype) {
  return (
    mimetype.type === "application/json" ||
    mimetype.type === "application/scim+json"
  );
}
function toErrorMessage(data) {
  if (typeof data === "string") {
    return data;
  }
  if (data instanceof ArrayBuffer) {
    return "Unknown error";
  }
  if ("message" in data) {
    const suffix =
      "documentation_url" in data ? ` - ${data.documentation_url}` : "";
    return Array.isArray(data.errors)
      ? `${data.message}: ${data.errors.map((v2) => JSON.stringify(v2)).join(", ")}${suffix}`
      : `${data.message}${suffix}`;
  }
  return `Unknown error: ${JSON.stringify(data)}`;
}
function withDefaults2(oldEndpoint, newDefaults) {
  const endpoint2 = oldEndpoint.defaults(newDefaults);
  const newApi = function (route, parameters) {
    const endpointOptions = endpoint2.merge(route, parameters);
    if (!endpointOptions.request || !endpointOptions.request.hook) {
      return fetchWrapper(endpoint2.parse(endpointOptions));
    }
    const request2 = (route2, parameters2) => {
      return fetchWrapper(
        endpoint2.parse(endpoint2.merge(route2, parameters2)),
      );
    };
    Object.assign(request2, {
      endpoint: endpoint2,
      defaults: withDefaults2.bind(null, endpoint2),
    });
    return endpointOptions.request.hook(request2, endpointOptions);
  };
  return Object.assign(newApi, {
    endpoint: endpoint2,
    defaults: withDefaults2.bind(null, endpoint2),
  });
}
var request = withDefaults2(endpoint, defaults_default);

// node_modules/@octokit/graphql/dist-bundle/index.js
var VERSION7 = "0.0.0-development";
function _buildMessageForResponseErrors(data) {
  return (
    `Request failed due to following response errors:
` + data.errors.map((e2) => ` - ${e2.message}`).join("\n")
  );
}
var GraphqlResponseError = class extends Error {
  constructor(request2, headers, response) {
    super(_buildMessageForResponseErrors(response));
    this.request = request2;
    this.headers = headers;
    this.response = response;
    this.errors = response.errors;
    this.data = response.data;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
  name = "GraphqlResponseError";
  errors;
  data;
};
var NON_VARIABLE_OPTIONS = [
  "method",
  "baseUrl",
  "url",
  "headers",
  "request",
  "query",
  "mediaType",
  "operationName",
];
var FORBIDDEN_VARIABLE_OPTIONS = ["query", "method", "url"];
var GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
function graphql(request2, query, options) {
  if (options) {
    if (typeof query === "string" && "query" in options) {
      return Promise.reject(
        new Error(`[@octokit/graphql] "query" cannot be used as variable name`),
      );
    }
    for (const key in options) {
      if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key)) continue;
      return Promise.reject(
        new Error(
          `[@octokit/graphql] "${key}" cannot be used as variable name`,
        ),
      );
    }
  }
  const parsedOptions =
    typeof query === "string" ? Object.assign({ query }, options) : query;
  const requestOptions = Object.keys(parsedOptions).reduce((result, key) => {
    if (NON_VARIABLE_OPTIONS.includes(key)) {
      result[key] = parsedOptions[key];
      return result;
    }
    if (!result.variables) {
      result.variables = {};
    }
    result.variables[key] = parsedOptions[key];
    return result;
  }, {});
  const baseUrl = parsedOptions.baseUrl || request2.endpoint.DEFAULTS.baseUrl;
  if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
    requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
  }
  return request2(requestOptions).then((response) => {
    if (response.data.errors) {
      const headers = {};
      for (const key of Object.keys(response.headers)) {
        headers[key] = response.headers[key];
      }
      throw new GraphqlResponseError(requestOptions, headers, response.data);
    }
    return response.data.data;
  });
}
function withDefaults3(request2, newDefaults) {
  const newRequest = request2.defaults(newDefaults);
  const newApi = (query, options) => {
    return graphql(newRequest, query, options);
  };
  return Object.assign(newApi, {
    defaults: withDefaults3.bind(null, newRequest),
    endpoint: newRequest.endpoint,
  });
}
var graphql2 = withDefaults3(request, {
  headers: {
    "user-agent": `octokit-graphql.js/${VERSION7} ${getUserAgent()}`,
  },
  method: "POST",
  url: "/graphql",
});
function withCustomRequest(customRequest) {
  return withDefaults3(customRequest, {
    method: "POST",
    url: "/graphql",
  });
}

// node_modules/@octokit/auth-token/dist-bundle/index.js
var b64url = "(?:[a-zA-Z0-9_-]+)";
var sep = "\\.";
var jwtRE = new RegExp(`^${b64url}${sep}${b64url}${sep}${b64url}$`);
var isJWT = jwtRE.test.bind(jwtRE);
async function auth(token) {
  const isApp = isJWT(token);
  const isInstallation = token.startsWith("v1.") || token.startsWith("ghs_");
  const isUserToServer = token.startsWith("ghu_");
  const tokenType = isApp
    ? "app"
    : isInstallation
      ? "installation"
      : isUserToServer
        ? "user-to-server"
        : "oauth";
  return {
    type: "token",
    token,
    tokenType,
  };
}
function withAuthorizationPrefix(token) {
  if (token.split(/\./).length === 3) {
    return `bearer ${token}`;
  }
  return `token ${token}`;
}
async function hook(token, request2, route, parameters) {
  const endpoint2 = request2.endpoint.merge(route, parameters);
  endpoint2.headers.authorization = withAuthorizationPrefix(token);
  return request2(endpoint2);
}
var createTokenAuth = function createTokenAuth2(token) {
  if (!token) {
    throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
  }
  if (typeof token !== "string") {
    throw new Error(
      "[@octokit/auth-token] Token passed to createTokenAuth is not a string",
    );
  }
  token = token.replace(/^(token|bearer) +/i, "");
  return Object.assign(auth.bind(null, token), {
    hook: hook.bind(null, token),
  });
};

// node_modules/@octokit/core/dist-src/version.js
var VERSION8 = "7.0.4";

// node_modules/@octokit/core/dist-src/index.js
var noop2 = () => {};
var consoleWarn = console.warn.bind(console);
var consoleError = console.error.bind(console);
function createLogger(logger = {}) {
  if (typeof logger.debug !== "function") {
    logger.debug = noop2;
  }
  if (typeof logger.info !== "function") {
    logger.info = noop2;
  }
  if (typeof logger.warn !== "function") {
    logger.warn = consoleWarn;
  }
  if (typeof logger.error !== "function") {
    logger.error = consoleError;
  }
  return logger;
}
var userAgentTrail = `octokit-core.js/${VERSION8} ${getUserAgent()}`;
var Octokit = class {
  static VERSION = VERSION8;
  static defaults(defaults) {
    const OctokitWithDefaults = class extends this {
      constructor(...args) {
        const options = args[0] || {};
        if (typeof defaults === "function") {
          super(defaults(options));
          return;
        }
        super(
          Object.assign(
            {},
            defaults,
            options,
            options.userAgent && defaults.userAgent
              ? {
                  userAgent: `${options.userAgent} ${defaults.userAgent}`,
                }
              : null,
          ),
        );
      }
    };
    return OctokitWithDefaults;
  }
  static plugins = [];
  /**
   * Attach a plugin (or many) to your Octokit instance.
   *
   * @example
   * const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)
   */
  static plugin(...newPlugins) {
    const currentPlugins = this.plugins;
    const NewOctokit = class extends this {
      static plugins = currentPlugins.concat(
        newPlugins.filter((plugin) => !currentPlugins.includes(plugin)),
      );
    };
    return NewOctokit;
  }
  constructor(options = {}) {
    const hook2 = new before_after_hook_default.Collection();
    const requestDefaults = {
      baseUrl: request.endpoint.DEFAULTS.baseUrl,
      headers: {},
      request: Object.assign({}, options.request, {
        // @ts-ignore internal usage only, no need to type
        hook: hook2.bind(null, "request"),
      }),
      mediaType: {
        previews: [],
        format: "",
      },
    };
    requestDefaults.headers["user-agent"] = options.userAgent
      ? `${options.userAgent} ${userAgentTrail}`
      : userAgentTrail;
    if (options.baseUrl) {
      requestDefaults.baseUrl = options.baseUrl;
    }
    if (options.previews) {
      requestDefaults.mediaType.previews = options.previews;
    }
    if (options.timeZone) {
      requestDefaults.headers["time-zone"] = options.timeZone;
    }
    this.request = request.defaults(requestDefaults);
    this.graphql = withCustomRequest(this.request).defaults(requestDefaults);
    this.log = createLogger(options.log);
    this.hook = hook2;
    if (!options.authStrategy) {
      if (!options.auth) {
        this.auth = async () => ({
          type: "unauthenticated",
        });
      } else {
        const auth2 = createTokenAuth(options.auth);
        hook2.wrap("request", auth2.hook);
        this.auth = auth2;
      }
    } else {
      const { authStrategy, ...otherOptions } = options;
      const auth2 = authStrategy(
        Object.assign(
          {
            request: this.request,
            log: this.log,
            // we pass the current octokit instance as well as its constructor options
            // to allow for authentication strategies that return a new octokit instance
            // that shares the same internal state as the current one. The original
            // requirement for this was the "event-octokit" authentication strategy
            // of https://github.com/probot/octokit-auth-probot.
            octokit: this,
            octokitOptions: otherOptions,
          },
          options.auth,
        ),
      );
      hook2.wrap("request", auth2.hook);
      this.auth = auth2;
    }
    const classConstructor = this.constructor;
    for (let i2 = 0; i2 < classConstructor.plugins.length; ++i2) {
      Object.assign(this, classConstructor.plugins[i2](this, options));
    }
  }
  // assigned during constructor
  request;
  graphql;
  log;
  hook;
  // TODO: type `octokit.auth` based on passed options.authStrategy
  auth;
};

// node_modules/@blink-sdk/github/dist/index.js
import { createRequire as createRequire$1 } from "module";
var __create2 = Object.create;
var __defProp3 = Object.defineProperty;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __getProtoOf2 = Object.getPrototypeOf;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __commonJS2 = (cb, mod) =>
  function () {
    return (
      mod ||
        (0, cb[__getOwnPropNames2(cb)[0]])(
          (mod = { exports: {} }).exports,
          mod,
        ),
      mod.exports
    );
  };
var __copyProps2 = (to, from, except, desc) => {
  if ((from && typeof from === "object") || typeof from === "function")
    for (
      var keys = __getOwnPropNames2(from), i$1 = 0, n = keys.length, key;
      i$1 < n;
      i$1++
    ) {
      key = keys[i$1];
      if (!__hasOwnProp2.call(to, key) && key !== except)
        __defProp3(to, key, {
          get: ((k) => from[k]).bind(null, key),
          enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable,
        });
    }
  return to;
};
var __toESM2 = (mod, isNodeMode, target) => (
  (target = mod != null ? __create2(__getProtoOf2(mod)) : {}),
  __copyProps2(
    isNodeMode || !mod || !mod.__esModule
      ? __defProp3(target, "default", {
          value: mod,
          enumerable: true,
        })
      : target,
    mod,
  )
);
var __require = /* @__PURE__ */ createRequire(import.meta.url);
var Diff = class {
  diff(oldStr, newStr, options = {}) {
    let callback;
    if (typeof options === "function") {
      callback = options;
      options = {};
    } else if ("callback" in options) callback = options.callback;
    const oldString = this.castInput(oldStr, options);
    const newString = this.castInput(newStr, options);
    const oldTokens = this.removeEmpty(this.tokenize(oldString, options));
    const newTokens = this.removeEmpty(this.tokenize(newString, options));
    return this.diffWithOptionsObj(oldTokens, newTokens, options, callback);
  }
  diffWithOptionsObj(oldTokens, newTokens, options, callback) {
    var _a$1;
    const done = (value) => {
      value = this.postProcess(value, options);
      if (callback) {
        setTimeout(function () {
          callback(value);
        }, 0);
        return void 0;
      } else return value;
    };
    const newLen = newTokens.length,
      oldLen = oldTokens.length;
    let editLength = 1;
    let maxEditLength = newLen + oldLen;
    if (options.maxEditLength != null)
      maxEditLength = Math.min(maxEditLength, options.maxEditLength);
    const maxExecutionTime =
      (_a$1 = options.timeout) !== null && _a$1 !== void 0 ? _a$1 : Infinity;
    const abortAfterTimestamp = Date.now() + maxExecutionTime;
    const bestPath = [
      {
        oldPos: -1,
        lastComponent: void 0,
      },
    ];
    let newPos = this.extractCommon(
      bestPath[0],
      newTokens,
      oldTokens,
      0,
      options,
    );
    if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen)
      return done(
        this.buildValues(bestPath[0].lastComponent, newTokens, oldTokens),
      );
    let minDiagonalToConsider = -Infinity,
      maxDiagonalToConsider = Infinity;
    const execEditLength = () => {
      for (
        let diagonalPath = Math.max(minDiagonalToConsider, -editLength);
        diagonalPath <= Math.min(maxDiagonalToConsider, editLength);
        diagonalPath += 2
      ) {
        let basePath;
        const removePath = bestPath[diagonalPath - 1],
          addPath = bestPath[diagonalPath + 1];
        if (removePath) bestPath[diagonalPath - 1] = void 0;
        let canAdd = false;
        if (addPath) {
          const addPathNewPos = addPath.oldPos - diagonalPath;
          canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;
        }
        const canRemove = removePath && removePath.oldPos + 1 < oldLen;
        if (!canAdd && !canRemove) {
          bestPath[diagonalPath] = void 0;
          continue;
        }
        if (!canRemove || (canAdd && removePath.oldPos < addPath.oldPos))
          basePath = this.addToPath(addPath, true, false, 0, options);
        else basePath = this.addToPath(removePath, false, true, 1, options);
        newPos = this.extractCommon(
          basePath,
          newTokens,
          oldTokens,
          diagonalPath,
          options,
        );
        if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen)
          return (
            done(
              this.buildValues(basePath.lastComponent, newTokens, oldTokens),
            ) || true
          );
        else {
          bestPath[diagonalPath] = basePath;
          if (basePath.oldPos + 1 >= oldLen)
            maxDiagonalToConsider = Math.min(
              maxDiagonalToConsider,
              diagonalPath - 1,
            );
          if (newPos + 1 >= newLen)
            minDiagonalToConsider = Math.max(
              minDiagonalToConsider,
              diagonalPath + 1,
            );
        }
      }
      editLength++;
    };
    if (callback)
      (function exec() {
        setTimeout(function () {
          if (editLength > maxEditLength || Date.now() > abortAfterTimestamp)
            return callback(void 0);
          if (!execEditLength()) exec();
        }, 0);
      })();
    else
      while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {
        const ret = execEditLength();
        if (ret) return ret;
      }
  }
  addToPath(path, added, removed, oldPosInc, options) {
    const last = path.lastComponent;
    if (
      last &&
      !options.oneChangePerToken &&
      last.added === added &&
      last.removed === removed
    )
      return {
        oldPos: path.oldPos + oldPosInc,
        lastComponent: {
          count: last.count + 1,
          added,
          removed,
          previousComponent: last.previousComponent,
        },
      };
    else
      return {
        oldPos: path.oldPos + oldPosInc,
        lastComponent: {
          count: 1,
          added,
          removed,
          previousComponent: last,
        },
      };
  }
  extractCommon(basePath, newTokens, oldTokens, diagonalPath, options) {
    const newLen = newTokens.length,
      oldLen = oldTokens.length;
    let oldPos = basePath.oldPos,
      newPos = oldPos - diagonalPath,
      commonCount = 0;
    while (
      newPos + 1 < newLen &&
      oldPos + 1 < oldLen &&
      this.equals(oldTokens[oldPos + 1], newTokens[newPos + 1], options)
    ) {
      newPos++;
      oldPos++;
      commonCount++;
      if (options.oneChangePerToken)
        basePath.lastComponent = {
          count: 1,
          previousComponent: basePath.lastComponent,
          added: false,
          removed: false,
        };
    }
    if (commonCount && !options.oneChangePerToken)
      basePath.lastComponent = {
        count: commonCount,
        previousComponent: basePath.lastComponent,
        added: false,
        removed: false,
      };
    basePath.oldPos = oldPos;
    return newPos;
  }
  equals(left, right, options) {
    if (options.comparator) return options.comparator(left, right);
    else
      return (
        left === right ||
        (!!options.ignoreCase && left.toLowerCase() === right.toLowerCase())
      );
  }
  removeEmpty(array3) {
    const ret = [];
    for (let i$1 = 0; i$1 < array3.length; i$1++)
      if (array3[i$1]) ret.push(array3[i$1]);
    return ret;
  }
  castInput(value, options) {
    return value;
  }
  tokenize(value, options) {
    return Array.from(value);
  }
  join(chars) {
    return chars.join("");
  }
  postProcess(changeObjects, options) {
    return changeObjects;
  }
  get useLongestToken() {
    return false;
  }
  buildValues(lastComponent, newTokens, oldTokens) {
    const components = [];
    let nextComponent;
    while (lastComponent) {
      components.push(lastComponent);
      nextComponent = lastComponent.previousComponent;
      delete lastComponent.previousComponent;
      lastComponent = nextComponent;
    }
    components.reverse();
    const componentLen = components.length;
    let componentPos = 0,
      newPos = 0,
      oldPos = 0;
    for (; componentPos < componentLen; componentPos++) {
      const component = components[componentPos];
      if (!component.removed) {
        if (!component.added && this.useLongestToken) {
          let value = newTokens.slice(newPos, newPos + component.count);
          value = value.map(function (value$1, i$1) {
            const oldValue = oldTokens[oldPos + i$1];
            return oldValue.length > value$1.length ? oldValue : value$1;
          });
          component.value = this.join(value);
        } else
          component.value = this.join(
            newTokens.slice(newPos, newPos + component.count),
          );
        newPos += component.count;
        if (!component.added) oldPos += component.count;
      } else {
        component.value = this.join(
          oldTokens.slice(oldPos, oldPos + component.count),
        );
        oldPos += component.count;
      }
    }
    return components;
  }
};
var CharacterDiff = class extends Diff {};
var characterDiff = new CharacterDiff();
function longestCommonPrefix(str1, str2) {
  let i$1;
  for (i$1 = 0; i$1 < str1.length && i$1 < str2.length; i$1++)
    if (str1[i$1] != str2[i$1]) return str1.slice(0, i$1);
  return str1.slice(0, i$1);
}
function longestCommonSuffix(str1, str2) {
  let i$1;
  if (!str1 || !str2 || str1[str1.length - 1] != str2[str2.length - 1])
    return "";
  for (i$1 = 0; i$1 < str1.length && i$1 < str2.length; i$1++)
    if (str1[str1.length - (i$1 + 1)] != str2[str2.length - (i$1 + 1)])
      return str1.slice(-i$1);
  return str1.slice(-i$1);
}
function replacePrefix(string5, oldPrefix, newPrefix) {
  if (string5.slice(0, oldPrefix.length) != oldPrefix)
    throw Error(
      `string ${JSON.stringify(string5)} doesn't start with prefix ${JSON.stringify(oldPrefix)}; this is a bug`,
    );
  return newPrefix + string5.slice(oldPrefix.length);
}
function replaceSuffix(string5, oldSuffix, newSuffix) {
  if (!oldSuffix) return string5 + newSuffix;
  if (string5.slice(-oldSuffix.length) != oldSuffix)
    throw Error(
      `string ${JSON.stringify(string5)} doesn't end with suffix ${JSON.stringify(oldSuffix)}; this is a bug`,
    );
  return string5.slice(0, -oldSuffix.length) + newSuffix;
}
function removePrefix(string5, oldPrefix) {
  return replacePrefix(string5, oldPrefix, "");
}
function removeSuffix(string5, oldSuffix) {
  return replaceSuffix(string5, oldSuffix, "");
}
function maximumOverlap(string1, string22) {
  return string22.slice(0, overlapCount(string1, string22));
}
function overlapCount(a2, b2) {
  let startA = 0;
  if (a2.length > b2.length) startA = a2.length - b2.length;
  let endB = b2.length;
  if (a2.length < b2.length) endB = a2.length;
  const map2 = Array(endB);
  let k = 0;
  map2[0] = 0;
  for (let j = 1; j < endB; j++) {
    if (b2[j] == b2[k]) map2[j] = map2[k];
    else map2[j] = k;
    while (k > 0 && b2[j] != b2[k]) k = map2[k];
    if (b2[j] == b2[k]) k++;
  }
  k = 0;
  for (let i$1 = startA; i$1 < a2.length; i$1++) {
    while (k > 0 && a2[i$1] != b2[k]) k = map2[k];
    if (a2[i$1] == b2[k]) k++;
  }
  return k;
}
function trailingWs(string5) {
  let i$1;
  for (i$1 = string5.length - 1; i$1 >= 0; i$1--)
    if (!string5[i$1].match(/\s/)) break;
  return string5.substring(i$1 + 1);
}
function leadingWs(string5) {
  const match = string5.match(/^\s*/);
  return match ? match[0] : "";
}
var extendedWordChars =
  "a-zA-Z0-9_\\u{C0}-\\u{FF}\\u{D8}-\\u{F6}\\u{F8}-\\u{2C6}\\u{2C8}-\\u{2D7}\\u{2DE}-\\u{2FF}\\u{1E00}-\\u{1EFF}";
var tokenizeIncludingWhitespace = new RegExp(
  `[${extendedWordChars}]+|\\s+|[^${extendedWordChars}]`,
  "ug",
);
var WordDiff = class extends Diff {
  equals(left, right, options) {
    if (options.ignoreCase) {
      left = left.toLowerCase();
      right = right.toLowerCase();
    }
    return left.trim() === right.trim();
  }
  tokenize(value, options = {}) {
    let parts;
    if (options.intlSegmenter) {
      const segmenter = options.intlSegmenter;
      if (segmenter.resolvedOptions().granularity != "word")
        throw new Error(
          'The segmenter passed must have a granularity of "word"',
        );
      parts = Array.from(
        segmenter.segment(value),
        (segment) => segment.segment,
      );
    } else parts = value.match(tokenizeIncludingWhitespace) || [];
    const tokens = [];
    let prevPart = null;
    parts.forEach((part) => {
      if (/\s/.test(part))
        if (prevPart == null) tokens.push(part);
        else tokens.push(tokens.pop() + part);
      else if (prevPart != null && /\s/.test(prevPart))
        if (tokens[tokens.length - 1] == prevPart)
          tokens.push(tokens.pop() + part);
        else tokens.push(prevPart + part);
      else tokens.push(part);
      prevPart = part;
    });
    return tokens;
  }
  join(tokens) {
    return tokens
      .map((token, i$1) => {
        if (i$1 == 0) return token;
        else return token.replace(/^\s+/, "");
      })
      .join("");
  }
  postProcess(changes, options) {
    if (!changes || options.oneChangePerToken) return changes;
    let lastKeep = null;
    let insertion = null;
    let deletion = null;
    changes.forEach((change) => {
      if (change.added) insertion = change;
      else if (change.removed) deletion = change;
      else {
        if (insertion || deletion)
          dedupeWhitespaceInChangeObjects(
            lastKeep,
            deletion,
            insertion,
            change,
          );
        lastKeep = change;
        insertion = null;
        deletion = null;
      }
    });
    if (insertion || deletion)
      dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, null);
    return changes;
  }
};
var wordDiff = new WordDiff();
function dedupeWhitespaceInChangeObjects(
  startKeep,
  deletion,
  insertion,
  endKeep,
) {
  if (deletion && insertion) {
    const oldWsPrefix = leadingWs(deletion.value);
    const oldWsSuffix = trailingWs(deletion.value);
    const newWsPrefix = leadingWs(insertion.value);
    const newWsSuffix = trailingWs(insertion.value);
    if (startKeep) {
      const commonWsPrefix = longestCommonPrefix(oldWsPrefix, newWsPrefix);
      startKeep.value = replaceSuffix(
        startKeep.value,
        newWsPrefix,
        commonWsPrefix,
      );
      deletion.value = removePrefix(deletion.value, commonWsPrefix);
      insertion.value = removePrefix(insertion.value, commonWsPrefix);
    }
    if (endKeep) {
      const commonWsSuffix = longestCommonSuffix(oldWsSuffix, newWsSuffix);
      endKeep.value = replacePrefix(endKeep.value, newWsSuffix, commonWsSuffix);
      deletion.value = removeSuffix(deletion.value, commonWsSuffix);
      insertion.value = removeSuffix(insertion.value, commonWsSuffix);
    }
  } else if (insertion) {
    if (startKeep) {
      const ws = leadingWs(insertion.value);
      insertion.value = insertion.value.substring(ws.length);
    }
    if (endKeep) {
      const ws = leadingWs(endKeep.value);
      endKeep.value = endKeep.value.substring(ws.length);
    }
  } else if (startKeep && endKeep) {
    const newWsFull = leadingWs(endKeep.value),
      delWsStart = leadingWs(deletion.value),
      delWsEnd = trailingWs(deletion.value);
    const newWsStart = longestCommonPrefix(newWsFull, delWsStart);
    deletion.value = removePrefix(deletion.value, newWsStart);
    const newWsEnd = longestCommonSuffix(
      removePrefix(newWsFull, newWsStart),
      delWsEnd,
    );
    deletion.value = removeSuffix(deletion.value, newWsEnd);
    endKeep.value = replacePrefix(endKeep.value, newWsFull, newWsEnd);
    startKeep.value = replaceSuffix(
      startKeep.value,
      newWsFull,
      newWsFull.slice(0, newWsFull.length - newWsEnd.length),
    );
  } else if (endKeep) {
    const endKeepWsPrefix = leadingWs(endKeep.value);
    const deletionWsSuffix = trailingWs(deletion.value);
    const overlap = maximumOverlap(deletionWsSuffix, endKeepWsPrefix);
    deletion.value = removeSuffix(deletion.value, overlap);
  } else if (startKeep) {
    const startKeepWsSuffix = trailingWs(startKeep.value);
    const deletionWsPrefix = leadingWs(deletion.value);
    const overlap = maximumOverlap(startKeepWsSuffix, deletionWsPrefix);
    deletion.value = removePrefix(deletion.value, overlap);
  }
}
var WordsWithSpaceDiff = class extends Diff {
  tokenize(value) {
    const regex = new RegExp(
      `(\\r?\\n)|[${extendedWordChars}]+|[^\\S\\n\\r]+|[^${extendedWordChars}]`,
      "ug",
    );
    return value.match(regex) || [];
  }
};
var wordsWithSpaceDiff = new WordsWithSpaceDiff();
var LineDiff = class extends Diff {
  constructor() {
    super(...arguments);
    this.tokenize = tokenize;
  }
  equals(left, right, options) {
    if (options.ignoreWhitespace) {
      if (!options.newlineIsToken || !left.includes("\n")) left = left.trim();
      if (!options.newlineIsToken || !right.includes("\n"))
        right = right.trim();
    } else if (options.ignoreNewlineAtEof && !options.newlineIsToken) {
      if (left.endsWith("\n")) left = left.slice(0, -1);
      if (right.endsWith("\n")) right = right.slice(0, -1);
    }
    return super.equals(left, right, options);
  }
};
var lineDiff = new LineDiff();
function tokenize(value, options) {
  if (options.stripTrailingCr) value = value.replace(/\r\n/g, "\n");
  const retLines = [],
    linesAndNewlines = value.split(/(\n|\r\n)/);
  if (!linesAndNewlines[linesAndNewlines.length - 1]) linesAndNewlines.pop();
  for (let i$1 = 0; i$1 < linesAndNewlines.length; i$1++) {
    const line = linesAndNewlines[i$1];
    if (i$1 % 2 && !options.newlineIsToken)
      retLines[retLines.length - 1] += line;
    else retLines.push(line);
  }
  return retLines;
}
function isSentenceEndPunct(char) {
  return char == "." || char == "!" || char == "?";
}
var SentenceDiff = class extends Diff {
  tokenize(value) {
    var _a$1;
    const result = [];
    let tokenStartI = 0;
    for (let i$1 = 0; i$1 < value.length; i$1++) {
      if (i$1 == value.length - 1) {
        result.push(value.slice(tokenStartI));
        break;
      }
      if (isSentenceEndPunct(value[i$1]) && value[i$1 + 1].match(/\s/)) {
        result.push(value.slice(tokenStartI, i$1 + 1));
        i$1 = tokenStartI = i$1 + 1;
        while (
          (_a$1 = value[i$1 + 1]) === null || _a$1 === void 0
            ? void 0
            : _a$1.match(/\s/)
        )
          i$1++;
        result.push(value.slice(tokenStartI, i$1 + 1));
        tokenStartI = i$1 + 1;
      }
    }
    return result;
  }
};
var sentenceDiff = new SentenceDiff();
var CssDiff = class extends Diff {
  tokenize(value) {
    return value.split(/([{}:;,]|\s+)/);
  }
};
var cssDiff = new CssDiff();
var JsonDiff = class extends Diff {
  constructor() {
    super(...arguments);
    this.tokenize = tokenize;
  }
  get useLongestToken() {
    return true;
  }
  castInput(value, options) {
    const {
      undefinedReplacement,
      stringifyReplacer = (k, v2) =>
        typeof v2 === "undefined" ? undefinedReplacement : v2,
    } = options;
    return typeof value === "string"
      ? value
      : JSON.stringify(
          canonicalize(value, null, null, stringifyReplacer),
          null,
          "  ",
        );
  }
  equals(left, right, options) {
    return super.equals(
      left.replace(/,([\r\n])/g, "$1"),
      right.replace(/,([\r\n])/g, "$1"),
      options,
    );
  }
};
var jsonDiff = new JsonDiff();
function canonicalize(obj, stack, replacementStack, replacer, key) {
  stack = stack || [];
  replacementStack = replacementStack || [];
  if (replacer) obj = replacer(key === void 0 ? "" : key, obj);
  let i$1;
  for (i$1 = 0; i$1 < stack.length; i$1 += 1)
    if (stack[i$1] === obj) return replacementStack[i$1];
  let canonicalizedObj;
  if ("[object Array]" === Object.prototype.toString.call(obj)) {
    stack.push(obj);
    canonicalizedObj = new Array(obj.length);
    replacementStack.push(canonicalizedObj);
    for (i$1 = 0; i$1 < obj.length; i$1 += 1)
      canonicalizedObj[i$1] = canonicalize(
        obj[i$1],
        stack,
        replacementStack,
        replacer,
        String(i$1),
      );
    stack.pop();
    replacementStack.pop();
    return canonicalizedObj;
  }
  if (obj && obj.toJSON) obj = obj.toJSON();
  if (typeof obj === "object" && obj !== null) {
    stack.push(obj);
    canonicalizedObj = {};
    replacementStack.push(canonicalizedObj);
    const sortedKeys = [];
    let key$1;
    for (key$1 in obj)
      if (Object.prototype.hasOwnProperty.call(obj, key$1))
        sortedKeys.push(key$1);
    sortedKeys.sort();
    for (i$1 = 0; i$1 < sortedKeys.length; i$1 += 1) {
      key$1 = sortedKeys[i$1];
      canonicalizedObj[key$1] = canonicalize(
        obj[key$1],
        stack,
        replacementStack,
        replacer,
        key$1,
      );
    }
    stack.pop();
    replacementStack.pop();
  } else canonicalizedObj = obj;
  return canonicalizedObj;
}
var ArrayDiff = class extends Diff {
  tokenize(value) {
    return value.slice();
  }
  join(value) {
    return value;
  }
  removeEmpty(value) {
    return value;
  }
};
var arrayDiff = new ArrayDiff();
function parsePatch(uniDiff) {
  const diffstr = uniDiff.split(/\n/),
    list = [];
  let i$1 = 0;
  function parseIndex() {
    const index = {};
    list.push(index);
    while (i$1 < diffstr.length) {
      const line = diffstr[i$1];
      if (/^(---|\+\+\+|@@)\s/.test(line)) break;
      const header = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(line);
      if (header) index.index = header[1];
      i$1++;
    }
    parseFileHeader(index);
    parseFileHeader(index);
    index.hunks = [];
    while (i$1 < diffstr.length) {
      const line = diffstr[i$1];
      if (
        /^(Index:\s|diff\s|---\s|\+\+\+\s|===================================================================)/.test(
          line,
        )
      )
        break;
      else if (/^@@/.test(line)) index.hunks.push(parseHunk());
      else if (line)
        throw new Error(
          "Unknown line " + (i$1 + 1) + " " + JSON.stringify(line),
        );
      else i$1++;
    }
  }
  function parseFileHeader(index) {
    const fileHeader = /^(---|\+\+\+)\s+(.*)\r?$/.exec(diffstr[i$1]);
    if (fileHeader) {
      const data = fileHeader[2].split("	", 2),
        header = (data[1] || "").trim();
      let fileName = data[0].replace(/\\\\/g, "\\");
      if (/^".*"$/.test(fileName))
        fileName = fileName.substr(1, fileName.length - 2);
      if (fileHeader[1] === "---") {
        index.oldFileName = fileName;
        index.oldHeader = header;
      } else {
        index.newFileName = fileName;
        index.newHeader = header;
      }
      i$1++;
    }
  }
  function parseHunk() {
    var _a$1;
    const chunkHeaderIndex = i$1,
      chunkHeaderLine = diffstr[i$1++],
      chunkHeader = chunkHeaderLine.split(
        /@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/,
      );
    const hunk = {
      oldStart: +chunkHeader[1],
      oldLines: typeof chunkHeader[2] === "undefined" ? 1 : +chunkHeader[2],
      newStart: +chunkHeader[3],
      newLines: typeof chunkHeader[4] === "undefined" ? 1 : +chunkHeader[4],
      lines: [],
    };
    if (hunk.oldLines === 0) hunk.oldStart += 1;
    if (hunk.newLines === 0) hunk.newStart += 1;
    let addCount = 0,
      removeCount = 0;
    for (
      ;
      i$1 < diffstr.length &&
      (removeCount < hunk.oldLines ||
        addCount < hunk.newLines ||
        ((_a$1 = diffstr[i$1]) === null || _a$1 === void 0
          ? void 0
          : _a$1.startsWith("\\")));
      i$1++
    ) {
      const operation =
        diffstr[i$1].length == 0 && i$1 != diffstr.length - 1
          ? " "
          : diffstr[i$1][0];
      if (
        operation === "+" ||
        operation === "-" ||
        operation === " " ||
        operation === "\\"
      ) {
        hunk.lines.push(diffstr[i$1]);
        if (operation === "+") addCount++;
        else if (operation === "-") removeCount++;
        else if (operation === " ") {
          addCount++;
          removeCount++;
        }
      } else
        throw new Error(
          `Hunk at line ${chunkHeaderIndex + 1} contained invalid line ${diffstr[i$1]}`,
        );
    }
    if (!addCount && hunk.newLines === 1) hunk.newLines = 0;
    if (!removeCount && hunk.oldLines === 1) hunk.oldLines = 0;
    if (addCount !== hunk.newLines)
      throw new Error(
        "Added line count did not match for hunk at line " +
          (chunkHeaderIndex + 1),
      );
    if (removeCount !== hunk.oldLines)
      throw new Error(
        "Removed line count did not match for hunk at line " +
          (chunkHeaderIndex + 1),
      );
    return hunk;
  }
  while (i$1 < diffstr.length) parseIndex();
  return list;
}
var defaultMessages = "End-Of-Stream";
var EndOfStreamError = class extends Error {
  constructor() {
    super(defaultMessages);
    this.name = "EndOfStreamError";
  }
};
var AbortError = class extends Error {
  constructor(message = "The operation was aborted") {
    super(message);
    this.name = "AbortError";
  }
};
var AbstractStreamReader = class {
  constructor() {
    this.endOfStream = false;
    this.interrupted = false;
    this.peekQueue = [];
  }
  async peek(uint8Array, mayBeLess = false) {
    const bytesRead = await this.read(uint8Array, mayBeLess);
    this.peekQueue.push(uint8Array.subarray(0, bytesRead));
    return bytesRead;
  }
  async read(buffer, mayBeLess = false) {
    if (buffer.length === 0) return 0;
    let bytesRead = this.readFromPeekBuffer(buffer);
    if (!this.endOfStream)
      bytesRead += await this.readRemainderFromStream(
        buffer.subarray(bytesRead),
        mayBeLess,
      );
    if (bytesRead === 0 && !mayBeLess) throw new EndOfStreamError();
    return bytesRead;
  }
  /**
   * Read chunk from stream
   * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
   * @returns Number of bytes read
   */
  readFromPeekBuffer(buffer) {
    let remaining = buffer.length;
    let bytesRead = 0;
    while (this.peekQueue.length > 0 && remaining > 0) {
      const peekData = this.peekQueue.pop();
      if (!peekData) throw new Error("peekData should be defined");
      const lenCopy = Math.min(peekData.length, remaining);
      buffer.set(peekData.subarray(0, lenCopy), bytesRead);
      bytesRead += lenCopy;
      remaining -= lenCopy;
      if (lenCopy < peekData.length)
        this.peekQueue.push(peekData.subarray(lenCopy));
    }
    return bytesRead;
  }
  async readRemainderFromStream(buffer, mayBeLess) {
    let bytesRead = 0;
    while (bytesRead < buffer.length && !this.endOfStream) {
      if (this.interrupted) throw new AbortError();
      const chunkLen = await this.readFromStream(
        buffer.subarray(bytesRead),
        mayBeLess,
      );
      if (chunkLen === 0) break;
      bytesRead += chunkLen;
    }
    if (!mayBeLess && bytesRead < buffer.length) throw new EndOfStreamError();
    return bytesRead;
  }
};
var WebStreamReader = class extends AbstractStreamReader {
  constructor(reader) {
    super();
    this.reader = reader;
  }
  async abort() {
    return this.close();
  }
  async close() {
    this.reader.releaseLock();
  }
};
var WebStreamByobReader = class extends WebStreamReader {
  /**
   * Read from stream
   * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
   * @param mayBeLess - If true, may fill the buffer partially
   * @protected Bytes read
   */
  async readFromStream(buffer, mayBeLess) {
    if (buffer.length === 0) return 0;
    const result = await this.reader.read(new Uint8Array(buffer.length), {
      min: mayBeLess ? void 0 : buffer.length,
    });
    if (result.done) this.endOfStream = result.done;
    if (result.value) {
      buffer.set(result.value);
      return result.value.length;
    }
    return 0;
  }
};
var WebStreamDefaultReader = class extends AbstractStreamReader {
  constructor(reader) {
    super();
    this.reader = reader;
    this.buffer = null;
  }
  /**
   * Copy chunk to target, and store the remainder in this.buffer
   */
  writeChunk(target, chunk) {
    const written = Math.min(chunk.length, target.length);
    target.set(chunk.subarray(0, written));
    if (written < chunk.length) this.buffer = chunk.subarray(written);
    else this.buffer = null;
    return written;
  }
  /**
   * Read from stream
   * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
   * @param mayBeLess - If true, may fill the buffer partially
   * @protected Bytes read
   */
  async readFromStream(buffer, mayBeLess) {
    if (buffer.length === 0) return 0;
    let totalBytesRead = 0;
    if (this.buffer) totalBytesRead += this.writeChunk(buffer, this.buffer);
    while (totalBytesRead < buffer.length && !this.endOfStream) {
      const result = await this.reader.read();
      if (result.done) {
        this.endOfStream = true;
        break;
      }
      if (result.value)
        totalBytesRead += this.writeChunk(
          buffer.subarray(totalBytesRead),
          result.value,
        );
    }
    if (!mayBeLess && totalBytesRead === 0 && this.endOfStream)
      throw new EndOfStreamError();
    return totalBytesRead;
  }
  abort() {
    this.interrupted = true;
    return this.reader.cancel();
  }
  async close() {
    await this.abort();
    this.reader.releaseLock();
  }
};
function makeWebStreamReader(stream) {
  try {
    const reader = stream.getReader({ mode: "byob" });
    if (reader instanceof ReadableStreamDefaultReader)
      return new WebStreamDefaultReader(reader);
    return new WebStreamByobReader(reader);
  } catch (error45) {
    if (error45 instanceof TypeError)
      return new WebStreamDefaultReader(stream.getReader());
    throw error45;
  }
}
var AbstractTokenizer = class {
  /**
   * Constructor
   * @param options Tokenizer options
   * @protected
   */
  constructor(options) {
    this.numBuffer = new Uint8Array(8);
    this.position = 0;
    this.onClose = options?.onClose;
    if (options?.abortSignal)
      options.abortSignal.addEventListener("abort", () => {
        this.abort();
      });
  }
  /**
   * Read a token from the tokenizer-stream
   * @param token - The token to read
   * @param position - If provided, the desired position in the tokenizer-stream
   * @returns Promise with token data
   */
  async readToken(token, position = this.position) {
    const uint8Array = new Uint8Array(token.len);
    const len = await this.readBuffer(uint8Array, { position });
    if (len < token.len) throw new EndOfStreamError();
    return token.get(uint8Array, 0);
  }
  /**
   * Peek a token from the tokenizer-stream.
   * @param token - Token to peek from the tokenizer-stream.
   * @param position - Offset where to begin reading within the file. If position is null, data will be read from the current file position.
   * @returns Promise with token data
   */
  async peekToken(token, position = this.position) {
    const uint8Array = new Uint8Array(token.len);
    const len = await this.peekBuffer(uint8Array, { position });
    if (len < token.len) throw new EndOfStreamError();
    return token.get(uint8Array, 0);
  }
  /**
   * Read a numeric token from the stream
   * @param token - Numeric token
   * @returns Promise with number
   */
  async readNumber(token) {
    const len = await this.readBuffer(this.numBuffer, { length: token.len });
    if (len < token.len) throw new EndOfStreamError();
    return token.get(this.numBuffer, 0);
  }
  /**
   * Read a numeric token from the stream
   * @param token - Numeric token
   * @returns Promise with number
   */
  async peekNumber(token) {
    const len = await this.peekBuffer(this.numBuffer, { length: token.len });
    if (len < token.len) throw new EndOfStreamError();
    return token.get(this.numBuffer, 0);
  }
  /**
   * Ignore number of bytes, advances the pointer in under tokenizer-stream.
   * @param length - Number of bytes to ignore
   * @return resolves the number of bytes ignored, equals length if this available, otherwise the number of bytes available
   */
  async ignore(length) {
    if (this.fileInfo.size !== void 0) {
      const bytesLeft = this.fileInfo.size - this.position;
      if (length > bytesLeft) {
        this.position += bytesLeft;
        return bytesLeft;
      }
    }
    this.position += length;
    return length;
  }
  async close() {
    await this.abort();
    await this.onClose?.();
  }
  normalizeOptions(uint8Array, options) {
    if (
      !this.supportsRandomAccess() &&
      options &&
      options.position !== void 0 &&
      options.position < this.position
    )
      throw new Error(
        "`options.position` must be equal or greater than `tokenizer.position`",
      );
    return {
      mayBeLess: false,
      offset: 0,
      length: uint8Array.length,
      position: this.position,
      ...options,
    };
  }
  abort() {
    return Promise.resolve();
  }
};
var maxBufferSize = 256e3;
var ReadStreamTokenizer = class extends AbstractTokenizer {
  /**
   * Constructor
   * @param streamReader stream-reader to read from
   * @param options Tokenizer options
   */
  constructor(streamReader, options) {
    super(options);
    this.streamReader = streamReader;
    this.fileInfo = options?.fileInfo ?? {};
  }
  /**
   * Read buffer from tokenizer
   * @param uint8Array - Target Uint8Array to fill with data read from the tokenizer-stream
   * @param options - Read behaviour options
   * @returns Promise with number of bytes read
   */
  async readBuffer(uint8Array, options) {
    const normOptions = this.normalizeOptions(uint8Array, options);
    const skipBytes = normOptions.position - this.position;
    if (skipBytes > 0) {
      await this.ignore(skipBytes);
      return this.readBuffer(uint8Array, options);
    }
    if (skipBytes < 0)
      throw new Error(
        "`options.position` must be equal or greater than `tokenizer.position`",
      );
    if (normOptions.length === 0) return 0;
    const bytesRead = await this.streamReader.read(
      uint8Array.subarray(0, normOptions.length),
      normOptions.mayBeLess,
    );
    this.position += bytesRead;
    if ((!options || !options.mayBeLess) && bytesRead < normOptions.length)
      throw new EndOfStreamError();
    return bytesRead;
  }
  /**
   * Peek (read ahead) buffer from tokenizer
   * @param uint8Array - Uint8Array (or Buffer) to write data to
   * @param options - Read behaviour options
   * @returns Promise with number of bytes peeked
   */
  async peekBuffer(uint8Array, options) {
    const normOptions = this.normalizeOptions(uint8Array, options);
    let bytesRead = 0;
    if (normOptions.position) {
      const skipBytes = normOptions.position - this.position;
      if (skipBytes > 0) {
        const skipBuffer = new Uint8Array(normOptions.length + skipBytes);
        bytesRead = await this.peekBuffer(skipBuffer, {
          mayBeLess: normOptions.mayBeLess,
        });
        uint8Array.set(skipBuffer.subarray(skipBytes));
        return bytesRead - skipBytes;
      }
      if (skipBytes < 0)
        throw new Error("Cannot peek from a negative offset in a stream");
    }
    if (normOptions.length > 0) {
      try {
        bytesRead = await this.streamReader.peek(
          uint8Array.subarray(0, normOptions.length),
          normOptions.mayBeLess,
        );
      } catch (err$1) {
        if (options?.mayBeLess && err$1 instanceof EndOfStreamError) return 0;
        throw err$1;
      }
      if (!normOptions.mayBeLess && bytesRead < normOptions.length)
        throw new EndOfStreamError();
    }
    return bytesRead;
  }
  async ignore(length) {
    const bufSize = Math.min(maxBufferSize, length);
    const buf = new Uint8Array(bufSize);
    let totBytesRead = 0;
    while (totBytesRead < length) {
      const remaining = length - totBytesRead;
      const bytesRead = await this.readBuffer(buf, {
        length: Math.min(bufSize, remaining),
      });
      if (bytesRead < 0) return bytesRead;
      totBytesRead += bytesRead;
    }
    return totBytesRead;
  }
  abort() {
    return this.streamReader.abort();
  }
  async close() {
    return this.streamReader.close();
  }
  supportsRandomAccess() {
    return false;
  }
};
var BufferTokenizer = class extends AbstractTokenizer {
  /**
   * Construct BufferTokenizer
   * @param uint8Array - Uint8Array to tokenize
   * @param options Tokenizer options
   */
  constructor(uint8Array, options) {
    super(options);
    this.uint8Array = uint8Array;
    this.fileInfo = {
      ...(options?.fileInfo ?? {}),
      size: uint8Array.length,
    };
  }
  /**
   * Read buffer from tokenizer
   * @param uint8Array - Uint8Array to tokenize
   * @param options - Read behaviour options
   * @returns {Promise<number>}
   */
  async readBuffer(uint8Array, options) {
    if (options?.position) this.position = options.position;
    const bytesRead = await this.peekBuffer(uint8Array, options);
    this.position += bytesRead;
    return bytesRead;
  }
  /**
   * Peek (read ahead) buffer from tokenizer
   * @param uint8Array
   * @param options - Read behaviour options
   * @returns {Promise<number>}
   */
  async peekBuffer(uint8Array, options) {
    const normOptions = this.normalizeOptions(uint8Array, options);
    const bytes2read = Math.min(
      this.uint8Array.length - normOptions.position,
      normOptions.length,
    );
    if (!normOptions.mayBeLess && bytes2read < normOptions.length)
      throw new EndOfStreamError();
    uint8Array.set(
      this.uint8Array.subarray(
        normOptions.position,
        normOptions.position + bytes2read,
      ),
    );
    return bytes2read;
  }
  close() {
    return super.close();
  }
  supportsRandomAccess() {
    return true;
  }
  setPosition(position) {
    this.position = position;
  }
};
function fromWebStream(webStream, options) {
  const webStreamReader = makeWebStreamReader(webStream);
  const _options = options ?? {};
  const chainedClose = _options.onClose;
  _options.onClose = async () => {
    await webStreamReader.close();
    if (chainedClose) return chainedClose();
  };
  return new ReadStreamTokenizer(webStreamReader, _options);
}
function fromBuffer(uint8Array, options) {
  return new BufferTokenizer(uint8Array, options);
}
var WINDOWS_1252_EXTRA = {
  128: "\u20AC",
  130: "\u201A",
  131: "\u0192",
  132: "\u201E",
  133: "\u2026",
  134: "\u2020",
  135: "\u2021",
  136: "\u02C6",
  137: "\u2030",
  138: "\u0160",
  139: "\u2039",
  140: "\u0152",
  142: "\u017D",
  145: "\u2018",
  146: "\u2019",
  147: "\u201C",
  148: "\u201D",
  149: "\u2022",
  150: "\u2013",
  151: "\u2014",
  152: "\u02DC",
  153: "\u2122",
  154: "\u0161",
  155: "\u203A",
  156: "\u0153",
  158: "\u017E",
  159: "\u0178",
};
var WINDOWS_1252_REVERSE = {};
for (const [code, char] of Object.entries(WINDOWS_1252_EXTRA))
  WINDOWS_1252_REVERSE[char] = Number.parseInt(code);
function textDecode(bytes, encoding = "utf-8") {
  switch (encoding.toLowerCase()) {
    case "utf-8":
    case "utf8":
      if (typeof globalThis.TextDecoder !== "undefined")
        return new globalThis.TextDecoder("utf-8").decode(bytes);
      return decodeUTF8(bytes);
    case "utf-16le":
      return decodeUTF16LE(bytes);
    case "ascii":
      return decodeASCII(bytes);
    case "latin1":
    case "iso-8859-1":
      return decodeLatin1(bytes);
    case "windows-1252":
      return decodeWindows1252(bytes);
    default:
      throw new RangeError(`Encoding '${encoding}' not supported`);
  }
}
function decodeUTF8(bytes) {
  let out = "";
  let i$1 = 0;
  while (i$1 < bytes.length) {
    const b1 = bytes[i$1++];
    if (b1 < 128) out += String.fromCharCode(b1);
    else if (b1 < 224) {
      const b2 = bytes[i$1++] & 63;
      out += String.fromCharCode(((b1 & 31) << 6) | b2);
    } else if (b1 < 240) {
      const b2 = bytes[i$1++] & 63;
      const b3 = bytes[i$1++] & 63;
      out += String.fromCharCode(((b1 & 15) << 12) | (b2 << 6) | b3);
    } else {
      const b2 = bytes[i$1++] & 63;
      const b3 = bytes[i$1++] & 63;
      const b4 = bytes[i$1++] & 63;
      let cp = ((b1 & 7) << 18) | (b2 << 12) | (b3 << 6) | b4;
      cp -= 65536;
      out += String.fromCharCode(
        55296 + ((cp >> 10) & 1023),
        56320 + (cp & 1023),
      );
    }
  }
  return out;
}
function decodeUTF16LE(bytes) {
  let out = "";
  for (let i$1 = 0; i$1 < bytes.length; i$1 += 2)
    out += String.fromCharCode(bytes[i$1] | (bytes[i$1 + 1] << 8));
  return out;
}
function decodeASCII(bytes) {
  return String.fromCharCode(...bytes.map((b2) => b2 & 127));
}
function decodeLatin1(bytes) {
  return String.fromCharCode(...bytes);
}
function decodeWindows1252(bytes) {
  let out = "";
  for (const b2 of bytes)
    if (b2 >= 128 && b2 <= 159 && WINDOWS_1252_EXTRA[b2])
      out += WINDOWS_1252_EXTRA[b2];
    else out += String.fromCharCode(b2);
  return out;
}
function dv(array3) {
  return new DataView(array3.buffer, array3.byteOffset);
}
var UINT8 = {
  len: 1,
  get(array3, offset) {
    return dv(array3).getUint8(offset);
  },
  put(array3, offset, value) {
    dv(array3).setUint8(offset, value);
    return offset + 1;
  },
};
var UINT16_LE = {
  len: 2,
  get(array3, offset) {
    return dv(array3).getUint16(offset, true);
  },
  put(array3, offset, value) {
    dv(array3).setUint16(offset, value, true);
    return offset + 2;
  },
};
var UINT16_BE = {
  len: 2,
  get(array3, offset) {
    return dv(array3).getUint16(offset);
  },
  put(array3, offset, value) {
    dv(array3).setUint16(offset, value);
    return offset + 2;
  },
};
var UINT32_LE = {
  len: 4,
  get(array3, offset) {
    return dv(array3).getUint32(offset, true);
  },
  put(array3, offset, value) {
    dv(array3).setUint32(offset, value, true);
    return offset + 4;
  },
};
var UINT32_BE = {
  len: 4,
  get(array3, offset) {
    return dv(array3).getUint32(offset);
  },
  put(array3, offset, value) {
    dv(array3).setUint32(offset, value);
    return offset + 4;
  },
};
var INT32_BE = {
  len: 4,
  get(array3, offset) {
    return dv(array3).getInt32(offset);
  },
  put(array3, offset, value) {
    dv(array3).setInt32(offset, value);
    return offset + 4;
  },
};
var UINT64_LE = {
  len: 8,
  get(array3, offset) {
    return dv(array3).getBigUint64(offset, true);
  },
  put(array3, offset, value) {
    dv(array3).setBigUint64(offset, value, true);
    return offset + 8;
  },
};
var StringType = class {
  constructor(len, encoding) {
    this.len = len;
    this.encoding = encoding;
  }
  get(data, offset = 0) {
    const bytes = data.subarray(offset, offset + this.len);
    return textDecode(bytes, this.encoding);
  }
};
var require$1 = createRequire$1("/");
var Worker;
try {
  Worker = require$1("worker_threads").Worker;
} catch (e2) {}
var u8 = Uint8Array;
var u16 = Uint16Array;
var i32 = Int32Array;
var fleb = new u8([
  0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5,
  5, 5, 0, 0, 0, 0,
]);
var fdeb = new u8([
  0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11,
  11, 12, 12, 13, 13, 0, 0,
]);
var clim = new u8([
  16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
]);
var freb = function (eb, start) {
  var b2 = new u16(31);
  for (var i$1 = 0; i$1 < 31; ++i$1) b2[i$1] = start += 1 << eb[i$1 - 1];
  var r2 = new i32(b2[30]);
  for (var i$1 = 1; i$1 < 30; ++i$1)
    for (var j = b2[i$1]; j < b2[i$1 + 1]; ++j)
      r2[j] = ((j - b2[i$1]) << 5) | i$1;
  return {
    b: b2,
    r: r2,
  };
};
var _a17 = freb(fleb, 2);
var fl = _a17.b;
var revfl = _a17.r;
((fl[28] = 258), (revfl[258] = 28));
var _b8 = freb(fdeb, 0);
var fd = _b8.b;
var revfd = _b8.r;
var rev = new u16(32768);
for (i2 = 0; i2 < 32768; ++i2) {
  x = ((i2 & 43690) >> 1) | ((i2 & 21845) << 1);
  x = ((x & 52428) >> 2) | ((x & 13107) << 2);
  x = ((x & 61680) >> 4) | ((x & 3855) << 4);
  rev[i2] = (((x & 65280) >> 8) | ((x & 255) << 8)) >> 1;
}
var x;
var i2;
var hMap = function (cd, mb, r2) {
  var s$1 = cd.length;
  var i$1 = 0;
  var l2 = new u16(mb);
  for (; i$1 < s$1; ++i$1) if (cd[i$1]) ++l2[cd[i$1] - 1];
  var le = new u16(mb);
  for (i$1 = 1; i$1 < mb; ++i$1) le[i$1] = (le[i$1 - 1] + l2[i$1 - 1]) << 1;
  var co;
  if (r2) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i$1 = 0; i$1 < s$1; ++i$1)
      if (cd[i$1]) {
        var sv = (i$1 << 4) | cd[i$1];
        var r_1 = mb - cd[i$1];
        var v2 = le[cd[i$1] - 1]++ << r_1;
        for (var m$1 = v2 | ((1 << r_1) - 1); v2 <= m$1; ++v2)
          co[rev[v2] >> rvb] = sv;
      }
  } else {
    co = new u16(s$1);
    for (i$1 = 0; i$1 < s$1; ++i$1)
      if (cd[i$1]) co[i$1] = rev[le[cd[i$1] - 1]++] >> (15 - cd[i$1]);
  }
  return co;
};
var flt = new u8(288);
for (i2 = 0; i2 < 144; ++i2) flt[i2] = 8;
var i2;
for (i2 = 144; i2 < 256; ++i2) flt[i2] = 9;
var i2;
for (i2 = 256; i2 < 280; ++i2) flt[i2] = 7;
var i2;
for (i2 = 280; i2 < 288; ++i2) flt[i2] = 8;
var i2;
var fdt = new u8(32);
for (i2 = 0; i2 < 32; ++i2) fdt[i2] = 5;
var i2;
var flrm = /* @__PURE__ */ hMap(flt, 9, 1);
var fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
var max = function (a2) {
  var m$1 = a2[0];
  for (var i$1 = 1; i$1 < a2.length; ++i$1) if (a2[i$1] > m$1) m$1 = a2[i$1];
  return m$1;
};
var bits = function (d$1, p2, m$1) {
  var o2 = (p2 / 8) | 0;
  return ((d$1[o2] | (d$1[o2 + 1] << 8)) >> (p2 & 7)) & m$1;
};
var bits16 = function (d$1, p2) {
  var o2 = (p2 / 8) | 0;
  return (d$1[o2] | (d$1[o2 + 1] << 8) | (d$1[o2 + 2] << 16)) >> (p2 & 7);
};
var shft = function (p2) {
  return ((p2 + 7) / 8) | 0;
};
var slc = function (v2, s$1, e2) {
  if (s$1 == null || s$1 < 0) s$1 = 0;
  if (e2 == null || e2 > v2.length) e2 = v2.length;
  return new u8(v2.subarray(s$1, e2));
};
var ec = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data",
];
var err = function (ind, msg, nt) {
  var e2 = new Error(msg || ec[ind]);
  e2.code = ind;
  if (Error.captureStackTrace) Error.captureStackTrace(e2, err);
  if (!nt) throw e2;
  return e2;
};
var inflt = function (dat, st, buf, dict) {
  var sl = dat.length,
    dl = dict ? dict.length : 0;
  if (!sl || (st.f && !st.l)) return buf || new u8(0);
  var noBuf = !buf;
  var resize = noBuf || st.i != 2;
  var noSt = st.i;
  if (noBuf) buf = new u8(sl * 3);
  var cbuf = function (l$1) {
    var bl = buf.length;
    if (l$1 > bl) {
      var nbuf = new u8(Math.max(bl * 2, l$1));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  var final = st.f || 0,
    pos = st.p || 0,
    bt = st.b || 0,
    lm = st.l,
    dm = st.d,
    lbt = st.m,
    dbt = st.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      final = bits(dat, pos, 1);
      var type = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type) {
        var s$1 = shft(pos) + 4,
          l2 = dat[s$1 - 4] | (dat[s$1 - 3] << 8),
          t2 = s$1 + l2;
        if (t2 > sl) {
          if (noSt) err(0);
          break;
        }
        if (resize) cbuf(bt + l2);
        buf.set(dat.subarray(s$1, t2), bt);
        ((st.b = bt += l2), (st.p = pos = t2 * 8), (st.f = final));
        continue;
      } else if (type == 1) ((lm = flrm), (dm = fdrm), (lbt = 9), (dbt = 5));
      else if (type == 2) {
        var hLit = bits(dat, pos, 31) + 257,
          hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl);
        var clt = new u8(19);
        for (var i$1 = 0; i$1 < hcLen; ++i$1)
          clt[clim[i$1]] = bits(dat, pos + i$1 * 3, 7);
        pos += hcLen * 3;
        var clb = max(clt),
          clbmsk = (1 << clb) - 1;
        var clm = hMap(clt, clb, 1);
        for (var i$1 = 0; i$1 < tl; ) {
          var r2 = clm[bits(dat, pos, clbmsk)];
          pos += r2 & 15;
          var s$1 = r2 >> 4;
          if (s$1 < 16) ldt[i$1++] = s$1;
          else {
            var c2 = 0,
              n = 0;
            if (s$1 == 16)
              ((n = 3 + bits(dat, pos, 3)), (pos += 2), (c2 = ldt[i$1 - 1]));
            else if (s$1 == 17) ((n = 3 + bits(dat, pos, 7)), (pos += 3));
            else if (s$1 == 18) ((n = 11 + bits(dat, pos, 127)), (pos += 7));
            while (n--) ldt[i$1++] = c2;
          }
        }
        var lt = ldt.subarray(0, hLit),
          dt = ldt.subarray(hLit);
        lbt = max(lt);
        dbt = max(dt);
        lm = hMap(lt, lbt, 1);
        dm = hMap(dt, dbt, 1);
      } else err(1);
      if (pos > tbts) {
        if (noSt) err(0);
        break;
      }
    }
    if (resize) cbuf(bt + 131072);
    var lms = (1 << lbt) - 1,
      dms = (1 << dbt) - 1;
    var lpos = pos;
    for (; ; lpos = pos) {
      var c2 = lm[bits16(dat, pos) & lms],
        sym = c2 >> 4;
      pos += c2 & 15;
      if (pos > tbts) {
        if (noSt) err(0);
        break;
      }
      if (!c2) err(2);
      if (sym < 256) buf[bt++] = sym;
      else if (sym == 256) {
        ((lpos = pos), (lm = null));
        break;
      } else {
        var add = sym - 254;
        if (sym > 264) {
          var i$1 = sym - 257,
            b2 = fleb[i$1];
          add = bits(dat, pos, (1 << b2) - 1) + fl[i$1];
          pos += b2;
        }
        var d$1 = dm[bits16(dat, pos) & dms],
          dsym = d$1 >> 4;
        if (!d$1) err(3);
        pos += d$1 & 15;
        var dt = fd[dsym];
        if (dsym > 3) {
          var b2 = fdeb[dsym];
          ((dt += bits16(dat, pos) & ((1 << b2) - 1)), (pos += b2));
        }
        if (pos > tbts) {
          if (noSt) err(0);
          break;
        }
        if (resize) cbuf(bt + 131072);
        var end = bt + add;
        if (bt < dt) {
          var shift = dl - dt,
            dend = Math.min(dt, end);
          if (shift + bt < 0) err(3);
          for (; bt < dend; ++bt) buf[bt] = dict[shift + bt];
        }
        for (; bt < end; ++bt) buf[bt] = buf[bt - dt];
      }
    }
    ((st.l = lm), (st.p = lpos), (st.b = bt), (st.f = final));
    if (lm) ((final = 1), (st.m = lbt), (st.d = dm), (st.n = dbt));
  } while (!final);
  return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
};
var et = /* @__PURE__ */ new u8(0);
var gzs = function (d$1) {
  if (d$1[0] != 31 || d$1[1] != 139 || d$1[2] != 8) err(6, "invalid gzip data");
  var flg = d$1[3];
  var st = 10;
  if (flg & 4) st += (d$1[10] | (d$1[11] << 8)) + 2;
  for (var zs = ((flg >> 3) & 1) + ((flg >> 4) & 1); zs > 0; zs -= !d$1[st++]);
  return st + (flg & 2);
};
var gzl = function (d$1) {
  var l2 = d$1.length;
  return (
    (d$1[l2 - 4] |
      (d$1[l2 - 3] << 8) |
      (d$1[l2 - 2] << 16) |
      (d$1[l2 - 1] << 24)) >>>
    0
  );
};
var zls = function (d$1, dict) {
  if ((d$1[0] & 15) != 8 || d$1[0] >> 4 > 7 || ((d$1[0] << 8) | d$1[1]) % 31)
    err(6, "invalid zlib data");
  if (((d$1[1] >> 5) & 1) == +!dict)
    err(
      6,
      "invalid zlib data: " +
        (d$1[1] & 32 ? "need" : "unexpected") +
        " dictionary",
    );
  return ((d$1[1] >> 3) & 4) + 2;
};
function inflateSync(data, opts) {
  return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
function gunzipSync(data, opts) {
  var st = gzs(data);
  if (st + 8 > data.length) err(6, "invalid gzip data");
  return inflt(
    data.subarray(st, -8),
    { i: 2 },
    (opts && opts.out) || new u8(gzl(data)),
    opts && opts.dictionary,
  );
}
function unzlibSync(data, opts) {
  return inflt(
    data.subarray(zls(data, opts && opts.dictionary), -4),
    { i: 2 },
    opts && opts.out,
    opts && opts.dictionary,
  );
}
function decompressSync(data, opts) {
  return data[0] == 31 && data[1] == 139 && data[2] == 8
    ? gunzipSync(data, opts)
    : (data[0] & 15) != 8 || data[0] >> 4 > 7 || ((data[0] << 8) | data[1]) % 31
      ? inflateSync(data, opts)
      : unzlibSync(data, opts);
}
var td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder();
var tds = 0;
try {
  td.decode(et, { stream: true });
  tds = 1;
} catch (e2) {}
var require_ms = /* @__PURE__ */ __commonJS2({
  "../../../node_modules/ms/index.js": (exports, module) => {
    var s2 = 1e3;
    var m2 = s2 * 60;
    var h2 = m2 * 60;
    var d2 = h2 * 24;
    var w = d2 * 7;
    var y2 = d2 * 365.25;
    module.exports = function (val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) return parse7(val);
      else if (type === "number" && isFinite(val))
        return options.long ? fmtLong(val) : fmtShort(val);
      throw new Error(
        "val is not a non-empty string or a valid number. val=" +
          JSON.stringify(val),
      );
    };
    function parse7(str) {
      str = String(str);
      if (str.length > 100) return;
      var match =
        /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          str,
        );
      if (!match) return;
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y2;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d2;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h2;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m2;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s2;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d2) return Math.round(ms / d2) + "d";
      if (msAbs >= h2) return Math.round(ms / h2) + "h";
      if (msAbs >= m2) return Math.round(ms / m2) + "m";
      if (msAbs >= s2) return Math.round(ms / s2) + "s";
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d2) return plural(ms, msAbs, d2, "day");
      if (msAbs >= h2) return plural(ms, msAbs, h2, "hour");
      if (msAbs >= m2) return plural(ms, msAbs, m2, "minute");
      if (msAbs >= s2) return plural(ms, msAbs, s2, "second");
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name18) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name18 + (isPlural ? "s" : "");
    }
  },
});
var require_common = /* @__PURE__ */ __commonJS2({
  "../../../node_modules/debug/src/common.js": (exports, module) => {
    function setup(env$1) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env$1).forEach((key) => {
        createDebug[key] = env$1[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash2 = 0;
        for (let i$1 = 0; i$1 < namespace.length; i$1++) {
          hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i$1);
          hash2 |= 0;
        }
        return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug$1(...args) {
          if (!debug$1.enabled) return;
          const self = debug$1;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") args.unshift("%O");
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") return "%";
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self, args);
          const logFn = self.log || createDebug.log;
          logFn.apply(self, args);
        }
        debug$1.namespace = namespace;
        debug$1.useColors = createDebug.useColors();
        debug$1.color = createDebug.selectColor(namespace);
        debug$1.extend = extend3;
        debug$1.destroy = createDebug.destroy;
        Object.defineProperty(debug$1, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) return enableOverride;
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v2) => {
            enableOverride = v2;
          },
        });
        if (typeof createDebug.init === "function") createDebug.init(debug$1);
        return debug$1;
      }
      function extend3(namespace, delimiter) {
        const newDebug = createDebug(
          this.namespace +
            (typeof delimiter === "undefined" ? ":" : delimiter) +
            namespace,
        );
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "")
          .trim()
          .replace(/\s+/g, ",")
          .split(",")
          .filter(Boolean);
        for (const ns of split)
          if (ns[0] === "-") createDebug.skips.push(ns.slice(1));
          else createDebug.names.push(ns);
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length)
          if (
            templateIndex < template.length &&
            (template[templateIndex] === search[searchIndex] ||
              template[templateIndex] === "*")
          )
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else return false;
        while (
          templateIndex < template.length &&
          template[templateIndex] === "*"
        )
          templateIndex++;
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace),
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name18) {
        for (const skip of createDebug.skips)
          if (matchesTemplate(name18, skip)) return false;
        for (const ns of createDebug.names)
          if (matchesTemplate(name18, ns)) return true;
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) return val.stack || val.message;
        return val;
      }
      function destroy() {
        console.warn(
          "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
        );
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  },
});
var require_browser = /* @__PURE__ */ __commonJS2({
  "../../../node_modules/debug/src/browser.js": (exports, module) => {
    exports.formatArgs = formatArgs$1;
    exports.save = save$1;
    exports.load = load$1;
    exports.useColors = useColors$1;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn(
            "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
          );
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33",
    ];
    function useColors$1() {
      if (
        typeof window !== "undefined" &&
        window.process &&
        (window.process.type === "renderer" || window.process.__nwjs)
      )
        return true;
      if (
        typeof navigator !== "undefined" &&
        navigator.userAgent &&
        navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
      )
        return false;
      let m$1;
      return (
        (typeof document !== "undefined" &&
          document.documentElement &&
          document.documentElement.style &&
          document.documentElement.style.WebkitAppearance) ||
        (typeof window !== "undefined" &&
          window.console &&
          (window.console.firebug ||
            (window.console.exception && window.console.table))) ||
        (typeof navigator !== "undefined" &&
          navigator.userAgent &&
          (m$1 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) &&
          parseInt(m$1[1], 10) >= 31) ||
        (typeof navigator !== "undefined" &&
          navigator.userAgent &&
          navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
      );
    }
    function formatArgs$1(args) {
      args[0] =
        (this.useColors ? "%c" : "") +
        this.namespace +
        (this.useColors ? " %c" : " ") +
        args[0] +
        (this.useColors ? "%c " : " ") +
        "+" +
        module.exports.humanize(this.diff);
      if (!this.useColors) return;
      const c2 = "color: " + this.color;
      args.splice(1, 0, c2, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") return;
        index++;
        if (match === "%c") lastC = index;
      });
      args.splice(lastC, 0, c2);
    }
    exports.log = console.debug || console.log || (() => {});
    function save$1(namespaces) {
      try {
        if (namespaces) exports.storage.setItem("debug", namespaces);
        else exports.storage.removeItem("debug");
      } catch (error45) {}
    }
    function load$1() {
      let r2;
      try {
        r2 =
          exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
      } catch (error45) {}
      if (!r2 && typeof process !== "undefined" && "env" in process)
        r2 = process.env.DEBUG;
      return r2;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error45) {}
    }
    module.exports = require_common()(exports);
    const { formatters: formatters$1 } = module.exports;
    formatters$1.j = function (v2) {
      try {
        return JSON.stringify(v2);
      } catch (error45) {
        return "[UnexpectedJSONParseError]: " + error45.message;
      }
    };
  },
});
var require_has_flag = /* @__PURE__ */ __commonJS2({
  "../../../node_modules/has-flag/index.js": (exports, module) => {
    module.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return (
        position !== -1 &&
        (terminatorPosition === -1 || position < terminatorPosition)
      );
    };
  },
});
var require_supports_color = /* @__PURE__ */ __commonJS2({
  "../../../node_modules/supports-color/index.js": (exports, module) => {
    const os = __import_OS;
    const tty$1 = __import_TTY;
    const hasFlag = require_has_flag();
    const { env } = process;
    let forceColor;
    if (
      hasFlag("no-color") ||
      hasFlag("no-colors") ||
      hasFlag("color=false") ||
      hasFlag("color=never")
    )
      forceColor = 0;
    else if (
      hasFlag("color") ||
      hasFlag("colors") ||
      hasFlag("color=true") ||
      hasFlag("color=always")
    )
      forceColor = 1;
    if ("FORCE_COLOR" in env)
      if (env.FORCE_COLOR === "true") forceColor = 1;
      else if (env.FORCE_COLOR === "false") forceColor = 0;
      else
        forceColor =
          env.FORCE_COLOR.length === 0
            ? 1
            : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    function translateLevel(level) {
      if (level === 0) return false;
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3,
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) return 0;
      if (
        hasFlag("color=16m") ||
        hasFlag("color=full") ||
        hasFlag("color=truecolor")
      )
        return 3;
      if (hasFlag("color=256")) return 2;
      if (haveStream && !streamIsTTY && forceColor === void 0) return 0;
      const min = forceColor || 0;
      if (env.TERM === "dumb") return min;
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586)
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        return 1;
      }
      if ("CI" in env) {
        if (
          [
            "TRAVIS",
            "CIRCLECI",
            "APPVEYOR",
            "GITLAB_CI",
            "GITHUB_ACTIONS",
            "BUILDKITE",
          ].some((sign) => sign in env) ||
          env.CI_NAME === "codeship"
        )
          return 1;
        return min;
      }
      if ("TEAMCITY_VERSION" in env)
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION)
          ? 1
          : 0;
      if (env.COLORTERM === "truecolor") return 3;
      if ("TERM_PROGRAM" in env) {
        const version3 = parseInt(
          (env.TERM_PROGRAM_VERSION || "").split(".")[0],
          10,
        );
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version3 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) return 2;
      if (
        /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(
          env.TERM,
        )
      )
        return 1;
      if ("COLORTERM" in env) return 1;
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty$1.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty$1.isatty(2))),
    };
  },
});
var require_node3 = /* @__PURE__ */ __commonJS2({
  "../../../node_modules/debug/src/node.js": (exports, module) => {
    const tty = __import_TTY;
    const util2 = __import_UTIL;
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util2.deprecate(
      () => {},
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
    );
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor$1 = require_supports_color();
      if (
        supportsColor$1 &&
        (supportsColor$1.stderr || supportsColor$1).level >= 2
      )
        exports.colors = [
          20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62,
          63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113,
          128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167,
          168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199,
          200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221,
        ];
    } catch (error45) {}
    exports.inspectOpts = Object.keys(process.env)
      .filter((key) => {
        return /^debug_/i.test(key);
      })
      .reduce((obj, key) => {
        const prop = key
          .substring(6)
          .toLowerCase()
          .replace(/_([a-z])/g, (_2, k) => {
            return k.toUpperCase();
          });
        let val = process.env[key];
        if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
        else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
        else if (val === "null") val = null;
        else val = Number(val);
        obj[prop] = val;
        return obj;
      }, {});
    function useColors() {
      return "colors" in exports.inspectOpts
        ? Boolean(exports.inspectOpts.colors)
        : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name18, useColors: useColors$2 } = this;
      if (useColors$2) {
        const c2 = this.color;
        const colorCode = "\x1B[3" + (c2 < 8 ? c2 : "8;5;" + c2);
        const prefix = `  ${colorCode};1m${name18} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(
          colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m",
        );
      } else args[0] = getDate() + name18 + " " + args[0];
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) return "";
      return /* @__PURE__ */ new Date().toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(
        util2.formatWithOptions(exports.inspectOpts, ...args) + "\n",
      );
    }
    function save(namespaces) {
      if (namespaces) process.env.DEBUG = namespaces;
      else delete process.env.DEBUG;
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug$1) {
      debug$1.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i$1 = 0; i$1 < keys.length; i$1++)
        debug$1.inspectOpts[keys[i$1]] = exports.inspectOpts[keys[i$1]];
    }
    module.exports = require_common()(exports);
    const { formatters } = module.exports;
    formatters.o = function (v2) {
      this.inspectOpts.colors = this.useColors;
      return util2
        .inspect(v2, this.inspectOpts)
        .split("\n")
        .map((str) => str.trim())
        .join(" ");
    };
    formatters.O = function (v2) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v2, this.inspectOpts);
    };
  },
});
var require_src = /* @__PURE__ */ __commonJS2({
  "../../../node_modules/debug/src/index.js": (exports, module) => {
    if (
      typeof process === "undefined" ||
      process.type === "renderer" ||
      process.browser === true ||
      process.__nwjs
    )
      module.exports = require_browser();
    else module.exports = require_node3();
  },
});
var Signature = {
  LocalFileHeader: 67324752,
  DataDescriptor: 134695760,
  CentralFileHeader: 33639248,
  EndOfCentralDirectory: 101010256,
};
var DataDescriptor = {
  get(array3) {
    UINT16_LE.get(array3, 6);
    return {
      signature: UINT32_LE.get(array3, 0),
      compressedSize: UINT32_LE.get(array3, 8),
      uncompressedSize: UINT32_LE.get(array3, 12),
    };
  },
  len: 16,
};
var LocalFileHeaderToken = {
  get(array3) {
    const flags = UINT16_LE.get(array3, 6);
    return {
      signature: UINT32_LE.get(array3, 0),
      minVersion: UINT16_LE.get(array3, 4),
      dataDescriptor: !!(flags & 8),
      compressedMethod: UINT16_LE.get(array3, 8),
      compressedSize: UINT32_LE.get(array3, 18),
      uncompressedSize: UINT32_LE.get(array3, 22),
      filenameLength: UINT16_LE.get(array3, 26),
      extraFieldLength: UINT16_LE.get(array3, 28),
      filename: null,
    };
  },
  len: 30,
};
var EndOfCentralDirectoryRecordToken = {
  get(array3) {
    return {
      signature: UINT32_LE.get(array3, 0),
      nrOfThisDisk: UINT16_LE.get(array3, 4),
      nrOfThisDiskWithTheStart: UINT16_LE.get(array3, 6),
      nrOfEntriesOnThisDisk: UINT16_LE.get(array3, 8),
      nrOfEntriesOfSize: UINT16_LE.get(array3, 10),
      sizeOfCd: UINT32_LE.get(array3, 12),
      offsetOfStartOfCd: UINT32_LE.get(array3, 16),
      zipFileCommentLength: UINT16_LE.get(array3, 20),
    };
  },
  len: 22,
};
var FileHeader = {
  get(array3) {
    const flags = UINT16_LE.get(array3, 8);
    return {
      signature: UINT32_LE.get(array3, 0),
      minVersion: UINT16_LE.get(array3, 6),
      dataDescriptor: !!(flags & 8),
      compressedMethod: UINT16_LE.get(array3, 10),
      compressedSize: UINT32_LE.get(array3, 20),
      uncompressedSize: UINT32_LE.get(array3, 24),
      filenameLength: UINT16_LE.get(array3, 28),
      extraFieldLength: UINT16_LE.get(array3, 30),
      fileCommentLength: UINT16_LE.get(array3, 32),
      relativeOffsetOfLocalHeader: UINT32_LE.get(array3, 42),
      filename: null,
    };
  },
  len: 46,
};
var import_src = /* @__PURE__ */ __toESM2(require_src(), 1);
function signatureToArray(signature) {
  const signatureBytes = new Uint8Array(UINT32_LE.len);
  UINT32_LE.put(signatureBytes, 0, signature);
  return signatureBytes;
}
var debug = (0, import_src.default)("tokenizer:inflate");
var syncBufferSize = 256 * 1024;
var ddSignatureArray = signatureToArray(Signature.DataDescriptor);
var eocdSignatureBytes = signatureToArray(Signature.EndOfCentralDirectory);
var ZipHandler = class {
  constructor(tokenizer) {
    this.tokenizer = tokenizer;
    this.syncBuffer = new Uint8Array(syncBufferSize);
  }
  async isZip() {
    return (await this.peekSignature()) === Signature.LocalFileHeader;
  }
  peekSignature() {
    return this.tokenizer.peekToken(UINT32_LE);
  }
  async findEndOfCentralDirectoryLocator() {
    const randomReadTokenizer = this.tokenizer;
    const chunkLength = Math.min(16 * 1024, randomReadTokenizer.fileInfo.size);
    const buffer = this.syncBuffer.subarray(0, chunkLength);
    await this.tokenizer.readBuffer(buffer, {
      position: randomReadTokenizer.fileInfo.size - chunkLength,
    });
    for (let i$1 = buffer.length - 4; i$1 >= 0; i$1--)
      if (
        buffer[i$1] === eocdSignatureBytes[0] &&
        buffer[i$1 + 1] === eocdSignatureBytes[1] &&
        buffer[i$1 + 2] === eocdSignatureBytes[2] &&
        buffer[i$1 + 3] === eocdSignatureBytes[3]
      )
        return randomReadTokenizer.fileInfo.size - chunkLength + i$1;
    return -1;
  }
  async readCentralDirectory() {
    if (!this.tokenizer.supportsRandomAccess()) {
      debug("Cannot reading central-directory without random-read support");
      return;
    }
    debug("Reading central-directory...");
    const pos = this.tokenizer.position;
    const offset = await this.findEndOfCentralDirectoryLocator();
    if (offset > 0) {
      debug("Central-directory 32-bit signature found");
      const eocdHeader = await this.tokenizer.readToken(
        EndOfCentralDirectoryRecordToken,
        offset,
      );
      const files = [];
      this.tokenizer.setPosition(eocdHeader.offsetOfStartOfCd);
      for (let n = 0; n < eocdHeader.nrOfEntriesOfSize; ++n) {
        const entry = await this.tokenizer.readToken(FileHeader);
        if (entry.signature !== Signature.CentralFileHeader)
          throw new Error("Expected Central-File-Header signature");
        entry.filename = await this.tokenizer.readToken(
          new StringType(entry.filenameLength, "utf-8"),
        );
        await this.tokenizer.ignore(entry.extraFieldLength);
        await this.tokenizer.ignore(entry.fileCommentLength);
        files.push(entry);
        debug(
          `Add central-directory file-entry: n=${n + 1}/${files.length}: filename=${files[n].filename}`,
        );
      }
      this.tokenizer.setPosition(pos);
      return files;
    }
    this.tokenizer.setPosition(pos);
  }
  async unzip(fileCb) {
    const entries = await this.readCentralDirectory();
    if (entries) return this.iterateOverCentralDirectory(entries, fileCb);
    let stop = false;
    do {
      const zipHeader = await this.readLocalFileHeader();
      if (!zipHeader) break;
      const next = fileCb(zipHeader);
      stop = !!next.stop;
      let fileData = void 0;
      await this.tokenizer.ignore(zipHeader.extraFieldLength);
      if (zipHeader.dataDescriptor && zipHeader.compressedSize === 0) {
        const chunks = [];
        let len = syncBufferSize;
        debug(
          "Compressed-file-size unknown, scanning for next data-descriptor-signature....",
        );
        let nextHeaderIndex = -1;
        while (nextHeaderIndex < 0 && len === syncBufferSize) {
          len = await this.tokenizer.peekBuffer(this.syncBuffer, {
            mayBeLess: true,
          });
          nextHeaderIndex = indexOf(
            this.syncBuffer.subarray(0, len),
            ddSignatureArray,
          );
          const size = nextHeaderIndex >= 0 ? nextHeaderIndex : len;
          if (next.handler) {
            const data = new Uint8Array(size);
            await this.tokenizer.readBuffer(data);
            chunks.push(data);
          } else await this.tokenizer.ignore(size);
        }
        debug(
          `Found data-descriptor-signature at pos=${this.tokenizer.position}`,
        );
        if (next.handler)
          await this.inflate(zipHeader, mergeArrays(chunks), next.handler);
      } else if (next.handler) {
        debug(
          `Reading compressed-file-data: ${zipHeader.compressedSize} bytes`,
        );
        fileData = new Uint8Array(zipHeader.compressedSize);
        await this.tokenizer.readBuffer(fileData);
        await this.inflate(zipHeader, fileData, next.handler);
      } else {
        debug(
          `Ignoring compressed-file-data: ${zipHeader.compressedSize} bytes`,
        );
        await this.tokenizer.ignore(zipHeader.compressedSize);
      }
      debug(`Reading data-descriptor at pos=${this.tokenizer.position}`);
      if (zipHeader.dataDescriptor) {
        const dataDescriptor = await this.tokenizer.readToken(DataDescriptor);
        if (dataDescriptor.signature !== 134695760)
          throw new Error(
            `Expected data-descriptor-signature at position ${this.tokenizer.position - DataDescriptor.len}`,
          );
      }
    } while (!stop);
  }
  async iterateOverCentralDirectory(entries, fileCb) {
    for (const fileHeader of entries) {
      const next = fileCb(fileHeader);
      if (next.handler) {
        this.tokenizer.setPosition(fileHeader.relativeOffsetOfLocalHeader);
        const zipHeader = await this.readLocalFileHeader();
        if (zipHeader) {
          await this.tokenizer.ignore(zipHeader.extraFieldLength);
          const fileData = new Uint8Array(fileHeader.compressedSize);
          await this.tokenizer.readBuffer(fileData);
          await this.inflate(zipHeader, fileData, next.handler);
        }
      }
      if (next.stop) break;
    }
  }
  inflate(zipHeader, fileData, cb) {
    if (zipHeader.compressedMethod === 0) return cb(fileData);
    debug(
      `Decompress filename=${zipHeader.filename}, compressed-size=${fileData.length}`,
    );
    const uncompressedData = decompressSync(fileData);
    return cb(uncompressedData);
  }
  async readLocalFileHeader() {
    const signature = await this.tokenizer.peekToken(UINT32_LE);
    if (signature === Signature.LocalFileHeader) {
      const header = await this.tokenizer.readToken(LocalFileHeaderToken);
      header.filename = await this.tokenizer.readToken(
        new StringType(header.filenameLength, "utf-8"),
      );
      return header;
    }
    if (signature === Signature.CentralFileHeader) return false;
    if (signature === 3759263696) throw new Error("Encrypted ZIP");
    throw new Error("Unexpected signature");
  }
};
function indexOf(buffer, portion) {
  const bufferLength = buffer.length;
  const portionLength = portion.length;
  if (portionLength > bufferLength) return -1;
  for (let i$1 = 0; i$1 <= bufferLength - portionLength; i$1++) {
    let found = true;
    for (let j = 0; j < portionLength; j++)
      if (buffer[i$1 + j] !== portion[j]) {
        found = false;
        break;
      }
    if (found) return i$1;
  }
  return -1;
}
function mergeArrays(chunks) {
  const totalLength = chunks.reduce((acc, curr) => acc + curr.length, 0);
  const mergedArray = new Uint8Array(totalLength);
  let offset = 0;
  for (const chunk of chunks) {
    mergedArray.set(chunk, offset);
    offset += chunk.length;
  }
  return mergedArray;
}
var cachedDecoders = { utf8: new globalThis.TextDecoder("utf8") };
var cachedEncoder = new globalThis.TextEncoder();
var byteToHexLookupTable = Array.from({ length: 256 }, (_2, index) =>
  index.toString(16).padStart(2, "0"),
);
function getUintBE(view) {
  const { byteLength } = view;
  if (byteLength === 6) return view.getUint16(0) * 2 ** 32 + view.getUint32(2);
  if (byteLength === 5) return view.getUint8(0) * 2 ** 32 + view.getUint32(1);
  if (byteLength === 4) return view.getUint32(0);
  if (byteLength === 3) return view.getUint8(0) * 2 ** 16 + view.getUint16(1);
  if (byteLength === 2) return view.getUint16(0);
  if (byteLength === 1) return view.getUint8(0);
}
function stringToBytes(string5) {
  return [...string5].map((character) => character.charCodeAt(0));
}
function tarHeaderChecksumMatches(arrayBuffer, offset = 0) {
  const readSum = Number.parseInt(
    new StringType(6).get(arrayBuffer, 148).replace(/\0.*$/, "").trim(),
    8,
  );
  if (Number.isNaN(readSum)) return false;
  let sum = 256;
  for (let index = offset; index < offset + 148; index++)
    sum += arrayBuffer[index];
  for (let index = offset + 156; index < offset + 512; index++)
    sum += arrayBuffer[index];
  return readSum === sum;
}
var uint32SyncSafeToken = {
  get: (buffer, offset) =>
    (buffer[offset + 3] & 127) |
    (buffer[offset + 2] << 7) |
    (buffer[offset + 1] << 14) |
    (buffer[offset] << 21),
  len: 4,
};
var extensions = [
  "jpg",
  "png",
  "apng",
  "gif",
  "webp",
  "flif",
  "xcf",
  "cr2",
  "cr3",
  "orf",
  "arw",
  "dng",
  "nef",
  "rw2",
  "raf",
  "tif",
  "bmp",
  "icns",
  "jxr",
  "psd",
  "indd",
  "zip",
  "tar",
  "rar",
  "gz",
  "bz2",
  "7z",
  "dmg",
  "mp4",
  "mid",
  "mkv",
  "webm",
  "mov",
  "avi",
  "mpg",
  "mp2",
  "mp3",
  "m4a",
  "oga",
  "ogg",
  "ogv",
  "opus",
  "flac",
  "wav",
  "spx",
  "amr",
  "pdf",
  "epub",
  "elf",
  "macho",
  "exe",
  "swf",
  "rtf",
  "wasm",
  "woff",
  "woff2",
  "eot",
  "ttf",
  "otf",
  "ttc",
  "ico",
  "flv",
  "ps",
  "xz",
  "sqlite",
  "nes",
  "crx",
  "xpi",
  "cab",
  "deb",
  "ar",
  "rpm",
  "Z",
  "lz",
  "cfb",
  "mxf",
  "mts",
  "blend",
  "bpg",
  "docx",
  "pptx",
  "xlsx",
  "3gp",
  "3g2",
  "j2c",
  "jp2",
  "jpm",
  "jpx",
  "mj2",
  "aif",
  "qcp",
  "odt",
  "ods",
  "odp",
  "xml",
  "mobi",
  "heic",
  "cur",
  "ktx",
  "ape",
  "wv",
  "dcm",
  "ics",
  "glb",
  "pcap",
  "dsf",
  "lnk",
  "alias",
  "voc",
  "ac3",
  "m4v",
  "m4p",
  "m4b",
  "f4v",
  "f4p",
  "f4b",
  "f4a",
  "mie",
  "asf",
  "ogm",
  "ogx",
  "mpc",
  "arrow",
  "shp",
  "aac",
  "mp1",
  "it",
  "s3m",
  "xm",
  "skp",
  "avif",
  "eps",
  "lzh",
  "pgp",
  "asar",
  "stl",
  "chm",
  "3mf",
  "zst",
  "jxl",
  "vcf",
  "jls",
  "pst",
  "dwg",
  "parquet",
  "class",
  "arj",
  "cpio",
  "ace",
  "avro",
  "icc",
  "fbx",
  "vsdx",
  "vtt",
  "apk",
  "drc",
  "lz4",
  "potx",
  "xltx",
  "dotx",
  "xltm",
  "ott",
  "ots",
  "otp",
  "odg",
  "otg",
  "xlsm",
  "docm",
  "dotm",
  "potm",
  "pptm",
  "jar",
  "rm",
  "ppsm",
  "ppsx",
];
var mimeTypes = [
  "image/jpeg",
  "image/png",
  "image/gif",
  "image/webp",
  "image/flif",
  "image/x-xcf",
  "image/x-canon-cr2",
  "image/x-canon-cr3",
  "image/tiff",
  "image/bmp",
  "image/vnd.ms-photo",
  "image/vnd.adobe.photoshop",
  "application/x-indesign",
  "application/epub+zip",
  "application/x-xpinstall",
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12",
  "application/vnd.oasis.opendocument.text",
  "application/vnd.oasis.opendocument.spreadsheet",
  "application/vnd.oasis.opendocument.presentation",
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
  "application/vnd.openxmlformats-officedocument.presentationml.presentation",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow",
  "application/zip",
  "application/x-tar",
  "application/x-rar-compressed",
  "application/gzip",
  "application/x-bzip2",
  "application/x-7z-compressed",
  "application/x-apple-diskimage",
  "application/vnd.apache.arrow.file",
  "video/mp4",
  "audio/midi",
  "video/matroska",
  "video/webm",
  "video/quicktime",
  "video/vnd.avi",
  "audio/wav",
  "audio/qcelp",
  "audio/x-ms-asf",
  "video/x-ms-asf",
  "application/vnd.ms-asf",
  "video/mpeg",
  "video/3gpp",
  "audio/mpeg",
  "audio/mp4",
  "video/ogg",
  "audio/ogg",
  "audio/ogg; codecs=opus",
  "application/ogg",
  "audio/flac",
  "audio/ape",
  "audio/wavpack",
  "audio/amr",
  "application/pdf",
  "application/x-elf",
  "application/x-mach-binary",
  "application/x-msdownload",
  "application/x-shockwave-flash",
  "application/rtf",
  "application/wasm",
  "font/woff",
  "font/woff2",
  "application/vnd.ms-fontobject",
  "font/ttf",
  "font/otf",
  "font/collection",
  "image/x-icon",
  "video/x-flv",
  "application/postscript",
  "application/eps",
  "application/x-xz",
  "application/x-sqlite3",
  "application/x-nintendo-nes-rom",
  "application/x-google-chrome-extension",
  "application/vnd.ms-cab-compressed",
  "application/x-deb",
  "application/x-unix-archive",
  "application/x-rpm",
  "application/x-compress",
  "application/x-lzip",
  "application/x-cfb",
  "application/x-mie",
  "application/mxf",
  "video/mp2t",
  "application/x-blender",
  "image/bpg",
  "image/j2c",
  "image/jp2",
  "image/jpx",
  "image/jpm",
  "image/mj2",
  "audio/aiff",
  "application/xml",
  "application/x-mobipocket-ebook",
  "image/heif",
  "image/heif-sequence",
  "image/heic",
  "image/heic-sequence",
  "image/icns",
  "image/ktx",
  "application/dicom",
  "audio/x-musepack",
  "text/calendar",
  "text/vcard",
  "text/vtt",
  "model/gltf-binary",
  "application/vnd.tcpdump.pcap",
  "audio/x-dsf",
  "application/x.ms.shortcut",
  "application/x.apple.alias",
  "audio/x-voc",
  "audio/vnd.dolby.dd-raw",
  "audio/x-m4a",
  "image/apng",
  "image/x-olympus-orf",
  "image/x-sony-arw",
  "image/x-adobe-dng",
  "image/x-nikon-nef",
  "image/x-panasonic-rw2",
  "image/x-fujifilm-raf",
  "video/x-m4v",
  "video/3gpp2",
  "application/x-esri-shape",
  "audio/aac",
  "audio/x-it",
  "audio/x-s3m",
  "audio/x-xm",
  "video/MP1S",
  "video/MP2P",
  "application/vnd.sketchup.skp",
  "image/avif",
  "application/x-lzh-compressed",
  "application/pgp-encrypted",
  "application/x-asar",
  "model/stl",
  "application/vnd.ms-htmlhelp",
  "model/3mf",
  "image/jxl",
  "application/zstd",
  "image/jls",
  "application/vnd.ms-outlook",
  "image/vnd.dwg",
  "application/vnd.apache.parquet",
  "application/java-vm",
  "application/x-arj",
  "application/x-cpio",
  "application/x-ace-compressed",
  "application/avro",
  "application/vnd.iccprofile",
  "application/x.autodesk.fbx",
  "application/vnd.visio",
  "application/vnd.android.package-archive",
  "application/vnd.google.draco",
  "application/x-lz4",
  "application/vnd.openxmlformats-officedocument.presentationml.template",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template",
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
  "application/vnd.ms-excel.template.macroenabled.12",
  "application/vnd.oasis.opendocument.text-template",
  "application/vnd.oasis.opendocument.spreadsheet-template",
  "application/vnd.oasis.opendocument.presentation-template",
  "application/vnd.oasis.opendocument.graphics",
  "application/vnd.oasis.opendocument.graphics-template",
  "application/vnd.ms-excel.sheet.macroenabled.12",
  "application/vnd.ms-word.document.macroenabled.12",
  "application/vnd.ms-word.template.macroenabled.12",
  "application/vnd.ms-powerpoint.template.macroenabled.12",
  "application/vnd.ms-powerpoint.presentation.macroenabled.12",
  "application/java-archive",
  "application/vnd.rn-realmedia",
];
var reasonableDetectionSizeInBytes = 4100;
async function fileTypeFromBuffer(input, options) {
  return new FileTypeParser(options).fromBuffer(input);
}
function getFileTypeFromMimeType(mimeType) {
  mimeType = mimeType.toLowerCase();
  switch (mimeType) {
    case "application/epub+zip":
      return {
        ext: "epub",
        mime: mimeType,
      };
    case "application/vnd.oasis.opendocument.text":
      return {
        ext: "odt",
        mime: mimeType,
      };
    case "application/vnd.oasis.opendocument.text-template":
      return {
        ext: "ott",
        mime: mimeType,
      };
    case "application/vnd.oasis.opendocument.spreadsheet":
      return {
        ext: "ods",
        mime: mimeType,
      };
    case "application/vnd.oasis.opendocument.spreadsheet-template":
      return {
        ext: "ots",
        mime: mimeType,
      };
    case "application/vnd.oasis.opendocument.presentation":
      return {
        ext: "odp",
        mime: mimeType,
      };
    case "application/vnd.oasis.opendocument.presentation-template":
      return {
        ext: "otp",
        mime: mimeType,
      };
    case "application/vnd.oasis.opendocument.graphics":
      return {
        ext: "odg",
        mime: mimeType,
      };
    case "application/vnd.oasis.opendocument.graphics-template":
      return {
        ext: "otg",
        mime: mimeType,
      };
    case "application/vnd.openxmlformats-officedocument.presentationml.slideshow":
      return {
        ext: "ppsx",
        mime: mimeType,
      };
    case "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":
      return {
        ext: "xlsx",
        mime: mimeType,
      };
    case "application/vnd.ms-excel.sheet.macroenabled":
      return {
        ext: "xlsm",
        mime: "application/vnd.ms-excel.sheet.macroenabled.12",
      };
    case "application/vnd.openxmlformats-officedocument.spreadsheetml.template":
      return {
        ext: "xltx",
        mime: mimeType,
      };
    case "application/vnd.ms-excel.template.macroenabled":
      return {
        ext: "xltm",
        mime: "application/vnd.ms-excel.template.macroenabled.12",
      };
    case "application/vnd.ms-powerpoint.slideshow.macroenabled":
      return {
        ext: "ppsm",
        mime: "application/vnd.ms-powerpoint.slideshow.macroenabled.12",
      };
    case "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
      return {
        ext: "docx",
        mime: mimeType,
      };
    case "application/vnd.ms-word.document.macroenabled":
      return {
        ext: "docm",
        mime: "application/vnd.ms-word.document.macroenabled.12",
      };
    case "application/vnd.openxmlformats-officedocument.wordprocessingml.template":
      return {
        ext: "dotx",
        mime: mimeType,
      };
    case "application/vnd.ms-word.template.macroenabledtemplate":
      return {
        ext: "dotm",
        mime: "application/vnd.ms-word.template.macroenabled.12",
      };
    case "application/vnd.openxmlformats-officedocument.presentationml.template":
      return {
        ext: "potx",
        mime: mimeType,
      };
    case "application/vnd.ms-powerpoint.template.macroenabled":
      return {
        ext: "potm",
        mime: "application/vnd.ms-powerpoint.template.macroenabled.12",
      };
    case "application/vnd.openxmlformats-officedocument.presentationml.presentation":
      return {
        ext: "pptx",
        mime: mimeType,
      };
    case "application/vnd.ms-powerpoint.presentation.macroenabled":
      return {
        ext: "pptm",
        mime: "application/vnd.ms-powerpoint.presentation.macroenabled.12",
      };
    case "application/vnd.ms-visio.drawing":
      return {
        ext: "vsdx",
        mime: "application/vnd.visio",
      };
    case "application/vnd.ms-package.3dmanufacturing-3dmodel+xml":
      return {
        ext: "3mf",
        mime: "model/3mf",
      };
    default:
  }
}
function _check2(buffer, headers, options) {
  options = {
    offset: 0,
    ...options,
  };
  for (const [index, header] of headers.entries())
    if (options.mask) {
      if (header !== (options.mask[index] & buffer[index + options.offset]))
        return false;
    } else if (header !== buffer[index + options.offset]) return false;
  return true;
}
var FileTypeParser = class {
  constructor(options) {
    this.options = {
      mpegOffsetTolerance: 0,
      ...options,
    };
    this.detectors = [
      ...(options?.customDetectors ?? []),
      {
        id: "core",
        detect: this.detectConfident,
      },
      {
        id: "core.imprecise",
        detect: this.detectImprecise,
      },
    ];
    this.tokenizerOptions = { abortSignal: options?.signal };
  }
  async fromTokenizer(tokenizer) {
    const initialPosition = tokenizer.position;
    for (const detector of this.detectors) {
      const fileType = await detector.detect(tokenizer);
      if (fileType) return fileType;
      if (initialPosition !== tokenizer.position) return void 0;
    }
  }
  async fromBuffer(input) {
    if (!(input instanceof Uint8Array || input instanceof ArrayBuffer))
      throw new TypeError(
        `Expected the \`input\` argument to be of type \`Uint8Array\` or \`ArrayBuffer\`, got \`${typeof input}\``,
      );
    const buffer = input instanceof Uint8Array ? input : new Uint8Array(input);
    if (!(buffer?.length > 1)) return;
    return this.fromTokenizer(fromBuffer(buffer, this.tokenizerOptions));
  }
  async fromBlob(blob) {
    return this.fromStream(blob.stream());
  }
  async fromStream(stream) {
    const tokenizer = await fromWebStream(stream, this.tokenizerOptions);
    try {
      return await this.fromTokenizer(tokenizer);
    } finally {
      await tokenizer.close();
    }
  }
  async toDetectionStream(stream, options) {
    const { sampleSize = reasonableDetectionSizeInBytes } = options;
    let detectedFileType;
    let firstChunk;
    const reader = stream.getReader({ mode: "byob" });
    try {
      const { value: chunk, done } = await reader.read(
        new Uint8Array(sampleSize),
      );
      firstChunk = chunk;
      if (!done && chunk)
        try {
          detectedFileType = await this.fromBuffer(
            chunk.subarray(0, sampleSize),
          );
        } catch (error45) {
          if (!(error45 instanceof EndOfStreamError)) throw error45;
          detectedFileType = void 0;
        }
      firstChunk = chunk;
    } finally {
      reader.releaseLock();
    }
    const transformStream = new TransformStream({
      async start(controller) {
        controller.enqueue(firstChunk);
      },
      transform(chunk, controller) {
        controller.enqueue(chunk);
      },
    });
    const newStream = stream.pipeThrough(transformStream);
    newStream.fileType = detectedFileType;
    return newStream;
  }
  check(header, options) {
    return _check2(this.buffer, header, options);
  }
  checkString(header, options) {
    return this.check(stringToBytes(header), options);
  }
  detectConfident = async (tokenizer) => {
    this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);
    if (tokenizer.fileInfo.size === void 0)
      tokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;
    this.tokenizer = tokenizer;
    await tokenizer.peekBuffer(this.buffer, {
      length: 12,
      mayBeLess: true,
    });
    if (this.check([66, 77]))
      return {
        ext: "bmp",
        mime: "image/bmp",
      };
    if (this.check([11, 119]))
      return {
        ext: "ac3",
        mime: "audio/vnd.dolby.dd-raw",
      };
    if (this.check([120, 1]))
      return {
        ext: "dmg",
        mime: "application/x-apple-diskimage",
      };
    if (this.check([77, 90]))
      return {
        ext: "exe",
        mime: "application/x-msdownload",
      };
    if (this.check([37, 33])) {
      await tokenizer.peekBuffer(this.buffer, {
        length: 24,
        mayBeLess: true,
      });
      if (
        this.checkString("PS-Adobe-", { offset: 2 }) &&
        this.checkString(" EPSF-", { offset: 14 })
      )
        return {
          ext: "eps",
          mime: "application/eps",
        };
      return {
        ext: "ps",
        mime: "application/postscript",
      };
    }
    if (this.check([31, 160]) || this.check([31, 157]))
      return {
        ext: "Z",
        mime: "application/x-compress",
      };
    if (this.check([199, 113]))
      return {
        ext: "cpio",
        mime: "application/x-cpio",
      };
    if (this.check([96, 234]))
      return {
        ext: "arj",
        mime: "application/x-arj",
      };
    if (this.check([239, 187, 191])) {
      this.tokenizer.ignore(3);
      return this.detectConfident(tokenizer);
    }
    if (this.check([71, 73, 70]))
      return {
        ext: "gif",
        mime: "image/gif",
      };
    if (this.check([73, 73, 188]))
      return {
        ext: "jxr",
        mime: "image/vnd.ms-photo",
      };
    if (this.check([31, 139, 8]))
      return {
        ext: "gz",
        mime: "application/gzip",
      };
    if (this.check([66, 90, 104]))
      return {
        ext: "bz2",
        mime: "application/x-bzip2",
      };
    if (this.checkString("ID3")) {
      await tokenizer.ignore(6);
      const id3HeaderLength = await tokenizer.readToken(uint32SyncSafeToken);
      if (tokenizer.position + id3HeaderLength > tokenizer.fileInfo.size)
        return {
          ext: "mp3",
          mime: "audio/mpeg",
        };
      await tokenizer.ignore(id3HeaderLength);
      return this.fromTokenizer(tokenizer);
    }
    if (this.checkString("MP+"))
      return {
        ext: "mpc",
        mime: "audio/x-musepack",
      };
    if (
      (this.buffer[0] === 67 || this.buffer[0] === 70) &&
      this.check([87, 83], { offset: 1 })
    )
      return {
        ext: "swf",
        mime: "application/x-shockwave-flash",
      };
    if (this.check([255, 216, 255])) {
      if (this.check([247], { offset: 3 }))
        return {
          ext: "jls",
          mime: "image/jls",
        };
      return {
        ext: "jpg",
        mime: "image/jpeg",
      };
    }
    if (this.check([79, 98, 106, 1]))
      return {
        ext: "avro",
        mime: "application/avro",
      };
    if (this.checkString("FLIF"))
      return {
        ext: "flif",
        mime: "image/flif",
      };
    if (this.checkString("8BPS"))
      return {
        ext: "psd",
        mime: "image/vnd.adobe.photoshop",
      };
    if (this.checkString("MPCK"))
      return {
        ext: "mpc",
        mime: "audio/x-musepack",
      };
    if (this.checkString("FORM"))
      return {
        ext: "aif",
        mime: "audio/aiff",
      };
    if (this.checkString("icns", { offset: 0 }))
      return {
        ext: "icns",
        mime: "image/icns",
      };
    if (this.check([80, 75, 3, 4])) {
      let fileType;
      await new ZipHandler(tokenizer).unzip((zipHeader) => {
        switch (zipHeader.filename) {
          case "META-INF/mozilla.rsa":
            fileType = {
              ext: "xpi",
              mime: "application/x-xpinstall",
            };
            return { stop: true };
          case "META-INF/MANIFEST.MF":
            fileType = {
              ext: "jar",
              mime: "application/java-archive",
            };
            return { stop: true };
          case "mimetype":
            return {
              async handler(fileData) {
                const mimeType = new TextDecoder("utf-8")
                  .decode(fileData)
                  .trim();
                fileType = getFileTypeFromMimeType(mimeType);
              },
              stop: true,
            };
          case "[Content_Types].xml":
            return {
              async handler(fileData) {
                let xmlContent = new TextDecoder("utf-8").decode(fileData);
                const endPos = xmlContent.indexOf('.main+xml"');
                if (endPos === -1) {
                  const mimeType =
                    "application/vnd.ms-package.3dmanufacturing-3dmodel+xml";
                  if (xmlContent.includes(`ContentType="${mimeType}"`))
                    fileType = getFileTypeFromMimeType(mimeType);
                } else {
                  xmlContent = xmlContent.slice(0, Math.max(0, endPos));
                  const firstPos = xmlContent.lastIndexOf('"');
                  const mimeType = xmlContent.slice(Math.max(0, firstPos + 1));
                  fileType = getFileTypeFromMimeType(mimeType);
                }
              },
              stop: true,
            };
          default:
            if (/classes\d*\.dex/.test(zipHeader.filename)) {
              fileType = {
                ext: "apk",
                mime: "application/vnd.android.package-archive",
              };
              return { stop: true };
            }
            return {};
        }
      });
      return (
        fileType ?? {
          ext: "zip",
          mime: "application/zip",
        }
      );
    }
    if (this.checkString("OggS")) {
      await tokenizer.ignore(28);
      const type = new Uint8Array(8);
      await tokenizer.readBuffer(type);
      if (_check2(type, [79, 112, 117, 115, 72, 101, 97, 100]))
        return {
          ext: "opus",
          mime: "audio/ogg; codecs=opus",
        };
      if (_check2(type, [128, 116, 104, 101, 111, 114, 97]))
        return {
          ext: "ogv",
          mime: "video/ogg",
        };
      if (_check2(type, [1, 118, 105, 100, 101, 111, 0]))
        return {
          ext: "ogm",
          mime: "video/ogg",
        };
      if (_check2(type, [127, 70, 76, 65, 67]))
        return {
          ext: "oga",
          mime: "audio/ogg",
        };
      if (_check2(type, [83, 112, 101, 101, 120, 32, 32]))
        return {
          ext: "spx",
          mime: "audio/ogg",
        };
      if (_check2(type, [1, 118, 111, 114, 98, 105, 115]))
        return {
          ext: "ogg",
          mime: "audio/ogg",
        };
      return {
        ext: "ogx",
        mime: "application/ogg",
      };
    }
    if (
      this.check([80, 75]) &&
      (this.buffer[2] === 3 || this.buffer[2] === 5 || this.buffer[2] === 7) &&
      (this.buffer[3] === 4 || this.buffer[3] === 6 || this.buffer[3] === 8)
    )
      return {
        ext: "zip",
        mime: "application/zip",
      };
    if (this.checkString("MThd"))
      return {
        ext: "mid",
        mime: "audio/midi",
      };
    if (
      this.checkString("wOFF") &&
      (this.check([0, 1, 0, 0], { offset: 4 }) ||
        this.checkString("OTTO", { offset: 4 }))
    )
      return {
        ext: "woff",
        mime: "font/woff",
      };
    if (
      this.checkString("wOF2") &&
      (this.check([0, 1, 0, 0], { offset: 4 }) ||
        this.checkString("OTTO", { offset: 4 }))
    )
      return {
        ext: "woff2",
        mime: "font/woff2",
      };
    if (this.check([212, 195, 178, 161]) || this.check([161, 178, 195, 212]))
      return {
        ext: "pcap",
        mime: "application/vnd.tcpdump.pcap",
      };
    if (this.checkString("DSD "))
      return {
        ext: "dsf",
        mime: "audio/x-dsf",
      };
    if (this.checkString("LZIP"))
      return {
        ext: "lz",
        mime: "application/x-lzip",
      };
    if (this.checkString("fLaC"))
      return {
        ext: "flac",
        mime: "audio/flac",
      };
    if (this.check([66, 80, 71, 251]))
      return {
        ext: "bpg",
        mime: "image/bpg",
      };
    if (this.checkString("wvpk"))
      return {
        ext: "wv",
        mime: "audio/wavpack",
      };
    if (this.checkString("%PDF"))
      return {
        ext: "pdf",
        mime: "application/pdf",
      };
    if (this.check([0, 97, 115, 109]))
      return {
        ext: "wasm",
        mime: "application/wasm",
      };
    if (this.check([73, 73])) {
      const fileType = await this.readTiffHeader(false);
      if (fileType) return fileType;
    }
    if (this.check([77, 77])) {
      const fileType = await this.readTiffHeader(true);
      if (fileType) return fileType;
    }
    if (this.checkString("MAC "))
      return {
        ext: "ape",
        mime: "audio/ape",
      };
    if (this.check([26, 69, 223, 163])) {
      async function readField() {
        const msb = await tokenizer.peekNumber(UINT8);
        let mask = 128;
        let ic = 0;
        while ((msb & mask) === 0 && mask !== 0) {
          ++ic;
          mask >>= 1;
        }
        const id = new Uint8Array(ic + 1);
        await tokenizer.readBuffer(id);
        return id;
      }
      async function readElement() {
        const idField = await readField();
        const lengthField = await readField();
        lengthField[0] ^= 128 >> (lengthField.length - 1);
        const nrLength = Math.min(6, lengthField.length);
        const idView = new DataView(idField.buffer);
        const lengthView = new DataView(
          lengthField.buffer,
          lengthField.length - nrLength,
          nrLength,
        );
        return {
          id: getUintBE(idView),
          len: getUintBE(lengthView),
        };
      }
      async function readChildren(children) {
        while (children > 0) {
          const element = await readElement();
          if (element.id === 17026) {
            const rawValue = await tokenizer.readToken(
              new StringType(element.len),
            );
            return rawValue.replaceAll(/\00.*$/g, "");
          }
          await tokenizer.ignore(element.len);
          --children;
        }
      }
      const re2 = await readElement();
      const documentType = await readChildren(re2.len);
      switch (documentType) {
        case "webm":
          return {
            ext: "webm",
            mime: "video/webm",
          };
        case "matroska":
          return {
            ext: "mkv",
            mime: "video/matroska",
          };
        default:
          return;
      }
    }
    if (this.checkString("SQLi"))
      return {
        ext: "sqlite",
        mime: "application/x-sqlite3",
      };
    if (this.check([78, 69, 83, 26]))
      return {
        ext: "nes",
        mime: "application/x-nintendo-nes-rom",
      };
    if (this.checkString("Cr24"))
      return {
        ext: "crx",
        mime: "application/x-google-chrome-extension",
      };
    if (this.checkString("MSCF") || this.checkString("ISc("))
      return {
        ext: "cab",
        mime: "application/vnd.ms-cab-compressed",
      };
    if (this.check([237, 171, 238, 219]))
      return {
        ext: "rpm",
        mime: "application/x-rpm",
      };
    if (this.check([197, 208, 211, 198]))
      return {
        ext: "eps",
        mime: "application/eps",
      };
    if (this.check([40, 181, 47, 253]))
      return {
        ext: "zst",
        mime: "application/zstd",
      };
    if (this.check([127, 69, 76, 70]))
      return {
        ext: "elf",
        mime: "application/x-elf",
      };
    if (this.check([33, 66, 68, 78]))
      return {
        ext: "pst",
        mime: "application/vnd.ms-outlook",
      };
    if (this.checkString("PAR1") || this.checkString("PARE"))
      return {
        ext: "parquet",
        mime: "application/vnd.apache.parquet",
      };
    if (this.checkString("ttcf"))
      return {
        ext: "ttc",
        mime: "font/collection",
      };
    if (this.check([207, 250, 237, 254]))
      return {
        ext: "macho",
        mime: "application/x-mach-binary",
      };
    if (this.check([4, 34, 77, 24]))
      return {
        ext: "lz4",
        mime: "application/x-lz4",
      };
    if (this.check([79, 84, 84, 79, 0]))
      return {
        ext: "otf",
        mime: "font/otf",
      };
    if (this.checkString("#!AMR"))
      return {
        ext: "amr",
        mime: "audio/amr",
      };
    if (this.checkString("{\\rtf"))
      return {
        ext: "rtf",
        mime: "application/rtf",
      };
    if (this.check([70, 76, 86, 1]))
      return {
        ext: "flv",
        mime: "video/x-flv",
      };
    if (this.checkString("IMPM"))
      return {
        ext: "it",
        mime: "audio/x-it",
      };
    if (
      this.checkString("-lh0-", { offset: 2 }) ||
      this.checkString("-lh1-", { offset: 2 }) ||
      this.checkString("-lh2-", { offset: 2 }) ||
      this.checkString("-lh3-", { offset: 2 }) ||
      this.checkString("-lh4-", { offset: 2 }) ||
      this.checkString("-lh5-", { offset: 2 }) ||
      this.checkString("-lh6-", { offset: 2 }) ||
      this.checkString("-lh7-", { offset: 2 }) ||
      this.checkString("-lzs-", { offset: 2 }) ||
      this.checkString("-lz4-", { offset: 2 }) ||
      this.checkString("-lz5-", { offset: 2 }) ||
      this.checkString("-lhd-", { offset: 2 })
    )
      return {
        ext: "lzh",
        mime: "application/x-lzh-compressed",
      };
    if (this.check([0, 0, 1, 186])) {
      if (
        this.check([33], {
          offset: 4,
          mask: [241],
        })
      )
        return {
          ext: "mpg",
          mime: "video/MP1S",
        };
      if (
        this.check([68], {
          offset: 4,
          mask: [196],
        })
      )
        return {
          ext: "mpg",
          mime: "video/MP2P",
        };
    }
    if (this.checkString("ITSF"))
      return {
        ext: "chm",
        mime: "application/vnd.ms-htmlhelp",
      };
    if (this.check([202, 254, 186, 190]))
      return {
        ext: "class",
        mime: "application/java-vm",
      };
    if (this.checkString(".RMF"))
      return {
        ext: "rm",
        mime: "application/vnd.rn-realmedia",
      };
    if (this.checkString("DRACO"))
      return {
        ext: "drc",
        mime: "application/vnd.google.draco",
      };
    if (this.check([253, 55, 122, 88, 90, 0]))
      return {
        ext: "xz",
        mime: "application/x-xz",
      };
    if (this.checkString("<?xml "))
      return {
        ext: "xml",
        mime: "application/xml",
      };
    if (this.check([55, 122, 188, 175, 39, 28]))
      return {
        ext: "7z",
        mime: "application/x-7z-compressed",
      };
    if (
      this.check([82, 97, 114, 33, 26, 7]) &&
      (this.buffer[6] === 0 || this.buffer[6] === 1)
    )
      return {
        ext: "rar",
        mime: "application/x-rar-compressed",
      };
    if (this.checkString("solid "))
      return {
        ext: "stl",
        mime: "model/stl",
      };
    if (this.checkString("AC")) {
      const version3 = new StringType(4, "latin1").get(this.buffer, 2);
      if (version3.match("^d*") && version3 >= 1e3 && version3 <= 1050)
        return {
          ext: "dwg",
          mime: "image/vnd.dwg",
        };
    }
    if (this.checkString("070707"))
      return {
        ext: "cpio",
        mime: "application/x-cpio",
      };
    if (this.checkString("BLENDER"))
      return {
        ext: "blend",
        mime: "application/x-blender",
      };
    if (this.checkString("!<arch>")) {
      await tokenizer.ignore(8);
      const string5 = await tokenizer.readToken(new StringType(13, "ascii"));
      if (string5 === "debian-binary")
        return {
          ext: "deb",
          mime: "application/x-deb",
        };
      return {
        ext: "ar",
        mime: "application/x-unix-archive",
      };
    }
    if (
      this.checkString("WEBVTT") &&
      ["\n", "\r", "	", " ", "\0"].some((char7) =>
        this.checkString(char7, { offset: 6 }),
      )
    )
      return {
        ext: "vtt",
        mime: "text/vtt",
      };
    if (this.check([137, 80, 78, 71, 13, 10, 26, 10])) {
      await tokenizer.ignore(8);
      async function readChunkHeader() {
        return {
          length: await tokenizer.readToken(INT32_BE),
          type: await tokenizer.readToken(new StringType(4, "latin1")),
        };
      }
      do {
        const chunk = await readChunkHeader();
        if (chunk.length < 0) return;
        switch (chunk.type) {
          case "IDAT":
            return {
              ext: "png",
              mime: "image/png",
            };
          case "acTL":
            return {
              ext: "apng",
              mime: "image/apng",
            };
          default:
            await tokenizer.ignore(chunk.length + 4);
        }
      } while (tokenizer.position + 8 < tokenizer.fileInfo.size);
      return {
        ext: "png",
        mime: "image/png",
      };
    }
    if (this.check([65, 82, 82, 79, 87, 49, 0, 0]))
      return {
        ext: "arrow",
        mime: "application/vnd.apache.arrow.file",
      };
    if (this.check([103, 108, 84, 70, 2, 0, 0, 0]))
      return {
        ext: "glb",
        mime: "model/gltf-binary",
      };
    if (
      this.check([102, 114, 101, 101], { offset: 4 }) ||
      this.check([109, 100, 97, 116], { offset: 4 }) ||
      this.check([109, 111, 111, 118], { offset: 4 }) ||
      this.check([119, 105, 100, 101], { offset: 4 })
    )
      return {
        ext: "mov",
        mime: "video/quicktime",
      };
    if (this.check([73, 73, 82, 79, 8, 0, 0, 0, 24]))
      return {
        ext: "orf",
        mime: "image/x-olympus-orf",
      };
    if (this.checkString("gimp xcf "))
      return {
        ext: "xcf",
        mime: "image/x-xcf",
      };
    if (
      this.checkString("ftyp", { offset: 4 }) &&
      (this.buffer[8] & 96) !== 0
    ) {
      const brandMajor = new StringType(4, "latin1")
        .get(this.buffer, 8)
        .replace("\0", " ")
        .trim();
      switch (brandMajor) {
        case "avif":
        case "avis":
          return {
            ext: "avif",
            mime: "image/avif",
          };
        case "mif1":
          return {
            ext: "heic",
            mime: "image/heif",
          };
        case "msf1":
          return {
            ext: "heic",
            mime: "image/heif-sequence",
          };
        case "heic":
        case "heix":
          return {
            ext: "heic",
            mime: "image/heic",
          };
        case "hevc":
        case "hevx":
          return {
            ext: "heic",
            mime: "image/heic-sequence",
          };
        case "qt":
          return {
            ext: "mov",
            mime: "video/quicktime",
          };
        case "M4V":
        case "M4VH":
        case "M4VP":
          return {
            ext: "m4v",
            mime: "video/x-m4v",
          };
        case "M4P":
          return {
            ext: "m4p",
            mime: "video/mp4",
          };
        case "M4B":
          return {
            ext: "m4b",
            mime: "audio/mp4",
          };
        case "M4A":
          return {
            ext: "m4a",
            mime: "audio/x-m4a",
          };
        case "F4V":
          return {
            ext: "f4v",
            mime: "video/mp4",
          };
        case "F4P":
          return {
            ext: "f4p",
            mime: "video/mp4",
          };
        case "F4A":
          return {
            ext: "f4a",
            mime: "audio/mp4",
          };
        case "F4B":
          return {
            ext: "f4b",
            mime: "audio/mp4",
          };
        case "crx":
          return {
            ext: "cr3",
            mime: "image/x-canon-cr3",
          };
        default:
          if (brandMajor.startsWith("3g")) {
            if (brandMajor.startsWith("3g2"))
              return {
                ext: "3g2",
                mime: "video/3gpp2",
              };
            return {
              ext: "3gp",
              mime: "video/3gpp",
            };
          }
          return {
            ext: "mp4",
            mime: "video/mp4",
          };
      }
    }
    if (this.check([82, 73, 70, 70])) {
      if (this.checkString("WEBP", { offset: 8 }))
        return {
          ext: "webp",
          mime: "image/webp",
        };
      if (this.check([65, 86, 73], { offset: 8 }))
        return {
          ext: "avi",
          mime: "video/vnd.avi",
        };
      if (this.check([87, 65, 86, 69], { offset: 8 }))
        return {
          ext: "wav",
          mime: "audio/wav",
        };
      if (this.check([81, 76, 67, 77], { offset: 8 }))
        return {
          ext: "qcp",
          mime: "audio/qcelp",
        };
    }
    if (this.check([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216]))
      return {
        ext: "rw2",
        mime: "image/x-panasonic-rw2",
      };
    if (this.check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
      async function readHeader() {
        const guid4 = new Uint8Array(16);
        await tokenizer.readBuffer(guid4);
        return {
          id: guid4,
          size: Number(await tokenizer.readToken(UINT64_LE)),
        };
      }
      await tokenizer.ignore(30);
      while (tokenizer.position + 24 < tokenizer.fileInfo.size) {
        const header = await readHeader();
        let payload = header.size - 24;
        if (
          _check2(
            header.id,
            [
              145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83,
              101,
            ],
          )
        ) {
          const typeId = new Uint8Array(16);
          payload -= await tokenizer.readBuffer(typeId);
          if (
            _check2(
              typeId,
              [
                64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92,
                68, 43,
              ],
            )
          )
            return {
              ext: "asf",
              mime: "audio/x-ms-asf",
            };
          if (
            _check2(
              typeId,
              [
                192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92,
                68, 43,
              ],
            )
          )
            return {
              ext: "asf",
              mime: "video/x-ms-asf",
            };
          break;
        }
        await tokenizer.ignore(payload);
      }
      return {
        ext: "asf",
        mime: "application/vnd.ms-asf",
      };
    }
    if (this.check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10]))
      return {
        ext: "ktx",
        mime: "image/ktx",
      };
    if (
      (this.check([126, 16, 4]) || this.check([126, 24, 4])) &&
      this.check([48, 77, 73, 69], { offset: 4 })
    )
      return {
        ext: "mie",
        mime: "application/x-mie",
      };
    if (this.check([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 }))
      return {
        ext: "shp",
        mime: "application/x-esri-shape",
      };
    if (this.check([255, 79, 255, 81]))
      return {
        ext: "j2c",
        mime: "image/j2c",
      };
    if (this.check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
      await tokenizer.ignore(20);
      const type = await tokenizer.readToken(new StringType(4, "ascii"));
      switch (type) {
        case "jp2 ":
          return {
            ext: "jp2",
            mime: "image/jp2",
          };
        case "jpx ":
          return {
            ext: "jpx",
            mime: "image/jpx",
          };
        case "jpm ":
          return {
            ext: "jpm",
            mime: "image/jpm",
          };
        case "mjp2":
          return {
            ext: "mj2",
            mime: "image/mj2",
          };
        default:
          return;
      }
    }
    if (
      this.check([255, 10]) ||
      this.check([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10])
    )
      return {
        ext: "jxl",
        mime: "image/jxl",
      };
    if (this.check([254, 255])) {
      if (this.check([0, 60, 0, 63, 0, 120, 0, 109, 0, 108], { offset: 2 }))
        return {
          ext: "xml",
          mime: "application/xml",
        };
      return void 0;
    }
    if (this.check([208, 207, 17, 224, 161, 177, 26, 225]))
      return {
        ext: "cfb",
        mime: "application/x-cfb",
      };
    await tokenizer.peekBuffer(this.buffer, {
      length: Math.min(256, tokenizer.fileInfo.size),
      mayBeLess: true,
    });
    if (this.check([97, 99, 115, 112], { offset: 36 }))
      return {
        ext: "icc",
        mime: "application/vnd.iccprofile",
      };
    if (
      this.checkString("**ACE", { offset: 7 }) &&
      this.checkString("**", { offset: 12 })
    )
      return {
        ext: "ace",
        mime: "application/x-ace-compressed",
      };
    if (this.checkString("BEGIN:")) {
      if (this.checkString("VCARD", { offset: 6 }))
        return {
          ext: "vcf",
          mime: "text/vcard",
        };
      if (this.checkString("VCALENDAR", { offset: 6 }))
        return {
          ext: "ics",
          mime: "text/calendar",
        };
    }
    if (this.checkString("FUJIFILMCCD-RAW"))
      return {
        ext: "raf",
        mime: "image/x-fujifilm-raf",
      };
    if (this.checkString("Extended Module:"))
      return {
        ext: "xm",
        mime: "audio/x-xm",
      };
    if (this.checkString("Creative Voice File"))
      return {
        ext: "voc",
        mime: "audio/x-voc",
      };
    if (this.check([4, 0, 0, 0]) && this.buffer.length >= 16) {
      const jsonSize = new DataView(this.buffer.buffer).getUint32(12, true);
      if (jsonSize > 12 && this.buffer.length >= jsonSize + 16)
        try {
          const header = new TextDecoder().decode(
            this.buffer.subarray(16, jsonSize + 16),
          );
          const json2 = JSON.parse(header);
          if (json2.files)
            return {
              ext: "asar",
              mime: "application/x-asar",
            };
        } catch {}
    }
    if (this.check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2]))
      return {
        ext: "mxf",
        mime: "application/mxf",
      };
    if (this.checkString("SCRM", { offset: 44 }))
      return {
        ext: "s3m",
        mime: "audio/x-s3m",
      };
    if (this.check([71]) && this.check([71], { offset: 188 }))
      return {
        ext: "mts",
        mime: "video/mp2t",
      };
    if (this.check([71], { offset: 4 }) && this.check([71], { offset: 196 }))
      return {
        ext: "mts",
        mime: "video/mp2t",
      };
    if (this.check([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 }))
      return {
        ext: "mobi",
        mime: "application/x-mobipocket-ebook",
      };
    if (this.check([68, 73, 67, 77], { offset: 128 }))
      return {
        ext: "dcm",
        mime: "application/dicom",
      };
    if (
      this.check([
        76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70,
      ])
    )
      return {
        ext: "lnk",
        mime: "application/x.ms.shortcut",
      };
    if (
      this.check([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0])
    )
      return {
        ext: "alias",
        mime: "application/x.apple.alias",
      };
    if (this.checkString("Kaydara FBX Binary  \0"))
      return {
        ext: "fbx",
        mime: "application/x.autodesk.fbx",
      };
    if (
      this.check([76, 80], { offset: 34 }) &&
      (this.check([0, 0, 1], { offset: 8 }) ||
        this.check([1, 0, 2], { offset: 8 }) ||
        this.check([2, 0, 2], { offset: 8 }))
    )
      return {
        ext: "eot",
        mime: "application/vnd.ms-fontobject",
      };
    if (
      this.check([
        6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29,
      ])
    )
      return {
        ext: "indd",
        mime: "application/x-indesign",
      };
    await tokenizer.peekBuffer(this.buffer, {
      length: Math.min(512, tokenizer.fileInfo.size),
      mayBeLess: true,
    });
    if (
      (this.checkString("ustar", { offset: 257 }) &&
        (this.checkString("\0", { offset: 262 }) ||
          this.checkString(" ", { offset: 262 }))) ||
      (this.check([0, 0, 0, 0, 0, 0], { offset: 257 }) &&
        tarHeaderChecksumMatches(this.buffer))
    )
      return {
        ext: "tar",
        mime: "application/x-tar",
      };
    if (this.check([255, 254])) {
      if (this.check([60, 0, 63, 0, 120, 0, 109, 0, 108, 0], { offset: 2 }))
        return {
          ext: "xml",
          mime: "application/xml",
        };
      if (
        this.check(
          [
            255, 14, 83, 0, 107, 0, 101, 0, 116, 0, 99, 0, 104, 0, 85, 0, 112,
            0, 32, 0, 77, 0, 111, 0, 100, 0, 101, 0, 108, 0,
          ],
          { offset: 2 },
        )
      )
        return {
          ext: "skp",
          mime: "application/vnd.sketchup.skp",
        };
      return void 0;
    }
    if (this.checkString("-----BEGIN PGP MESSAGE-----"))
      return {
        ext: "pgp",
        mime: "application/pgp-encrypted",
      };
  };
  detectImprecise = async (tokenizer) => {
    this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);
    await tokenizer.peekBuffer(this.buffer, {
      length: Math.min(8, tokenizer.fileInfo.size),
      mayBeLess: true,
    });
    if (this.check([0, 0, 1, 186]) || this.check([0, 0, 1, 179]))
      return {
        ext: "mpg",
        mime: "video/mpeg",
      };
    if (this.check([0, 1, 0, 0, 0]))
      return {
        ext: "ttf",
        mime: "font/ttf",
      };
    if (this.check([0, 0, 1, 0]))
      return {
        ext: "ico",
        mime: "image/x-icon",
      };
    if (this.check([0, 0, 2, 0]))
      return {
        ext: "cur",
        mime: "image/x-icon",
      };
    await tokenizer.peekBuffer(this.buffer, {
      length: Math.min(
        2 + this.options.mpegOffsetTolerance,
        tokenizer.fileInfo.size,
      ),
      mayBeLess: true,
    });
    if (this.buffer.length >= 2 + this.options.mpegOffsetTolerance)
      for (let depth = 0; depth <= this.options.mpegOffsetTolerance; ++depth) {
        const type = this.scanMpeg(depth);
        if (type) return type;
      }
  };
  async readTiffTag(bigEndian) {
    const tagId = await this.tokenizer.readToken(
      bigEndian ? UINT16_BE : UINT16_LE,
    );
    this.tokenizer.ignore(10);
    switch (tagId) {
      case 50341:
        return {
          ext: "arw",
          mime: "image/x-sony-arw",
        };
      case 50706:
        return {
          ext: "dng",
          mime: "image/x-adobe-dng",
        };
      default:
    }
  }
  async readTiffIFD(bigEndian) {
    const numberOfTags = await this.tokenizer.readToken(
      bigEndian ? UINT16_BE : UINT16_LE,
    );
    for (let n = 0; n < numberOfTags; ++n) {
      const fileType = await this.readTiffTag(bigEndian);
      if (fileType) return fileType;
    }
  }
  async readTiffHeader(bigEndian) {
    const version3 = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 2);
    const ifdOffset = (bigEndian ? UINT32_BE : UINT32_LE).get(this.buffer, 4);
    if (version3 === 42) {
      if (ifdOffset >= 6) {
        if (this.checkString("CR", { offset: 8 }))
          return {
            ext: "cr2",
            mime: "image/x-canon-cr2",
          };
        if (ifdOffset >= 8) {
          const someId1 = (bigEndian ? UINT16_BE : UINT16_LE).get(
            this.buffer,
            8,
          );
          const someId2 = (bigEndian ? UINT16_BE : UINT16_LE).get(
            this.buffer,
            10,
          );
          if (
            (someId1 === 28 && someId2 === 254) ||
            (someId1 === 31 && someId2 === 11)
          )
            return {
              ext: "nef",
              mime: "image/x-nikon-nef",
            };
        }
      }
      await this.tokenizer.ignore(ifdOffset);
      const fileType = await this.readTiffIFD(bigEndian);
      return (
        fileType ?? {
          ext: "tif",
          mime: "image/tiff",
        }
      );
    }
    if (version3 === 43)
      return {
        ext: "tif",
        mime: "image/tiff",
      };
  }
  /**
  Scan check MPEG 1 or 2 Layer 3 header, or 'layer 0' for ADTS (MPEG sync-word 0xFFE).
  
  @param offset - Offset to scan for sync-preamble.
  @returns {{ext: string, mime: string}}
  */
  scanMpeg(offset) {
    if (
      this.check([255, 224], {
        offset,
        mask: [255, 224],
      })
    ) {
      if (
        this.check([16], {
          offset: offset + 1,
          mask: [22],
        })
      ) {
        if (
          this.check([8], {
            offset: offset + 1,
            mask: [8],
          })
        )
          return {
            ext: "aac",
            mime: "audio/aac",
          };
        return {
          ext: "aac",
          mime: "audio/aac",
        };
      }
      if (
        this.check([2], {
          offset: offset + 1,
          mask: [6],
        })
      )
        return {
          ext: "mp3",
          mime: "audio/mpeg",
        };
      if (
        this.check([4], {
          offset: offset + 1,
          mask: [6],
        })
      )
        return {
          ext: "mp2",
          mime: "audio/mpeg",
        };
      if (
        this.check([6], {
          offset: offset + 1,
          mask: [6],
        })
      )
        return {
          ext: "mp1",
          mime: "audio/mpeg",
        };
    }
  }
};
var supportedExtensions = new Set(extensions);
var supportedMimeTypes = new Set(mimeTypes);
var globalOctokit = new Octokit();
var toolWithOctokit = (fn) => {
  return {
    ...fn({ octokit: globalOctokit }),
    with: (ctx) => {
      let octokit = ctx.octokit ?? globalOctokit;
      if (ctx.accessToken)
        if (typeof ctx.accessToken === "string")
          octokit = new Octokit({ auth: ctx.accessToken });
        else
          octokit = ctx.accessToken.then(
            (token) => new Octokit({ auth: token }),
          );
      return fn({ octokit });
    },
  };
};
var githubReactionSchema = external_exports.enum([
  "+1",
  "-1",
  "laugh",
  "confused",
  "heart",
  "hooray",
  "rocket",
  "eyes",
]);
var tools = {
  list_user_installations: toolWithOctokit(({ octokit }) =>
    tool({
      description: `List GitHub installations you have access to.`,
      inputSchema: external_exports.object({
        page: external_exports.number().optional(),
        per_page: external_exports.number().optional(),
      }),
      execute: async (args, { abortSignal }) => {
        const response = await (
          await octokit
        ).request("GET /user/installations", {
          page: args.page,
          per_page: args.per_page,
          request: { signal: abortSignal },
        });
        return response.data;
      },
    }),
  ),
  list_app_installations: toolWithOctokit(({ octokit }) =>
    tool({
      description: `List GitHub installations you have access to.`,
      inputSchema: external_exports.object({
        page: external_exports.number().optional(),
        per_page: external_exports.number().optional(),
      }),
      execute: async (args, { abortSignal }) => {
        const response = await (
          await octokit
        ).request("GET /app/installations", {
          page: args.page,
          per_page: args.per_page,
        });
        return response.data;
      },
    }),
  ),
  get_organization: toolWithOctokit(({ octokit }) =>
    tool({
      description: "Get information about a GitHub organization.",
      inputSchema: external_exports.object({
        organization: external_exports.string(),
      }),
      execute: async ({ organization }, { abortSignal }) => {
        const response = await (
          await octokit
        ).request("GET /orgs/{org}", {
          org: organization,
          request: { signal: abortSignal },
        });
        return {
          name: response.data.name ?? "",
          description: response.data.description ?? "",
          avatar_url: response.data.avatar_url ?? "",
          url: response.data.url ?? "",
          html_url: response.data.html_url ?? "",
        };
      },
    }),
  ),
  search_repositories: toolWithOctokit(({ octokit }) =>
    tool({
      description:
        "Search for GitHub repositories. Use the GitHub Search Syntax (e.g. 'org:<org>' or 'repo:<org/repo>' or '<plain text>').",
      inputSchema: external_exports.object({
        query: external_exports.string(),
        page: external_exports.number(),
        per_page: external_exports.number(),
      }),
      execute: async (args, opts) => {
        const response = await (
          await octokit
        ).request("GET /search/repositories", {
          q: args.query,
          page: args.page,
          per_page: args.per_page,
        });
        return {
          incomplete_results: response.data.incomplete_results,
          total_count: response.data.total_count,
          items: response.data.items.map((repo) => ({
            name: repo.name,
            stargazers_count: repo.stargazers_count ?? 0,
            watchers_count: repo.watchers_count ?? 0,
            language: repo.language ?? "",
            description: repo.description?.slice(0, 255) ?? "",
            fork: repo.fork,
            homepage: repo.homepage ?? "",
            open_issues_count: repo.open_issues_count ?? 0,
            topics: repo.topics ?? [],
            default_branch: repo.default_branch ?? "",
            visibility: repo.visibility ?? "public",
            license: { name: repo.license?.name ?? "" },
          })),
        };
      },
    }),
  ),
  get_repository: toolWithOctokit(({ octokit }) =>
    tool({
      description: `Get a repository.`,
      inputSchema: external_exports.object({
        owner: external_exports.string(),
        repo: external_exports.string(),
      }),
      execute: async (args, opts) => {
        const response = await (
          await octokit
        ).request("GET /repos/{owner}/{repo}", {
          owner: args.owner,
          repo: args.repo,
          request: { signal: opts.abortSignal },
        });
        return {
          name: response.data.name,
          stargazers_count: response.data.stargazers_count,
          watchers_count: response.data.watchers_count,
          language: response.data.language ?? "",
          description: response.data.description?.slice(0, 255) ?? "",
          fork: response.data.fork,
          homepage: response.data.homepage ?? "",
          open_issues_count: response.data.open_issues_count,
          topics: response.data.topics ?? [],
          default_branch: response.data.default_branch,
          visibility: response.data.visibility ?? "public",
          license: { name: response.data.license?.name ?? "" },
        };
      },
    }),
  ),
  search_issues: toolWithOctokit(({ octokit }) =>
    tool({
      description:
        "Search for issues or pull requests. Use the GitHub Search Syntax (e.g. 'org:<org>', 'repo:<org/repo>', '<plain text>', 'is:issue', 'is:pr').",
      inputSchema: external_exports.object({
        query: external_exports.string(),
        page: external_exports.number(),
        per_page: external_exports.number(),
        sort: external_exports.enum([
          "comments",
          "reactions",
          "reactions-+1",
          "reactions--1",
          "reactions-smile",
          "reactions-thinking_face",
          "reactions-heart",
          "reactions-tada",
          "interactions",
          "created",
          "updated",
        ]),
        include_body: external_exports.boolean(),
      }),
      execute: async (args, opts) => {
        const response = await (
          await octokit
        ).request("GET /search/issues", {
          q: args.query,
          page: args.page,
          sort: args.sort,
          per_page: args.per_page,
          advanced_search: "true",
          request: { signal: opts.abortSignal },
        });
        return {
          total_count: response.data.total_count,
          incomplete_results: response.data.incomplete_results,
          items: response.data.items.map((issue3) => ({
            number: issue3.number,
            comments: issue3.comments,
            url: issue3.html_url,
            title: issue3.title,
            state: issue3.state,
            locked: issue3.locked,
            citation_id: crypto.randomUUID(),
            user: { login: issue3.user?.login ?? "" },
            assignees:
              issue3.assignees?.map((a2) => ({
                name: a2.login,
                avatar_url: a2.avatar_url ?? "",
                url: a2.url ?? "",
                html_url: a2.html_url ?? "",
              })) ?? [],
            labels:
              issue3.labels.map((l2) => ({
                name: l2.name,
                description: l2.description ?? "",
              })) ?? [],
            body: args.include_body ? issue3.body : void 0,
            created_at: issue3.created_at,
            updated_at: issue3.updated_at,
            closed_at: issue3.closed_at ?? void 0,
            pull_request: issue3.pull_request
              ? { merged_at: issue3.pull_request.merged_at ?? void 0 }
              : void 0,
          })),
        };
      },
    }),
  ),
  get_pull_request: toolWithOctokit(({ octokit }) =>
    tool({
      description: "Get a pull request.",
      inputSchema: external_exports.object({
        owner: external_exports.string(),
        repo: external_exports.string(),
        pull_number: external_exports.number(),
      }),
      execute: async (args, opts) => {
        const response = await (
          await octokit
        ).request("GET /repos/{owner}/{repo}/pulls/{pull_number}", {
          owner: args.owner,
          repo: args.repo,
          pull_number: args.pull_number,
          request: { signal: opts.abortSignal },
        });
        return {
          number: response.data.number,
          state: response.data.state,
          title: response.data.title ?? "",
          body: response.data.body ?? "",
          created_at: response.data.created_at,
          updated_at: response.data.updated_at,
          closed_at: response.data.closed_at ?? void 0,
          merged_at: response.data.merged_at ?? void 0,
          merge_commit_sha: response.data.merge_commit_sha ?? void 0,
          user: { login: response.data.user?.login ?? "" },
          head: {
            ref: response.data.head.ref,
            sha: response.data.head.sha,
          },
          base: {
            ref: response.data.base.ref,
            sha: response.data.base.sha,
          },
          comments: response.data.comments,
          review_comments: response.data.review_comments,
          additions: response.data.additions,
          deletions: response.data.deletions,
          changed_files: response.data.changed_files,
          merged_by: response.data.merged_by
            ? {
                login: response.data.merged_by.login,
                avatar_url: response.data.merged_by.avatar_url ?? "",
                html_url: response.data.merged_by.html_url ?? "",
              }
            : void 0,
        };
      },
    }),
  ),
  get_issue: toolWithOctokit(({ octokit }) =>
    tool({
      description: "Get an issue.",
      inputSchema: external_exports.object({
        owner: external_exports.string(),
        repo: external_exports.string(),
        issue_number: external_exports.number(),
      }),
      execute: async (args, opts) => {
        const response = await (
          await octokit
        ).request("GET /repos/{owner}/{repo}/issues/{issue_number}", {
          owner: args.owner,
          repo: args.repo,
          issue_number: args.issue_number,
          mediaType: { format: "html" },
          request: { signal: opts.abortSignal },
        });
        return {
          number: response.data.number,
          url: response.data.html_url,
          state: response.data.state,
          title: response.data.title ?? "",
          body_html: response.data.body_html ?? "",
          citation_id: crypto.randomUUID(),
          assignees:
            response.data.assignees?.map((a2) => ({
              name: a2.login,
              avatar_url: a2.avatar_url ?? "",
              url: a2.url ?? "",
              html_url: a2.html_url ?? "",
            })) ?? [],
          labels:
            response.data.labels.map((l2) => {
              if (typeof l2 === "string")
                return {
                  name: l2,
                  description: "",
                };
              return {
                name: l2.name,
                description: l2.description ?? "",
              };
            }) ?? [],
          locked: response.data.locked,
          user: { login: response.data.user?.login ?? "" },
          comments: response.data.comments,
          created_at: response.data.created_at,
          updated_at: response.data.updated_at,
          closed_at: response.data.closed_at ?? void 0,
          pull_request: response.data.pull_request
            ? { merged_at: response.data.pull_request.merged_at ?? void 0 }
            : void 0,
        };
      },
    }),
  ),
  list_issue_comments: toolWithOctokit(({ octokit }) =>
    tool({
      description: "List comments on an issue or pull request.",
      inputSchema: external_exports.object({
        owner: external_exports.string(),
        repo: external_exports.string(),
        issue_number: external_exports.number(),
      }),
      execute: async (args, opts) => {
        const response = await (
          await octokit
        ).request("GET /repos/{owner}/{repo}/issues/{issue_number}/comments", {
          owner: args.owner,
          repo: args.repo,
          issue_number: args.issue_number,
          request: { signal: opts.abortSignal },
        });
        return {
          comments: response.data.map((comment) => ({
            id: comment.id,
            body: comment.body ?? "",
            created_at: comment.created_at,
            updated_at: comment.updated_at,
            author_association: comment.author_association,
            user: { login: comment.user?.login ?? "" },
          })),
        };
      },
    }),
  ),
  list_repository_contributors: toolWithOctokit(({ octokit }) =>
    tool({
      description: "List contributors to a repository.",
      inputSchema: external_exports.object({
        owner: external_exports.string(),
        repo: external_exports.string(),
      }),
      execute: async (args, opts) => {
        const response = await (
          await octokit
        ).request("GET /repos/{owner}/{repo}/contributors", {
          owner: args.owner,
          repo: args.repo,
          request: { signal: opts.abortSignal },
        });
        return {
          contributors: response.data.map((contributor) => ({
            login: contributor.login ?? "",
            contributions: contributor.contributions,
            type: contributor.type,
          })),
        };
      },
    }),
  ),
  list_pull_request_files: toolWithOctokit(({ octokit }) =>
    tool({
      inputSchema: external_exports.object({
        owner: external_exports.string(),
        repo: external_exports.string(),
        pull_number: external_exports.number(),
        page: external_exports.number(),
        per_page: external_exports.number(),
      }),
      description:
        "List files changed in a pull request. Use this with 'github_repository_read_file' to read the contents of the files.",
      execute: async (args, opts) => {
        const response = await (
          await octokit
        ).request("GET /repos/{owner}/{repo}/pulls/{pull_number}/files", {
          owner: args.owner,
          repo: args.repo,
          pull_number: args.pull_number,
          page: args.page,
          per_page: args.per_page,
          request: { signal: opts.abortSignal },
        });
        return {
          files: response.data.map((file2) => {
            const patches = parsePatch(file2.patch);
            if (patches.length > 1)
              throw new Error("Multiple patches found for a single file!");
            const patch = patches[0];
            return {
              filename: file2.filename,
              status: file2.status,
              structured_patch: patch.hunks.map((hunk) => {
                return {
                  old_start: hunk.oldStart,
                  old_end: hunk.oldLines,
                  new_start: hunk.newStart,
                  new_end: hunk.newLines,
                };
              }),
              sha: file2.sha,
              additions: file2.additions,
              deletions: file2.deletions,
              changes: file2.changes,
              contents_url: file2.contents_url,
              blob_url: file2.blob_url,
            };
          }),
        };
      },
    }),
  ),
  repository_read_file: toolWithOctokit(({ octokit }) =>
    tool({
      description:
        "Read a file from a repository. This does not use GitHub API calls. Absolute paths must be used. The root is at /. Read 250 lines at a time.",
      inputSchema: external_exports.object({
        owner: external_exports.string(),
        repo: external_exports.string(),
        ref: external_exports.string(),
        file_path: external_exports.string(),
        line_offset: external_exports.number(),
        line_limit: external_exports.number(),
      }),
      execute: async (args, opts) => {
        const response = await (
          await octokit
        ).request("GET /repos/{owner}/{repo}/contents/{path}", {
          owner: args.owner,
          repo: args.repo,
          path: args.file_path,
          ref: args.ref,
          mediaType: { format: "raw" },
          request: { signal: opts.abortSignal },
        });
        const content = response.data;
        const buffer = Buffer.from(content, "utf8");
        const fileType = await fileTypeFromBuffer(buffer);
        const isText = !fileType?.mime || fileType.mime === "text/plain";
        if (!isText)
          return {
            content: Buffer.from(buffer).toString("base64"),
            mime_type: fileType?.mime,
            total_lines: 0,
            lines_read: 0,
            start_line: 0,
          };
        const lines = content.split("\n");
        return {
          citation_id: crypto.randomUUID(),
          total_lines: lines.length,
          lines_read: lines.length,
          start_line: args.line_offset,
          content: lines
            .slice(args.line_offset, args.line_offset + args.line_limit)
            .join("\n"),
          mime_type: fileType?.mime,
        };
      },
      toModelOutput(result) {
        if (result.mime_type?.startsWith("image/"))
          return {
            type: "content",
            value: [
              {
                type: "media",
                data: result.content,
                mediaType: result.mime_type,
              },
            ],
          };
        return {
          type: "json",
          value: result,
        };
      },
    }),
  ),
  repository_grep_file: toolWithOctokit(({ octokit }) =>
    tool({
      description: "Grep a file in a repository.",
      inputSchema: external_exports.object({
        owner: external_exports.string(),
        repo: external_exports.string(),
        ref: external_exports.string(),
        file_path: external_exports.string(),
        pattern: external_exports.string(),
        before_lines: external_exports.number(),
        after_lines: external_exports.number(),
      }),
      execute: async (args, opts) => {
        const response = await (
          await octokit
        ).request("GET /repos/{owner}/{repo}/contents/{path}", {
          owner: args.owner,
          repo: args.repo,
          path: args.file_path,
          ref: args.ref,
          mediaType: { format: "raw" },
          request: { signal: opts.abortSignal },
        });
        if (Array.isArray(response.data))
          throw new Error("This path is a directory, not a file.");
        const content = response.data;
        let regex;
        try {
          regex = new RegExp(args.pattern);
        } catch (err$1) {
          throw new Error(`Invalid regex pattern: ${args.pattern}`);
        }
        const matches = [];
        const lines = content.split("\n");
        for (let i$1 = 0; i$1 < lines.length; i$1++) {
          const line = lines[i$1];
          const match = line.match(regex);
          if (match) {
            const startLine = Math.max(0, i$1 - args.before_lines);
            const endLine = Math.min(lines.length - 1, i$1 + args.after_lines);
            const contextLines = lines.slice(startLine, endLine + 1);
            matches.push({
              line_number: i$1,
              lines: contextLines,
            });
          }
        }
        if (matches.length > 256)
          throw new Error("Too many matches. Please refine your search.");
        return {
          citation_id: crypto.randomUUID(),
          matches,
          total_matches: matches.length,
        };
      },
    }),
  ),
  repository_list_directory: toolWithOctokit(({ octokit }) =>
    tool({
      inputSchema: external_exports.object({
        owner: external_exports.string(),
        repo: external_exports.string(),
        ref: external_exports.string(),
        path: external_exports.string(),
      }),
      description:
        "List a directory in a repository. This does not use GitHub API calls. Absolute paths must be used. The root is at /.",
      execute: async (args, opts) => {
        const response = await (
          await octokit
        ).request("GET /repos/{owner}/{repo}/contents/{path}", {
          owner: args.owner,
          repo: args.repo,
          path: args.path,
          ref: args.ref,
          mediaType: { format: "raw" },
          request: { signal: opts.abortSignal },
        });
        if (!Array.isArray(response.data))
          throw new Error("This path is a file, not a directory.");
        return {
          files: response.data.map((file2) => {
            return {
              type: file2.type,
              path: file2.path,
              size: file2.type === "file" ? file2.size : void 0,
            };
          }),
        };
      },
    }),
  ),
  search_code: toolWithOctokit(({ octokit }) =>
    tool({
      inputSchema: external_exports.object({
        query: external_exports.string(),
        page: external_exports.number(),
        per_page: external_exports.number(),
      }),
      description:
        "Search for code in a repository. Use the GitHub Search Syntax (e.g. 'org:<org>', 'repo:<org/repo>', '<plain text>', 'is:issue', 'is:pr'). This endpoint is highly rate-limited, so use it sparingly.",
      execute: async (args, opts) => {
        const response = await (
          await octokit
        ).request("GET /search/code", {
          q: args.query,
          page: args.page,
          per_page: args.per_page,
          mediaType: { format: "text-match" },
          request: { signal: opts.abortSignal },
        });
        return {
          total_count: response.data.total_count,
          incomplete_results: response.data.incomplete_results,
          items: response.data.items.map((item) => ({
            path: "/" + item.path,
            repository: {
              owner: item.repository.owner.login,
              name: item.repository.name,
            },
            text_matches:
              item.text_matches?.map((match) => {
                return {
                  fragment: match.fragment,
                  citation_id: crypto.randomUUID(),
                  matches:
                    match.matches?.map((m$1) => {
                      return {
                        text: m$1.text,
                        indices: m$1.indices,
                      };
                    }) || [],
                };
              }) || [],
          })),
        };
      },
    }),
  ),
  list_releases: toolWithOctokit(({ octokit }) =>
    tool({
      inputSchema: external_exports.object({
        owner: external_exports.string(),
        repo: external_exports.string(),
        page: external_exports.number(),
        per_page: external_exports.number(),
        include_body_and_assets: external_exports.boolean(),
      }),
      description: "List releases for a repository.",
      execute: async (args, opts) => {
        const response = await (
          await octokit
        ).request("GET /repos/{owner}/{repo}/releases", {
          owner: args.owner,
          repo: args.repo,
          page: args.page,
          per_page: args.per_page,
          request: { signal: opts.abortSignal },
        });
        return {
          releases: response.data.map((release) => ({
            id: release.id,
            name: release.name ?? void 0,
            tag_name: release.tag_name,
            body: args.include_body_and_assets
              ? (release.body ?? void 0)
              : void 0,
            draft: release.draft,
            prerelease: release.prerelease,
            created_at: release.created_at,
            published_at: release.published_at ?? void 0,
            target_commitish: release.target_commitish,
            citation_id: crypto.randomUUID(),
            assets: args.include_body_and_assets
              ? release.assets.map((asset) => ({
                  id: asset.id,
                  name: asset.name,
                  browser_download_url: asset.browser_download_url,
                  download_count: asset.download_count,
                  content_type: asset.content_type,
                  size: asset.size,
                }))
              : void 0,
          })),
        };
      },
    }),
  ),
  get_commit: toolWithOctokit(({ octokit }) =>
    tool({
      inputSchema: external_exports.object({
        owner: external_exports.string(),
        repo: external_exports.string(),
        commit_sha: external_exports.string(),
      }),
      description: "Get a commit by its SHA.",
      execute: async (args, opts) => {
        const response = await (
          await octokit
        ).request("GET /repos/{owner}/{repo}/commits/{commit_sha}", {
          owner: args.owner,
          repo: args.repo,
          commit_sha: args.commit_sha,
          request: { signal: opts.abortSignal },
        });
        return {
          message: response.data.commit.message,
          html_url: response.data.html_url,
          citation_id: crypto.randomUUID(),
          sha: response.data.sha,
          commit_author: {
            name: response.data.commit.author?.name ?? "",
            date: response.data.commit.author?.date ?? "",
            email: response.data.commit.author?.email ?? "",
          },
          parents: response.data.parents.map((p2) => ({
            sha: p2.sha,
            html_url: p2.html_url,
          })),
        };
      },
    }),
  ),
  get_pull_request_diff: toolWithOctokit(({ octokit }) =>
    tool({
      inputSchema: external_exports.object({
        owner: external_exports.string(),
        repo: external_exports.string(),
        pull_number: external_exports.number(),
        line_offset: external_exports.number(),
        line_limit: external_exports.number(),
      }),
      description: `Get the diff for a pull request.

    Usage:
    - A 250 line limit is enforced. If over 250 lines are requested, only 250 lines will be returned.
    - Use the line_offset and line_limit parameters to read a specific range of lines.`,
      execute: async (args, opts) => {
        const response = await (
          await octokit
        ).request("GET /repos/{owner}/{repo}/pulls/{pull_number}", {
          owner: args.owner,
          repo: args.repo,
          pull_number: args.pull_number,
          mediaType: { format: "diff" },
          request: { signal: opts.abortSignal },
        });
        const diff = response.data;
        const lines = diff.split("\n");
        const startLine = args.line_offset;
        const endLine = startLine + args.line_limit;
        const content = lines.slice(startLine, endLine).join("\n");
        return {
          content,
          total_lines: lines.length,
          lines_read: endLine - startLine,
          start_line: startLine,
        };
      },
    }),
  ),
  get_commit_diff: toolWithOctokit(({ octokit }) =>
    tool({
      inputSchema: external_exports.object({
        owner: external_exports.string(),
        repo: external_exports.string(),
        commit_sha: external_exports.string(),
        line_offset: external_exports.number(),
        line_limit: external_exports.number(),
      }),
      description: `Get the diff for a commit.

    Usage:
    - A 250 line limit is enforced. If over 250 lines are requested, only 250 lines will be returned.
    - Use the line_offset and line_limit parameters to read a specific range of lines.`,
      execute: async (args, opts) => {
        const response = await (
          await octokit
        ).request("GET /repos/{owner}/{repo}/commits/{commit_sha}", {
          owner: args.owner,
          repo: args.repo,
          commit_sha: args.commit_sha,
          mediaType: { format: "diff" },
          request: { signal: opts.abortSignal },
        });
        const diff = response.data;
        const lines = diff.split("\n");
        const startLine = args.line_offset;
        const endLine = startLine + args.line_limit;
        const content = lines.slice(startLine, endLine).join("\n");
        return {
          total_lines: lines.length,
          lines_read: endLine - startLine,
          start_line: startLine,
          content,
        };
      },
    }),
  ),
  list_commits: toolWithOctokit(({ octokit }) =>
    tool({
      inputSchema: external_exports.object({
        owner: external_exports.string(),
        repo: external_exports.string(),
        page: external_exports.number(),
        per_page: external_exports.number(),
        sha: external_exports
          .string()
          .describe(
            "The SHA or branch to list commits from. Leave blank to use the repository's default branch.",
          ),
        path: external_exports
          .string()
          .describe(
            "A file path to filter commits by. Leave blank to include all paths.",
          ),
        author: external_exports
          .string()
          .describe(
            "GitHub username or email to filter by. Leave blank to include all authors.",
          ),
        since: external_exports
          .string()
          .describe(
            "ISO 8601 date to include commits after this date. Leave blank to not filter by date.",
          ),
        until: external_exports
          .string()
          .describe(
            "ISO 8601 date to include commits before this date. Leave blank to not filter by date.",
          ),
      }),
      description: "List commits for a repository.",
      execute: async (args, opts) => {
        const response = await (
          await octokit
        ).request("GET /repos/{owner}/{repo}/commits", {
          owner: args.owner,
          repo: args.repo,
          per_page: args.per_page,
          page: args.page,
          sha: args.sha.length > 0 ? args.sha : void 0,
          path: args.path.length > 0 ? args.path : void 0,
          author: args.author.length > 0 ? args.author : void 0,
          since: args.since.length > 0 ? args.since : void 0,
          until: args.until.length > 0 ? args.until : void 0,
          request: { signal: opts.abortSignal },
        });
        return {
          commits: response.data.map((c2) => ({
            sha: c2.sha,
            html_url:
              c2.html_url ||
              `https://github.com/${args.owner}/${args.repo}/commit/${c2.sha}`,
            message: c2.commit?.message ?? "",
            commit_author: {
              name: c2.commit?.author?.name ?? "",
              email: c2.commit?.author?.email ?? "",
              date: c2.commit?.author?.date ?? "",
            },
            parents: (c2.parents ?? []).map((p2) => ({
              sha: p2.sha,
              html_url:
                p2.html_url ||
                `https://github.com/${args.owner}/${args.repo}/commit/${p2.sha}`,
            })),
            citation_id: crypto.randomUUID(),
          })),
        };
      },
    }),
  ),
  get_user: toolWithOctokit(({ octokit }) =>
    tool({
      inputSchema: external_exports.object({
        username: external_exports.string().optional(),
      }),
      description:
        "Get a user by their username. Leave the username blank to get the currently authenticated user.",
      execute: async (args, { abortSignal }) => {
        let response;
        if (args.username)
          response = (
            await (
              await octokit
            ).request("GET /users/{username}", {
              username: args.username,
              request: { signal: abortSignal },
            })
          ).data;
        else
          response = (
            await (
              await octokit
            ).request("GET /user", { request: { signal: abortSignal } })
          ).data;
        return {
          login: response.login,
          name: response.name ?? "",
          url: response.url,
          id: response.id,
          avatar_url: response.avatar_url,
          html_url: response.html_url,
          followers_url: response.followers_url ?? void 0,
          following_url: response.following_url ?? void 0,
          gists_url: response.gists_url ?? void 0,
        };
      },
    }),
  ),
  create_pull_request: toolWithOctokit(({ octokit }) =>
    tool({
      inputSchema: external_exports.object({
        owner: external_exports.string(),
        repo: external_exports.string(),
        base: external_exports.string(),
        head: external_exports.string(),
        title: external_exports.string(),
        body: external_exports.string().optional(),
        draft: external_exports.boolean().optional(),
      }),
      description: `Create a pull request on GitHub.`,
      execute: async (args, { abortSignal }) => {
        const response = await (
          await octokit
        ).request("POST /repos/{owner}/{repo}/pulls", {
          owner: args.owner,
          repo: args.repo,
          base: args.base,
          head: args.head,
          title: args.title,
          body: args.body ?? "",
          draft: args.draft,
          request: { signal: abortSignal },
        });
        return {
          pull_request: {
            number: response.data.number,
            comments: response.data.comments,
            title: response.data.title ?? "",
            body: response.data.body ?? "",
            state: response.data.state,
            created_at: response.data.created_at,
            updated_at: response.data.updated_at,
            user: { login: response.data.user?.login ?? "" },
            head: {
              ref: response.data.head.ref,
              sha: response.data.head.sha,
            },
            base: {
              ref: response.data.base.ref,
              sha: response.data.base.sha,
            },
            merged_at: response.data.merged_at ?? void 0,
            merge_commit_sha: response.data.merge_commit_sha ?? void 0,
            merged_by: response.data.merged_by
              ? {
                  login: response.data.merged_by.login,
                  avatar_url: response.data.merged_by.avatar_url ?? "",
                  html_url: response.data.merged_by.html_url ?? "",
                }
              : void 0,
            review_comments: response.data.review_comments,
            additions: response.data.additions,
            deletions: response.data.deletions,
            changed_files: response.data.changed_files,
          },
        };
      },
    }),
  ),
  actions_list_runs: toolWithOctokit(({ octokit }) =>
    tool({
      inputSchema: external_exports.object({
        owner: external_exports.string(),
        repo: external_exports.string(),
        head_sha: external_exports.string(),
      }),
      description: "List runs for a repository.",
      execute: async (args, opts) => {
        const response = await (
          await octokit
        ).request("GET /repos/{owner}/{repo}/actions/runs", {
          owner: args.owner,
          repo: args.repo,
          head_sha: args.head_sha,
          request: { signal: opts.abortSignal },
        });
        return {
          total_count: response.data.total_count,
          workflow_runs: response.data.workflow_runs.map((run) => ({
            id: run.id,
            name: run.name ?? "",
            status: run.status,
            conclusion: run.conclusion,
            created_at: run.created_at,
            updated_at: run.updated_at,
            path: run.path,
            display_title: run.display_title,
          })),
        };
      },
    }),
  ),
  actions_list_jobs: toolWithOctokit(({ octokit }) =>
    tool({
      inputSchema: external_exports.object({
        owner: external_exports.string(),
        repo: external_exports.string(),
        run_id: external_exports.number(),
      }),
      description: "List jobs for a run.",
      execute: async (args, opts) => {
        const response = await (
          await octokit
        ).request("GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs", {
          owner: args.owner,
          repo: args.repo,
          run_id: args.run_id,
          request: { signal: opts.abortSignal },
        });
        return {
          total_count: response.data.total_count,
          jobs: response.data.jobs.map((job) => ({
            id: job.id,
            workflow_name: job.workflow_name,
            completed_at: job.completed_at,
            created_at: job.created_at,
            name: job.name,
            labels: job.labels,
            head_branch: job.head_branch,
            run_attempt: job.run_attempt,
            runner_name: job.runner_name,
            runner_group_name: job.runner_group_name,
            conclusion: job.conclusion,
            started_at: job.started_at,
            status: job.status,
            steps:
              job.steps?.map((step) => ({
                name: step.name,
                status: step.status,
                conclusion: step.conclusion,
                started_at: step.started_at,
                completed_at: step.completed_at,
              })) || [],
          })),
        };
      },
    }),
  ),
  actions_get_job_logs: toolWithOctokit(({ octokit }) =>
    tool({
      inputSchema: external_exports.object({
        owner: external_exports.string(),
        repo: external_exports.string(),
        job_id: external_exports.number(),
        line_offset: external_exports.number(),
        line_limit: external_exports.number(),
      }),
      description: `Get the logs for a job.

Usage:
- A 250 line limit is enforced. If over 250 lines are requested, only 250 lines will be returned.
- Use the line_offset and line_limit parameters to read a specific range of lines.`,
      execute: async (args, opts) => {
        let logs;
        try {
          const response = await (
            await octokit
          ).request("GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs", {
            owner: args.owner,
            repo: args.repo,
            job_id: args.job_id,
            request: { signal: opts.abortSignal },
          });
          logs = response.data;
          if (typeof logs !== "string")
            throw new Error("Logs are not a string: " + typeof logs);
        } catch (err$1) {
          if (err$1?.response?.url) {
            const response = await fetch(err$1.response.url);
            logs = await response.text();
          } else throw err$1;
        }
        const totalLines = logs.split("\n");
        let lines = totalLines.slice(
          args.line_offset,
          args.line_offset + args.line_limit,
        );
        if (lines.length > 250) lines = lines.slice(0, 250);
        return {
          total_lines: totalLines.length,
          lines_read: lines.length,
          start_line: args.line_offset,
          content: lines.join("\n"),
        };
      },
    }),
  ),
  update_issue: toolWithOctokit(({ octokit }) =>
    tool({
      inputSchema: external_exports.object({
        owner: external_exports.string(),
        repo: external_exports.string(),
        issue_number: external_exports.number(),
        title: external_exports.string(),
        body: external_exports.string(),
        state: external_exports.enum(["open", "closed"]),
        labels: external_exports.array(external_exports.string()),
        assignees: external_exports.array(external_exports.string()),
      }),
      description: "Update an issue.",
      execute: async (args, opts) => {
        const response = await (
          await octokit
        ).request("PATCH /repos/{owner}/{repo}/issues/{issue_number}", {
          owner: args.owner,
          repo: args.repo,
          issue_number: args.issue_number,
          title: args.title,
          body: args.body,
          state: args.state,
          labels: args.labels,
          assignees: args.assignees,
          request: { signal: opts.abortSignal },
        });
        return {
          issue: {
            number: response.data.number,
            url: response.data.html_url,
            state: response.data.state,
            title: response.data.title ?? "",
            body: response.data.body ?? "",
            assignees:
              response.data.assignees?.map((assignee) => ({
                name: assignee.login,
                avatar_url: assignee.avatar_url ?? "",
                url: assignee.url ?? "",
                html_url: assignee.html_url ?? "",
              })) ?? [],
            labels:
              response.data.labels?.map((label) => ({
                name: typeof label === "string" ? label : (label.name ?? ""),
                description:
                  typeof label === "string" ? "" : (label.description ?? ""),
              })) ?? [],
            locked: response.data.locked,
            comments: response.data.comments,
            created_at: response.data.created_at,
            updated_at: response.data.updated_at,
            citation_id: crypto.randomUUID(),
            user: { login: response.data.user?.login ?? "" },
          },
        };
      },
    }),
  ),
  update_pull_request: toolWithOctokit(({ octokit }) =>
    tool({
      inputSchema: external_exports.object({
        owner: external_exports.string(),
        repo: external_exports.string(),
        pull_number: external_exports.number(),
        title: external_exports.string(),
        body: external_exports.string(),
        state: external_exports.enum(["open", "closed"]),
        base_branch: external_exports
          .string()
          .describe(
            "The name of the branch you want your changes pulled into. Typically, this is the default branch.",
          ),
      }),
      description: "Update a pull request.",
      execute: async (args, opts) => {
        const response = await (
          await octokit
        ).request("PATCH /repos/{owner}/{repo}/pulls/{pull_number}", {
          owner: args.owner,
          repo: args.repo,
          pull_number: args.pull_number,
          title: args.title,
          body: args.body,
          state: args.state,
          base: args.base_branch,
          request: { signal: opts.abortSignal },
        });
        return {
          pull_request: {
            number: response.data.number,
            comments: response.data.comments,
            title: response.data.title ?? "",
            body: response.data.body ?? "",
            state: response.data.state,
            created_at: response.data.created_at,
            updated_at: response.data.updated_at,
            user: { login: response.data.user?.login ?? "" },
            head: {
              ref: response.data.head.ref,
              sha: response.data.head.sha,
            },
            base: {
              ref: response.data.base.ref,
              sha: response.data.base.sha,
            },
            additions: response.data.additions,
            deletions: response.data.deletions,
            changed_files: response.data.changed_files,
            review_comments: response.data.review_comments,
            closed_at: response.data.closed_at ?? void 0,
            merged_at: response.data.merged_at ?? void 0,
            merge_commit_sha: response.data.merge_commit_sha ?? void 0,
            merged_by: response.data.merged_by
              ? {
                  login: response.data.merged_by.login,
                  avatar_url: response.data.merged_by.avatar_url ?? "",
                  html_url: response.data.merged_by.html_url ?? "",
                }
              : void 0,
          },
        };
      },
    }),
  ),
  create_issue: toolWithOctokit(({ octokit }) =>
    tool({
      inputSchema: external_exports.object({
        owner: external_exports.string(),
        repo: external_exports.string(),
        title: external_exports.string(),
        body: external_exports.string(),
        labels: external_exports
          .array(external_exports.string())
          .describe(
            "Only use labels if the user explicitly requested it, or you're confident a label exists.",
          ),
        assignees: external_exports
          .array(external_exports.string())
          .describe(
            "Only set assignees if you're confident the user exists and should be assigned to the issue.",
          ),
      }),
      description: `Create an issue. Do not use this tool unless explicitly instructed to do so.
        
    Avoid mentioning users with @ unless you are *certain* they are the user you intend to mention.
    
    All links must be publically accessible URLs.`,
      execute: async (args, opts) => {
        const response = await (
          await octokit
        ).request("POST /repos/{owner}/{repo}/issues", {
          owner: args.owner,
          repo: args.repo,
          title: args.title,
          body: args.body,
          labels: args.labels,
          assignees: args.assignees,
          request: { signal: opts.abortSignal },
        });
        return {
          issue: {
            number: response.data.number,
            url: response.data.html_url,
            state: response.data.state,
            title: response.data.title ?? "",
            body: response.data.body ?? "",
            assignees:
              response.data.assignees?.map((assignee) => ({
                name: assignee.login,
                avatar_url: assignee.avatar_url ?? "",
                url: assignee.url ?? "",
                html_url: assignee.html_url ?? "",
              })) ?? [],
            labels:
              response.data.labels?.map((label) => ({
                name: typeof label === "string" ? label : (label.name ?? ""),
                description:
                  typeof label === "string" ? "" : (label.description ?? ""),
              })) ?? [],
            locked: response.data.locked,
            comments: response.data.comments,
            created_at: response.data.created_at,
            updated_at: response.data.updated_at,
            citation_id: crypto.randomUUID(),
            user: { login: response.data.user?.login ?? "" },
            author_association: response.data.author_association,
            pull_request: response.data.pull_request
              ? { merged_at: response.data.pull_request.merged_at ?? void 0 }
              : void 0,
          },
        };
      },
    }),
  ),
  create_issue_comment: toolWithOctokit(({ octokit }) =>
    tool({
      inputSchema: external_exports.object({
        owner: external_exports.string(),
        repo: external_exports.string(),
        issue_number: external_exports.number(),
        body: external_exports.string(),
      }),
      description:
        "Create a comment on an issue. Do not use this tool unless explicitly instructed to do so.",
      execute: async (args, opts) => {
        const response = await (
          await octokit
        ).request("POST /repos/{owner}/{repo}/issues/{issue_number}/comments", {
          owner: args.owner,
          repo: args.repo,
          issue_number: args.issue_number,
          body: args.body,
          request: { signal: opts.abortSignal },
        });
        return {
          comment: {
            id: response.data.id,
            body: response.data.body ?? "",
            created_at: response.data.created_at,
            updated_at: response.data.updated_at,
            user: { login: response.data.user?.login ?? "" },
            author_association: response.data.author_association,
          },
        };
      },
    }),
  ),
  create_issue_comment_reaction: toolWithOctokit(({ octokit }) =>
    tool({
      inputSchema: external_exports.object({
        owner: external_exports.string(),
        repo: external_exports.string(),
        issue_number: external_exports.number(),
        comment_id: external_exports.number(),
        reaction: githubReactionSchema,
      }),
      description:
        "Create a reaction on an issue comment. This will not work for pull request comments. Do not use this tool unless explicitly instructed to do so.",
      execute: async (args, opts) => {
        await (
          await octokit
        ).request(
          "POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions",
          {
            owner: args.owner,
            repo: args.repo,
            comment_id: args.comment_id,
            content: args.reaction,
            request: { signal: opts.abortSignal },
          },
        );
        return { success: true };
      },
    }),
  ),
  create_pull_request_review_comment_reaction: toolWithOctokit(
    ({ octokit }) => ({
      inputSchema: external_exports.object({
        owner: external_exports.string(),
        repo: external_exports.string(),
        comment_id: external_exports.number(),
        reaction: githubReactionSchema,
      }),
      description:
        "Create a reaction on a pull request comment. Do not use this tool unless explicitly instructed to do so.",
      execute: async (args, opts) => {
        await (
          await octokit
        ).request(
          "POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions",
          {
            owner: args.owner,
            repo: args.repo,
            comment_id: args.comment_id,
            content: args.reaction,
            request: { signal: opts.abortSignal },
          },
        );
        return { success: true };
      },
    }),
  ),
  list_pull_request_review_comments: toolWithOctokit(({ octokit }) =>
    tool({
      inputSchema: external_exports.object({
        owner: external_exports.string(),
        repo: external_exports.string(),
        pull_number: external_exports.number(),
        page: external_exports.number(),
        per_page: external_exports.number(),
        review_id: external_exports.number(),
      }),
      description: "List comments on a pull request.",
      execute: async (args, opts) => {
        const response = await (
          await octokit
        ).request("GET /repos/{owner}/{repo}/pulls/{pull_number}/comments", {
          owner: args.owner,
          repo: args.repo,
          pull_number: args.pull_number,
          page: args.page,
          per_page: args.per_page,
          request: { signal: opts.abortSignal },
        });
        return {
          comments: response.data
            .filter((comment) => {
              return comment.pull_request_review_id === args.review_id;
            })
            .map((comment) => ({
              id: comment.id,
              body: comment.body ?? "",
              created_at: comment.created_at,
              updated_at: comment.updated_at,
              user: { login: comment.user?.login ?? "" },
              author_association: comment.author_association,
              path: comment.path,
              start_line: comment.start_line ?? comment.line ?? -1,
              end_line: comment.line ?? -1,
              diff_hunk: comment.diff_hunk,
            })),
        };
      },
    }),
  ),
  create_pull_request_review_comment_reply: toolWithOctokit(({ octokit }) =>
    tool({
      inputSchema: external_exports.object({
        owner: external_exports.string(),
        repo: external_exports.string(),
        pull_number: external_exports.number(),
        comment_id: external_exports.number(),
        body: external_exports.string(),
      }),
      description: "Create a reply to a pull request comment.",
      execute: async (args, opts) => {
        const response = await (
          await octokit
        ).request(
          "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies",
          {
            owner: args.owner,
            repo: args.repo,
            pull_number: args.pull_number,
            comment_id: args.comment_id,
            body: args.body,
            request: { signal: opts.abortSignal },
          },
        );
        return {
          comment: {
            id: response.data.id,
            body: response.data.body ?? "",
            created_at: response.data.created_at,
            updated_at: response.data.updated_at,
            user: { login: response.data.user?.login ?? "" },
            author_association: response.data.author_association,
            in_reply_to_id: response.data.in_reply_to_id,
            diff_hunk: response.data.diff_hunk,
            path: response.data.path,
            position: response.data.position,
            original_position: response.data.original_position,
          },
        };
      },
    }),
  ),
  get_pull_request_review: toolWithOctokit(({ octokit }) =>
    tool({
      inputSchema: external_exports.object({
        owner: external_exports.string(),
        repo: external_exports.string(),
        pull_number: external_exports.number(),
        review_id: external_exports.number(),
      }),
      description: "Get a review of a pull request.",
      execute: async (args, opts) => {
        const response = await (
          await octokit
        ).request(
          "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}",
          {
            owner: args.owner,
            repo: args.repo,
            pull_number: args.pull_number,
            review_id: args.review_id,
            request: { signal: opts.abortSignal },
          },
        );
        return {
          review: {
            author_association: response.data.author_association,
            body: response.data.body ?? "",
            commit_id: response.data.commit_id ?? "",
            id: response.data.id,
            state: response.data.state,
            submitted_at: response.data.submitted_at,
            user: { login: response.data.user?.login ?? "" },
          },
        };
      },
    }),
  ),
  list_pull_request_reviews: toolWithOctokit(({ octokit }) =>
    tool({
      inputSchema: external_exports.object({
        owner: external_exports.string(),
        repo: external_exports.string(),
        pull_number: external_exports.number(),
      }),
      description: "List reviews of a pull request.",
      execute: async (args, opts) => {
        const response = await (
          await octokit
        ).request("GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews", {
          owner: args.owner,
          repo: args.repo,
          pull_number: args.pull_number,
          request: { signal: opts.abortSignal },
        });
        return {
          reviews: response.data.map((review) => ({
            id: review.id,
            state: review.state,
            author_association: review.author_association,
            body: review.body ?? "",
            commit_id: review.commit_id ?? "",
            submitted_at: review.submitted_at,
            user: { login: review.user?.login ?? "" },
          })),
        };
      },
    }),
  ),
  list_organization_projects: toolWithOctokit(({ octokit }) =>
    tool({
      inputSchema: external_exports.object({
        org: external_exports.string().describe("The organization name"),
        first: external_exports
          .number()
          .min(1)
          .max(100)
          .describe("Number of projects to return"),
        after: external_exports
          .string()
          .describe(
            "Cursor for pagination. Leave blank to start from the beginning.",
          ),
      }),
      description: "List projects for an organization.",
      execute: async (args, opts) => {
        const result = await (
          await octokit
        ).graphql(
          `query ($org: String!, $first: Int, $after: String) {
  organization(login: $org) {
    projectsV2(first: $first, after: $after) {
      totalCount
      pageInfo {
        startCursor
        endCursor
        hasNextPage
        hasPreviousPage
      }
      nodes {
        id
        title
        createdAt
        creator {
          login
        }
        shortDescription
        number
        public
        readme
        repositories(first: 10) {
          nodes {
            name
            owner {
              login
            }
          }
        }
      }
    }
  }
        }`,
          {
            org: args.org,
            first: args.first,
            after: args.after,
            request: { signal: opts.abortSignal },
          },
        );
        return { data: result };
      },
    }),
  ),
  list_organization_project_items: toolWithOctokit(({ octokit }) =>
    tool({
      inputSchema: external_exports.object({
        project_id: external_exports.string(),
        first: external_exports
          .number()
          .min(1)
          .max(100)
          .describe("Number of items to return"),
        after: external_exports
          .string()
          .describe(
            "Cursor for pagination. Leave blank to start from the beginning.",
          ),
      }),
      description: "List items in a project.",
      execute: async (args, opts) => {
        const result = await (
          await octokit
        ).graphql(
          `query ($project_id: ID!, $first: Int, $after: String) {
node(id: $project_id) {
    ... on ProjectV2 {
      items(first: $first, after: $after) {
        totalCount
        pageInfo {
          startCursor
          endCursor
          hasNextPage
          hasPreviousPage
        }
        nodes{
          id
          type
          createdAt
          updatedAt
          fieldValues(first:100) {
            nodes {
              ... on ProjectV2ItemFieldTextValue {
                text
                field {
                  ... on ProjectV2FieldCommon {
                    name
                  }
                }
              }
              ...on ProjectV2ItemFieldDateValue {
                date
                field {
                  ... on ProjectV2FieldCommon {
                    name
                  }
                }
              }
              ... on ProjectV2ItemFieldSingleSelectValue {
                name
                field {
                  ... on ProjectV2FieldCommon {
                    name
                  }
                }
              }
            }
          }
          content{
            ... on DraftIssue {
              title
              body
            }
            ...on Issue {
              title
              number
              state
              url
              createdAt
              updatedAt
              assignees(first: 10) {
                nodes{
                  login
                }
              }
            }
            ...on PullRequest {
              title
              number
              url
              state
              createdAt
              updatedAt              
              assignees(first: 10) {
                nodes{
                  login
                }
              }
            }
          }
        }
      }
    }
  }
}
        `,
          {
            project_id: args.project_id,
            first: args.first,
            after: args.after,
            request: { signal: opts.abortSignal },
          },
        );
        return { data: result };
      },
    }),
  ),
};

// node_modules/@blink-sdk/web-search/dist/index.js
import { createRequire as createRequire2 } from "node:module";
var __create3 = Object.create;
var __defProp4 = Object.defineProperty;
var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames3 = Object.getOwnPropertyNames;
var __getProtoOf3 = Object.getPrototypeOf;
var __hasOwnProp3 = Object.prototype.hasOwnProperty;
var __commonJS3 = (cb, mod) =>
  function () {
    return (
      mod ||
        (0, cb[__getOwnPropNames3(cb)[0]])(
          (mod = { exports: {} }).exports,
          mod,
        ),
      mod.exports
    );
  };
var __copyProps3 = (to, from, except, desc) => {
  if ((from && typeof from === "object") || typeof from === "function")
    for (
      var keys = __getOwnPropNames3(from), i2 = 0, n = keys.length, key;
      i2 < n;
      i2++
    ) {
      key = keys[i2];
      if (!__hasOwnProp3.call(to, key) && key !== except)
        __defProp4(to, key, {
          get: ((k) => from[k]).bind(null, key),
          enumerable: !(desc = __getOwnPropDesc3(from, key)) || desc.enumerable,
        });
    }
  return to;
};
var __toESM3 = (mod, isNodeMode, target) => (
  (target = mod != null ? __create3(__getProtoOf3(mod)) : {}),
  __copyProps3(
    isNodeMode || !mod || !mod.__esModule
      ? __defProp4(target, "default", {
          value: mod,
          enumerable: true,
        })
      : target,
    mod,
  )
);
var __require2 = /* @__PURE__ */ createRequire2(import.meta.url);
var marker17 = "vercel.ai.error";
var symbol18 = Symbol.for(marker17);
var _a18;
var _AISDKError3 = class _AISDKError$1 extends Error {
  /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */
  constructor({ name: name143, message, cause }) {
    super(message);
    this[_a18] = true;
    this.name = name143;
    this.cause = cause;
  }
  /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */
  static isInstance(error45) {
    return _AISDKError$1.hasMarker(error45, marker17);
  }
  static hasMarker(error45, marker153) {
    const markerSymbol = Symbol.for(marker153);
    return (
      error45 != null &&
      typeof error45 === "object" &&
      markerSymbol in error45 &&
      typeof error45[markerSymbol] === "boolean" &&
      error45[markerSymbol] === true
    );
  }
};
_a18 = symbol18;
var AISDKError2 = _AISDKError3;
var name17 = "AI_APICallError";
var marker24 = `vercel.ai.error.${name17}`;
var symbol24 = Symbol.for(marker24);
var _a24;
_a24 = symbol24;
var name24 = "AI_EmptyResponseBodyError";
var marker34 = `vercel.ai.error.${name24}`;
var symbol34 = Symbol.for(marker34);
var _a34;
_a34 = symbol34;
var name34 = "AI_InvalidArgumentError";
var marker44 = `vercel.ai.error.${name34}`;
var symbol44 = Symbol.for(marker44);
var _a44;
var InvalidArgumentError3 = class extends AISDKError2 {
  constructor({ message, cause, argument }) {
    super({
      name: name34,
      message,
      cause,
    });
    this[_a44] = true;
    this.argument = argument;
  }
  static isInstance(error45) {
    return AISDKError2.hasMarker(error45, marker44);
  }
};
_a44 = symbol44;
var name44 = "AI_InvalidPromptError";
var marker54 = `vercel.ai.error.${name44}`;
var symbol54 = Symbol.for(marker54);
var _a54;
_a54 = symbol54;
var name54 = "AI_InvalidResponseDataError";
var marker64 = `vercel.ai.error.${name54}`;
var symbol64 = Symbol.for(marker64);
var _a64;
_a64 = symbol64;
var name64 = "AI_JSONParseError";
var marker74 = `vercel.ai.error.${name64}`;
var symbol74 = Symbol.for(marker74);
var _a74;
_a74 = symbol74;
var name73 = "AI_LoadAPIKeyError";
var marker83 = `vercel.ai.error.${name73}`;
var symbol83 = Symbol.for(marker83);
var _a83;
_a83 = symbol83;
var name83 = "AI_LoadSettingError";
var marker93 = `vercel.ai.error.${name83}`;
var symbol93 = Symbol.for(marker93);
var _a93;
_a93 = symbol93;
var name93 = "AI_NoContentGeneratedError";
var marker103 = `vercel.ai.error.${name93}`;
var symbol103 = Symbol.for(marker103);
var _a103;
_a103 = symbol103;
var name103 = "AI_NoSuchModelError";
var marker113 = `vercel.ai.error.${name103}`;
var symbol113 = Symbol.for(marker113);
var _a113;
_a113 = symbol113;
var name113 = "AI_TooManyEmbeddingValuesForCallError";
var marker123 = `vercel.ai.error.${name113}`;
var symbol123 = Symbol.for(marker123);
var _a123;
_a123 = symbol123;
var name123 = "AI_TypeValidationError";
var marker133 = `vercel.ai.error.${name123}`;
var symbol133 = Symbol.for(marker133);
var _a133;
_a133 = symbol133;
var name133 = "AI_UnsupportedFunctionalityError";
var marker143 = `vercel.ai.error.${name133}`;
var symbol143 = Symbol.for(marker143);
var _a143;
_a143 = symbol143;
var createIdGenerator2 = ({
  prefix,
  size = 16,
  alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator = "-",
} = {}) => {
  const generator = () => {
    const alphabetLength = alphabet.length;
    const chars = new Array(size);
    for (let i2 = 0; i2 < size; i2++)
      chars[i2] = alphabet[(Math.random() * alphabetLength) | 0];
    return chars.join("");
  };
  if (prefix == null) return generator;
  if (alphabet.includes(separator))
    throw new InvalidArgumentError3({
      argument: "separator",
      message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`,
    });
  return () => `${prefix}${separator}${generator()}`;
};
var generateId2 = createIdGenerator2();
var validatorSymbol2 = Symbol.for("vercel.ai.validator");
function tool2(tool22) {
  return tool22;
}
var ignoreOverride$1 = Symbol(
  "Let zodToJsonSchema decide on which parser to use",
);
var schemaSymbol2 = Symbol.for("vercel.ai.schema");
var { btoa: btoa3, atob: atob3 } = globalThis;
var require_lib$1 = /* @__PURE__ */ __commonJS3({
  "../../../node_modules/webidl-conversions/lib/index.js": (
    exports,
    module,
  ) => {
    var conversions$1 = {};
    module.exports = conversions$1;
    function sign(x) {
      return x < 0 ? -1 : 1;
    }
    function evenRound(x) {
      if (x % 1 === 0.5 && (x & 1) === 0) return Math.floor(x);
      else return Math.round(x);
    }
    function createNumberConversion(bitLength, typeOpts) {
      if (!typeOpts.unsigned) --bitLength;
      const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
      const upperBound = Math.pow(2, bitLength) - 1;
      const moduloVal = typeOpts.moduloBitLength
        ? Math.pow(2, typeOpts.moduloBitLength)
        : Math.pow(2, bitLength);
      const moduloBound = typeOpts.moduloBitLength
        ? Math.pow(2, typeOpts.moduloBitLength - 1)
        : Math.pow(2, bitLength - 1);
      return function (V, opts) {
        if (!opts) opts = {};
        let x = +V;
        if (opts.enforceRange) {
          if (!Number.isFinite(x))
            throw new TypeError("Argument is not a finite number");
          x = sign(x) * Math.floor(Math.abs(x));
          if (x < lowerBound || x > upperBound)
            throw new TypeError("Argument is not in byte range");
          return x;
        }
        if (!isNaN(x) && opts.clamp) {
          x = evenRound(x);
          if (x < lowerBound) x = lowerBound;
          if (x > upperBound) x = upperBound;
          return x;
        }
        if (!Number.isFinite(x) || x === 0) return 0;
        x = sign(x) * Math.floor(Math.abs(x));
        x = x % moduloVal;
        if (!typeOpts.unsigned && x >= moduloBound) return x - moduloVal;
        else if (typeOpts.unsigned) {
          if (x < 0) x += moduloVal;
          else if (x === -0) return 0;
        }
        return x;
      };
    }
    conversions$1["void"] = function () {
      return void 0;
    };
    conversions$1["boolean"] = function (val) {
      return !!val;
    };
    conversions$1["byte"] = createNumberConversion(8, { unsigned: false });
    conversions$1["octet"] = createNumberConversion(8, { unsigned: true });
    conversions$1["short"] = createNumberConversion(16, { unsigned: false });
    conversions$1["unsigned short"] = createNumberConversion(16, {
      unsigned: true,
    });
    conversions$1["long"] = createNumberConversion(32, { unsigned: false });
    conversions$1["unsigned long"] = createNumberConversion(32, {
      unsigned: true,
    });
    conversions$1["long long"] = createNumberConversion(32, {
      unsigned: false,
      moduloBitLength: 64,
    });
    conversions$1["unsigned long long"] = createNumberConversion(32, {
      unsigned: true,
      moduloBitLength: 64,
    });
    conversions$1["double"] = function (V) {
      const x = +V;
      if (!Number.isFinite(x))
        throw new TypeError("Argument is not a finite floating-point value");
      return x;
    };
    conversions$1["unrestricted double"] = function (V) {
      const x = +V;
      if (isNaN(x)) throw new TypeError("Argument is NaN");
      return x;
    };
    conversions$1["float"] = conversions$1["double"];
    conversions$1["unrestricted float"] = conversions$1["unrestricted double"];
    conversions$1["DOMString"] = function (V, opts) {
      if (!opts) opts = {};
      if (opts.treatNullAsEmptyString && V === null) return "";
      return String(V);
    };
    conversions$1["ByteString"] = function (V, opts) {
      const x = String(V);
      let c2 = void 0;
      for (let i2 = 0; (c2 = x.codePointAt(i2)) !== void 0; ++i2)
        if (c2 > 255) throw new TypeError("Argument is not a valid bytestring");
      return x;
    };
    conversions$1["USVString"] = function (V) {
      const S3 = String(V);
      const n = S3.length;
      const U = [];
      for (let i2 = 0; i2 < n; ++i2) {
        const c2 = S3.charCodeAt(i2);
        if (c2 < 55296 || c2 > 57343) U.push(String.fromCodePoint(c2));
        else if (56320 <= c2 && c2 <= 57343)
          U.push(String.fromCodePoint(65533));
        else if (i2 === n - 1) U.push(String.fromCodePoint(65533));
        else {
          const d2 = S3.charCodeAt(i2 + 1);
          if (56320 <= d2 && d2 <= 57343) {
            const a2 = c2 & 1023;
            const b2 = d2 & 1023;
            U.push(String.fromCodePoint(65536 + 1024 * a2 + b2));
            ++i2;
          } else U.push(String.fromCodePoint(65533));
        }
      }
      return U.join("");
    };
    conversions$1["Date"] = function (V, opts) {
      if (!(V instanceof Date))
        throw new TypeError("Argument is not a Date object");
      if (isNaN(V)) return void 0;
      return V;
    };
    conversions$1["RegExp"] = function (V, opts) {
      if (!(V instanceof RegExp)) V = new RegExp(V);
      return V;
    };
  },
});
var require_utils = /* @__PURE__ */ __commonJS3({
  "../../../node_modules/whatwg-url/lib/utils.js": (exports, module) => {
    module.exports.mixin = function mixin(target, source) {
      const keys = Object.getOwnPropertyNames(source);
      for (let i2 = 0; i2 < keys.length; ++i2)
        Object.defineProperty(
          target,
          keys[i2],
          Object.getOwnPropertyDescriptor(source, keys[i2]),
        );
    };
    module.exports.wrapperSymbol = Symbol("wrapper");
    module.exports.implSymbol = Symbol("impl");
    module.exports.wrapperForImpl = function (impl$1) {
      return impl$1[module.exports.wrapperSymbol];
    };
    module.exports.implForWrapper = function (wrapper) {
      return wrapper[module.exports.implSymbol];
    };
  },
});
var require_mappingTable = /* @__PURE__ */ __commonJS3({
  "../../../node_modules/tr46/lib/mappingTable.json": (exports, module) => {
    module.exports = [
      [[0, 44], "disallowed_STD3_valid"],
      [[45, 46], "valid"],
      [[47, 47], "disallowed_STD3_valid"],
      [[48, 57], "valid"],
      [[58, 64], "disallowed_STD3_valid"],
      [[65, 65], "mapped", [97]],
      [[66, 66], "mapped", [98]],
      [[67, 67], "mapped", [99]],
      [[68, 68], "mapped", [100]],
      [[69, 69], "mapped", [101]],
      [[70, 70], "mapped", [102]],
      [[71, 71], "mapped", [103]],
      [[72, 72], "mapped", [104]],
      [[73, 73], "mapped", [105]],
      [[74, 74], "mapped", [106]],
      [[75, 75], "mapped", [107]],
      [[76, 76], "mapped", [108]],
      [[77, 77], "mapped", [109]],
      [[78, 78], "mapped", [110]],
      [[79, 79], "mapped", [111]],
      [[80, 80], "mapped", [112]],
      [[81, 81], "mapped", [113]],
      [[82, 82], "mapped", [114]],
      [[83, 83], "mapped", [115]],
      [[84, 84], "mapped", [116]],
      [[85, 85], "mapped", [117]],
      [[86, 86], "mapped", [118]],
      [[87, 87], "mapped", [119]],
      [[88, 88], "mapped", [120]],
      [[89, 89], "mapped", [121]],
      [[90, 90], "mapped", [122]],
      [[91, 96], "disallowed_STD3_valid"],
      [[97, 122], "valid"],
      [[123, 127], "disallowed_STD3_valid"],
      [[128, 159], "disallowed"],
      [[160, 160], "disallowed_STD3_mapped", [32]],
      [[161, 167], "valid", [], "NV8"],
      [[168, 168], "disallowed_STD3_mapped", [32, 776]],
      [[169, 169], "valid", [], "NV8"],
      [[170, 170], "mapped", [97]],
      [[171, 172], "valid", [], "NV8"],
      [[173, 173], "ignored"],
      [[174, 174], "valid", [], "NV8"],
      [[175, 175], "disallowed_STD3_mapped", [32, 772]],
      [[176, 177], "valid", [], "NV8"],
      [[178, 178], "mapped", [50]],
      [[179, 179], "mapped", [51]],
      [[180, 180], "disallowed_STD3_mapped", [32, 769]],
      [[181, 181], "mapped", [956]],
      [[182, 182], "valid", [], "NV8"],
      [[183, 183], "valid"],
      [[184, 184], "disallowed_STD3_mapped", [32, 807]],
      [[185, 185], "mapped", [49]],
      [[186, 186], "mapped", [111]],
      [[187, 187], "valid", [], "NV8"],
      [[188, 188], "mapped", [49, 8260, 52]],
      [[189, 189], "mapped", [49, 8260, 50]],
      [[190, 190], "mapped", [51, 8260, 52]],
      [[191, 191], "valid", [], "NV8"],
      [[192, 192], "mapped", [224]],
      [[193, 193], "mapped", [225]],
      [[194, 194], "mapped", [226]],
      [[195, 195], "mapped", [227]],
      [[196, 196], "mapped", [228]],
      [[197, 197], "mapped", [229]],
      [[198, 198], "mapped", [230]],
      [[199, 199], "mapped", [231]],
      [[200, 200], "mapped", [232]],
      [[201, 201], "mapped", [233]],
      [[202, 202], "mapped", [234]],
      [[203, 203], "mapped", [235]],
      [[204, 204], "mapped", [236]],
      [[205, 205], "mapped", [237]],
      [[206, 206], "mapped", [238]],
      [[207, 207], "mapped", [239]],
      [[208, 208], "mapped", [240]],
      [[209, 209], "mapped", [241]],
      [[210, 210], "mapped", [242]],
      [[211, 211], "mapped", [243]],
      [[212, 212], "mapped", [244]],
      [[213, 213], "mapped", [245]],
      [[214, 214], "mapped", [246]],
      [[215, 215], "valid", [], "NV8"],
      [[216, 216], "mapped", [248]],
      [[217, 217], "mapped", [249]],
      [[218, 218], "mapped", [250]],
      [[219, 219], "mapped", [251]],
      [[220, 220], "mapped", [252]],
      [[221, 221], "mapped", [253]],
      [[222, 222], "mapped", [254]],
      [[223, 223], "deviation", [115, 115]],
      [[224, 246], "valid"],
      [[247, 247], "valid", [], "NV8"],
      [[248, 255], "valid"],
      [[256, 256], "mapped", [257]],
      [[257, 257], "valid"],
      [[258, 258], "mapped", [259]],
      [[259, 259], "valid"],
      [[260, 260], "mapped", [261]],
      [[261, 261], "valid"],
      [[262, 262], "mapped", [263]],
      [[263, 263], "valid"],
      [[264, 264], "mapped", [265]],
      [[265, 265], "valid"],
      [[266, 266], "mapped", [267]],
      [[267, 267], "valid"],
      [[268, 268], "mapped", [269]],
      [[269, 269], "valid"],
      [[270, 270], "mapped", [271]],
      [[271, 271], "valid"],
      [[272, 272], "mapped", [273]],
      [[273, 273], "valid"],
      [[274, 274], "mapped", [275]],
      [[275, 275], "valid"],
      [[276, 276], "mapped", [277]],
      [[277, 277], "valid"],
      [[278, 278], "mapped", [279]],
      [[279, 279], "valid"],
      [[280, 280], "mapped", [281]],
      [[281, 281], "valid"],
      [[282, 282], "mapped", [283]],
      [[283, 283], "valid"],
      [[284, 284], "mapped", [285]],
      [[285, 285], "valid"],
      [[286, 286], "mapped", [287]],
      [[287, 287], "valid"],
      [[288, 288], "mapped", [289]],
      [[289, 289], "valid"],
      [[290, 290], "mapped", [291]],
      [[291, 291], "valid"],
      [[292, 292], "mapped", [293]],
      [[293, 293], "valid"],
      [[294, 294], "mapped", [295]],
      [[295, 295], "valid"],
      [[296, 296], "mapped", [297]],
      [[297, 297], "valid"],
      [[298, 298], "mapped", [299]],
      [[299, 299], "valid"],
      [[300, 300], "mapped", [301]],
      [[301, 301], "valid"],
      [[302, 302], "mapped", [303]],
      [[303, 303], "valid"],
      [[304, 304], "mapped", [105, 775]],
      [[305, 305], "valid"],
      [[306, 307], "mapped", [105, 106]],
      [[308, 308], "mapped", [309]],
      [[309, 309], "valid"],
      [[310, 310], "mapped", [311]],
      [[311, 312], "valid"],
      [[313, 313], "mapped", [314]],
      [[314, 314], "valid"],
      [[315, 315], "mapped", [316]],
      [[316, 316], "valid"],
      [[317, 317], "mapped", [318]],
      [[318, 318], "valid"],
      [[319, 320], "mapped", [108, 183]],
      [[321, 321], "mapped", [322]],
      [[322, 322], "valid"],
      [[323, 323], "mapped", [324]],
      [[324, 324], "valid"],
      [[325, 325], "mapped", [326]],
      [[326, 326], "valid"],
      [[327, 327], "mapped", [328]],
      [[328, 328], "valid"],
      [[329, 329], "mapped", [700, 110]],
      [[330, 330], "mapped", [331]],
      [[331, 331], "valid"],
      [[332, 332], "mapped", [333]],
      [[333, 333], "valid"],
      [[334, 334], "mapped", [335]],
      [[335, 335], "valid"],
      [[336, 336], "mapped", [337]],
      [[337, 337], "valid"],
      [[338, 338], "mapped", [339]],
      [[339, 339], "valid"],
      [[340, 340], "mapped", [341]],
      [[341, 341], "valid"],
      [[342, 342], "mapped", [343]],
      [[343, 343], "valid"],
      [[344, 344], "mapped", [345]],
      [[345, 345], "valid"],
      [[346, 346], "mapped", [347]],
      [[347, 347], "valid"],
      [[348, 348], "mapped", [349]],
      [[349, 349], "valid"],
      [[350, 350], "mapped", [351]],
      [[351, 351], "valid"],
      [[352, 352], "mapped", [353]],
      [[353, 353], "valid"],
      [[354, 354], "mapped", [355]],
      [[355, 355], "valid"],
      [[356, 356], "mapped", [357]],
      [[357, 357], "valid"],
      [[358, 358], "mapped", [359]],
      [[359, 359], "valid"],
      [[360, 360], "mapped", [361]],
      [[361, 361], "valid"],
      [[362, 362], "mapped", [363]],
      [[363, 363], "valid"],
      [[364, 364], "mapped", [365]],
      [[365, 365], "valid"],
      [[366, 366], "mapped", [367]],
      [[367, 367], "valid"],
      [[368, 368], "mapped", [369]],
      [[369, 369], "valid"],
      [[370, 370], "mapped", [371]],
      [[371, 371], "valid"],
      [[372, 372], "mapped", [373]],
      [[373, 373], "valid"],
      [[374, 374], "mapped", [375]],
      [[375, 375], "valid"],
      [[376, 376], "mapped", [255]],
      [[377, 377], "mapped", [378]],
      [[378, 378], "valid"],
      [[379, 379], "mapped", [380]],
      [[380, 380], "valid"],
      [[381, 381], "mapped", [382]],
      [[382, 382], "valid"],
      [[383, 383], "mapped", [115]],
      [[384, 384], "valid"],
      [[385, 385], "mapped", [595]],
      [[386, 386], "mapped", [387]],
      [[387, 387], "valid"],
      [[388, 388], "mapped", [389]],
      [[389, 389], "valid"],
      [[390, 390], "mapped", [596]],
      [[391, 391], "mapped", [392]],
      [[392, 392], "valid"],
      [[393, 393], "mapped", [598]],
      [[394, 394], "mapped", [599]],
      [[395, 395], "mapped", [396]],
      [[396, 397], "valid"],
      [[398, 398], "mapped", [477]],
      [[399, 399], "mapped", [601]],
      [[400, 400], "mapped", [603]],
      [[401, 401], "mapped", [402]],
      [[402, 402], "valid"],
      [[403, 403], "mapped", [608]],
      [[404, 404], "mapped", [611]],
      [[405, 405], "valid"],
      [[406, 406], "mapped", [617]],
      [[407, 407], "mapped", [616]],
      [[408, 408], "mapped", [409]],
      [[409, 411], "valid"],
      [[412, 412], "mapped", [623]],
      [[413, 413], "mapped", [626]],
      [[414, 414], "valid"],
      [[415, 415], "mapped", [629]],
      [[416, 416], "mapped", [417]],
      [[417, 417], "valid"],
      [[418, 418], "mapped", [419]],
      [[419, 419], "valid"],
      [[420, 420], "mapped", [421]],
      [[421, 421], "valid"],
      [[422, 422], "mapped", [640]],
      [[423, 423], "mapped", [424]],
      [[424, 424], "valid"],
      [[425, 425], "mapped", [643]],
      [[426, 427], "valid"],
      [[428, 428], "mapped", [429]],
      [[429, 429], "valid"],
      [[430, 430], "mapped", [648]],
      [[431, 431], "mapped", [432]],
      [[432, 432], "valid"],
      [[433, 433], "mapped", [650]],
      [[434, 434], "mapped", [651]],
      [[435, 435], "mapped", [436]],
      [[436, 436], "valid"],
      [[437, 437], "mapped", [438]],
      [[438, 438], "valid"],
      [[439, 439], "mapped", [658]],
      [[440, 440], "mapped", [441]],
      [[441, 443], "valid"],
      [[444, 444], "mapped", [445]],
      [[445, 451], "valid"],
      [[452, 454], "mapped", [100, 382]],
      [[455, 457], "mapped", [108, 106]],
      [[458, 460], "mapped", [110, 106]],
      [[461, 461], "mapped", [462]],
      [[462, 462], "valid"],
      [[463, 463], "mapped", [464]],
      [[464, 464], "valid"],
      [[465, 465], "mapped", [466]],
      [[466, 466], "valid"],
      [[467, 467], "mapped", [468]],
      [[468, 468], "valid"],
      [[469, 469], "mapped", [470]],
      [[470, 470], "valid"],
      [[471, 471], "mapped", [472]],
      [[472, 472], "valid"],
      [[473, 473], "mapped", [474]],
      [[474, 474], "valid"],
      [[475, 475], "mapped", [476]],
      [[476, 477], "valid"],
      [[478, 478], "mapped", [479]],
      [[479, 479], "valid"],
      [[480, 480], "mapped", [481]],
      [[481, 481], "valid"],
      [[482, 482], "mapped", [483]],
      [[483, 483], "valid"],
      [[484, 484], "mapped", [485]],
      [[485, 485], "valid"],
      [[486, 486], "mapped", [487]],
      [[487, 487], "valid"],
      [[488, 488], "mapped", [489]],
      [[489, 489], "valid"],
      [[490, 490], "mapped", [491]],
      [[491, 491], "valid"],
      [[492, 492], "mapped", [493]],
      [[493, 493], "valid"],
      [[494, 494], "mapped", [495]],
      [[495, 496], "valid"],
      [[497, 499], "mapped", [100, 122]],
      [[500, 500], "mapped", [501]],
      [[501, 501], "valid"],
      [[502, 502], "mapped", [405]],
      [[503, 503], "mapped", [447]],
      [[504, 504], "mapped", [505]],
      [[505, 505], "valid"],
      [[506, 506], "mapped", [507]],
      [[507, 507], "valid"],
      [[508, 508], "mapped", [509]],
      [[509, 509], "valid"],
      [[510, 510], "mapped", [511]],
      [[511, 511], "valid"],
      [[512, 512], "mapped", [513]],
      [[513, 513], "valid"],
      [[514, 514], "mapped", [515]],
      [[515, 515], "valid"],
      [[516, 516], "mapped", [517]],
      [[517, 517], "valid"],
      [[518, 518], "mapped", [519]],
      [[519, 519], "valid"],
      [[520, 520], "mapped", [521]],
      [[521, 521], "valid"],
      [[522, 522], "mapped", [523]],
      [[523, 523], "valid"],
      [[524, 524], "mapped", [525]],
      [[525, 525], "valid"],
      [[526, 526], "mapped", [527]],
      [[527, 527], "valid"],
      [[528, 528], "mapped", [529]],
      [[529, 529], "valid"],
      [[530, 530], "mapped", [531]],
      [[531, 531], "valid"],
      [[532, 532], "mapped", [533]],
      [[533, 533], "valid"],
      [[534, 534], "mapped", [535]],
      [[535, 535], "valid"],
      [[536, 536], "mapped", [537]],
      [[537, 537], "valid"],
      [[538, 538], "mapped", [539]],
      [[539, 539], "valid"],
      [[540, 540], "mapped", [541]],
      [[541, 541], "valid"],
      [[542, 542], "mapped", [543]],
      [[543, 543], "valid"],
      [[544, 544], "mapped", [414]],
      [[545, 545], "valid"],
      [[546, 546], "mapped", [547]],
      [[547, 547], "valid"],
      [[548, 548], "mapped", [549]],
      [[549, 549], "valid"],
      [[550, 550], "mapped", [551]],
      [[551, 551], "valid"],
      [[552, 552], "mapped", [553]],
      [[553, 553], "valid"],
      [[554, 554], "mapped", [555]],
      [[555, 555], "valid"],
      [[556, 556], "mapped", [557]],
      [[557, 557], "valid"],
      [[558, 558], "mapped", [559]],
      [[559, 559], "valid"],
      [[560, 560], "mapped", [561]],
      [[561, 561], "valid"],
      [[562, 562], "mapped", [563]],
      [[563, 563], "valid"],
      [[564, 566], "valid"],
      [[567, 569], "valid"],
      [[570, 570], "mapped", [11365]],
      [[571, 571], "mapped", [572]],
      [[572, 572], "valid"],
      [[573, 573], "mapped", [410]],
      [[574, 574], "mapped", [11366]],
      [[575, 576], "valid"],
      [[577, 577], "mapped", [578]],
      [[578, 578], "valid"],
      [[579, 579], "mapped", [384]],
      [[580, 580], "mapped", [649]],
      [[581, 581], "mapped", [652]],
      [[582, 582], "mapped", [583]],
      [[583, 583], "valid"],
      [[584, 584], "mapped", [585]],
      [[585, 585], "valid"],
      [[586, 586], "mapped", [587]],
      [[587, 587], "valid"],
      [[588, 588], "mapped", [589]],
      [[589, 589], "valid"],
      [[590, 590], "mapped", [591]],
      [[591, 591], "valid"],
      [[592, 680], "valid"],
      [[681, 685], "valid"],
      [[686, 687], "valid"],
      [[688, 688], "mapped", [104]],
      [[689, 689], "mapped", [614]],
      [[690, 690], "mapped", [106]],
      [[691, 691], "mapped", [114]],
      [[692, 692], "mapped", [633]],
      [[693, 693], "mapped", [635]],
      [[694, 694], "mapped", [641]],
      [[695, 695], "mapped", [119]],
      [[696, 696], "mapped", [121]],
      [[697, 705], "valid"],
      [[706, 709], "valid", [], "NV8"],
      [[710, 721], "valid"],
      [[722, 727], "valid", [], "NV8"],
      [[728, 728], "disallowed_STD3_mapped", [32, 774]],
      [[729, 729], "disallowed_STD3_mapped", [32, 775]],
      [[730, 730], "disallowed_STD3_mapped", [32, 778]],
      [[731, 731], "disallowed_STD3_mapped", [32, 808]],
      [[732, 732], "disallowed_STD3_mapped", [32, 771]],
      [[733, 733], "disallowed_STD3_mapped", [32, 779]],
      [[734, 734], "valid", [], "NV8"],
      [[735, 735], "valid", [], "NV8"],
      [[736, 736], "mapped", [611]],
      [[737, 737], "mapped", [108]],
      [[738, 738], "mapped", [115]],
      [[739, 739], "mapped", [120]],
      [[740, 740], "mapped", [661]],
      [[741, 745], "valid", [], "NV8"],
      [[746, 747], "valid", [], "NV8"],
      [[748, 748], "valid"],
      [[749, 749], "valid", [], "NV8"],
      [[750, 750], "valid"],
      [[751, 767], "valid", [], "NV8"],
      [[768, 831], "valid"],
      [[832, 832], "mapped", [768]],
      [[833, 833], "mapped", [769]],
      [[834, 834], "valid"],
      [[835, 835], "mapped", [787]],
      [[836, 836], "mapped", [776, 769]],
      [[837, 837], "mapped", [953]],
      [[838, 846], "valid"],
      [[847, 847], "ignored"],
      [[848, 855], "valid"],
      [[856, 860], "valid"],
      [[861, 863], "valid"],
      [[864, 865], "valid"],
      [[866, 866], "valid"],
      [[867, 879], "valid"],
      [[880, 880], "mapped", [881]],
      [[881, 881], "valid"],
      [[882, 882], "mapped", [883]],
      [[883, 883], "valid"],
      [[884, 884], "mapped", [697]],
      [[885, 885], "valid"],
      [[886, 886], "mapped", [887]],
      [[887, 887], "valid"],
      [[888, 889], "disallowed"],
      [[890, 890], "disallowed_STD3_mapped", [32, 953]],
      [[891, 893], "valid"],
      [[894, 894], "disallowed_STD3_mapped", [59]],
      [[895, 895], "mapped", [1011]],
      [[896, 899], "disallowed"],
      [[900, 900], "disallowed_STD3_mapped", [32, 769]],
      [[901, 901], "disallowed_STD3_mapped", [32, 776, 769]],
      [[902, 902], "mapped", [940]],
      [[903, 903], "mapped", [183]],
      [[904, 904], "mapped", [941]],
      [[905, 905], "mapped", [942]],
      [[906, 906], "mapped", [943]],
      [[907, 907], "disallowed"],
      [[908, 908], "mapped", [972]],
      [[909, 909], "disallowed"],
      [[910, 910], "mapped", [973]],
      [[911, 911], "mapped", [974]],
      [[912, 912], "valid"],
      [[913, 913], "mapped", [945]],
      [[914, 914], "mapped", [946]],
      [[915, 915], "mapped", [947]],
      [[916, 916], "mapped", [948]],
      [[917, 917], "mapped", [949]],
      [[918, 918], "mapped", [950]],
      [[919, 919], "mapped", [951]],
      [[920, 920], "mapped", [952]],
      [[921, 921], "mapped", [953]],
      [[922, 922], "mapped", [954]],
      [[923, 923], "mapped", [955]],
      [[924, 924], "mapped", [956]],
      [[925, 925], "mapped", [957]],
      [[926, 926], "mapped", [958]],
      [[927, 927], "mapped", [959]],
      [[928, 928], "mapped", [960]],
      [[929, 929], "mapped", [961]],
      [[930, 930], "disallowed"],
      [[931, 931], "mapped", [963]],
      [[932, 932], "mapped", [964]],
      [[933, 933], "mapped", [965]],
      [[934, 934], "mapped", [966]],
      [[935, 935], "mapped", [967]],
      [[936, 936], "mapped", [968]],
      [[937, 937], "mapped", [969]],
      [[938, 938], "mapped", [970]],
      [[939, 939], "mapped", [971]],
      [[940, 961], "valid"],
      [[962, 962], "deviation", [963]],
      [[963, 974], "valid"],
      [[975, 975], "mapped", [983]],
      [[976, 976], "mapped", [946]],
      [[977, 977], "mapped", [952]],
      [[978, 978], "mapped", [965]],
      [[979, 979], "mapped", [973]],
      [[980, 980], "mapped", [971]],
      [[981, 981], "mapped", [966]],
      [[982, 982], "mapped", [960]],
      [[983, 983], "valid"],
      [[984, 984], "mapped", [985]],
      [[985, 985], "valid"],
      [[986, 986], "mapped", [987]],
      [[987, 987], "valid"],
      [[988, 988], "mapped", [989]],
      [[989, 989], "valid"],
      [[990, 990], "mapped", [991]],
      [[991, 991], "valid"],
      [[992, 992], "mapped", [993]],
      [[993, 993], "valid"],
      [[994, 994], "mapped", [995]],
      [[995, 995], "valid"],
      [[996, 996], "mapped", [997]],
      [[997, 997], "valid"],
      [[998, 998], "mapped", [999]],
      [[999, 999], "valid"],
      [[1e3, 1e3], "mapped", [1001]],
      [[1001, 1001], "valid"],
      [[1002, 1002], "mapped", [1003]],
      [[1003, 1003], "valid"],
      [[1004, 1004], "mapped", [1005]],
      [[1005, 1005], "valid"],
      [[1006, 1006], "mapped", [1007]],
      [[1007, 1007], "valid"],
      [[1008, 1008], "mapped", [954]],
      [[1009, 1009], "mapped", [961]],
      [[1010, 1010], "mapped", [963]],
      [[1011, 1011], "valid"],
      [[1012, 1012], "mapped", [952]],
      [[1013, 1013], "mapped", [949]],
      [[1014, 1014], "valid", [], "NV8"],
      [[1015, 1015], "mapped", [1016]],
      [[1016, 1016], "valid"],
      [[1017, 1017], "mapped", [963]],
      [[1018, 1018], "mapped", [1019]],
      [[1019, 1019], "valid"],
      [[1020, 1020], "valid"],
      [[1021, 1021], "mapped", [891]],
      [[1022, 1022], "mapped", [892]],
      [[1023, 1023], "mapped", [893]],
      [[1024, 1024], "mapped", [1104]],
      [[1025, 1025], "mapped", [1105]],
      [[1026, 1026], "mapped", [1106]],
      [[1027, 1027], "mapped", [1107]],
      [[1028, 1028], "mapped", [1108]],
      [[1029, 1029], "mapped", [1109]],
      [[1030, 1030], "mapped", [1110]],
      [[1031, 1031], "mapped", [1111]],
      [[1032, 1032], "mapped", [1112]],
      [[1033, 1033], "mapped", [1113]],
      [[1034, 1034], "mapped", [1114]],
      [[1035, 1035], "mapped", [1115]],
      [[1036, 1036], "mapped", [1116]],
      [[1037, 1037], "mapped", [1117]],
      [[1038, 1038], "mapped", [1118]],
      [[1039, 1039], "mapped", [1119]],
      [[1040, 1040], "mapped", [1072]],
      [[1041, 1041], "mapped", [1073]],
      [[1042, 1042], "mapped", [1074]],
      [[1043, 1043], "mapped", [1075]],
      [[1044, 1044], "mapped", [1076]],
      [[1045, 1045], "mapped", [1077]],
      [[1046, 1046], "mapped", [1078]],
      [[1047, 1047], "mapped", [1079]],
      [[1048, 1048], "mapped", [1080]],
      [[1049, 1049], "mapped", [1081]],
      [[1050, 1050], "mapped", [1082]],
      [[1051, 1051], "mapped", [1083]],
      [[1052, 1052], "mapped", [1084]],
      [[1053, 1053], "mapped", [1085]],
      [[1054, 1054], "mapped", [1086]],
      [[1055, 1055], "mapped", [1087]],
      [[1056, 1056], "mapped", [1088]],
      [[1057, 1057], "mapped", [1089]],
      [[1058, 1058], "mapped", [1090]],
      [[1059, 1059], "mapped", [1091]],
      [[1060, 1060], "mapped", [1092]],
      [[1061, 1061], "mapped", [1093]],
      [[1062, 1062], "mapped", [1094]],
      [[1063, 1063], "mapped", [1095]],
      [[1064, 1064], "mapped", [1096]],
      [[1065, 1065], "mapped", [1097]],
      [[1066, 1066], "mapped", [1098]],
      [[1067, 1067], "mapped", [1099]],
      [[1068, 1068], "mapped", [1100]],
      [[1069, 1069], "mapped", [1101]],
      [[1070, 1070], "mapped", [1102]],
      [[1071, 1071], "mapped", [1103]],
      [[1072, 1103], "valid"],
      [[1104, 1104], "valid"],
      [[1105, 1116], "valid"],
      [[1117, 1117], "valid"],
      [[1118, 1119], "valid"],
      [[1120, 1120], "mapped", [1121]],
      [[1121, 1121], "valid"],
      [[1122, 1122], "mapped", [1123]],
      [[1123, 1123], "valid"],
      [[1124, 1124], "mapped", [1125]],
      [[1125, 1125], "valid"],
      [[1126, 1126], "mapped", [1127]],
      [[1127, 1127], "valid"],
      [[1128, 1128], "mapped", [1129]],
      [[1129, 1129], "valid"],
      [[1130, 1130], "mapped", [1131]],
      [[1131, 1131], "valid"],
      [[1132, 1132], "mapped", [1133]],
      [[1133, 1133], "valid"],
      [[1134, 1134], "mapped", [1135]],
      [[1135, 1135], "valid"],
      [[1136, 1136], "mapped", [1137]],
      [[1137, 1137], "valid"],
      [[1138, 1138], "mapped", [1139]],
      [[1139, 1139], "valid"],
      [[1140, 1140], "mapped", [1141]],
      [[1141, 1141], "valid"],
      [[1142, 1142], "mapped", [1143]],
      [[1143, 1143], "valid"],
      [[1144, 1144], "mapped", [1145]],
      [[1145, 1145], "valid"],
      [[1146, 1146], "mapped", [1147]],
      [[1147, 1147], "valid"],
      [[1148, 1148], "mapped", [1149]],
      [[1149, 1149], "valid"],
      [[1150, 1150], "mapped", [1151]],
      [[1151, 1151], "valid"],
      [[1152, 1152], "mapped", [1153]],
      [[1153, 1153], "valid"],
      [[1154, 1154], "valid", [], "NV8"],
      [[1155, 1158], "valid"],
      [[1159, 1159], "valid"],
      [[1160, 1161], "valid", [], "NV8"],
      [[1162, 1162], "mapped", [1163]],
      [[1163, 1163], "valid"],
      [[1164, 1164], "mapped", [1165]],
      [[1165, 1165], "valid"],
      [[1166, 1166], "mapped", [1167]],
      [[1167, 1167], "valid"],
      [[1168, 1168], "mapped", [1169]],
      [[1169, 1169], "valid"],
      [[1170, 1170], "mapped", [1171]],
      [[1171, 1171], "valid"],
      [[1172, 1172], "mapped", [1173]],
      [[1173, 1173], "valid"],
      [[1174, 1174], "mapped", [1175]],
      [[1175, 1175], "valid"],
      [[1176, 1176], "mapped", [1177]],
      [[1177, 1177], "valid"],
      [[1178, 1178], "mapped", [1179]],
      [[1179, 1179], "valid"],
      [[1180, 1180], "mapped", [1181]],
      [[1181, 1181], "valid"],
      [[1182, 1182], "mapped", [1183]],
      [[1183, 1183], "valid"],
      [[1184, 1184], "mapped", [1185]],
      [[1185, 1185], "valid"],
      [[1186, 1186], "mapped", [1187]],
      [[1187, 1187], "valid"],
      [[1188, 1188], "mapped", [1189]],
      [[1189, 1189], "valid"],
      [[1190, 1190], "mapped", [1191]],
      [[1191, 1191], "valid"],
      [[1192, 1192], "mapped", [1193]],
      [[1193, 1193], "valid"],
      [[1194, 1194], "mapped", [1195]],
      [[1195, 1195], "valid"],
      [[1196, 1196], "mapped", [1197]],
      [[1197, 1197], "valid"],
      [[1198, 1198], "mapped", [1199]],
      [[1199, 1199], "valid"],
      [[1200, 1200], "mapped", [1201]],
      [[1201, 1201], "valid"],
      [[1202, 1202], "mapped", [1203]],
      [[1203, 1203], "valid"],
      [[1204, 1204], "mapped", [1205]],
      [[1205, 1205], "valid"],
      [[1206, 1206], "mapped", [1207]],
      [[1207, 1207], "valid"],
      [[1208, 1208], "mapped", [1209]],
      [[1209, 1209], "valid"],
      [[1210, 1210], "mapped", [1211]],
      [[1211, 1211], "valid"],
      [[1212, 1212], "mapped", [1213]],
      [[1213, 1213], "valid"],
      [[1214, 1214], "mapped", [1215]],
      [[1215, 1215], "valid"],
      [[1216, 1216], "disallowed"],
      [[1217, 1217], "mapped", [1218]],
      [[1218, 1218], "valid"],
      [[1219, 1219], "mapped", [1220]],
      [[1220, 1220], "valid"],
      [[1221, 1221], "mapped", [1222]],
      [[1222, 1222], "valid"],
      [[1223, 1223], "mapped", [1224]],
      [[1224, 1224], "valid"],
      [[1225, 1225], "mapped", [1226]],
      [[1226, 1226], "valid"],
      [[1227, 1227], "mapped", [1228]],
      [[1228, 1228], "valid"],
      [[1229, 1229], "mapped", [1230]],
      [[1230, 1230], "valid"],
      [[1231, 1231], "valid"],
      [[1232, 1232], "mapped", [1233]],
      [[1233, 1233], "valid"],
      [[1234, 1234], "mapped", [1235]],
      [[1235, 1235], "valid"],
      [[1236, 1236], "mapped", [1237]],
      [[1237, 1237], "valid"],
      [[1238, 1238], "mapped", [1239]],
      [[1239, 1239], "valid"],
      [[1240, 1240], "mapped", [1241]],
      [[1241, 1241], "valid"],
      [[1242, 1242], "mapped", [1243]],
      [[1243, 1243], "valid"],
      [[1244, 1244], "mapped", [1245]],
      [[1245, 1245], "valid"],
      [[1246, 1246], "mapped", [1247]],
      [[1247, 1247], "valid"],
      [[1248, 1248], "mapped", [1249]],
      [[1249, 1249], "valid"],
      [[1250, 1250], "mapped", [1251]],
      [[1251, 1251], "valid"],
      [[1252, 1252], "mapped", [1253]],
      [[1253, 1253], "valid"],
      [[1254, 1254], "mapped", [1255]],
      [[1255, 1255], "valid"],
      [[1256, 1256], "mapped", [1257]],
      [[1257, 1257], "valid"],
      [[1258, 1258], "mapped", [1259]],
      [[1259, 1259], "valid"],
      [[1260, 1260], "mapped", [1261]],
      [[1261, 1261], "valid"],
      [[1262, 1262], "mapped", [1263]],
      [[1263, 1263], "valid"],
      [[1264, 1264], "mapped", [1265]],
      [[1265, 1265], "valid"],
      [[1266, 1266], "mapped", [1267]],
      [[1267, 1267], "valid"],
      [[1268, 1268], "mapped", [1269]],
      [[1269, 1269], "valid"],
      [[1270, 1270], "mapped", [1271]],
      [[1271, 1271], "valid"],
      [[1272, 1272], "mapped", [1273]],
      [[1273, 1273], "valid"],
      [[1274, 1274], "mapped", [1275]],
      [[1275, 1275], "valid"],
      [[1276, 1276], "mapped", [1277]],
      [[1277, 1277], "valid"],
      [[1278, 1278], "mapped", [1279]],
      [[1279, 1279], "valid"],
      [[1280, 1280], "mapped", [1281]],
      [[1281, 1281], "valid"],
      [[1282, 1282], "mapped", [1283]],
      [[1283, 1283], "valid"],
      [[1284, 1284], "mapped", [1285]],
      [[1285, 1285], "valid"],
      [[1286, 1286], "mapped", [1287]],
      [[1287, 1287], "valid"],
      [[1288, 1288], "mapped", [1289]],
      [[1289, 1289], "valid"],
      [[1290, 1290], "mapped", [1291]],
      [[1291, 1291], "valid"],
      [[1292, 1292], "mapped", [1293]],
      [[1293, 1293], "valid"],
      [[1294, 1294], "mapped", [1295]],
      [[1295, 1295], "valid"],
      [[1296, 1296], "mapped", [1297]],
      [[1297, 1297], "valid"],
      [[1298, 1298], "mapped", [1299]],
      [[1299, 1299], "valid"],
      [[1300, 1300], "mapped", [1301]],
      [[1301, 1301], "valid"],
      [[1302, 1302], "mapped", [1303]],
      [[1303, 1303], "valid"],
      [[1304, 1304], "mapped", [1305]],
      [[1305, 1305], "valid"],
      [[1306, 1306], "mapped", [1307]],
      [[1307, 1307], "valid"],
      [[1308, 1308], "mapped", [1309]],
      [[1309, 1309], "valid"],
      [[1310, 1310], "mapped", [1311]],
      [[1311, 1311], "valid"],
      [[1312, 1312], "mapped", [1313]],
      [[1313, 1313], "valid"],
      [[1314, 1314], "mapped", [1315]],
      [[1315, 1315], "valid"],
      [[1316, 1316], "mapped", [1317]],
      [[1317, 1317], "valid"],
      [[1318, 1318], "mapped", [1319]],
      [[1319, 1319], "valid"],
      [[1320, 1320], "mapped", [1321]],
      [[1321, 1321], "valid"],
      [[1322, 1322], "mapped", [1323]],
      [[1323, 1323], "valid"],
      [[1324, 1324], "mapped", [1325]],
      [[1325, 1325], "valid"],
      [[1326, 1326], "mapped", [1327]],
      [[1327, 1327], "valid"],
      [[1328, 1328], "disallowed"],
      [[1329, 1329], "mapped", [1377]],
      [[1330, 1330], "mapped", [1378]],
      [[1331, 1331], "mapped", [1379]],
      [[1332, 1332], "mapped", [1380]],
      [[1333, 1333], "mapped", [1381]],
      [[1334, 1334], "mapped", [1382]],
      [[1335, 1335], "mapped", [1383]],
      [[1336, 1336], "mapped", [1384]],
      [[1337, 1337], "mapped", [1385]],
      [[1338, 1338], "mapped", [1386]],
      [[1339, 1339], "mapped", [1387]],
      [[1340, 1340], "mapped", [1388]],
      [[1341, 1341], "mapped", [1389]],
      [[1342, 1342], "mapped", [1390]],
      [[1343, 1343], "mapped", [1391]],
      [[1344, 1344], "mapped", [1392]],
      [[1345, 1345], "mapped", [1393]],
      [[1346, 1346], "mapped", [1394]],
      [[1347, 1347], "mapped", [1395]],
      [[1348, 1348], "mapped", [1396]],
      [[1349, 1349], "mapped", [1397]],
      [[1350, 1350], "mapped", [1398]],
      [[1351, 1351], "mapped", [1399]],
      [[1352, 1352], "mapped", [1400]],
      [[1353, 1353], "mapped", [1401]],
      [[1354, 1354], "mapped", [1402]],
      [[1355, 1355], "mapped", [1403]],
      [[1356, 1356], "mapped", [1404]],
      [[1357, 1357], "mapped", [1405]],
      [[1358, 1358], "mapped", [1406]],
      [[1359, 1359], "mapped", [1407]],
      [[1360, 1360], "mapped", [1408]],
      [[1361, 1361], "mapped", [1409]],
      [[1362, 1362], "mapped", [1410]],
      [[1363, 1363], "mapped", [1411]],
      [[1364, 1364], "mapped", [1412]],
      [[1365, 1365], "mapped", [1413]],
      [[1366, 1366], "mapped", [1414]],
      [[1367, 1368], "disallowed"],
      [[1369, 1369], "valid"],
      [[1370, 1375], "valid", [], "NV8"],
      [[1376, 1376], "disallowed"],
      [[1377, 1414], "valid"],
      [[1415, 1415], "mapped", [1381, 1410]],
      [[1416, 1416], "disallowed"],
      [[1417, 1417], "valid", [], "NV8"],
      [[1418, 1418], "valid", [], "NV8"],
      [[1419, 1420], "disallowed"],
      [[1421, 1422], "valid", [], "NV8"],
      [[1423, 1423], "valid", [], "NV8"],
      [[1424, 1424], "disallowed"],
      [[1425, 1441], "valid"],
      [[1442, 1442], "valid"],
      [[1443, 1455], "valid"],
      [[1456, 1465], "valid"],
      [[1466, 1466], "valid"],
      [[1467, 1469], "valid"],
      [[1470, 1470], "valid", [], "NV8"],
      [[1471, 1471], "valid"],
      [[1472, 1472], "valid", [], "NV8"],
      [[1473, 1474], "valid"],
      [[1475, 1475], "valid", [], "NV8"],
      [[1476, 1476], "valid"],
      [[1477, 1477], "valid"],
      [[1478, 1478], "valid", [], "NV8"],
      [[1479, 1479], "valid"],
      [[1480, 1487], "disallowed"],
      [[1488, 1514], "valid"],
      [[1515, 1519], "disallowed"],
      [[1520, 1524], "valid"],
      [[1525, 1535], "disallowed"],
      [[1536, 1539], "disallowed"],
      [[1540, 1540], "disallowed"],
      [[1541, 1541], "disallowed"],
      [[1542, 1546], "valid", [], "NV8"],
      [[1547, 1547], "valid", [], "NV8"],
      [[1548, 1548], "valid", [], "NV8"],
      [[1549, 1551], "valid", [], "NV8"],
      [[1552, 1557], "valid"],
      [[1558, 1562], "valid"],
      [[1563, 1563], "valid", [], "NV8"],
      [[1564, 1564], "disallowed"],
      [[1565, 1565], "disallowed"],
      [[1566, 1566], "valid", [], "NV8"],
      [[1567, 1567], "valid", [], "NV8"],
      [[1568, 1568], "valid"],
      [[1569, 1594], "valid"],
      [[1595, 1599], "valid"],
      [[1600, 1600], "valid", [], "NV8"],
      [[1601, 1618], "valid"],
      [[1619, 1621], "valid"],
      [[1622, 1624], "valid"],
      [[1625, 1630], "valid"],
      [[1631, 1631], "valid"],
      [[1632, 1641], "valid"],
      [[1642, 1645], "valid", [], "NV8"],
      [[1646, 1647], "valid"],
      [[1648, 1652], "valid"],
      [[1653, 1653], "mapped", [1575, 1652]],
      [[1654, 1654], "mapped", [1608, 1652]],
      [[1655, 1655], "mapped", [1735, 1652]],
      [[1656, 1656], "mapped", [1610, 1652]],
      [[1657, 1719], "valid"],
      [[1720, 1721], "valid"],
      [[1722, 1726], "valid"],
      [[1727, 1727], "valid"],
      [[1728, 1742], "valid"],
      [[1743, 1743], "valid"],
      [[1744, 1747], "valid"],
      [[1748, 1748], "valid", [], "NV8"],
      [[1749, 1756], "valid"],
      [[1757, 1757], "disallowed"],
      [[1758, 1758], "valid", [], "NV8"],
      [[1759, 1768], "valid"],
      [[1769, 1769], "valid", [], "NV8"],
      [[1770, 1773], "valid"],
      [[1774, 1775], "valid"],
      [[1776, 1785], "valid"],
      [[1786, 1790], "valid"],
      [[1791, 1791], "valid"],
      [[1792, 1805], "valid", [], "NV8"],
      [[1806, 1806], "disallowed"],
      [[1807, 1807], "disallowed"],
      [[1808, 1836], "valid"],
      [[1837, 1839], "valid"],
      [[1840, 1866], "valid"],
      [[1867, 1868], "disallowed"],
      [[1869, 1871], "valid"],
      [[1872, 1901], "valid"],
      [[1902, 1919], "valid"],
      [[1920, 1968], "valid"],
      [[1969, 1969], "valid"],
      [[1970, 1983], "disallowed"],
      [[1984, 2037], "valid"],
      [[2038, 2042], "valid", [], "NV8"],
      [[2043, 2047], "disallowed"],
      [[2048, 2093], "valid"],
      [[2094, 2095], "disallowed"],
      [[2096, 2110], "valid", [], "NV8"],
      [[2111, 2111], "disallowed"],
      [[2112, 2139], "valid"],
      [[2140, 2141], "disallowed"],
      [[2142, 2142], "valid", [], "NV8"],
      [[2143, 2207], "disallowed"],
      [[2208, 2208], "valid"],
      [[2209, 2209], "valid"],
      [[2210, 2220], "valid"],
      [[2221, 2226], "valid"],
      [[2227, 2228], "valid"],
      [[2229, 2274], "disallowed"],
      [[2275, 2275], "valid"],
      [[2276, 2302], "valid"],
      [[2303, 2303], "valid"],
      [[2304, 2304], "valid"],
      [[2305, 2307], "valid"],
      [[2308, 2308], "valid"],
      [[2309, 2361], "valid"],
      [[2362, 2363], "valid"],
      [[2364, 2381], "valid"],
      [[2382, 2382], "valid"],
      [[2383, 2383], "valid"],
      [[2384, 2388], "valid"],
      [[2389, 2389], "valid"],
      [[2390, 2391], "valid"],
      [[2392, 2392], "mapped", [2325, 2364]],
      [[2393, 2393], "mapped", [2326, 2364]],
      [[2394, 2394], "mapped", [2327, 2364]],
      [[2395, 2395], "mapped", [2332, 2364]],
      [[2396, 2396], "mapped", [2337, 2364]],
      [[2397, 2397], "mapped", [2338, 2364]],
      [[2398, 2398], "mapped", [2347, 2364]],
      [[2399, 2399], "mapped", [2351, 2364]],
      [[2400, 2403], "valid"],
      [[2404, 2405], "valid", [], "NV8"],
      [[2406, 2415], "valid"],
      [[2416, 2416], "valid", [], "NV8"],
      [[2417, 2418], "valid"],
      [[2419, 2423], "valid"],
      [[2424, 2424], "valid"],
      [[2425, 2426], "valid"],
      [[2427, 2428], "valid"],
      [[2429, 2429], "valid"],
      [[2430, 2431], "valid"],
      [[2432, 2432], "valid"],
      [[2433, 2435], "valid"],
      [[2436, 2436], "disallowed"],
      [[2437, 2444], "valid"],
      [[2445, 2446], "disallowed"],
      [[2447, 2448], "valid"],
      [[2449, 2450], "disallowed"],
      [[2451, 2472], "valid"],
      [[2473, 2473], "disallowed"],
      [[2474, 2480], "valid"],
      [[2481, 2481], "disallowed"],
      [[2482, 2482], "valid"],
      [[2483, 2485], "disallowed"],
      [[2486, 2489], "valid"],
      [[2490, 2491], "disallowed"],
      [[2492, 2492], "valid"],
      [[2493, 2493], "valid"],
      [[2494, 2500], "valid"],
      [[2501, 2502], "disallowed"],
      [[2503, 2504], "valid"],
      [[2505, 2506], "disallowed"],
      [[2507, 2509], "valid"],
      [[2510, 2510], "valid"],
      [[2511, 2518], "disallowed"],
      [[2519, 2519], "valid"],
      [[2520, 2523], "disallowed"],
      [[2524, 2524], "mapped", [2465, 2492]],
      [[2525, 2525], "mapped", [2466, 2492]],
      [[2526, 2526], "disallowed"],
      [[2527, 2527], "mapped", [2479, 2492]],
      [[2528, 2531], "valid"],
      [[2532, 2533], "disallowed"],
      [[2534, 2545], "valid"],
      [[2546, 2554], "valid", [], "NV8"],
      [[2555, 2555], "valid", [], "NV8"],
      [[2556, 2560], "disallowed"],
      [[2561, 2561], "valid"],
      [[2562, 2562], "valid"],
      [[2563, 2563], "valid"],
      [[2564, 2564], "disallowed"],
      [[2565, 2570], "valid"],
      [[2571, 2574], "disallowed"],
      [[2575, 2576], "valid"],
      [[2577, 2578], "disallowed"],
      [[2579, 2600], "valid"],
      [[2601, 2601], "disallowed"],
      [[2602, 2608], "valid"],
      [[2609, 2609], "disallowed"],
      [[2610, 2610], "valid"],
      [[2611, 2611], "mapped", [2610, 2620]],
      [[2612, 2612], "disallowed"],
      [[2613, 2613], "valid"],
      [[2614, 2614], "mapped", [2616, 2620]],
      [[2615, 2615], "disallowed"],
      [[2616, 2617], "valid"],
      [[2618, 2619], "disallowed"],
      [[2620, 2620], "valid"],
      [[2621, 2621], "disallowed"],
      [[2622, 2626], "valid"],
      [[2627, 2630], "disallowed"],
      [[2631, 2632], "valid"],
      [[2633, 2634], "disallowed"],
      [[2635, 2637], "valid"],
      [[2638, 2640], "disallowed"],
      [[2641, 2641], "valid"],
      [[2642, 2648], "disallowed"],
      [[2649, 2649], "mapped", [2582, 2620]],
      [[2650, 2650], "mapped", [2583, 2620]],
      [[2651, 2651], "mapped", [2588, 2620]],
      [[2652, 2652], "valid"],
      [[2653, 2653], "disallowed"],
      [[2654, 2654], "mapped", [2603, 2620]],
      [[2655, 2661], "disallowed"],
      [[2662, 2676], "valid"],
      [[2677, 2677], "valid"],
      [[2678, 2688], "disallowed"],
      [[2689, 2691], "valid"],
      [[2692, 2692], "disallowed"],
      [[2693, 2699], "valid"],
      [[2700, 2700], "valid"],
      [[2701, 2701], "valid"],
      [[2702, 2702], "disallowed"],
      [[2703, 2705], "valid"],
      [[2706, 2706], "disallowed"],
      [[2707, 2728], "valid"],
      [[2729, 2729], "disallowed"],
      [[2730, 2736], "valid"],
      [[2737, 2737], "disallowed"],
      [[2738, 2739], "valid"],
      [[2740, 2740], "disallowed"],
      [[2741, 2745], "valid"],
      [[2746, 2747], "disallowed"],
      [[2748, 2757], "valid"],
      [[2758, 2758], "disallowed"],
      [[2759, 2761], "valid"],
      [[2762, 2762], "disallowed"],
      [[2763, 2765], "valid"],
      [[2766, 2767], "disallowed"],
      [[2768, 2768], "valid"],
      [[2769, 2783], "disallowed"],
      [[2784, 2784], "valid"],
      [[2785, 2787], "valid"],
      [[2788, 2789], "disallowed"],
      [[2790, 2799], "valid"],
      [[2800, 2800], "valid", [], "NV8"],
      [[2801, 2801], "valid", [], "NV8"],
      [[2802, 2808], "disallowed"],
      [[2809, 2809], "valid"],
      [[2810, 2816], "disallowed"],
      [[2817, 2819], "valid"],
      [[2820, 2820], "disallowed"],
      [[2821, 2828], "valid"],
      [[2829, 2830], "disallowed"],
      [[2831, 2832], "valid"],
      [[2833, 2834], "disallowed"],
      [[2835, 2856], "valid"],
      [[2857, 2857], "disallowed"],
      [[2858, 2864], "valid"],
      [[2865, 2865], "disallowed"],
      [[2866, 2867], "valid"],
      [[2868, 2868], "disallowed"],
      [[2869, 2869], "valid"],
      [[2870, 2873], "valid"],
      [[2874, 2875], "disallowed"],
      [[2876, 2883], "valid"],
      [[2884, 2884], "valid"],
      [[2885, 2886], "disallowed"],
      [[2887, 2888], "valid"],
      [[2889, 2890], "disallowed"],
      [[2891, 2893], "valid"],
      [[2894, 2901], "disallowed"],
      [[2902, 2903], "valid"],
      [[2904, 2907], "disallowed"],
      [[2908, 2908], "mapped", [2849, 2876]],
      [[2909, 2909], "mapped", [2850, 2876]],
      [[2910, 2910], "disallowed"],
      [[2911, 2913], "valid"],
      [[2914, 2915], "valid"],
      [[2916, 2917], "disallowed"],
      [[2918, 2927], "valid"],
      [[2928, 2928], "valid", [], "NV8"],
      [[2929, 2929], "valid"],
      [[2930, 2935], "valid", [], "NV8"],
      [[2936, 2945], "disallowed"],
      [[2946, 2947], "valid"],
      [[2948, 2948], "disallowed"],
      [[2949, 2954], "valid"],
      [[2955, 2957], "disallowed"],
      [[2958, 2960], "valid"],
      [[2961, 2961], "disallowed"],
      [[2962, 2965], "valid"],
      [[2966, 2968], "disallowed"],
      [[2969, 2970], "valid"],
      [[2971, 2971], "disallowed"],
      [[2972, 2972], "valid"],
      [[2973, 2973], "disallowed"],
      [[2974, 2975], "valid"],
      [[2976, 2978], "disallowed"],
      [[2979, 2980], "valid"],
      [[2981, 2983], "disallowed"],
      [[2984, 2986], "valid"],
      [[2987, 2989], "disallowed"],
      [[2990, 2997], "valid"],
      [[2998, 2998], "valid"],
      [[2999, 3001], "valid"],
      [[3002, 3005], "disallowed"],
      [[3006, 3010], "valid"],
      [[3011, 3013], "disallowed"],
      [[3014, 3016], "valid"],
      [[3017, 3017], "disallowed"],
      [[3018, 3021], "valid"],
      [[3022, 3023], "disallowed"],
      [[3024, 3024], "valid"],
      [[3025, 3030], "disallowed"],
      [[3031, 3031], "valid"],
      [[3032, 3045], "disallowed"],
      [[3046, 3046], "valid"],
      [[3047, 3055], "valid"],
      [[3056, 3058], "valid", [], "NV8"],
      [[3059, 3066], "valid", [], "NV8"],
      [[3067, 3071], "disallowed"],
      [[3072, 3072], "valid"],
      [[3073, 3075], "valid"],
      [[3076, 3076], "disallowed"],
      [[3077, 3084], "valid"],
      [[3085, 3085], "disallowed"],
      [[3086, 3088], "valid"],
      [[3089, 3089], "disallowed"],
      [[3090, 3112], "valid"],
      [[3113, 3113], "disallowed"],
      [[3114, 3123], "valid"],
      [[3124, 3124], "valid"],
      [[3125, 3129], "valid"],
      [[3130, 3132], "disallowed"],
      [[3133, 3133], "valid"],
      [[3134, 3140], "valid"],
      [[3141, 3141], "disallowed"],
      [[3142, 3144], "valid"],
      [[3145, 3145], "disallowed"],
      [[3146, 3149], "valid"],
      [[3150, 3156], "disallowed"],
      [[3157, 3158], "valid"],
      [[3159, 3159], "disallowed"],
      [[3160, 3161], "valid"],
      [[3162, 3162], "valid"],
      [[3163, 3167], "disallowed"],
      [[3168, 3169], "valid"],
      [[3170, 3171], "valid"],
      [[3172, 3173], "disallowed"],
      [[3174, 3183], "valid"],
      [[3184, 3191], "disallowed"],
      [[3192, 3199], "valid", [], "NV8"],
      [[3200, 3200], "disallowed"],
      [[3201, 3201], "valid"],
      [[3202, 3203], "valid"],
      [[3204, 3204], "disallowed"],
      [[3205, 3212], "valid"],
      [[3213, 3213], "disallowed"],
      [[3214, 3216], "valid"],
      [[3217, 3217], "disallowed"],
      [[3218, 3240], "valid"],
      [[3241, 3241], "disallowed"],
      [[3242, 3251], "valid"],
      [[3252, 3252], "disallowed"],
      [[3253, 3257], "valid"],
      [[3258, 3259], "disallowed"],
      [[3260, 3261], "valid"],
      [[3262, 3268], "valid"],
      [[3269, 3269], "disallowed"],
      [[3270, 3272], "valid"],
      [[3273, 3273], "disallowed"],
      [[3274, 3277], "valid"],
      [[3278, 3284], "disallowed"],
      [[3285, 3286], "valid"],
      [[3287, 3293], "disallowed"],
      [[3294, 3294], "valid"],
      [[3295, 3295], "disallowed"],
      [[3296, 3297], "valid"],
      [[3298, 3299], "valid"],
      [[3300, 3301], "disallowed"],
      [[3302, 3311], "valid"],
      [[3312, 3312], "disallowed"],
      [[3313, 3314], "valid"],
      [[3315, 3328], "disallowed"],
      [[3329, 3329], "valid"],
      [[3330, 3331], "valid"],
      [[3332, 3332], "disallowed"],
      [[3333, 3340], "valid"],
      [[3341, 3341], "disallowed"],
      [[3342, 3344], "valid"],
      [[3345, 3345], "disallowed"],
      [[3346, 3368], "valid"],
      [[3369, 3369], "valid"],
      [[3370, 3385], "valid"],
      [[3386, 3386], "valid"],
      [[3387, 3388], "disallowed"],
      [[3389, 3389], "valid"],
      [[3390, 3395], "valid"],
      [[3396, 3396], "valid"],
      [[3397, 3397], "disallowed"],
      [[3398, 3400], "valid"],
      [[3401, 3401], "disallowed"],
      [[3402, 3405], "valid"],
      [[3406, 3406], "valid"],
      [[3407, 3414], "disallowed"],
      [[3415, 3415], "valid"],
      [[3416, 3422], "disallowed"],
      [[3423, 3423], "valid"],
      [[3424, 3425], "valid"],
      [[3426, 3427], "valid"],
      [[3428, 3429], "disallowed"],
      [[3430, 3439], "valid"],
      [[3440, 3445], "valid", [], "NV8"],
      [[3446, 3448], "disallowed"],
      [[3449, 3449], "valid", [], "NV8"],
      [[3450, 3455], "valid"],
      [[3456, 3457], "disallowed"],
      [[3458, 3459], "valid"],
      [[3460, 3460], "disallowed"],
      [[3461, 3478], "valid"],
      [[3479, 3481], "disallowed"],
      [[3482, 3505], "valid"],
      [[3506, 3506], "disallowed"],
      [[3507, 3515], "valid"],
      [[3516, 3516], "disallowed"],
      [[3517, 3517], "valid"],
      [[3518, 3519], "disallowed"],
      [[3520, 3526], "valid"],
      [[3527, 3529], "disallowed"],
      [[3530, 3530], "valid"],
      [[3531, 3534], "disallowed"],
      [[3535, 3540], "valid"],
      [[3541, 3541], "disallowed"],
      [[3542, 3542], "valid"],
      [[3543, 3543], "disallowed"],
      [[3544, 3551], "valid"],
      [[3552, 3557], "disallowed"],
      [[3558, 3567], "valid"],
      [[3568, 3569], "disallowed"],
      [[3570, 3571], "valid"],
      [[3572, 3572], "valid", [], "NV8"],
      [[3573, 3584], "disallowed"],
      [[3585, 3634], "valid"],
      [[3635, 3635], "mapped", [3661, 3634]],
      [[3636, 3642], "valid"],
      [[3643, 3646], "disallowed"],
      [[3647, 3647], "valid", [], "NV8"],
      [[3648, 3662], "valid"],
      [[3663, 3663], "valid", [], "NV8"],
      [[3664, 3673], "valid"],
      [[3674, 3675], "valid", [], "NV8"],
      [[3676, 3712], "disallowed"],
      [[3713, 3714], "valid"],
      [[3715, 3715], "disallowed"],
      [[3716, 3716], "valid"],
      [[3717, 3718], "disallowed"],
      [[3719, 3720], "valid"],
      [[3721, 3721], "disallowed"],
      [[3722, 3722], "valid"],
      [[3723, 3724], "disallowed"],
      [[3725, 3725], "valid"],
      [[3726, 3731], "disallowed"],
      [[3732, 3735], "valid"],
      [[3736, 3736], "disallowed"],
      [[3737, 3743], "valid"],
      [[3744, 3744], "disallowed"],
      [[3745, 3747], "valid"],
      [[3748, 3748], "disallowed"],
      [[3749, 3749], "valid"],
      [[3750, 3750], "disallowed"],
      [[3751, 3751], "valid"],
      [[3752, 3753], "disallowed"],
      [[3754, 3755], "valid"],
      [[3756, 3756], "disallowed"],
      [[3757, 3762], "valid"],
      [[3763, 3763], "mapped", [3789, 3762]],
      [[3764, 3769], "valid"],
      [[3770, 3770], "disallowed"],
      [[3771, 3773], "valid"],
      [[3774, 3775], "disallowed"],
      [[3776, 3780], "valid"],
      [[3781, 3781], "disallowed"],
      [[3782, 3782], "valid"],
      [[3783, 3783], "disallowed"],
      [[3784, 3789], "valid"],
      [[3790, 3791], "disallowed"],
      [[3792, 3801], "valid"],
      [[3802, 3803], "disallowed"],
      [[3804, 3804], "mapped", [3755, 3737]],
      [[3805, 3805], "mapped", [3755, 3745]],
      [[3806, 3807], "valid"],
      [[3808, 3839], "disallowed"],
      [[3840, 3840], "valid"],
      [[3841, 3850], "valid", [], "NV8"],
      [[3851, 3851], "valid"],
      [[3852, 3852], "mapped", [3851]],
      [[3853, 3863], "valid", [], "NV8"],
      [[3864, 3865], "valid"],
      [[3866, 3871], "valid", [], "NV8"],
      [[3872, 3881], "valid"],
      [[3882, 3892], "valid", [], "NV8"],
      [[3893, 3893], "valid"],
      [[3894, 3894], "valid", [], "NV8"],
      [[3895, 3895], "valid"],
      [[3896, 3896], "valid", [], "NV8"],
      [[3897, 3897], "valid"],
      [[3898, 3901], "valid", [], "NV8"],
      [[3902, 3906], "valid"],
      [[3907, 3907], "mapped", [3906, 4023]],
      [[3908, 3911], "valid"],
      [[3912, 3912], "disallowed"],
      [[3913, 3916], "valid"],
      [[3917, 3917], "mapped", [3916, 4023]],
      [[3918, 3921], "valid"],
      [[3922, 3922], "mapped", [3921, 4023]],
      [[3923, 3926], "valid"],
      [[3927, 3927], "mapped", [3926, 4023]],
      [[3928, 3931], "valid"],
      [[3932, 3932], "mapped", [3931, 4023]],
      [[3933, 3944], "valid"],
      [[3945, 3945], "mapped", [3904, 4021]],
      [[3946, 3946], "valid"],
      [[3947, 3948], "valid"],
      [[3949, 3952], "disallowed"],
      [[3953, 3954], "valid"],
      [[3955, 3955], "mapped", [3953, 3954]],
      [[3956, 3956], "valid"],
      [[3957, 3957], "mapped", [3953, 3956]],
      [[3958, 3958], "mapped", [4018, 3968]],
      [[3959, 3959], "mapped", [4018, 3953, 3968]],
      [[3960, 3960], "mapped", [4019, 3968]],
      [[3961, 3961], "mapped", [4019, 3953, 3968]],
      [[3962, 3968], "valid"],
      [[3969, 3969], "mapped", [3953, 3968]],
      [[3970, 3972], "valid"],
      [[3973, 3973], "valid", [], "NV8"],
      [[3974, 3979], "valid"],
      [[3980, 3983], "valid"],
      [[3984, 3986], "valid"],
      [[3987, 3987], "mapped", [3986, 4023]],
      [[3988, 3989], "valid"],
      [[3990, 3990], "valid"],
      [[3991, 3991], "valid"],
      [[3992, 3992], "disallowed"],
      [[3993, 3996], "valid"],
      [[3997, 3997], "mapped", [3996, 4023]],
      [[3998, 4001], "valid"],
      [[4002, 4002], "mapped", [4001, 4023]],
      [[4003, 4006], "valid"],
      [[4007, 4007], "mapped", [4006, 4023]],
      [[4008, 4011], "valid"],
      [[4012, 4012], "mapped", [4011, 4023]],
      [[4013, 4013], "valid"],
      [[4014, 4016], "valid"],
      [[4017, 4023], "valid"],
      [[4024, 4024], "valid"],
      [[4025, 4025], "mapped", [3984, 4021]],
      [[4026, 4028], "valid"],
      [[4029, 4029], "disallowed"],
      [[4030, 4037], "valid", [], "NV8"],
      [[4038, 4038], "valid"],
      [[4039, 4044], "valid", [], "NV8"],
      [[4045, 4045], "disallowed"],
      [[4046, 4046], "valid", [], "NV8"],
      [[4047, 4047], "valid", [], "NV8"],
      [[4048, 4049], "valid", [], "NV8"],
      [[4050, 4052], "valid", [], "NV8"],
      [[4053, 4056], "valid", [], "NV8"],
      [[4057, 4058], "valid", [], "NV8"],
      [[4059, 4095], "disallowed"],
      [[4096, 4129], "valid"],
      [[4130, 4130], "valid"],
      [[4131, 4135], "valid"],
      [[4136, 4136], "valid"],
      [[4137, 4138], "valid"],
      [[4139, 4139], "valid"],
      [[4140, 4146], "valid"],
      [[4147, 4149], "valid"],
      [[4150, 4153], "valid"],
      [[4154, 4159], "valid"],
      [[4160, 4169], "valid"],
      [[4170, 4175], "valid", [], "NV8"],
      [[4176, 4185], "valid"],
      [[4186, 4249], "valid"],
      [[4250, 4253], "valid"],
      [[4254, 4255], "valid", [], "NV8"],
      [[4256, 4293], "disallowed"],
      [[4294, 4294], "disallowed"],
      [[4295, 4295], "mapped", [11559]],
      [[4296, 4300], "disallowed"],
      [[4301, 4301], "mapped", [11565]],
      [[4302, 4303], "disallowed"],
      [[4304, 4342], "valid"],
      [[4343, 4344], "valid"],
      [[4345, 4346], "valid"],
      [[4347, 4347], "valid", [], "NV8"],
      [[4348, 4348], "mapped", [4316]],
      [[4349, 4351], "valid"],
      [[4352, 4441], "valid", [], "NV8"],
      [[4442, 4446], "valid", [], "NV8"],
      [[4447, 4448], "disallowed"],
      [[4449, 4514], "valid", [], "NV8"],
      [[4515, 4519], "valid", [], "NV8"],
      [[4520, 4601], "valid", [], "NV8"],
      [[4602, 4607], "valid", [], "NV8"],
      [[4608, 4614], "valid"],
      [[4615, 4615], "valid"],
      [[4616, 4678], "valid"],
      [[4679, 4679], "valid"],
      [[4680, 4680], "valid"],
      [[4681, 4681], "disallowed"],
      [[4682, 4685], "valid"],
      [[4686, 4687], "disallowed"],
      [[4688, 4694], "valid"],
      [[4695, 4695], "disallowed"],
      [[4696, 4696], "valid"],
      [[4697, 4697], "disallowed"],
      [[4698, 4701], "valid"],
      [[4702, 4703], "disallowed"],
      [[4704, 4742], "valid"],
      [[4743, 4743], "valid"],
      [[4744, 4744], "valid"],
      [[4745, 4745], "disallowed"],
      [[4746, 4749], "valid"],
      [[4750, 4751], "disallowed"],
      [[4752, 4782], "valid"],
      [[4783, 4783], "valid"],
      [[4784, 4784], "valid"],
      [[4785, 4785], "disallowed"],
      [[4786, 4789], "valid"],
      [[4790, 4791], "disallowed"],
      [[4792, 4798], "valid"],
      [[4799, 4799], "disallowed"],
      [[4800, 4800], "valid"],
      [[4801, 4801], "disallowed"],
      [[4802, 4805], "valid"],
      [[4806, 4807], "disallowed"],
      [[4808, 4814], "valid"],
      [[4815, 4815], "valid"],
      [[4816, 4822], "valid"],
      [[4823, 4823], "disallowed"],
      [[4824, 4846], "valid"],
      [[4847, 4847], "valid"],
      [[4848, 4878], "valid"],
      [[4879, 4879], "valid"],
      [[4880, 4880], "valid"],
      [[4881, 4881], "disallowed"],
      [[4882, 4885], "valid"],
      [[4886, 4887], "disallowed"],
      [[4888, 4894], "valid"],
      [[4895, 4895], "valid"],
      [[4896, 4934], "valid"],
      [[4935, 4935], "valid"],
      [[4936, 4954], "valid"],
      [[4955, 4956], "disallowed"],
      [[4957, 4958], "valid"],
      [[4959, 4959], "valid"],
      [[4960, 4960], "valid", [], "NV8"],
      [[4961, 4988], "valid", [], "NV8"],
      [[4989, 4991], "disallowed"],
      [[4992, 5007], "valid"],
      [[5008, 5017], "valid", [], "NV8"],
      [[5018, 5023], "disallowed"],
      [[5024, 5108], "valid"],
      [[5109, 5109], "valid"],
      [[5110, 5111], "disallowed"],
      [[5112, 5112], "mapped", [5104]],
      [[5113, 5113], "mapped", [5105]],
      [[5114, 5114], "mapped", [5106]],
      [[5115, 5115], "mapped", [5107]],
      [[5116, 5116], "mapped", [5108]],
      [[5117, 5117], "mapped", [5109]],
      [[5118, 5119], "disallowed"],
      [[5120, 5120], "valid", [], "NV8"],
      [[5121, 5740], "valid"],
      [[5741, 5742], "valid", [], "NV8"],
      [[5743, 5750], "valid"],
      [[5751, 5759], "valid"],
      [[5760, 5760], "disallowed"],
      [[5761, 5786], "valid"],
      [[5787, 5788], "valid", [], "NV8"],
      [[5789, 5791], "disallowed"],
      [[5792, 5866], "valid"],
      [[5867, 5872], "valid", [], "NV8"],
      [[5873, 5880], "valid"],
      [[5881, 5887], "disallowed"],
      [[5888, 5900], "valid"],
      [[5901, 5901], "disallowed"],
      [[5902, 5908], "valid"],
      [[5909, 5919], "disallowed"],
      [[5920, 5940], "valid"],
      [[5941, 5942], "valid", [], "NV8"],
      [[5943, 5951], "disallowed"],
      [[5952, 5971], "valid"],
      [[5972, 5983], "disallowed"],
      [[5984, 5996], "valid"],
      [[5997, 5997], "disallowed"],
      [[5998, 6e3], "valid"],
      [[6001, 6001], "disallowed"],
      [[6002, 6003], "valid"],
      [[6004, 6015], "disallowed"],
      [[6016, 6067], "valid"],
      [[6068, 6069], "disallowed"],
      [[6070, 6099], "valid"],
      [[6100, 6102], "valid", [], "NV8"],
      [[6103, 6103], "valid"],
      [[6104, 6107], "valid", [], "NV8"],
      [[6108, 6108], "valid"],
      [[6109, 6109], "valid"],
      [[6110, 6111], "disallowed"],
      [[6112, 6121], "valid"],
      [[6122, 6127], "disallowed"],
      [[6128, 6137], "valid", [], "NV8"],
      [[6138, 6143], "disallowed"],
      [[6144, 6149], "valid", [], "NV8"],
      [[6150, 6150], "disallowed"],
      [[6151, 6154], "valid", [], "NV8"],
      [[6155, 6157], "ignored"],
      [[6158, 6158], "disallowed"],
      [[6159, 6159], "disallowed"],
      [[6160, 6169], "valid"],
      [[6170, 6175], "disallowed"],
      [[6176, 6263], "valid"],
      [[6264, 6271], "disallowed"],
      [[6272, 6313], "valid"],
      [[6314, 6314], "valid"],
      [[6315, 6319], "disallowed"],
      [[6320, 6389], "valid"],
      [[6390, 6399], "disallowed"],
      [[6400, 6428], "valid"],
      [[6429, 6430], "valid"],
      [[6431, 6431], "disallowed"],
      [[6432, 6443], "valid"],
      [[6444, 6447], "disallowed"],
      [[6448, 6459], "valid"],
      [[6460, 6463], "disallowed"],
      [[6464, 6464], "valid", [], "NV8"],
      [[6465, 6467], "disallowed"],
      [[6468, 6469], "valid", [], "NV8"],
      [[6470, 6509], "valid"],
      [[6510, 6511], "disallowed"],
      [[6512, 6516], "valid"],
      [[6517, 6527], "disallowed"],
      [[6528, 6569], "valid"],
      [[6570, 6571], "valid"],
      [[6572, 6575], "disallowed"],
      [[6576, 6601], "valid"],
      [[6602, 6607], "disallowed"],
      [[6608, 6617], "valid"],
      [[6618, 6618], "valid", [], "XV8"],
      [[6619, 6621], "disallowed"],
      [[6622, 6623], "valid", [], "NV8"],
      [[6624, 6655], "valid", [], "NV8"],
      [[6656, 6683], "valid"],
      [[6684, 6685], "disallowed"],
      [[6686, 6687], "valid", [], "NV8"],
      [[6688, 6750], "valid"],
      [[6751, 6751], "disallowed"],
      [[6752, 6780], "valid"],
      [[6781, 6782], "disallowed"],
      [[6783, 6793], "valid"],
      [[6794, 6799], "disallowed"],
      [[6800, 6809], "valid"],
      [[6810, 6815], "disallowed"],
      [[6816, 6822], "valid", [], "NV8"],
      [[6823, 6823], "valid"],
      [[6824, 6829], "valid", [], "NV8"],
      [[6830, 6831], "disallowed"],
      [[6832, 6845], "valid"],
      [[6846, 6846], "valid", [], "NV8"],
      [[6847, 6911], "disallowed"],
      [[6912, 6987], "valid"],
      [[6988, 6991], "disallowed"],
      [[6992, 7001], "valid"],
      [[7002, 7018], "valid", [], "NV8"],
      [[7019, 7027], "valid"],
      [[7028, 7036], "valid", [], "NV8"],
      [[7037, 7039], "disallowed"],
      [[7040, 7082], "valid"],
      [[7083, 7085], "valid"],
      [[7086, 7097], "valid"],
      [[7098, 7103], "valid"],
      [[7104, 7155], "valid"],
      [[7156, 7163], "disallowed"],
      [[7164, 7167], "valid", [], "NV8"],
      [[7168, 7223], "valid"],
      [[7224, 7226], "disallowed"],
      [[7227, 7231], "valid", [], "NV8"],
      [[7232, 7241], "valid"],
      [[7242, 7244], "disallowed"],
      [[7245, 7293], "valid"],
      [[7294, 7295], "valid", [], "NV8"],
      [[7296, 7359], "disallowed"],
      [[7360, 7367], "valid", [], "NV8"],
      [[7368, 7375], "disallowed"],
      [[7376, 7378], "valid"],
      [[7379, 7379], "valid", [], "NV8"],
      [[7380, 7410], "valid"],
      [[7411, 7414], "valid"],
      [[7415, 7415], "disallowed"],
      [[7416, 7417], "valid"],
      [[7418, 7423], "disallowed"],
      [[7424, 7467], "valid"],
      [[7468, 7468], "mapped", [97]],
      [[7469, 7469], "mapped", [230]],
      [[7470, 7470], "mapped", [98]],
      [[7471, 7471], "valid"],
      [[7472, 7472], "mapped", [100]],
      [[7473, 7473], "mapped", [101]],
      [[7474, 7474], "mapped", [477]],
      [[7475, 7475], "mapped", [103]],
      [[7476, 7476], "mapped", [104]],
      [[7477, 7477], "mapped", [105]],
      [[7478, 7478], "mapped", [106]],
      [[7479, 7479], "mapped", [107]],
      [[7480, 7480], "mapped", [108]],
      [[7481, 7481], "mapped", [109]],
      [[7482, 7482], "mapped", [110]],
      [[7483, 7483], "valid"],
      [[7484, 7484], "mapped", [111]],
      [[7485, 7485], "mapped", [547]],
      [[7486, 7486], "mapped", [112]],
      [[7487, 7487], "mapped", [114]],
      [[7488, 7488], "mapped", [116]],
      [[7489, 7489], "mapped", [117]],
      [[7490, 7490], "mapped", [119]],
      [[7491, 7491], "mapped", [97]],
      [[7492, 7492], "mapped", [592]],
      [[7493, 7493], "mapped", [593]],
      [[7494, 7494], "mapped", [7426]],
      [[7495, 7495], "mapped", [98]],
      [[7496, 7496], "mapped", [100]],
      [[7497, 7497], "mapped", [101]],
      [[7498, 7498], "mapped", [601]],
      [[7499, 7499], "mapped", [603]],
      [[7500, 7500], "mapped", [604]],
      [[7501, 7501], "mapped", [103]],
      [[7502, 7502], "valid"],
      [[7503, 7503], "mapped", [107]],
      [[7504, 7504], "mapped", [109]],
      [[7505, 7505], "mapped", [331]],
      [[7506, 7506], "mapped", [111]],
      [[7507, 7507], "mapped", [596]],
      [[7508, 7508], "mapped", [7446]],
      [[7509, 7509], "mapped", [7447]],
      [[7510, 7510], "mapped", [112]],
      [[7511, 7511], "mapped", [116]],
      [[7512, 7512], "mapped", [117]],
      [[7513, 7513], "mapped", [7453]],
      [[7514, 7514], "mapped", [623]],
      [[7515, 7515], "mapped", [118]],
      [[7516, 7516], "mapped", [7461]],
      [[7517, 7517], "mapped", [946]],
      [[7518, 7518], "mapped", [947]],
      [[7519, 7519], "mapped", [948]],
      [[7520, 7520], "mapped", [966]],
      [[7521, 7521], "mapped", [967]],
      [[7522, 7522], "mapped", [105]],
      [[7523, 7523], "mapped", [114]],
      [[7524, 7524], "mapped", [117]],
      [[7525, 7525], "mapped", [118]],
      [[7526, 7526], "mapped", [946]],
      [[7527, 7527], "mapped", [947]],
      [[7528, 7528], "mapped", [961]],
      [[7529, 7529], "mapped", [966]],
      [[7530, 7530], "mapped", [967]],
      [[7531, 7531], "valid"],
      [[7532, 7543], "valid"],
      [[7544, 7544], "mapped", [1085]],
      [[7545, 7578], "valid"],
      [[7579, 7579], "mapped", [594]],
      [[7580, 7580], "mapped", [99]],
      [[7581, 7581], "mapped", [597]],
      [[7582, 7582], "mapped", [240]],
      [[7583, 7583], "mapped", [604]],
      [[7584, 7584], "mapped", [102]],
      [[7585, 7585], "mapped", [607]],
      [[7586, 7586], "mapped", [609]],
      [[7587, 7587], "mapped", [613]],
      [[7588, 7588], "mapped", [616]],
      [[7589, 7589], "mapped", [617]],
      [[7590, 7590], "mapped", [618]],
      [[7591, 7591], "mapped", [7547]],
      [[7592, 7592], "mapped", [669]],
      [[7593, 7593], "mapped", [621]],
      [[7594, 7594], "mapped", [7557]],
      [[7595, 7595], "mapped", [671]],
      [[7596, 7596], "mapped", [625]],
      [[7597, 7597], "mapped", [624]],
      [[7598, 7598], "mapped", [626]],
      [[7599, 7599], "mapped", [627]],
      [[7600, 7600], "mapped", [628]],
      [[7601, 7601], "mapped", [629]],
      [[7602, 7602], "mapped", [632]],
      [[7603, 7603], "mapped", [642]],
      [[7604, 7604], "mapped", [643]],
      [[7605, 7605], "mapped", [427]],
      [[7606, 7606], "mapped", [649]],
      [[7607, 7607], "mapped", [650]],
      [[7608, 7608], "mapped", [7452]],
      [[7609, 7609], "mapped", [651]],
      [[7610, 7610], "mapped", [652]],
      [[7611, 7611], "mapped", [122]],
      [[7612, 7612], "mapped", [656]],
      [[7613, 7613], "mapped", [657]],
      [[7614, 7614], "mapped", [658]],
      [[7615, 7615], "mapped", [952]],
      [[7616, 7619], "valid"],
      [[7620, 7626], "valid"],
      [[7627, 7654], "valid"],
      [[7655, 7669], "valid"],
      [[7670, 7675], "disallowed"],
      [[7676, 7676], "valid"],
      [[7677, 7677], "valid"],
      [[7678, 7679], "valid"],
      [[7680, 7680], "mapped", [7681]],
      [[7681, 7681], "valid"],
      [[7682, 7682], "mapped", [7683]],
      [[7683, 7683], "valid"],
      [[7684, 7684], "mapped", [7685]],
      [[7685, 7685], "valid"],
      [[7686, 7686], "mapped", [7687]],
      [[7687, 7687], "valid"],
      [[7688, 7688], "mapped", [7689]],
      [[7689, 7689], "valid"],
      [[7690, 7690], "mapped", [7691]],
      [[7691, 7691], "valid"],
      [[7692, 7692], "mapped", [7693]],
      [[7693, 7693], "valid"],
      [[7694, 7694], "mapped", [7695]],
      [[7695, 7695], "valid"],
      [[7696, 7696], "mapped", [7697]],
      [[7697, 7697], "valid"],
      [[7698, 7698], "mapped", [7699]],
      [[7699, 7699], "valid"],
      [[7700, 7700], "mapped", [7701]],
      [[7701, 7701], "valid"],
      [[7702, 7702], "mapped", [7703]],
      [[7703, 7703], "valid"],
      [[7704, 7704], "mapped", [7705]],
      [[7705, 7705], "valid"],
      [[7706, 7706], "mapped", [7707]],
      [[7707, 7707], "valid"],
      [[7708, 7708], "mapped", [7709]],
      [[7709, 7709], "valid"],
      [[7710, 7710], "mapped", [7711]],
      [[7711, 7711], "valid"],
      [[7712, 7712], "mapped", [7713]],
      [[7713, 7713], "valid"],
      [[7714, 7714], "mapped", [7715]],
      [[7715, 7715], "valid"],
      [[7716, 7716], "mapped", [7717]],
      [[7717, 7717], "valid"],
      [[7718, 7718], "mapped", [7719]],
      [[7719, 7719], "valid"],
      [[7720, 7720], "mapped", [7721]],
      [[7721, 7721], "valid"],
      [[7722, 7722], "mapped", [7723]],
      [[7723, 7723], "valid"],
      [[7724, 7724], "mapped", [7725]],
      [[7725, 7725], "valid"],
      [[7726, 7726], "mapped", [7727]],
      [[7727, 7727], "valid"],
      [[7728, 7728], "mapped", [7729]],
      [[7729, 7729], "valid"],
      [[7730, 7730], "mapped", [7731]],
      [[7731, 7731], "valid"],
      [[7732, 7732], "mapped", [7733]],
      [[7733, 7733], "valid"],
      [[7734, 7734], "mapped", [7735]],
      [[7735, 7735], "valid"],
      [[7736, 7736], "mapped", [7737]],
      [[7737, 7737], "valid"],
      [[7738, 7738], "mapped", [7739]],
      [[7739, 7739], "valid"],
      [[7740, 7740], "mapped", [7741]],
      [[7741, 7741], "valid"],
      [[7742, 7742], "mapped", [7743]],
      [[7743, 7743], "valid"],
      [[7744, 7744], "mapped", [7745]],
      [[7745, 7745], "valid"],
      [[7746, 7746], "mapped", [7747]],
      [[7747, 7747], "valid"],
      [[7748, 7748], "mapped", [7749]],
      [[7749, 7749], "valid"],
      [[7750, 7750], "mapped", [7751]],
      [[7751, 7751], "valid"],
      [[7752, 7752], "mapped", [7753]],
      [[7753, 7753], "valid"],
      [[7754, 7754], "mapped", [7755]],
      [[7755, 7755], "valid"],
      [[7756, 7756], "mapped", [7757]],
      [[7757, 7757], "valid"],
      [[7758, 7758], "mapped", [7759]],
      [[7759, 7759], "valid"],
      [[7760, 7760], "mapped", [7761]],
      [[7761, 7761], "valid"],
      [[7762, 7762], "mapped", [7763]],
      [[7763, 7763], "valid"],
      [[7764, 7764], "mapped", [7765]],
      [[7765, 7765], "valid"],
      [[7766, 7766], "mapped", [7767]],
      [[7767, 7767], "valid"],
      [[7768, 7768], "mapped", [7769]],
      [[7769, 7769], "valid"],
      [[7770, 7770], "mapped", [7771]],
      [[7771, 7771], "valid"],
      [[7772, 7772], "mapped", [7773]],
      [[7773, 7773], "valid"],
      [[7774, 7774], "mapped", [7775]],
      [[7775, 7775], "valid"],
      [[7776, 7776], "mapped", [7777]],
      [[7777, 7777], "valid"],
      [[7778, 7778], "mapped", [7779]],
      [[7779, 7779], "valid"],
      [[7780, 7780], "mapped", [7781]],
      [[7781, 7781], "valid"],
      [[7782, 7782], "mapped", [7783]],
      [[7783, 7783], "valid"],
      [[7784, 7784], "mapped", [7785]],
      [[7785, 7785], "valid"],
      [[7786, 7786], "mapped", [7787]],
      [[7787, 7787], "valid"],
      [[7788, 7788], "mapped", [7789]],
      [[7789, 7789], "valid"],
      [[7790, 7790], "mapped", [7791]],
      [[7791, 7791], "valid"],
      [[7792, 7792], "mapped", [7793]],
      [[7793, 7793], "valid"],
      [[7794, 7794], "mapped", [7795]],
      [[7795, 7795], "valid"],
      [[7796, 7796], "mapped", [7797]],
      [[7797, 7797], "valid"],
      [[7798, 7798], "mapped", [7799]],
      [[7799, 7799], "valid"],
      [[7800, 7800], "mapped", [7801]],
      [[7801, 7801], "valid"],
      [[7802, 7802], "mapped", [7803]],
      [[7803, 7803], "valid"],
      [[7804, 7804], "mapped", [7805]],
      [[7805, 7805], "valid"],
      [[7806, 7806], "mapped", [7807]],
      [[7807, 7807], "valid"],
      [[7808, 7808], "mapped", [7809]],
      [[7809, 7809], "valid"],
      [[7810, 7810], "mapped", [7811]],
      [[7811, 7811], "valid"],
      [[7812, 7812], "mapped", [7813]],
      [[7813, 7813], "valid"],
      [[7814, 7814], "mapped", [7815]],
      [[7815, 7815], "valid"],
      [[7816, 7816], "mapped", [7817]],
      [[7817, 7817], "valid"],
      [[7818, 7818], "mapped", [7819]],
      [[7819, 7819], "valid"],
      [[7820, 7820], "mapped", [7821]],
      [[7821, 7821], "valid"],
      [[7822, 7822], "mapped", [7823]],
      [[7823, 7823], "valid"],
      [[7824, 7824], "mapped", [7825]],
      [[7825, 7825], "valid"],
      [[7826, 7826], "mapped", [7827]],
      [[7827, 7827], "valid"],
      [[7828, 7828], "mapped", [7829]],
      [[7829, 7833], "valid"],
      [[7834, 7834], "mapped", [97, 702]],
      [[7835, 7835], "mapped", [7777]],
      [[7836, 7837], "valid"],
      [[7838, 7838], "mapped", [115, 115]],
      [[7839, 7839], "valid"],
      [[7840, 7840], "mapped", [7841]],
      [[7841, 7841], "valid"],
      [[7842, 7842], "mapped", [7843]],
      [[7843, 7843], "valid"],
      [[7844, 7844], "mapped", [7845]],
      [[7845, 7845], "valid"],
      [[7846, 7846], "mapped", [7847]],
      [[7847, 7847], "valid"],
      [[7848, 7848], "mapped", [7849]],
      [[7849, 7849], "valid"],
      [[7850, 7850], "mapped", [7851]],
      [[7851, 7851], "valid"],
      [[7852, 7852], "mapped", [7853]],
      [[7853, 7853], "valid"],
      [[7854, 7854], "mapped", [7855]],
      [[7855, 7855], "valid"],
      [[7856, 7856], "mapped", [7857]],
      [[7857, 7857], "valid"],
      [[7858, 7858], "mapped", [7859]],
      [[7859, 7859], "valid"],
      [[7860, 7860], "mapped", [7861]],
      [[7861, 7861], "valid"],
      [[7862, 7862], "mapped", [7863]],
      [[7863, 7863], "valid"],
      [[7864, 7864], "mapped", [7865]],
      [[7865, 7865], "valid"],
      [[7866, 7866], "mapped", [7867]],
      [[7867, 7867], "valid"],
      [[7868, 7868], "mapped", [7869]],
      [[7869, 7869], "valid"],
      [[7870, 7870], "mapped", [7871]],
      [[7871, 7871], "valid"],
      [[7872, 7872], "mapped", [7873]],
      [[7873, 7873], "valid"],
      [[7874, 7874], "mapped", [7875]],
      [[7875, 7875], "valid"],
      [[7876, 7876], "mapped", [7877]],
      [[7877, 7877], "valid"],
      [[7878, 7878], "mapped", [7879]],
      [[7879, 7879], "valid"],
      [[7880, 7880], "mapped", [7881]],
      [[7881, 7881], "valid"],
      [[7882, 7882], "mapped", [7883]],
      [[7883, 7883], "valid"],
      [[7884, 7884], "mapped", [7885]],
      [[7885, 7885], "valid"],
      [[7886, 7886], "mapped", [7887]],
      [[7887, 7887], "valid"],
      [[7888, 7888], "mapped", [7889]],
      [[7889, 7889], "valid"],
      [[7890, 7890], "mapped", [7891]],
      [[7891, 7891], "valid"],
      [[7892, 7892], "mapped", [7893]],
      [[7893, 7893], "valid"],
      [[7894, 7894], "mapped", [7895]],
      [[7895, 7895], "valid"],
      [[7896, 7896], "mapped", [7897]],
      [[7897, 7897], "valid"],
      [[7898, 7898], "mapped", [7899]],
      [[7899, 7899], "valid"],
      [[7900, 7900], "mapped", [7901]],
      [[7901, 7901], "valid"],
      [[7902, 7902], "mapped", [7903]],
      [[7903, 7903], "valid"],
      [[7904, 7904], "mapped", [7905]],
      [[7905, 7905], "valid"],
      [[7906, 7906], "mapped", [7907]],
      [[7907, 7907], "valid"],
      [[7908, 7908], "mapped", [7909]],
      [[7909, 7909], "valid"],
      [[7910, 7910], "mapped", [7911]],
      [[7911, 7911], "valid"],
      [[7912, 7912], "mapped", [7913]],
      [[7913, 7913], "valid"],
      [[7914, 7914], "mapped", [7915]],
      [[7915, 7915], "valid"],
      [[7916, 7916], "mapped", [7917]],
      [[7917, 7917], "valid"],
      [[7918, 7918], "mapped", [7919]],
      [[7919, 7919], "valid"],
      [[7920, 7920], "mapped", [7921]],
      [[7921, 7921], "valid"],
      [[7922, 7922], "mapped", [7923]],
      [[7923, 7923], "valid"],
      [[7924, 7924], "mapped", [7925]],
      [[7925, 7925], "valid"],
      [[7926, 7926], "mapped", [7927]],
      [[7927, 7927], "valid"],
      [[7928, 7928], "mapped", [7929]],
      [[7929, 7929], "valid"],
      [[7930, 7930], "mapped", [7931]],
      [[7931, 7931], "valid"],
      [[7932, 7932], "mapped", [7933]],
      [[7933, 7933], "valid"],
      [[7934, 7934], "mapped", [7935]],
      [[7935, 7935], "valid"],
      [[7936, 7943], "valid"],
      [[7944, 7944], "mapped", [7936]],
      [[7945, 7945], "mapped", [7937]],
      [[7946, 7946], "mapped", [7938]],
      [[7947, 7947], "mapped", [7939]],
      [[7948, 7948], "mapped", [7940]],
      [[7949, 7949], "mapped", [7941]],
      [[7950, 7950], "mapped", [7942]],
      [[7951, 7951], "mapped", [7943]],
      [[7952, 7957], "valid"],
      [[7958, 7959], "disallowed"],
      [[7960, 7960], "mapped", [7952]],
      [[7961, 7961], "mapped", [7953]],
      [[7962, 7962], "mapped", [7954]],
      [[7963, 7963], "mapped", [7955]],
      [[7964, 7964], "mapped", [7956]],
      [[7965, 7965], "mapped", [7957]],
      [[7966, 7967], "disallowed"],
      [[7968, 7975], "valid"],
      [[7976, 7976], "mapped", [7968]],
      [[7977, 7977], "mapped", [7969]],
      [[7978, 7978], "mapped", [7970]],
      [[7979, 7979], "mapped", [7971]],
      [[7980, 7980], "mapped", [7972]],
      [[7981, 7981], "mapped", [7973]],
      [[7982, 7982], "mapped", [7974]],
      [[7983, 7983], "mapped", [7975]],
      [[7984, 7991], "valid"],
      [[7992, 7992], "mapped", [7984]],
      [[7993, 7993], "mapped", [7985]],
      [[7994, 7994], "mapped", [7986]],
      [[7995, 7995], "mapped", [7987]],
      [[7996, 7996], "mapped", [7988]],
      [[7997, 7997], "mapped", [7989]],
      [[7998, 7998], "mapped", [7990]],
      [[7999, 7999], "mapped", [7991]],
      [[8e3, 8005], "valid"],
      [[8006, 8007], "disallowed"],
      [[8008, 8008], "mapped", [8e3]],
      [[8009, 8009], "mapped", [8001]],
      [[8010, 8010], "mapped", [8002]],
      [[8011, 8011], "mapped", [8003]],
      [[8012, 8012], "mapped", [8004]],
      [[8013, 8013], "mapped", [8005]],
      [[8014, 8015], "disallowed"],
      [[8016, 8023], "valid"],
      [[8024, 8024], "disallowed"],
      [[8025, 8025], "mapped", [8017]],
      [[8026, 8026], "disallowed"],
      [[8027, 8027], "mapped", [8019]],
      [[8028, 8028], "disallowed"],
      [[8029, 8029], "mapped", [8021]],
      [[8030, 8030], "disallowed"],
      [[8031, 8031], "mapped", [8023]],
      [[8032, 8039], "valid"],
      [[8040, 8040], "mapped", [8032]],
      [[8041, 8041], "mapped", [8033]],
      [[8042, 8042], "mapped", [8034]],
      [[8043, 8043], "mapped", [8035]],
      [[8044, 8044], "mapped", [8036]],
      [[8045, 8045], "mapped", [8037]],
      [[8046, 8046], "mapped", [8038]],
      [[8047, 8047], "mapped", [8039]],
      [[8048, 8048], "valid"],
      [[8049, 8049], "mapped", [940]],
      [[8050, 8050], "valid"],
      [[8051, 8051], "mapped", [941]],
      [[8052, 8052], "valid"],
      [[8053, 8053], "mapped", [942]],
      [[8054, 8054], "valid"],
      [[8055, 8055], "mapped", [943]],
      [[8056, 8056], "valid"],
      [[8057, 8057], "mapped", [972]],
      [[8058, 8058], "valid"],
      [[8059, 8059], "mapped", [973]],
      [[8060, 8060], "valid"],
      [[8061, 8061], "mapped", [974]],
      [[8062, 8063], "disallowed"],
      [[8064, 8064], "mapped", [7936, 953]],
      [[8065, 8065], "mapped", [7937, 953]],
      [[8066, 8066], "mapped", [7938, 953]],
      [[8067, 8067], "mapped", [7939, 953]],
      [[8068, 8068], "mapped", [7940, 953]],
      [[8069, 8069], "mapped", [7941, 953]],
      [[8070, 8070], "mapped", [7942, 953]],
      [[8071, 8071], "mapped", [7943, 953]],
      [[8072, 8072], "mapped", [7936, 953]],
      [[8073, 8073], "mapped", [7937, 953]],
      [[8074, 8074], "mapped", [7938, 953]],
      [[8075, 8075], "mapped", [7939, 953]],
      [[8076, 8076], "mapped", [7940, 953]],
      [[8077, 8077], "mapped", [7941, 953]],
      [[8078, 8078], "mapped", [7942, 953]],
      [[8079, 8079], "mapped", [7943, 953]],
      [[8080, 8080], "mapped", [7968, 953]],
      [[8081, 8081], "mapped", [7969, 953]],
      [[8082, 8082], "mapped", [7970, 953]],
      [[8083, 8083], "mapped", [7971, 953]],
      [[8084, 8084], "mapped", [7972, 953]],
      [[8085, 8085], "mapped", [7973, 953]],
      [[8086, 8086], "mapped", [7974, 953]],
      [[8087, 8087], "mapped", [7975, 953]],
      [[8088, 8088], "mapped", [7968, 953]],
      [[8089, 8089], "mapped", [7969, 953]],
      [[8090, 8090], "mapped", [7970, 953]],
      [[8091, 8091], "mapped", [7971, 953]],
      [[8092, 8092], "mapped", [7972, 953]],
      [[8093, 8093], "mapped", [7973, 953]],
      [[8094, 8094], "mapped", [7974, 953]],
      [[8095, 8095], "mapped", [7975, 953]],
      [[8096, 8096], "mapped", [8032, 953]],
      [[8097, 8097], "mapped", [8033, 953]],
      [[8098, 8098], "mapped", [8034, 953]],
      [[8099, 8099], "mapped", [8035, 953]],
      [[8100, 8100], "mapped", [8036, 953]],
      [[8101, 8101], "mapped", [8037, 953]],
      [[8102, 8102], "mapped", [8038, 953]],
      [[8103, 8103], "mapped", [8039, 953]],
      [[8104, 8104], "mapped", [8032, 953]],
      [[8105, 8105], "mapped", [8033, 953]],
      [[8106, 8106], "mapped", [8034, 953]],
      [[8107, 8107], "mapped", [8035, 953]],
      [[8108, 8108], "mapped", [8036, 953]],
      [[8109, 8109], "mapped", [8037, 953]],
      [[8110, 8110], "mapped", [8038, 953]],
      [[8111, 8111], "mapped", [8039, 953]],
      [[8112, 8113], "valid"],
      [[8114, 8114], "mapped", [8048, 953]],
      [[8115, 8115], "mapped", [945, 953]],
      [[8116, 8116], "mapped", [940, 953]],
      [[8117, 8117], "disallowed"],
      [[8118, 8118], "valid"],
      [[8119, 8119], "mapped", [8118, 953]],
      [[8120, 8120], "mapped", [8112]],
      [[8121, 8121], "mapped", [8113]],
      [[8122, 8122], "mapped", [8048]],
      [[8123, 8123], "mapped", [940]],
      [[8124, 8124], "mapped", [945, 953]],
      [[8125, 8125], "disallowed_STD3_mapped", [32, 787]],
      [[8126, 8126], "mapped", [953]],
      [[8127, 8127], "disallowed_STD3_mapped", [32, 787]],
      [[8128, 8128], "disallowed_STD3_mapped", [32, 834]],
      [[8129, 8129], "disallowed_STD3_mapped", [32, 776, 834]],
      [[8130, 8130], "mapped", [8052, 953]],
      [[8131, 8131], "mapped", [951, 953]],
      [[8132, 8132], "mapped", [942, 953]],
      [[8133, 8133], "disallowed"],
      [[8134, 8134], "valid"],
      [[8135, 8135], "mapped", [8134, 953]],
      [[8136, 8136], "mapped", [8050]],
      [[8137, 8137], "mapped", [941]],
      [[8138, 8138], "mapped", [8052]],
      [[8139, 8139], "mapped", [942]],
      [[8140, 8140], "mapped", [951, 953]],
      [[8141, 8141], "disallowed_STD3_mapped", [32, 787, 768]],
      [[8142, 8142], "disallowed_STD3_mapped", [32, 787, 769]],
      [[8143, 8143], "disallowed_STD3_mapped", [32, 787, 834]],
      [[8144, 8146], "valid"],
      [[8147, 8147], "mapped", [912]],
      [[8148, 8149], "disallowed"],
      [[8150, 8151], "valid"],
      [[8152, 8152], "mapped", [8144]],
      [[8153, 8153], "mapped", [8145]],
      [[8154, 8154], "mapped", [8054]],
      [[8155, 8155], "mapped", [943]],
      [[8156, 8156], "disallowed"],
      [[8157, 8157], "disallowed_STD3_mapped", [32, 788, 768]],
      [[8158, 8158], "disallowed_STD3_mapped", [32, 788, 769]],
      [[8159, 8159], "disallowed_STD3_mapped", [32, 788, 834]],
      [[8160, 8162], "valid"],
      [[8163, 8163], "mapped", [944]],
      [[8164, 8167], "valid"],
      [[8168, 8168], "mapped", [8160]],
      [[8169, 8169], "mapped", [8161]],
      [[8170, 8170], "mapped", [8058]],
      [[8171, 8171], "mapped", [973]],
      [[8172, 8172], "mapped", [8165]],
      [[8173, 8173], "disallowed_STD3_mapped", [32, 776, 768]],
      [[8174, 8174], "disallowed_STD3_mapped", [32, 776, 769]],
      [[8175, 8175], "disallowed_STD3_mapped", [96]],
      [[8176, 8177], "disallowed"],
      [[8178, 8178], "mapped", [8060, 953]],
      [[8179, 8179], "mapped", [969, 953]],
      [[8180, 8180], "mapped", [974, 953]],
      [[8181, 8181], "disallowed"],
      [[8182, 8182], "valid"],
      [[8183, 8183], "mapped", [8182, 953]],
      [[8184, 8184], "mapped", [8056]],
      [[8185, 8185], "mapped", [972]],
      [[8186, 8186], "mapped", [8060]],
      [[8187, 8187], "mapped", [974]],
      [[8188, 8188], "mapped", [969, 953]],
      [[8189, 8189], "disallowed_STD3_mapped", [32, 769]],
      [[8190, 8190], "disallowed_STD3_mapped", [32, 788]],
      [[8191, 8191], "disallowed"],
      [[8192, 8202], "disallowed_STD3_mapped", [32]],
      [[8203, 8203], "ignored"],
      [[8204, 8205], "deviation", []],
      [[8206, 8207], "disallowed"],
      [[8208, 8208], "valid", [], "NV8"],
      [[8209, 8209], "mapped", [8208]],
      [[8210, 8214], "valid", [], "NV8"],
      [[8215, 8215], "disallowed_STD3_mapped", [32, 819]],
      [[8216, 8227], "valid", [], "NV8"],
      [[8228, 8230], "disallowed"],
      [[8231, 8231], "valid", [], "NV8"],
      [[8232, 8238], "disallowed"],
      [[8239, 8239], "disallowed_STD3_mapped", [32]],
      [[8240, 8242], "valid", [], "NV8"],
      [[8243, 8243], "mapped", [8242, 8242]],
      [[8244, 8244], "mapped", [8242, 8242, 8242]],
      [[8245, 8245], "valid", [], "NV8"],
      [[8246, 8246], "mapped", [8245, 8245]],
      [[8247, 8247], "mapped", [8245, 8245, 8245]],
      [[8248, 8251], "valid", [], "NV8"],
      [[8252, 8252], "disallowed_STD3_mapped", [33, 33]],
      [[8253, 8253], "valid", [], "NV8"],
      [[8254, 8254], "disallowed_STD3_mapped", [32, 773]],
      [[8255, 8262], "valid", [], "NV8"],
      [[8263, 8263], "disallowed_STD3_mapped", [63, 63]],
      [[8264, 8264], "disallowed_STD3_mapped", [63, 33]],
      [[8265, 8265], "disallowed_STD3_mapped", [33, 63]],
      [[8266, 8269], "valid", [], "NV8"],
      [[8270, 8274], "valid", [], "NV8"],
      [[8275, 8276], "valid", [], "NV8"],
      [[8277, 8278], "valid", [], "NV8"],
      [[8279, 8279], "mapped", [8242, 8242, 8242, 8242]],
      [[8280, 8286], "valid", [], "NV8"],
      [[8287, 8287], "disallowed_STD3_mapped", [32]],
      [[8288, 8288], "ignored"],
      [[8289, 8291], "disallowed"],
      [[8292, 8292], "ignored"],
      [[8293, 8293], "disallowed"],
      [[8294, 8297], "disallowed"],
      [[8298, 8303], "disallowed"],
      [[8304, 8304], "mapped", [48]],
      [[8305, 8305], "mapped", [105]],
      [[8306, 8307], "disallowed"],
      [[8308, 8308], "mapped", [52]],
      [[8309, 8309], "mapped", [53]],
      [[8310, 8310], "mapped", [54]],
      [[8311, 8311], "mapped", [55]],
      [[8312, 8312], "mapped", [56]],
      [[8313, 8313], "mapped", [57]],
      [[8314, 8314], "disallowed_STD3_mapped", [43]],
      [[8315, 8315], "mapped", [8722]],
      [[8316, 8316], "disallowed_STD3_mapped", [61]],
      [[8317, 8317], "disallowed_STD3_mapped", [40]],
      [[8318, 8318], "disallowed_STD3_mapped", [41]],
      [[8319, 8319], "mapped", [110]],
      [[8320, 8320], "mapped", [48]],
      [[8321, 8321], "mapped", [49]],
      [[8322, 8322], "mapped", [50]],
      [[8323, 8323], "mapped", [51]],
      [[8324, 8324], "mapped", [52]],
      [[8325, 8325], "mapped", [53]],
      [[8326, 8326], "mapped", [54]],
      [[8327, 8327], "mapped", [55]],
      [[8328, 8328], "mapped", [56]],
      [[8329, 8329], "mapped", [57]],
      [[8330, 8330], "disallowed_STD3_mapped", [43]],
      [[8331, 8331], "mapped", [8722]],
      [[8332, 8332], "disallowed_STD3_mapped", [61]],
      [[8333, 8333], "disallowed_STD3_mapped", [40]],
      [[8334, 8334], "disallowed_STD3_mapped", [41]],
      [[8335, 8335], "disallowed"],
      [[8336, 8336], "mapped", [97]],
      [[8337, 8337], "mapped", [101]],
      [[8338, 8338], "mapped", [111]],
      [[8339, 8339], "mapped", [120]],
      [[8340, 8340], "mapped", [601]],
      [[8341, 8341], "mapped", [104]],
      [[8342, 8342], "mapped", [107]],
      [[8343, 8343], "mapped", [108]],
      [[8344, 8344], "mapped", [109]],
      [[8345, 8345], "mapped", [110]],
      [[8346, 8346], "mapped", [112]],
      [[8347, 8347], "mapped", [115]],
      [[8348, 8348], "mapped", [116]],
      [[8349, 8351], "disallowed"],
      [[8352, 8359], "valid", [], "NV8"],
      [[8360, 8360], "mapped", [114, 115]],
      [[8361, 8362], "valid", [], "NV8"],
      [[8363, 8363], "valid", [], "NV8"],
      [[8364, 8364], "valid", [], "NV8"],
      [[8365, 8367], "valid", [], "NV8"],
      [[8368, 8369], "valid", [], "NV8"],
      [[8370, 8373], "valid", [], "NV8"],
      [[8374, 8376], "valid", [], "NV8"],
      [[8377, 8377], "valid", [], "NV8"],
      [[8378, 8378], "valid", [], "NV8"],
      [[8379, 8381], "valid", [], "NV8"],
      [[8382, 8382], "valid", [], "NV8"],
      [[8383, 8399], "disallowed"],
      [[8400, 8417], "valid", [], "NV8"],
      [[8418, 8419], "valid", [], "NV8"],
      [[8420, 8426], "valid", [], "NV8"],
      [[8427, 8427], "valid", [], "NV8"],
      [[8428, 8431], "valid", [], "NV8"],
      [[8432, 8432], "valid", [], "NV8"],
      [[8433, 8447], "disallowed"],
      [[8448, 8448], "disallowed_STD3_mapped", [97, 47, 99]],
      [[8449, 8449], "disallowed_STD3_mapped", [97, 47, 115]],
      [[8450, 8450], "mapped", [99]],
      [[8451, 8451], "mapped", [176, 99]],
      [[8452, 8452], "valid", [], "NV8"],
      [[8453, 8453], "disallowed_STD3_mapped", [99, 47, 111]],
      [[8454, 8454], "disallowed_STD3_mapped", [99, 47, 117]],
      [[8455, 8455], "mapped", [603]],
      [[8456, 8456], "valid", [], "NV8"],
      [[8457, 8457], "mapped", [176, 102]],
      [[8458, 8458], "mapped", [103]],
      [[8459, 8462], "mapped", [104]],
      [[8463, 8463], "mapped", [295]],
      [[8464, 8465], "mapped", [105]],
      [[8466, 8467], "mapped", [108]],
      [[8468, 8468], "valid", [], "NV8"],
      [[8469, 8469], "mapped", [110]],
      [[8470, 8470], "mapped", [110, 111]],
      [[8471, 8472], "valid", [], "NV8"],
      [[8473, 8473], "mapped", [112]],
      [[8474, 8474], "mapped", [113]],
      [[8475, 8477], "mapped", [114]],
      [[8478, 8479], "valid", [], "NV8"],
      [[8480, 8480], "mapped", [115, 109]],
      [[8481, 8481], "mapped", [116, 101, 108]],
      [[8482, 8482], "mapped", [116, 109]],
      [[8483, 8483], "valid", [], "NV8"],
      [[8484, 8484], "mapped", [122]],
      [[8485, 8485], "valid", [], "NV8"],
      [[8486, 8486], "mapped", [969]],
      [[8487, 8487], "valid", [], "NV8"],
      [[8488, 8488], "mapped", [122]],
      [[8489, 8489], "valid", [], "NV8"],
      [[8490, 8490], "mapped", [107]],
      [[8491, 8491], "mapped", [229]],
      [[8492, 8492], "mapped", [98]],
      [[8493, 8493], "mapped", [99]],
      [[8494, 8494], "valid", [], "NV8"],
      [[8495, 8496], "mapped", [101]],
      [[8497, 8497], "mapped", [102]],
      [[8498, 8498], "disallowed"],
      [[8499, 8499], "mapped", [109]],
      [[8500, 8500], "mapped", [111]],
      [[8501, 8501], "mapped", [1488]],
      [[8502, 8502], "mapped", [1489]],
      [[8503, 8503], "mapped", [1490]],
      [[8504, 8504], "mapped", [1491]],
      [[8505, 8505], "mapped", [105]],
      [[8506, 8506], "valid", [], "NV8"],
      [[8507, 8507], "mapped", [102, 97, 120]],
      [[8508, 8508], "mapped", [960]],
      [[8509, 8510], "mapped", [947]],
      [[8511, 8511], "mapped", [960]],
      [[8512, 8512], "mapped", [8721]],
      [[8513, 8516], "valid", [], "NV8"],
      [[8517, 8518], "mapped", [100]],
      [[8519, 8519], "mapped", [101]],
      [[8520, 8520], "mapped", [105]],
      [[8521, 8521], "mapped", [106]],
      [[8522, 8523], "valid", [], "NV8"],
      [[8524, 8524], "valid", [], "NV8"],
      [[8525, 8525], "valid", [], "NV8"],
      [[8526, 8526], "valid"],
      [[8527, 8527], "valid", [], "NV8"],
      [[8528, 8528], "mapped", [49, 8260, 55]],
      [[8529, 8529], "mapped", [49, 8260, 57]],
      [[8530, 8530], "mapped", [49, 8260, 49, 48]],
      [[8531, 8531], "mapped", [49, 8260, 51]],
      [[8532, 8532], "mapped", [50, 8260, 51]],
      [[8533, 8533], "mapped", [49, 8260, 53]],
      [[8534, 8534], "mapped", [50, 8260, 53]],
      [[8535, 8535], "mapped", [51, 8260, 53]],
      [[8536, 8536], "mapped", [52, 8260, 53]],
      [[8537, 8537], "mapped", [49, 8260, 54]],
      [[8538, 8538], "mapped", [53, 8260, 54]],
      [[8539, 8539], "mapped", [49, 8260, 56]],
      [[8540, 8540], "mapped", [51, 8260, 56]],
      [[8541, 8541], "mapped", [53, 8260, 56]],
      [[8542, 8542], "mapped", [55, 8260, 56]],
      [[8543, 8543], "mapped", [49, 8260]],
      [[8544, 8544], "mapped", [105]],
      [[8545, 8545], "mapped", [105, 105]],
      [[8546, 8546], "mapped", [105, 105, 105]],
      [[8547, 8547], "mapped", [105, 118]],
      [[8548, 8548], "mapped", [118]],
      [[8549, 8549], "mapped", [118, 105]],
      [[8550, 8550], "mapped", [118, 105, 105]],
      [[8551, 8551], "mapped", [118, 105, 105, 105]],
      [[8552, 8552], "mapped", [105, 120]],
      [[8553, 8553], "mapped", [120]],
      [[8554, 8554], "mapped", [120, 105]],
      [[8555, 8555], "mapped", [120, 105, 105]],
      [[8556, 8556], "mapped", [108]],
      [[8557, 8557], "mapped", [99]],
      [[8558, 8558], "mapped", [100]],
      [[8559, 8559], "mapped", [109]],
      [[8560, 8560], "mapped", [105]],
      [[8561, 8561], "mapped", [105, 105]],
      [[8562, 8562], "mapped", [105, 105, 105]],
      [[8563, 8563], "mapped", [105, 118]],
      [[8564, 8564], "mapped", [118]],
      [[8565, 8565], "mapped", [118, 105]],
      [[8566, 8566], "mapped", [118, 105, 105]],
      [[8567, 8567], "mapped", [118, 105, 105, 105]],
      [[8568, 8568], "mapped", [105, 120]],
      [[8569, 8569], "mapped", [120]],
      [[8570, 8570], "mapped", [120, 105]],
      [[8571, 8571], "mapped", [120, 105, 105]],
      [[8572, 8572], "mapped", [108]],
      [[8573, 8573], "mapped", [99]],
      [[8574, 8574], "mapped", [100]],
      [[8575, 8575], "mapped", [109]],
      [[8576, 8578], "valid", [], "NV8"],
      [[8579, 8579], "disallowed"],
      [[8580, 8580], "valid"],
      [[8581, 8584], "valid", [], "NV8"],
      [[8585, 8585], "mapped", [48, 8260, 51]],
      [[8586, 8587], "valid", [], "NV8"],
      [[8588, 8591], "disallowed"],
      [[8592, 8682], "valid", [], "NV8"],
      [[8683, 8691], "valid", [], "NV8"],
      [[8692, 8703], "valid", [], "NV8"],
      [[8704, 8747], "valid", [], "NV8"],
      [[8748, 8748], "mapped", [8747, 8747]],
      [[8749, 8749], "mapped", [8747, 8747, 8747]],
      [[8750, 8750], "valid", [], "NV8"],
      [[8751, 8751], "mapped", [8750, 8750]],
      [[8752, 8752], "mapped", [8750, 8750, 8750]],
      [[8753, 8799], "valid", [], "NV8"],
      [[8800, 8800], "disallowed_STD3_valid"],
      [[8801, 8813], "valid", [], "NV8"],
      [[8814, 8815], "disallowed_STD3_valid"],
      [[8816, 8945], "valid", [], "NV8"],
      [[8946, 8959], "valid", [], "NV8"],
      [[8960, 8960], "valid", [], "NV8"],
      [[8961, 8961], "valid", [], "NV8"],
      [[8962, 9e3], "valid", [], "NV8"],
      [[9001, 9001], "mapped", [12296]],
      [[9002, 9002], "mapped", [12297]],
      [[9003, 9082], "valid", [], "NV8"],
      [[9083, 9083], "valid", [], "NV8"],
      [[9084, 9084], "valid", [], "NV8"],
      [[9085, 9114], "valid", [], "NV8"],
      [[9115, 9166], "valid", [], "NV8"],
      [[9167, 9168], "valid", [], "NV8"],
      [[9169, 9179], "valid", [], "NV8"],
      [[9180, 9191], "valid", [], "NV8"],
      [[9192, 9192], "valid", [], "NV8"],
      [[9193, 9203], "valid", [], "NV8"],
      [[9204, 9210], "valid", [], "NV8"],
      [[9211, 9215], "disallowed"],
      [[9216, 9252], "valid", [], "NV8"],
      [[9253, 9254], "valid", [], "NV8"],
      [[9255, 9279], "disallowed"],
      [[9280, 9290], "valid", [], "NV8"],
      [[9291, 9311], "disallowed"],
      [[9312, 9312], "mapped", [49]],
      [[9313, 9313], "mapped", [50]],
      [[9314, 9314], "mapped", [51]],
      [[9315, 9315], "mapped", [52]],
      [[9316, 9316], "mapped", [53]],
      [[9317, 9317], "mapped", [54]],
      [[9318, 9318], "mapped", [55]],
      [[9319, 9319], "mapped", [56]],
      [[9320, 9320], "mapped", [57]],
      [[9321, 9321], "mapped", [49, 48]],
      [[9322, 9322], "mapped", [49, 49]],
      [[9323, 9323], "mapped", [49, 50]],
      [[9324, 9324], "mapped", [49, 51]],
      [[9325, 9325], "mapped", [49, 52]],
      [[9326, 9326], "mapped", [49, 53]],
      [[9327, 9327], "mapped", [49, 54]],
      [[9328, 9328], "mapped", [49, 55]],
      [[9329, 9329], "mapped", [49, 56]],
      [[9330, 9330], "mapped", [49, 57]],
      [[9331, 9331], "mapped", [50, 48]],
      [[9332, 9332], "disallowed_STD3_mapped", [40, 49, 41]],
      [[9333, 9333], "disallowed_STD3_mapped", [40, 50, 41]],
      [[9334, 9334], "disallowed_STD3_mapped", [40, 51, 41]],
      [[9335, 9335], "disallowed_STD3_mapped", [40, 52, 41]],
      [[9336, 9336], "disallowed_STD3_mapped", [40, 53, 41]],
      [[9337, 9337], "disallowed_STD3_mapped", [40, 54, 41]],
      [[9338, 9338], "disallowed_STD3_mapped", [40, 55, 41]],
      [[9339, 9339], "disallowed_STD3_mapped", [40, 56, 41]],
      [[9340, 9340], "disallowed_STD3_mapped", [40, 57, 41]],
      [[9341, 9341], "disallowed_STD3_mapped", [40, 49, 48, 41]],
      [[9342, 9342], "disallowed_STD3_mapped", [40, 49, 49, 41]],
      [[9343, 9343], "disallowed_STD3_mapped", [40, 49, 50, 41]],
      [[9344, 9344], "disallowed_STD3_mapped", [40, 49, 51, 41]],
      [[9345, 9345], "disallowed_STD3_mapped", [40, 49, 52, 41]],
      [[9346, 9346], "disallowed_STD3_mapped", [40, 49, 53, 41]],
      [[9347, 9347], "disallowed_STD3_mapped", [40, 49, 54, 41]],
      [[9348, 9348], "disallowed_STD3_mapped", [40, 49, 55, 41]],
      [[9349, 9349], "disallowed_STD3_mapped", [40, 49, 56, 41]],
      [[9350, 9350], "disallowed_STD3_mapped", [40, 49, 57, 41]],
      [[9351, 9351], "disallowed_STD3_mapped", [40, 50, 48, 41]],
      [[9352, 9371], "disallowed"],
      [[9372, 9372], "disallowed_STD3_mapped", [40, 97, 41]],
      [[9373, 9373], "disallowed_STD3_mapped", [40, 98, 41]],
      [[9374, 9374], "disallowed_STD3_mapped", [40, 99, 41]],
      [[9375, 9375], "disallowed_STD3_mapped", [40, 100, 41]],
      [[9376, 9376], "disallowed_STD3_mapped", [40, 101, 41]],
      [[9377, 9377], "disallowed_STD3_mapped", [40, 102, 41]],
      [[9378, 9378], "disallowed_STD3_mapped", [40, 103, 41]],
      [[9379, 9379], "disallowed_STD3_mapped", [40, 104, 41]],
      [[9380, 9380], "disallowed_STD3_mapped", [40, 105, 41]],
      [[9381, 9381], "disallowed_STD3_mapped", [40, 106, 41]],
      [[9382, 9382], "disallowed_STD3_mapped", [40, 107, 41]],
      [[9383, 9383], "disallowed_STD3_mapped", [40, 108, 41]],
      [[9384, 9384], "disallowed_STD3_mapped", [40, 109, 41]],
      [[9385, 9385], "disallowed_STD3_mapped", [40, 110, 41]],
      [[9386, 9386], "disallowed_STD3_mapped", [40, 111, 41]],
      [[9387, 9387], "disallowed_STD3_mapped", [40, 112, 41]],
      [[9388, 9388], "disallowed_STD3_mapped", [40, 113, 41]],
      [[9389, 9389], "disallowed_STD3_mapped", [40, 114, 41]],
      [[9390, 9390], "disallowed_STD3_mapped", [40, 115, 41]],
      [[9391, 9391], "disallowed_STD3_mapped", [40, 116, 41]],
      [[9392, 9392], "disallowed_STD3_mapped", [40, 117, 41]],
      [[9393, 9393], "disallowed_STD3_mapped", [40, 118, 41]],
      [[9394, 9394], "disallowed_STD3_mapped", [40, 119, 41]],
      [[9395, 9395], "disallowed_STD3_mapped", [40, 120, 41]],
      [[9396, 9396], "disallowed_STD3_mapped", [40, 121, 41]],
      [[9397, 9397], "disallowed_STD3_mapped", [40, 122, 41]],
      [[9398, 9398], "mapped", [97]],
      [[9399, 9399], "mapped", [98]],
      [[9400, 9400], "mapped", [99]],
      [[9401, 9401], "mapped", [100]],
      [[9402, 9402], "mapped", [101]],
      [[9403, 9403], "mapped", [102]],
      [[9404, 9404], "mapped", [103]],
      [[9405, 9405], "mapped", [104]],
      [[9406, 9406], "mapped", [105]],
      [[9407, 9407], "mapped", [106]],
      [[9408, 9408], "mapped", [107]],
      [[9409, 9409], "mapped", [108]],
      [[9410, 9410], "mapped", [109]],
      [[9411, 9411], "mapped", [110]],
      [[9412, 9412], "mapped", [111]],
      [[9413, 9413], "mapped", [112]],
      [[9414, 9414], "mapped", [113]],
      [[9415, 9415], "mapped", [114]],
      [[9416, 9416], "mapped", [115]],
      [[9417, 9417], "mapped", [116]],
      [[9418, 9418], "mapped", [117]],
      [[9419, 9419], "mapped", [118]],
      [[9420, 9420], "mapped", [119]],
      [[9421, 9421], "mapped", [120]],
      [[9422, 9422], "mapped", [121]],
      [[9423, 9423], "mapped", [122]],
      [[9424, 9424], "mapped", [97]],
      [[9425, 9425], "mapped", [98]],
      [[9426, 9426], "mapped", [99]],
      [[9427, 9427], "mapped", [100]],
      [[9428, 9428], "mapped", [101]],
      [[9429, 9429], "mapped", [102]],
      [[9430, 9430], "mapped", [103]],
      [[9431, 9431], "mapped", [104]],
      [[9432, 9432], "mapped", [105]],
      [[9433, 9433], "mapped", [106]],
      [[9434, 9434], "mapped", [107]],
      [[9435, 9435], "mapped", [108]],
      [[9436, 9436], "mapped", [109]],
      [[9437, 9437], "mapped", [110]],
      [[9438, 9438], "mapped", [111]],
      [[9439, 9439], "mapped", [112]],
      [[9440, 9440], "mapped", [113]],
      [[9441, 9441], "mapped", [114]],
      [[9442, 9442], "mapped", [115]],
      [[9443, 9443], "mapped", [116]],
      [[9444, 9444], "mapped", [117]],
      [[9445, 9445], "mapped", [118]],
      [[9446, 9446], "mapped", [119]],
      [[9447, 9447], "mapped", [120]],
      [[9448, 9448], "mapped", [121]],
      [[9449, 9449], "mapped", [122]],
      [[9450, 9450], "mapped", [48]],
      [[9451, 9470], "valid", [], "NV8"],
      [[9471, 9471], "valid", [], "NV8"],
      [[9472, 9621], "valid", [], "NV8"],
      [[9622, 9631], "valid", [], "NV8"],
      [[9632, 9711], "valid", [], "NV8"],
      [[9712, 9719], "valid", [], "NV8"],
      [[9720, 9727], "valid", [], "NV8"],
      [[9728, 9747], "valid", [], "NV8"],
      [[9748, 9749], "valid", [], "NV8"],
      [[9750, 9751], "valid", [], "NV8"],
      [[9752, 9752], "valid", [], "NV8"],
      [[9753, 9753], "valid", [], "NV8"],
      [[9754, 9839], "valid", [], "NV8"],
      [[9840, 9841], "valid", [], "NV8"],
      [[9842, 9853], "valid", [], "NV8"],
      [[9854, 9855], "valid", [], "NV8"],
      [[9856, 9865], "valid", [], "NV8"],
      [[9866, 9873], "valid", [], "NV8"],
      [[9874, 9884], "valid", [], "NV8"],
      [[9885, 9885], "valid", [], "NV8"],
      [[9886, 9887], "valid", [], "NV8"],
      [[9888, 9889], "valid", [], "NV8"],
      [[9890, 9905], "valid", [], "NV8"],
      [[9906, 9906], "valid", [], "NV8"],
      [[9907, 9916], "valid", [], "NV8"],
      [[9917, 9919], "valid", [], "NV8"],
      [[9920, 9923], "valid", [], "NV8"],
      [[9924, 9933], "valid", [], "NV8"],
      [[9934, 9934], "valid", [], "NV8"],
      [[9935, 9953], "valid", [], "NV8"],
      [[9954, 9954], "valid", [], "NV8"],
      [[9955, 9955], "valid", [], "NV8"],
      [[9956, 9959], "valid", [], "NV8"],
      [[9960, 9983], "valid", [], "NV8"],
      [[9984, 9984], "valid", [], "NV8"],
      [[9985, 9988], "valid", [], "NV8"],
      [[9989, 9989], "valid", [], "NV8"],
      [[9990, 9993], "valid", [], "NV8"],
      [[9994, 9995], "valid", [], "NV8"],
      [[9996, 10023], "valid", [], "NV8"],
      [[10024, 10024], "valid", [], "NV8"],
      [[10025, 10059], "valid", [], "NV8"],
      [[10060, 10060], "valid", [], "NV8"],
      [[10061, 10061], "valid", [], "NV8"],
      [[10062, 10062], "valid", [], "NV8"],
      [[10063, 10066], "valid", [], "NV8"],
      [[10067, 10069], "valid", [], "NV8"],
      [[10070, 10070], "valid", [], "NV8"],
      [[10071, 10071], "valid", [], "NV8"],
      [[10072, 10078], "valid", [], "NV8"],
      [[10079, 10080], "valid", [], "NV8"],
      [[10081, 10087], "valid", [], "NV8"],
      [[10088, 10101], "valid", [], "NV8"],
      [[10102, 10132], "valid", [], "NV8"],
      [[10133, 10135], "valid", [], "NV8"],
      [[10136, 10159], "valid", [], "NV8"],
      [[10160, 10160], "valid", [], "NV8"],
      [[10161, 10174], "valid", [], "NV8"],
      [[10175, 10175], "valid", [], "NV8"],
      [[10176, 10182], "valid", [], "NV8"],
      [[10183, 10186], "valid", [], "NV8"],
      [[10187, 10187], "valid", [], "NV8"],
      [[10188, 10188], "valid", [], "NV8"],
      [[10189, 10189], "valid", [], "NV8"],
      [[10190, 10191], "valid", [], "NV8"],
      [[10192, 10219], "valid", [], "NV8"],
      [[10220, 10223], "valid", [], "NV8"],
      [[10224, 10239], "valid", [], "NV8"],
      [[10240, 10495], "valid", [], "NV8"],
      [[10496, 10763], "valid", [], "NV8"],
      [[10764, 10764], "mapped", [8747, 8747, 8747, 8747]],
      [[10765, 10867], "valid", [], "NV8"],
      [[10868, 10868], "disallowed_STD3_mapped", [58, 58, 61]],
      [[10869, 10869], "disallowed_STD3_mapped", [61, 61]],
      [[10870, 10870], "disallowed_STD3_mapped", [61, 61, 61]],
      [[10871, 10971], "valid", [], "NV8"],
      [[10972, 10972], "mapped", [10973, 824]],
      [[10973, 11007], "valid", [], "NV8"],
      [[11008, 11021], "valid", [], "NV8"],
      [[11022, 11027], "valid", [], "NV8"],
      [[11028, 11034], "valid", [], "NV8"],
      [[11035, 11039], "valid", [], "NV8"],
      [[11040, 11043], "valid", [], "NV8"],
      [[11044, 11084], "valid", [], "NV8"],
      [[11085, 11087], "valid", [], "NV8"],
      [[11088, 11092], "valid", [], "NV8"],
      [[11093, 11097], "valid", [], "NV8"],
      [[11098, 11123], "valid", [], "NV8"],
      [[11124, 11125], "disallowed"],
      [[11126, 11157], "valid", [], "NV8"],
      [[11158, 11159], "disallowed"],
      [[11160, 11193], "valid", [], "NV8"],
      [[11194, 11196], "disallowed"],
      [[11197, 11208], "valid", [], "NV8"],
      [[11209, 11209], "disallowed"],
      [[11210, 11217], "valid", [], "NV8"],
      [[11218, 11243], "disallowed"],
      [[11244, 11247], "valid", [], "NV8"],
      [[11248, 11263], "disallowed"],
      [[11264, 11264], "mapped", [11312]],
      [[11265, 11265], "mapped", [11313]],
      [[11266, 11266], "mapped", [11314]],
      [[11267, 11267], "mapped", [11315]],
      [[11268, 11268], "mapped", [11316]],
      [[11269, 11269], "mapped", [11317]],
      [[11270, 11270], "mapped", [11318]],
      [[11271, 11271], "mapped", [11319]],
      [[11272, 11272], "mapped", [11320]],
      [[11273, 11273], "mapped", [11321]],
      [[11274, 11274], "mapped", [11322]],
      [[11275, 11275], "mapped", [11323]],
      [[11276, 11276], "mapped", [11324]],
      [[11277, 11277], "mapped", [11325]],
      [[11278, 11278], "mapped", [11326]],
      [[11279, 11279], "mapped", [11327]],
      [[11280, 11280], "mapped", [11328]],
      [[11281, 11281], "mapped", [11329]],
      [[11282, 11282], "mapped", [11330]],
      [[11283, 11283], "mapped", [11331]],
      [[11284, 11284], "mapped", [11332]],
      [[11285, 11285], "mapped", [11333]],
      [[11286, 11286], "mapped", [11334]],
      [[11287, 11287], "mapped", [11335]],
      [[11288, 11288], "mapped", [11336]],
      [[11289, 11289], "mapped", [11337]],
      [[11290, 11290], "mapped", [11338]],
      [[11291, 11291], "mapped", [11339]],
      [[11292, 11292], "mapped", [11340]],
      [[11293, 11293], "mapped", [11341]],
      [[11294, 11294], "mapped", [11342]],
      [[11295, 11295], "mapped", [11343]],
      [[11296, 11296], "mapped", [11344]],
      [[11297, 11297], "mapped", [11345]],
      [[11298, 11298], "mapped", [11346]],
      [[11299, 11299], "mapped", [11347]],
      [[11300, 11300], "mapped", [11348]],
      [[11301, 11301], "mapped", [11349]],
      [[11302, 11302], "mapped", [11350]],
      [[11303, 11303], "mapped", [11351]],
      [[11304, 11304], "mapped", [11352]],
      [[11305, 11305], "mapped", [11353]],
      [[11306, 11306], "mapped", [11354]],
      [[11307, 11307], "mapped", [11355]],
      [[11308, 11308], "mapped", [11356]],
      [[11309, 11309], "mapped", [11357]],
      [[11310, 11310], "mapped", [11358]],
      [[11311, 11311], "disallowed"],
      [[11312, 11358], "valid"],
      [[11359, 11359], "disallowed"],
      [[11360, 11360], "mapped", [11361]],
      [[11361, 11361], "valid"],
      [[11362, 11362], "mapped", [619]],
      [[11363, 11363], "mapped", [7549]],
      [[11364, 11364], "mapped", [637]],
      [[11365, 11366], "valid"],
      [[11367, 11367], "mapped", [11368]],
      [[11368, 11368], "valid"],
      [[11369, 11369], "mapped", [11370]],
      [[11370, 11370], "valid"],
      [[11371, 11371], "mapped", [11372]],
      [[11372, 11372], "valid"],
      [[11373, 11373], "mapped", [593]],
      [[11374, 11374], "mapped", [625]],
      [[11375, 11375], "mapped", [592]],
      [[11376, 11376], "mapped", [594]],
      [[11377, 11377], "valid"],
      [[11378, 11378], "mapped", [11379]],
      [[11379, 11379], "valid"],
      [[11380, 11380], "valid"],
      [[11381, 11381], "mapped", [11382]],
      [[11382, 11383], "valid"],
      [[11384, 11387], "valid"],
      [[11388, 11388], "mapped", [106]],
      [[11389, 11389], "mapped", [118]],
      [[11390, 11390], "mapped", [575]],
      [[11391, 11391], "mapped", [576]],
      [[11392, 11392], "mapped", [11393]],
      [[11393, 11393], "valid"],
      [[11394, 11394], "mapped", [11395]],
      [[11395, 11395], "valid"],
      [[11396, 11396], "mapped", [11397]],
      [[11397, 11397], "valid"],
      [[11398, 11398], "mapped", [11399]],
      [[11399, 11399], "valid"],
      [[11400, 11400], "mapped", [11401]],
      [[11401, 11401], "valid"],
      [[11402, 11402], "mapped", [11403]],
      [[11403, 11403], "valid"],
      [[11404, 11404], "mapped", [11405]],
      [[11405, 11405], "valid"],
      [[11406, 11406], "mapped", [11407]],
      [[11407, 11407], "valid"],
      [[11408, 11408], "mapped", [11409]],
      [[11409, 11409], "valid"],
      [[11410, 11410], "mapped", [11411]],
      [[11411, 11411], "valid"],
      [[11412, 11412], "mapped", [11413]],
      [[11413, 11413], "valid"],
      [[11414, 11414], "mapped", [11415]],
      [[11415, 11415], "valid"],
      [[11416, 11416], "mapped", [11417]],
      [[11417, 11417], "valid"],
      [[11418, 11418], "mapped", [11419]],
      [[11419, 11419], "valid"],
      [[11420, 11420], "mapped", [11421]],
      [[11421, 11421], "valid"],
      [[11422, 11422], "mapped", [11423]],
      [[11423, 11423], "valid"],
      [[11424, 11424], "mapped", [11425]],
      [[11425, 11425], "valid"],
      [[11426, 11426], "mapped", [11427]],
      [[11427, 11427], "valid"],
      [[11428, 11428], "mapped", [11429]],
      [[11429, 11429], "valid"],
      [[11430, 11430], "mapped", [11431]],
      [[11431, 11431], "valid"],
      [[11432, 11432], "mapped", [11433]],
      [[11433, 11433], "valid"],
      [[11434, 11434], "mapped", [11435]],
      [[11435, 11435], "valid"],
      [[11436, 11436], "mapped", [11437]],
      [[11437, 11437], "valid"],
      [[11438, 11438], "mapped", [11439]],
      [[11439, 11439], "valid"],
      [[11440, 11440], "mapped", [11441]],
      [[11441, 11441], "valid"],
      [[11442, 11442], "mapped", [11443]],
      [[11443, 11443], "valid"],
      [[11444, 11444], "mapped", [11445]],
      [[11445, 11445], "valid"],
      [[11446, 11446], "mapped", [11447]],
      [[11447, 11447], "valid"],
      [[11448, 11448], "mapped", [11449]],
      [[11449, 11449], "valid"],
      [[11450, 11450], "mapped", [11451]],
      [[11451, 11451], "valid"],
      [[11452, 11452], "mapped", [11453]],
      [[11453, 11453], "valid"],
      [[11454, 11454], "mapped", [11455]],
      [[11455, 11455], "valid"],
      [[11456, 11456], "mapped", [11457]],
      [[11457, 11457], "valid"],
      [[11458, 11458], "mapped", [11459]],
      [[11459, 11459], "valid"],
      [[11460, 11460], "mapped", [11461]],
      [[11461, 11461], "valid"],
      [[11462, 11462], "mapped", [11463]],
      [[11463, 11463], "valid"],
      [[11464, 11464], "mapped", [11465]],
      [[11465, 11465], "valid"],
      [[11466, 11466], "mapped", [11467]],
      [[11467, 11467], "valid"],
      [[11468, 11468], "mapped", [11469]],
      [[11469, 11469], "valid"],
      [[11470, 11470], "mapped", [11471]],
      [[11471, 11471], "valid"],
      [[11472, 11472], "mapped", [11473]],
      [[11473, 11473], "valid"],
      [[11474, 11474], "mapped", [11475]],
      [[11475, 11475], "valid"],
      [[11476, 11476], "mapped", [11477]],
      [[11477, 11477], "valid"],
      [[11478, 11478], "mapped", [11479]],
      [[11479, 11479], "valid"],
      [[11480, 11480], "mapped", [11481]],
      [[11481, 11481], "valid"],
      [[11482, 11482], "mapped", [11483]],
      [[11483, 11483], "valid"],
      [[11484, 11484], "mapped", [11485]],
      [[11485, 11485], "valid"],
      [[11486, 11486], "mapped", [11487]],
      [[11487, 11487], "valid"],
      [[11488, 11488], "mapped", [11489]],
      [[11489, 11489], "valid"],
      [[11490, 11490], "mapped", [11491]],
      [[11491, 11492], "valid"],
      [[11493, 11498], "valid", [], "NV8"],
      [[11499, 11499], "mapped", [11500]],
      [[11500, 11500], "valid"],
      [[11501, 11501], "mapped", [11502]],
      [[11502, 11505], "valid"],
      [[11506, 11506], "mapped", [11507]],
      [[11507, 11507], "valid"],
      [[11508, 11512], "disallowed"],
      [[11513, 11519], "valid", [], "NV8"],
      [[11520, 11557], "valid"],
      [[11558, 11558], "disallowed"],
      [[11559, 11559], "valid"],
      [[11560, 11564], "disallowed"],
      [[11565, 11565], "valid"],
      [[11566, 11567], "disallowed"],
      [[11568, 11621], "valid"],
      [[11622, 11623], "valid"],
      [[11624, 11630], "disallowed"],
      [[11631, 11631], "mapped", [11617]],
      [[11632, 11632], "valid", [], "NV8"],
      [[11633, 11646], "disallowed"],
      [[11647, 11647], "valid"],
      [[11648, 11670], "valid"],
      [[11671, 11679], "disallowed"],
      [[11680, 11686], "valid"],
      [[11687, 11687], "disallowed"],
      [[11688, 11694], "valid"],
      [[11695, 11695], "disallowed"],
      [[11696, 11702], "valid"],
      [[11703, 11703], "disallowed"],
      [[11704, 11710], "valid"],
      [[11711, 11711], "disallowed"],
      [[11712, 11718], "valid"],
      [[11719, 11719], "disallowed"],
      [[11720, 11726], "valid"],
      [[11727, 11727], "disallowed"],
      [[11728, 11734], "valid"],
      [[11735, 11735], "disallowed"],
      [[11736, 11742], "valid"],
      [[11743, 11743], "disallowed"],
      [[11744, 11775], "valid"],
      [[11776, 11799], "valid", [], "NV8"],
      [[11800, 11803], "valid", [], "NV8"],
      [[11804, 11805], "valid", [], "NV8"],
      [[11806, 11822], "valid", [], "NV8"],
      [[11823, 11823], "valid"],
      [[11824, 11824], "valid", [], "NV8"],
      [[11825, 11825], "valid", [], "NV8"],
      [[11826, 11835], "valid", [], "NV8"],
      [[11836, 11842], "valid", [], "NV8"],
      [[11843, 11903], "disallowed"],
      [[11904, 11929], "valid", [], "NV8"],
      [[11930, 11930], "disallowed"],
      [[11931, 11934], "valid", [], "NV8"],
      [[11935, 11935], "mapped", [27597]],
      [[11936, 12018], "valid", [], "NV8"],
      [[12019, 12019], "mapped", [40863]],
      [[12020, 12031], "disallowed"],
      [[12032, 12032], "mapped", [19968]],
      [[12033, 12033], "mapped", [20008]],
      [[12034, 12034], "mapped", [20022]],
      [[12035, 12035], "mapped", [20031]],
      [[12036, 12036], "mapped", [20057]],
      [[12037, 12037], "mapped", [20101]],
      [[12038, 12038], "mapped", [20108]],
      [[12039, 12039], "mapped", [20128]],
      [[12040, 12040], "mapped", [20154]],
      [[12041, 12041], "mapped", [20799]],
      [[12042, 12042], "mapped", [20837]],
      [[12043, 12043], "mapped", [20843]],
      [[12044, 12044], "mapped", [20866]],
      [[12045, 12045], "mapped", [20886]],
      [[12046, 12046], "mapped", [20907]],
      [[12047, 12047], "mapped", [20960]],
      [[12048, 12048], "mapped", [20981]],
      [[12049, 12049], "mapped", [20992]],
      [[12050, 12050], "mapped", [21147]],
      [[12051, 12051], "mapped", [21241]],
      [[12052, 12052], "mapped", [21269]],
      [[12053, 12053], "mapped", [21274]],
      [[12054, 12054], "mapped", [21304]],
      [[12055, 12055], "mapped", [21313]],
      [[12056, 12056], "mapped", [21340]],
      [[12057, 12057], "mapped", [21353]],
      [[12058, 12058], "mapped", [21378]],
      [[12059, 12059], "mapped", [21430]],
      [[12060, 12060], "mapped", [21448]],
      [[12061, 12061], "mapped", [21475]],
      [[12062, 12062], "mapped", [22231]],
      [[12063, 12063], "mapped", [22303]],
      [[12064, 12064], "mapped", [22763]],
      [[12065, 12065], "mapped", [22786]],
      [[12066, 12066], "mapped", [22794]],
      [[12067, 12067], "mapped", [22805]],
      [[12068, 12068], "mapped", [22823]],
      [[12069, 12069], "mapped", [22899]],
      [[12070, 12070], "mapped", [23376]],
      [[12071, 12071], "mapped", [23424]],
      [[12072, 12072], "mapped", [23544]],
      [[12073, 12073], "mapped", [23567]],
      [[12074, 12074], "mapped", [23586]],
      [[12075, 12075], "mapped", [23608]],
      [[12076, 12076], "mapped", [23662]],
      [[12077, 12077], "mapped", [23665]],
      [[12078, 12078], "mapped", [24027]],
      [[12079, 12079], "mapped", [24037]],
      [[12080, 12080], "mapped", [24049]],
      [[12081, 12081], "mapped", [24062]],
      [[12082, 12082], "mapped", [24178]],
      [[12083, 12083], "mapped", [24186]],
      [[12084, 12084], "mapped", [24191]],
      [[12085, 12085], "mapped", [24308]],
      [[12086, 12086], "mapped", [24318]],
      [[12087, 12087], "mapped", [24331]],
      [[12088, 12088], "mapped", [24339]],
      [[12089, 12089], "mapped", [24400]],
      [[12090, 12090], "mapped", [24417]],
      [[12091, 12091], "mapped", [24435]],
      [[12092, 12092], "mapped", [24515]],
      [[12093, 12093], "mapped", [25096]],
      [[12094, 12094], "mapped", [25142]],
      [[12095, 12095], "mapped", [25163]],
      [[12096, 12096], "mapped", [25903]],
      [[12097, 12097], "mapped", [25908]],
      [[12098, 12098], "mapped", [25991]],
      [[12099, 12099], "mapped", [26007]],
      [[12100, 12100], "mapped", [26020]],
      [[12101, 12101], "mapped", [26041]],
      [[12102, 12102], "mapped", [26080]],
      [[12103, 12103], "mapped", [26085]],
      [[12104, 12104], "mapped", [26352]],
      [[12105, 12105], "mapped", [26376]],
      [[12106, 12106], "mapped", [26408]],
      [[12107, 12107], "mapped", [27424]],
      [[12108, 12108], "mapped", [27490]],
      [[12109, 12109], "mapped", [27513]],
      [[12110, 12110], "mapped", [27571]],
      [[12111, 12111], "mapped", [27595]],
      [[12112, 12112], "mapped", [27604]],
      [[12113, 12113], "mapped", [27611]],
      [[12114, 12114], "mapped", [27663]],
      [[12115, 12115], "mapped", [27668]],
      [[12116, 12116], "mapped", [27700]],
      [[12117, 12117], "mapped", [28779]],
      [[12118, 12118], "mapped", [29226]],
      [[12119, 12119], "mapped", [29238]],
      [[12120, 12120], "mapped", [29243]],
      [[12121, 12121], "mapped", [29247]],
      [[12122, 12122], "mapped", [29255]],
      [[12123, 12123], "mapped", [29273]],
      [[12124, 12124], "mapped", [29275]],
      [[12125, 12125], "mapped", [29356]],
      [[12126, 12126], "mapped", [29572]],
      [[12127, 12127], "mapped", [29577]],
      [[12128, 12128], "mapped", [29916]],
      [[12129, 12129], "mapped", [29926]],
      [[12130, 12130], "mapped", [29976]],
      [[12131, 12131], "mapped", [29983]],
      [[12132, 12132], "mapped", [29992]],
      [[12133, 12133], "mapped", [3e4]],
      [[12134, 12134], "mapped", [30091]],
      [[12135, 12135], "mapped", [30098]],
      [[12136, 12136], "mapped", [30326]],
      [[12137, 12137], "mapped", [30333]],
      [[12138, 12138], "mapped", [30382]],
      [[12139, 12139], "mapped", [30399]],
      [[12140, 12140], "mapped", [30446]],
      [[12141, 12141], "mapped", [30683]],
      [[12142, 12142], "mapped", [30690]],
      [[12143, 12143], "mapped", [30707]],
      [[12144, 12144], "mapped", [31034]],
      [[12145, 12145], "mapped", [31160]],
      [[12146, 12146], "mapped", [31166]],
      [[12147, 12147], "mapped", [31348]],
      [[12148, 12148], "mapped", [31435]],
      [[12149, 12149], "mapped", [31481]],
      [[12150, 12150], "mapped", [31859]],
      [[12151, 12151], "mapped", [31992]],
      [[12152, 12152], "mapped", [32566]],
      [[12153, 12153], "mapped", [32593]],
      [[12154, 12154], "mapped", [32650]],
      [[12155, 12155], "mapped", [32701]],
      [[12156, 12156], "mapped", [32769]],
      [[12157, 12157], "mapped", [32780]],
      [[12158, 12158], "mapped", [32786]],
      [[12159, 12159], "mapped", [32819]],
      [[12160, 12160], "mapped", [32895]],
      [[12161, 12161], "mapped", [32905]],
      [[12162, 12162], "mapped", [33251]],
      [[12163, 12163], "mapped", [33258]],
      [[12164, 12164], "mapped", [33267]],
      [[12165, 12165], "mapped", [33276]],
      [[12166, 12166], "mapped", [33292]],
      [[12167, 12167], "mapped", [33307]],
      [[12168, 12168], "mapped", [33311]],
      [[12169, 12169], "mapped", [33390]],
      [[12170, 12170], "mapped", [33394]],
      [[12171, 12171], "mapped", [33400]],
      [[12172, 12172], "mapped", [34381]],
      [[12173, 12173], "mapped", [34411]],
      [[12174, 12174], "mapped", [34880]],
      [[12175, 12175], "mapped", [34892]],
      [[12176, 12176], "mapped", [34915]],
      [[12177, 12177], "mapped", [35198]],
      [[12178, 12178], "mapped", [35211]],
      [[12179, 12179], "mapped", [35282]],
      [[12180, 12180], "mapped", [35328]],
      [[12181, 12181], "mapped", [35895]],
      [[12182, 12182], "mapped", [35910]],
      [[12183, 12183], "mapped", [35925]],
      [[12184, 12184], "mapped", [35960]],
      [[12185, 12185], "mapped", [35997]],
      [[12186, 12186], "mapped", [36196]],
      [[12187, 12187], "mapped", [36208]],
      [[12188, 12188], "mapped", [36275]],
      [[12189, 12189], "mapped", [36523]],
      [[12190, 12190], "mapped", [36554]],
      [[12191, 12191], "mapped", [36763]],
      [[12192, 12192], "mapped", [36784]],
      [[12193, 12193], "mapped", [36789]],
      [[12194, 12194], "mapped", [37009]],
      [[12195, 12195], "mapped", [37193]],
      [[12196, 12196], "mapped", [37318]],
      [[12197, 12197], "mapped", [37324]],
      [[12198, 12198], "mapped", [37329]],
      [[12199, 12199], "mapped", [38263]],
      [[12200, 12200], "mapped", [38272]],
      [[12201, 12201], "mapped", [38428]],
      [[12202, 12202], "mapped", [38582]],
      [[12203, 12203], "mapped", [38585]],
      [[12204, 12204], "mapped", [38632]],
      [[12205, 12205], "mapped", [38737]],
      [[12206, 12206], "mapped", [38750]],
      [[12207, 12207], "mapped", [38754]],
      [[12208, 12208], "mapped", [38761]],
      [[12209, 12209], "mapped", [38859]],
      [[12210, 12210], "mapped", [38893]],
      [[12211, 12211], "mapped", [38899]],
      [[12212, 12212], "mapped", [38913]],
      [[12213, 12213], "mapped", [39080]],
      [[12214, 12214], "mapped", [39131]],
      [[12215, 12215], "mapped", [39135]],
      [[12216, 12216], "mapped", [39318]],
      [[12217, 12217], "mapped", [39321]],
      [[12218, 12218], "mapped", [39340]],
      [[12219, 12219], "mapped", [39592]],
      [[12220, 12220], "mapped", [39640]],
      [[12221, 12221], "mapped", [39647]],
      [[12222, 12222], "mapped", [39717]],
      [[12223, 12223], "mapped", [39727]],
      [[12224, 12224], "mapped", [39730]],
      [[12225, 12225], "mapped", [39740]],
      [[12226, 12226], "mapped", [39770]],
      [[12227, 12227], "mapped", [40165]],
      [[12228, 12228], "mapped", [40565]],
      [[12229, 12229], "mapped", [40575]],
      [[12230, 12230], "mapped", [40613]],
      [[12231, 12231], "mapped", [40635]],
      [[12232, 12232], "mapped", [40643]],
      [[12233, 12233], "mapped", [40653]],
      [[12234, 12234], "mapped", [40657]],
      [[12235, 12235], "mapped", [40697]],
      [[12236, 12236], "mapped", [40701]],
      [[12237, 12237], "mapped", [40718]],
      [[12238, 12238], "mapped", [40723]],
      [[12239, 12239], "mapped", [40736]],
      [[12240, 12240], "mapped", [40763]],
      [[12241, 12241], "mapped", [40778]],
      [[12242, 12242], "mapped", [40786]],
      [[12243, 12243], "mapped", [40845]],
      [[12244, 12244], "mapped", [40860]],
      [[12245, 12245], "mapped", [40864]],
      [[12246, 12271], "disallowed"],
      [[12272, 12283], "disallowed"],
      [[12284, 12287], "disallowed"],
      [[12288, 12288], "disallowed_STD3_mapped", [32]],
      [[12289, 12289], "valid", [], "NV8"],
      [[12290, 12290], "mapped", [46]],
      [[12291, 12292], "valid", [], "NV8"],
      [[12293, 12295], "valid"],
      [[12296, 12329], "valid", [], "NV8"],
      [[12330, 12333], "valid"],
      [[12334, 12341], "valid", [], "NV8"],
      [[12342, 12342], "mapped", [12306]],
      [[12343, 12343], "valid", [], "NV8"],
      [[12344, 12344], "mapped", [21313]],
      [[12345, 12345], "mapped", [21316]],
      [[12346, 12346], "mapped", [21317]],
      [[12347, 12347], "valid", [], "NV8"],
      [[12348, 12348], "valid"],
      [[12349, 12349], "valid", [], "NV8"],
      [[12350, 12350], "valid", [], "NV8"],
      [[12351, 12351], "valid", [], "NV8"],
      [[12352, 12352], "disallowed"],
      [[12353, 12436], "valid"],
      [[12437, 12438], "valid"],
      [[12439, 12440], "disallowed"],
      [[12441, 12442], "valid"],
      [[12443, 12443], "disallowed_STD3_mapped", [32, 12441]],
      [[12444, 12444], "disallowed_STD3_mapped", [32, 12442]],
      [[12445, 12446], "valid"],
      [[12447, 12447], "mapped", [12424, 12426]],
      [[12448, 12448], "valid", [], "NV8"],
      [[12449, 12542], "valid"],
      [[12543, 12543], "mapped", [12467, 12488]],
      [[12544, 12548], "disallowed"],
      [[12549, 12588], "valid"],
      [[12589, 12589], "valid"],
      [[12590, 12592], "disallowed"],
      [[12593, 12593], "mapped", [4352]],
      [[12594, 12594], "mapped", [4353]],
      [[12595, 12595], "mapped", [4522]],
      [[12596, 12596], "mapped", [4354]],
      [[12597, 12597], "mapped", [4524]],
      [[12598, 12598], "mapped", [4525]],
      [[12599, 12599], "mapped", [4355]],
      [[12600, 12600], "mapped", [4356]],
      [[12601, 12601], "mapped", [4357]],
      [[12602, 12602], "mapped", [4528]],
      [[12603, 12603], "mapped", [4529]],
      [[12604, 12604], "mapped", [4530]],
      [[12605, 12605], "mapped", [4531]],
      [[12606, 12606], "mapped", [4532]],
      [[12607, 12607], "mapped", [4533]],
      [[12608, 12608], "mapped", [4378]],
      [[12609, 12609], "mapped", [4358]],
      [[12610, 12610], "mapped", [4359]],
      [[12611, 12611], "mapped", [4360]],
      [[12612, 12612], "mapped", [4385]],
      [[12613, 12613], "mapped", [4361]],
      [[12614, 12614], "mapped", [4362]],
      [[12615, 12615], "mapped", [4363]],
      [[12616, 12616], "mapped", [4364]],
      [[12617, 12617], "mapped", [4365]],
      [[12618, 12618], "mapped", [4366]],
      [[12619, 12619], "mapped", [4367]],
      [[12620, 12620], "mapped", [4368]],
      [[12621, 12621], "mapped", [4369]],
      [[12622, 12622], "mapped", [4370]],
      [[12623, 12623], "mapped", [4449]],
      [[12624, 12624], "mapped", [4450]],
      [[12625, 12625], "mapped", [4451]],
      [[12626, 12626], "mapped", [4452]],
      [[12627, 12627], "mapped", [4453]],
      [[12628, 12628], "mapped", [4454]],
      [[12629, 12629], "mapped", [4455]],
      [[12630, 12630], "mapped", [4456]],
      [[12631, 12631], "mapped", [4457]],
      [[12632, 12632], "mapped", [4458]],
      [[12633, 12633], "mapped", [4459]],
      [[12634, 12634], "mapped", [4460]],
      [[12635, 12635], "mapped", [4461]],
      [[12636, 12636], "mapped", [4462]],
      [[12637, 12637], "mapped", [4463]],
      [[12638, 12638], "mapped", [4464]],
      [[12639, 12639], "mapped", [4465]],
      [[12640, 12640], "mapped", [4466]],
      [[12641, 12641], "mapped", [4467]],
      [[12642, 12642], "mapped", [4468]],
      [[12643, 12643], "mapped", [4469]],
      [[12644, 12644], "disallowed"],
      [[12645, 12645], "mapped", [4372]],
      [[12646, 12646], "mapped", [4373]],
      [[12647, 12647], "mapped", [4551]],
      [[12648, 12648], "mapped", [4552]],
      [[12649, 12649], "mapped", [4556]],
      [[12650, 12650], "mapped", [4558]],
      [[12651, 12651], "mapped", [4563]],
      [[12652, 12652], "mapped", [4567]],
      [[12653, 12653], "mapped", [4569]],
      [[12654, 12654], "mapped", [4380]],
      [[12655, 12655], "mapped", [4573]],
      [[12656, 12656], "mapped", [4575]],
      [[12657, 12657], "mapped", [4381]],
      [[12658, 12658], "mapped", [4382]],
      [[12659, 12659], "mapped", [4384]],
      [[12660, 12660], "mapped", [4386]],
      [[12661, 12661], "mapped", [4387]],
      [[12662, 12662], "mapped", [4391]],
      [[12663, 12663], "mapped", [4393]],
      [[12664, 12664], "mapped", [4395]],
      [[12665, 12665], "mapped", [4396]],
      [[12666, 12666], "mapped", [4397]],
      [[12667, 12667], "mapped", [4398]],
      [[12668, 12668], "mapped", [4399]],
      [[12669, 12669], "mapped", [4402]],
      [[12670, 12670], "mapped", [4406]],
      [[12671, 12671], "mapped", [4416]],
      [[12672, 12672], "mapped", [4423]],
      [[12673, 12673], "mapped", [4428]],
      [[12674, 12674], "mapped", [4593]],
      [[12675, 12675], "mapped", [4594]],
      [[12676, 12676], "mapped", [4439]],
      [[12677, 12677], "mapped", [4440]],
      [[12678, 12678], "mapped", [4441]],
      [[12679, 12679], "mapped", [4484]],
      [[12680, 12680], "mapped", [4485]],
      [[12681, 12681], "mapped", [4488]],
      [[12682, 12682], "mapped", [4497]],
      [[12683, 12683], "mapped", [4498]],
      [[12684, 12684], "mapped", [4500]],
      [[12685, 12685], "mapped", [4510]],
      [[12686, 12686], "mapped", [4513]],
      [[12687, 12687], "disallowed"],
      [[12688, 12689], "valid", [], "NV8"],
      [[12690, 12690], "mapped", [19968]],
      [[12691, 12691], "mapped", [20108]],
      [[12692, 12692], "mapped", [19977]],
      [[12693, 12693], "mapped", [22235]],
      [[12694, 12694], "mapped", [19978]],
      [[12695, 12695], "mapped", [20013]],
      [[12696, 12696], "mapped", [19979]],
      [[12697, 12697], "mapped", [30002]],
      [[12698, 12698], "mapped", [20057]],
      [[12699, 12699], "mapped", [19993]],
      [[12700, 12700], "mapped", [19969]],
      [[12701, 12701], "mapped", [22825]],
      [[12702, 12702], "mapped", [22320]],
      [[12703, 12703], "mapped", [20154]],
      [[12704, 12727], "valid"],
      [[12728, 12730], "valid"],
      [[12731, 12735], "disallowed"],
      [[12736, 12751], "valid", [], "NV8"],
      [[12752, 12771], "valid", [], "NV8"],
      [[12772, 12783], "disallowed"],
      [[12784, 12799], "valid"],
      [[12800, 12800], "disallowed_STD3_mapped", [40, 4352, 41]],
      [[12801, 12801], "disallowed_STD3_mapped", [40, 4354, 41]],
      [[12802, 12802], "disallowed_STD3_mapped", [40, 4355, 41]],
      [[12803, 12803], "disallowed_STD3_mapped", [40, 4357, 41]],
      [[12804, 12804], "disallowed_STD3_mapped", [40, 4358, 41]],
      [[12805, 12805], "disallowed_STD3_mapped", [40, 4359, 41]],
      [[12806, 12806], "disallowed_STD3_mapped", [40, 4361, 41]],
      [[12807, 12807], "disallowed_STD3_mapped", [40, 4363, 41]],
      [[12808, 12808], "disallowed_STD3_mapped", [40, 4364, 41]],
      [[12809, 12809], "disallowed_STD3_mapped", [40, 4366, 41]],
      [[12810, 12810], "disallowed_STD3_mapped", [40, 4367, 41]],
      [[12811, 12811], "disallowed_STD3_mapped", [40, 4368, 41]],
      [[12812, 12812], "disallowed_STD3_mapped", [40, 4369, 41]],
      [[12813, 12813], "disallowed_STD3_mapped", [40, 4370, 41]],
      [[12814, 12814], "disallowed_STD3_mapped", [40, 44032, 41]],
      [[12815, 12815], "disallowed_STD3_mapped", [40, 45208, 41]],
      [[12816, 12816], "disallowed_STD3_mapped", [40, 45796, 41]],
      [[12817, 12817], "disallowed_STD3_mapped", [40, 46972, 41]],
      [[12818, 12818], "disallowed_STD3_mapped", [40, 47560, 41]],
      [[12819, 12819], "disallowed_STD3_mapped", [40, 48148, 41]],
      [[12820, 12820], "disallowed_STD3_mapped", [40, 49324, 41]],
      [[12821, 12821], "disallowed_STD3_mapped", [40, 50500, 41]],
      [[12822, 12822], "disallowed_STD3_mapped", [40, 51088, 41]],
      [[12823, 12823], "disallowed_STD3_mapped", [40, 52264, 41]],
      [[12824, 12824], "disallowed_STD3_mapped", [40, 52852, 41]],
      [[12825, 12825], "disallowed_STD3_mapped", [40, 53440, 41]],
      [[12826, 12826], "disallowed_STD3_mapped", [40, 54028, 41]],
      [[12827, 12827], "disallowed_STD3_mapped", [40, 54616, 41]],
      [[12828, 12828], "disallowed_STD3_mapped", [40, 51452, 41]],
      [[12829, 12829], "disallowed_STD3_mapped", [40, 50724, 51204, 41]],
      [[12830, 12830], "disallowed_STD3_mapped", [40, 50724, 54980, 41]],
      [[12831, 12831], "disallowed"],
      [[12832, 12832], "disallowed_STD3_mapped", [40, 19968, 41]],
      [[12833, 12833], "disallowed_STD3_mapped", [40, 20108, 41]],
      [[12834, 12834], "disallowed_STD3_mapped", [40, 19977, 41]],
      [[12835, 12835], "disallowed_STD3_mapped", [40, 22235, 41]],
      [[12836, 12836], "disallowed_STD3_mapped", [40, 20116, 41]],
      [[12837, 12837], "disallowed_STD3_mapped", [40, 20845, 41]],
      [[12838, 12838], "disallowed_STD3_mapped", [40, 19971, 41]],
      [[12839, 12839], "disallowed_STD3_mapped", [40, 20843, 41]],
      [[12840, 12840], "disallowed_STD3_mapped", [40, 20061, 41]],
      [[12841, 12841], "disallowed_STD3_mapped", [40, 21313, 41]],
      [[12842, 12842], "disallowed_STD3_mapped", [40, 26376, 41]],
      [[12843, 12843], "disallowed_STD3_mapped", [40, 28779, 41]],
      [[12844, 12844], "disallowed_STD3_mapped", [40, 27700, 41]],
      [[12845, 12845], "disallowed_STD3_mapped", [40, 26408, 41]],
      [[12846, 12846], "disallowed_STD3_mapped", [40, 37329, 41]],
      [[12847, 12847], "disallowed_STD3_mapped", [40, 22303, 41]],
      [[12848, 12848], "disallowed_STD3_mapped", [40, 26085, 41]],
      [[12849, 12849], "disallowed_STD3_mapped", [40, 26666, 41]],
      [[12850, 12850], "disallowed_STD3_mapped", [40, 26377, 41]],
      [[12851, 12851], "disallowed_STD3_mapped", [40, 31038, 41]],
      [[12852, 12852], "disallowed_STD3_mapped", [40, 21517, 41]],
      [[12853, 12853], "disallowed_STD3_mapped", [40, 29305, 41]],
      [[12854, 12854], "disallowed_STD3_mapped", [40, 36001, 41]],
      [[12855, 12855], "disallowed_STD3_mapped", [40, 31069, 41]],
      [[12856, 12856], "disallowed_STD3_mapped", [40, 21172, 41]],
      [[12857, 12857], "disallowed_STD3_mapped", [40, 20195, 41]],
      [[12858, 12858], "disallowed_STD3_mapped", [40, 21628, 41]],
      [[12859, 12859], "disallowed_STD3_mapped", [40, 23398, 41]],
      [[12860, 12860], "disallowed_STD3_mapped", [40, 30435, 41]],
      [[12861, 12861], "disallowed_STD3_mapped", [40, 20225, 41]],
      [[12862, 12862], "disallowed_STD3_mapped", [40, 36039, 41]],
      [[12863, 12863], "disallowed_STD3_mapped", [40, 21332, 41]],
      [[12864, 12864], "disallowed_STD3_mapped", [40, 31085, 41]],
      [[12865, 12865], "disallowed_STD3_mapped", [40, 20241, 41]],
      [[12866, 12866], "disallowed_STD3_mapped", [40, 33258, 41]],
      [[12867, 12867], "disallowed_STD3_mapped", [40, 33267, 41]],
      [[12868, 12868], "mapped", [21839]],
      [[12869, 12869], "mapped", [24188]],
      [[12870, 12870], "mapped", [25991]],
      [[12871, 12871], "mapped", [31631]],
      [[12872, 12879], "valid", [], "NV8"],
      [[12880, 12880], "mapped", [112, 116, 101]],
      [[12881, 12881], "mapped", [50, 49]],
      [[12882, 12882], "mapped", [50, 50]],
      [[12883, 12883], "mapped", [50, 51]],
      [[12884, 12884], "mapped", [50, 52]],
      [[12885, 12885], "mapped", [50, 53]],
      [[12886, 12886], "mapped", [50, 54]],
      [[12887, 12887], "mapped", [50, 55]],
      [[12888, 12888], "mapped", [50, 56]],
      [[12889, 12889], "mapped", [50, 57]],
      [[12890, 12890], "mapped", [51, 48]],
      [[12891, 12891], "mapped", [51, 49]],
      [[12892, 12892], "mapped", [51, 50]],
      [[12893, 12893], "mapped", [51, 51]],
      [[12894, 12894], "mapped", [51, 52]],
      [[12895, 12895], "mapped", [51, 53]],
      [[12896, 12896], "mapped", [4352]],
      [[12897, 12897], "mapped", [4354]],
      [[12898, 12898], "mapped", [4355]],
      [[12899, 12899], "mapped", [4357]],
      [[12900, 12900], "mapped", [4358]],
      [[12901, 12901], "mapped", [4359]],
      [[12902, 12902], "mapped", [4361]],
      [[12903, 12903], "mapped", [4363]],
      [[12904, 12904], "mapped", [4364]],
      [[12905, 12905], "mapped", [4366]],
      [[12906, 12906], "mapped", [4367]],
      [[12907, 12907], "mapped", [4368]],
      [[12908, 12908], "mapped", [4369]],
      [[12909, 12909], "mapped", [4370]],
      [[12910, 12910], "mapped", [44032]],
      [[12911, 12911], "mapped", [45208]],
      [[12912, 12912], "mapped", [45796]],
      [[12913, 12913], "mapped", [46972]],
      [[12914, 12914], "mapped", [47560]],
      [[12915, 12915], "mapped", [48148]],
      [[12916, 12916], "mapped", [49324]],
      [[12917, 12917], "mapped", [50500]],
      [[12918, 12918], "mapped", [51088]],
      [[12919, 12919], "mapped", [52264]],
      [[12920, 12920], "mapped", [52852]],
      [[12921, 12921], "mapped", [53440]],
      [[12922, 12922], "mapped", [54028]],
      [[12923, 12923], "mapped", [54616]],
      [[12924, 12924], "mapped", [52280, 44256]],
      [[12925, 12925], "mapped", [51452, 51032]],
      [[12926, 12926], "mapped", [50864]],
      [[12927, 12927], "valid", [], "NV8"],
      [[12928, 12928], "mapped", [19968]],
      [[12929, 12929], "mapped", [20108]],
      [[12930, 12930], "mapped", [19977]],
      [[12931, 12931], "mapped", [22235]],
      [[12932, 12932], "mapped", [20116]],
      [[12933, 12933], "mapped", [20845]],
      [[12934, 12934], "mapped", [19971]],
      [[12935, 12935], "mapped", [20843]],
      [[12936, 12936], "mapped", [20061]],
      [[12937, 12937], "mapped", [21313]],
      [[12938, 12938], "mapped", [26376]],
      [[12939, 12939], "mapped", [28779]],
      [[12940, 12940], "mapped", [27700]],
      [[12941, 12941], "mapped", [26408]],
      [[12942, 12942], "mapped", [37329]],
      [[12943, 12943], "mapped", [22303]],
      [[12944, 12944], "mapped", [26085]],
      [[12945, 12945], "mapped", [26666]],
      [[12946, 12946], "mapped", [26377]],
      [[12947, 12947], "mapped", [31038]],
      [[12948, 12948], "mapped", [21517]],
      [[12949, 12949], "mapped", [29305]],
      [[12950, 12950], "mapped", [36001]],
      [[12951, 12951], "mapped", [31069]],
      [[12952, 12952], "mapped", [21172]],
      [[12953, 12953], "mapped", [31192]],
      [[12954, 12954], "mapped", [30007]],
      [[12955, 12955], "mapped", [22899]],
      [[12956, 12956], "mapped", [36969]],
      [[12957, 12957], "mapped", [20778]],
      [[12958, 12958], "mapped", [21360]],
      [[12959, 12959], "mapped", [27880]],
      [[12960, 12960], "mapped", [38917]],
      [[12961, 12961], "mapped", [20241]],
      [[12962, 12962], "mapped", [20889]],
      [[12963, 12963], "mapped", [27491]],
      [[12964, 12964], "mapped", [19978]],
      [[12965, 12965], "mapped", [20013]],
      [[12966, 12966], "mapped", [19979]],
      [[12967, 12967], "mapped", [24038]],
      [[12968, 12968], "mapped", [21491]],
      [[12969, 12969], "mapped", [21307]],
      [[12970, 12970], "mapped", [23447]],
      [[12971, 12971], "mapped", [23398]],
      [[12972, 12972], "mapped", [30435]],
      [[12973, 12973], "mapped", [20225]],
      [[12974, 12974], "mapped", [36039]],
      [[12975, 12975], "mapped", [21332]],
      [[12976, 12976], "mapped", [22812]],
      [[12977, 12977], "mapped", [51, 54]],
      [[12978, 12978], "mapped", [51, 55]],
      [[12979, 12979], "mapped", [51, 56]],
      [[12980, 12980], "mapped", [51, 57]],
      [[12981, 12981], "mapped", [52, 48]],
      [[12982, 12982], "mapped", [52, 49]],
      [[12983, 12983], "mapped", [52, 50]],
      [[12984, 12984], "mapped", [52, 51]],
      [[12985, 12985], "mapped", [52, 52]],
      [[12986, 12986], "mapped", [52, 53]],
      [[12987, 12987], "mapped", [52, 54]],
      [[12988, 12988], "mapped", [52, 55]],
      [[12989, 12989], "mapped", [52, 56]],
      [[12990, 12990], "mapped", [52, 57]],
      [[12991, 12991], "mapped", [53, 48]],
      [[12992, 12992], "mapped", [49, 26376]],
      [[12993, 12993], "mapped", [50, 26376]],
      [[12994, 12994], "mapped", [51, 26376]],
      [[12995, 12995], "mapped", [52, 26376]],
      [[12996, 12996], "mapped", [53, 26376]],
      [[12997, 12997], "mapped", [54, 26376]],
      [[12998, 12998], "mapped", [55, 26376]],
      [[12999, 12999], "mapped", [56, 26376]],
      [[13e3, 13e3], "mapped", [57, 26376]],
      [[13001, 13001], "mapped", [49, 48, 26376]],
      [[13002, 13002], "mapped", [49, 49, 26376]],
      [[13003, 13003], "mapped", [49, 50, 26376]],
      [[13004, 13004], "mapped", [104, 103]],
      [[13005, 13005], "mapped", [101, 114, 103]],
      [[13006, 13006], "mapped", [101, 118]],
      [[13007, 13007], "mapped", [108, 116, 100]],
      [[13008, 13008], "mapped", [12450]],
      [[13009, 13009], "mapped", [12452]],
      [[13010, 13010], "mapped", [12454]],
      [[13011, 13011], "mapped", [12456]],
      [[13012, 13012], "mapped", [12458]],
      [[13013, 13013], "mapped", [12459]],
      [[13014, 13014], "mapped", [12461]],
      [[13015, 13015], "mapped", [12463]],
      [[13016, 13016], "mapped", [12465]],
      [[13017, 13017], "mapped", [12467]],
      [[13018, 13018], "mapped", [12469]],
      [[13019, 13019], "mapped", [12471]],
      [[13020, 13020], "mapped", [12473]],
      [[13021, 13021], "mapped", [12475]],
      [[13022, 13022], "mapped", [12477]],
      [[13023, 13023], "mapped", [12479]],
      [[13024, 13024], "mapped", [12481]],
      [[13025, 13025], "mapped", [12484]],
      [[13026, 13026], "mapped", [12486]],
      [[13027, 13027], "mapped", [12488]],
      [[13028, 13028], "mapped", [12490]],
      [[13029, 13029], "mapped", [12491]],
      [[13030, 13030], "mapped", [12492]],
      [[13031, 13031], "mapped", [12493]],
      [[13032, 13032], "mapped", [12494]],
      [[13033, 13033], "mapped", [12495]],
      [[13034, 13034], "mapped", [12498]],
      [[13035, 13035], "mapped", [12501]],
      [[13036, 13036], "mapped", [12504]],
      [[13037, 13037], "mapped", [12507]],
      [[13038, 13038], "mapped", [12510]],
      [[13039, 13039], "mapped", [12511]],
      [[13040, 13040], "mapped", [12512]],
      [[13041, 13041], "mapped", [12513]],
      [[13042, 13042], "mapped", [12514]],
      [[13043, 13043], "mapped", [12516]],
      [[13044, 13044], "mapped", [12518]],
      [[13045, 13045], "mapped", [12520]],
      [[13046, 13046], "mapped", [12521]],
      [[13047, 13047], "mapped", [12522]],
      [[13048, 13048], "mapped", [12523]],
      [[13049, 13049], "mapped", [12524]],
      [[13050, 13050], "mapped", [12525]],
      [[13051, 13051], "mapped", [12527]],
      [[13052, 13052], "mapped", [12528]],
      [[13053, 13053], "mapped", [12529]],
      [[13054, 13054], "mapped", [12530]],
      [[13055, 13055], "disallowed"],
      [[13056, 13056], "mapped", [12450, 12497, 12540, 12488]],
      [[13057, 13057], "mapped", [12450, 12523, 12501, 12449]],
      [[13058, 13058], "mapped", [12450, 12531, 12506, 12450]],
      [[13059, 13059], "mapped", [12450, 12540, 12523]],
      [[13060, 13060], "mapped", [12452, 12491, 12531, 12464]],
      [[13061, 13061], "mapped", [12452, 12531, 12481]],
      [[13062, 13062], "mapped", [12454, 12457, 12531]],
      [[13063, 13063], "mapped", [12456, 12473, 12463, 12540, 12489]],
      [[13064, 13064], "mapped", [12456, 12540, 12459, 12540]],
      [[13065, 13065], "mapped", [12458, 12531, 12473]],
      [[13066, 13066], "mapped", [12458, 12540, 12512]],
      [[13067, 13067], "mapped", [12459, 12452, 12522]],
      [[13068, 13068], "mapped", [12459, 12521, 12483, 12488]],
      [[13069, 13069], "mapped", [12459, 12525, 12522, 12540]],
      [[13070, 13070], "mapped", [12460, 12525, 12531]],
      [[13071, 13071], "mapped", [12460, 12531, 12510]],
      [[13072, 13072], "mapped", [12462, 12460]],
      [[13073, 13073], "mapped", [12462, 12491, 12540]],
      [[13074, 13074], "mapped", [12461, 12517, 12522, 12540]],
      [[13075, 13075], "mapped", [12462, 12523, 12480, 12540]],
      [[13076, 13076], "mapped", [12461, 12525]],
      [[13077, 13077], "mapped", [12461, 12525, 12464, 12521, 12512]],
      [[13078, 13078], "mapped", [12461, 12525, 12513, 12540, 12488, 12523]],
      [[13079, 13079], "mapped", [12461, 12525, 12527, 12483, 12488]],
      [[13080, 13080], "mapped", [12464, 12521, 12512]],
      [[13081, 13081], "mapped", [12464, 12521, 12512, 12488, 12531]],
      [[13082, 13082], "mapped", [12463, 12523, 12476, 12452, 12525]],
      [[13083, 13083], "mapped", [12463, 12525, 12540, 12493]],
      [[13084, 13084], "mapped", [12465, 12540, 12473]],
      [[13085, 13085], "mapped", [12467, 12523, 12490]],
      [[13086, 13086], "mapped", [12467, 12540, 12509]],
      [[13087, 13087], "mapped", [12469, 12452, 12463, 12523]],
      [[13088, 13088], "mapped", [12469, 12531, 12481, 12540, 12512]],
      [[13089, 13089], "mapped", [12471, 12522, 12531, 12464]],
      [[13090, 13090], "mapped", [12475, 12531, 12481]],
      [[13091, 13091], "mapped", [12475, 12531, 12488]],
      [[13092, 13092], "mapped", [12480, 12540, 12473]],
      [[13093, 13093], "mapped", [12487, 12471]],
      [[13094, 13094], "mapped", [12489, 12523]],
      [[13095, 13095], "mapped", [12488, 12531]],
      [[13096, 13096], "mapped", [12490, 12494]],
      [[13097, 13097], "mapped", [12494, 12483, 12488]],
      [[13098, 13098], "mapped", [12495, 12452, 12484]],
      [[13099, 13099], "mapped", [12497, 12540, 12475, 12531, 12488]],
      [[13100, 13100], "mapped", [12497, 12540, 12484]],
      [[13101, 13101], "mapped", [12496, 12540, 12524, 12523]],
      [[13102, 13102], "mapped", [12500, 12450, 12473, 12488, 12523]],
      [[13103, 13103], "mapped", [12500, 12463, 12523]],
      [[13104, 13104], "mapped", [12500, 12467]],
      [[13105, 13105], "mapped", [12499, 12523]],
      [[13106, 13106], "mapped", [12501, 12449, 12521, 12483, 12489]],
      [[13107, 13107], "mapped", [12501, 12451, 12540, 12488]],
      [[13108, 13108], "mapped", [12502, 12483, 12471, 12455, 12523]],
      [[13109, 13109], "mapped", [12501, 12521, 12531]],
      [[13110, 13110], "mapped", [12504, 12463, 12479, 12540, 12523]],
      [[13111, 13111], "mapped", [12506, 12477]],
      [[13112, 13112], "mapped", [12506, 12491, 12498]],
      [[13113, 13113], "mapped", [12504, 12523, 12484]],
      [[13114, 13114], "mapped", [12506, 12531, 12473]],
      [[13115, 13115], "mapped", [12506, 12540, 12472]],
      [[13116, 13116], "mapped", [12505, 12540, 12479]],
      [[13117, 13117], "mapped", [12509, 12452, 12531, 12488]],
      [[13118, 13118], "mapped", [12508, 12523, 12488]],
      [[13119, 13119], "mapped", [12507, 12531]],
      [[13120, 13120], "mapped", [12509, 12531, 12489]],
      [[13121, 13121], "mapped", [12507, 12540, 12523]],
      [[13122, 13122], "mapped", [12507, 12540, 12531]],
      [[13123, 13123], "mapped", [12510, 12452, 12463, 12525]],
      [[13124, 13124], "mapped", [12510, 12452, 12523]],
      [[13125, 13125], "mapped", [12510, 12483, 12495]],
      [[13126, 13126], "mapped", [12510, 12523, 12463]],
      [[13127, 13127], "mapped", [12510, 12531, 12471, 12519, 12531]],
      [[13128, 13128], "mapped", [12511, 12463, 12525, 12531]],
      [[13129, 13129], "mapped", [12511, 12522]],
      [[13130, 13130], "mapped", [12511, 12522, 12496, 12540, 12523]],
      [[13131, 13131], "mapped", [12513, 12460]],
      [[13132, 13132], "mapped", [12513, 12460, 12488, 12531]],
      [[13133, 13133], "mapped", [12513, 12540, 12488, 12523]],
      [[13134, 13134], "mapped", [12516, 12540, 12489]],
      [[13135, 13135], "mapped", [12516, 12540, 12523]],
      [[13136, 13136], "mapped", [12518, 12450, 12531]],
      [[13137, 13137], "mapped", [12522, 12483, 12488, 12523]],
      [[13138, 13138], "mapped", [12522, 12521]],
      [[13139, 13139], "mapped", [12523, 12500, 12540]],
      [[13140, 13140], "mapped", [12523, 12540, 12502, 12523]],
      [[13141, 13141], "mapped", [12524, 12512]],
      [[13142, 13142], "mapped", [12524, 12531, 12488, 12466, 12531]],
      [[13143, 13143], "mapped", [12527, 12483, 12488]],
      [[13144, 13144], "mapped", [48, 28857]],
      [[13145, 13145], "mapped", [49, 28857]],
      [[13146, 13146], "mapped", [50, 28857]],
      [[13147, 13147], "mapped", [51, 28857]],
      [[13148, 13148], "mapped", [52, 28857]],
      [[13149, 13149], "mapped", [53, 28857]],
      [[13150, 13150], "mapped", [54, 28857]],
      [[13151, 13151], "mapped", [55, 28857]],
      [[13152, 13152], "mapped", [56, 28857]],
      [[13153, 13153], "mapped", [57, 28857]],
      [[13154, 13154], "mapped", [49, 48, 28857]],
      [[13155, 13155], "mapped", [49, 49, 28857]],
      [[13156, 13156], "mapped", [49, 50, 28857]],
      [[13157, 13157], "mapped", [49, 51, 28857]],
      [[13158, 13158], "mapped", [49, 52, 28857]],
      [[13159, 13159], "mapped", [49, 53, 28857]],
      [[13160, 13160], "mapped", [49, 54, 28857]],
      [[13161, 13161], "mapped", [49, 55, 28857]],
      [[13162, 13162], "mapped", [49, 56, 28857]],
      [[13163, 13163], "mapped", [49, 57, 28857]],
      [[13164, 13164], "mapped", [50, 48, 28857]],
      [[13165, 13165], "mapped", [50, 49, 28857]],
      [[13166, 13166], "mapped", [50, 50, 28857]],
      [[13167, 13167], "mapped", [50, 51, 28857]],
      [[13168, 13168], "mapped", [50, 52, 28857]],
      [[13169, 13169], "mapped", [104, 112, 97]],
      [[13170, 13170], "mapped", [100, 97]],
      [[13171, 13171], "mapped", [97, 117]],
      [[13172, 13172], "mapped", [98, 97, 114]],
      [[13173, 13173], "mapped", [111, 118]],
      [[13174, 13174], "mapped", [112, 99]],
      [[13175, 13175], "mapped", [100, 109]],
      [[13176, 13176], "mapped", [100, 109, 50]],
      [[13177, 13177], "mapped", [100, 109, 51]],
      [[13178, 13178], "mapped", [105, 117]],
      [[13179, 13179], "mapped", [24179, 25104]],
      [[13180, 13180], "mapped", [26157, 21644]],
      [[13181, 13181], "mapped", [22823, 27491]],
      [[13182, 13182], "mapped", [26126, 27835]],
      [[13183, 13183], "mapped", [26666, 24335, 20250, 31038]],
      [[13184, 13184], "mapped", [112, 97]],
      [[13185, 13185], "mapped", [110, 97]],
      [[13186, 13186], "mapped", [956, 97]],
      [[13187, 13187], "mapped", [109, 97]],
      [[13188, 13188], "mapped", [107, 97]],
      [[13189, 13189], "mapped", [107, 98]],
      [[13190, 13190], "mapped", [109, 98]],
      [[13191, 13191], "mapped", [103, 98]],
      [[13192, 13192], "mapped", [99, 97, 108]],
      [[13193, 13193], "mapped", [107, 99, 97, 108]],
      [[13194, 13194], "mapped", [112, 102]],
      [[13195, 13195], "mapped", [110, 102]],
      [[13196, 13196], "mapped", [956, 102]],
      [[13197, 13197], "mapped", [956, 103]],
      [[13198, 13198], "mapped", [109, 103]],
      [[13199, 13199], "mapped", [107, 103]],
      [[13200, 13200], "mapped", [104, 122]],
      [[13201, 13201], "mapped", [107, 104, 122]],
      [[13202, 13202], "mapped", [109, 104, 122]],
      [[13203, 13203], "mapped", [103, 104, 122]],
      [[13204, 13204], "mapped", [116, 104, 122]],
      [[13205, 13205], "mapped", [956, 108]],
      [[13206, 13206], "mapped", [109, 108]],
      [[13207, 13207], "mapped", [100, 108]],
      [[13208, 13208], "mapped", [107, 108]],
      [[13209, 13209], "mapped", [102, 109]],
      [[13210, 13210], "mapped", [110, 109]],
      [[13211, 13211], "mapped", [956, 109]],
      [[13212, 13212], "mapped", [109, 109]],
      [[13213, 13213], "mapped", [99, 109]],
      [[13214, 13214], "mapped", [107, 109]],
      [[13215, 13215], "mapped", [109, 109, 50]],
      [[13216, 13216], "mapped", [99, 109, 50]],
      [[13217, 13217], "mapped", [109, 50]],
      [[13218, 13218], "mapped", [107, 109, 50]],
      [[13219, 13219], "mapped", [109, 109, 51]],
      [[13220, 13220], "mapped", [99, 109, 51]],
      [[13221, 13221], "mapped", [109, 51]],
      [[13222, 13222], "mapped", [107, 109, 51]],
      [[13223, 13223], "mapped", [109, 8725, 115]],
      [[13224, 13224], "mapped", [109, 8725, 115, 50]],
      [[13225, 13225], "mapped", [112, 97]],
      [[13226, 13226], "mapped", [107, 112, 97]],
      [[13227, 13227], "mapped", [109, 112, 97]],
      [[13228, 13228], "mapped", [103, 112, 97]],
      [[13229, 13229], "mapped", [114, 97, 100]],
      [[13230, 13230], "mapped", [114, 97, 100, 8725, 115]],
      [[13231, 13231], "mapped", [114, 97, 100, 8725, 115, 50]],
      [[13232, 13232], "mapped", [112, 115]],
      [[13233, 13233], "mapped", [110, 115]],
      [[13234, 13234], "mapped", [956, 115]],
      [[13235, 13235], "mapped", [109, 115]],
      [[13236, 13236], "mapped", [112, 118]],
      [[13237, 13237], "mapped", [110, 118]],
      [[13238, 13238], "mapped", [956, 118]],
      [[13239, 13239], "mapped", [109, 118]],
      [[13240, 13240], "mapped", [107, 118]],
      [[13241, 13241], "mapped", [109, 118]],
      [[13242, 13242], "mapped", [112, 119]],
      [[13243, 13243], "mapped", [110, 119]],
      [[13244, 13244], "mapped", [956, 119]],
      [[13245, 13245], "mapped", [109, 119]],
      [[13246, 13246], "mapped", [107, 119]],
      [[13247, 13247], "mapped", [109, 119]],
      [[13248, 13248], "mapped", [107, 969]],
      [[13249, 13249], "mapped", [109, 969]],
      [[13250, 13250], "disallowed"],
      [[13251, 13251], "mapped", [98, 113]],
      [[13252, 13252], "mapped", [99, 99]],
      [[13253, 13253], "mapped", [99, 100]],
      [[13254, 13254], "mapped", [99, 8725, 107, 103]],
      [[13255, 13255], "disallowed"],
      [[13256, 13256], "mapped", [100, 98]],
      [[13257, 13257], "mapped", [103, 121]],
      [[13258, 13258], "mapped", [104, 97]],
      [[13259, 13259], "mapped", [104, 112]],
      [[13260, 13260], "mapped", [105, 110]],
      [[13261, 13261], "mapped", [107, 107]],
      [[13262, 13262], "mapped", [107, 109]],
      [[13263, 13263], "mapped", [107, 116]],
      [[13264, 13264], "mapped", [108, 109]],
      [[13265, 13265], "mapped", [108, 110]],
      [[13266, 13266], "mapped", [108, 111, 103]],
      [[13267, 13267], "mapped", [108, 120]],
      [[13268, 13268], "mapped", [109, 98]],
      [[13269, 13269], "mapped", [109, 105, 108]],
      [[13270, 13270], "mapped", [109, 111, 108]],
      [[13271, 13271], "mapped", [112, 104]],
      [[13272, 13272], "disallowed"],
      [[13273, 13273], "mapped", [112, 112, 109]],
      [[13274, 13274], "mapped", [112, 114]],
      [[13275, 13275], "mapped", [115, 114]],
      [[13276, 13276], "mapped", [115, 118]],
      [[13277, 13277], "mapped", [119, 98]],
      [[13278, 13278], "mapped", [118, 8725, 109]],
      [[13279, 13279], "mapped", [97, 8725, 109]],
      [[13280, 13280], "mapped", [49, 26085]],
      [[13281, 13281], "mapped", [50, 26085]],
      [[13282, 13282], "mapped", [51, 26085]],
      [[13283, 13283], "mapped", [52, 26085]],
      [[13284, 13284], "mapped", [53, 26085]],
      [[13285, 13285], "mapped", [54, 26085]],
      [[13286, 13286], "mapped", [55, 26085]],
      [[13287, 13287], "mapped", [56, 26085]],
      [[13288, 13288], "mapped", [57, 26085]],
      [[13289, 13289], "mapped", [49, 48, 26085]],
      [[13290, 13290], "mapped", [49, 49, 26085]],
      [[13291, 13291], "mapped", [49, 50, 26085]],
      [[13292, 13292], "mapped", [49, 51, 26085]],
      [[13293, 13293], "mapped", [49, 52, 26085]],
      [[13294, 13294], "mapped", [49, 53, 26085]],
      [[13295, 13295], "mapped", [49, 54, 26085]],
      [[13296, 13296], "mapped", [49, 55, 26085]],
      [[13297, 13297], "mapped", [49, 56, 26085]],
      [[13298, 13298], "mapped", [49, 57, 26085]],
      [[13299, 13299], "mapped", [50, 48, 26085]],
      [[13300, 13300], "mapped", [50, 49, 26085]],
      [[13301, 13301], "mapped", [50, 50, 26085]],
      [[13302, 13302], "mapped", [50, 51, 26085]],
      [[13303, 13303], "mapped", [50, 52, 26085]],
      [[13304, 13304], "mapped", [50, 53, 26085]],
      [[13305, 13305], "mapped", [50, 54, 26085]],
      [[13306, 13306], "mapped", [50, 55, 26085]],
      [[13307, 13307], "mapped", [50, 56, 26085]],
      [[13308, 13308], "mapped", [50, 57, 26085]],
      [[13309, 13309], "mapped", [51, 48, 26085]],
      [[13310, 13310], "mapped", [51, 49, 26085]],
      [[13311, 13311], "mapped", [103, 97, 108]],
      [[13312, 19893], "valid"],
      [[19894, 19903], "disallowed"],
      [[19904, 19967], "valid", [], "NV8"],
      [[19968, 40869], "valid"],
      [[40870, 40891], "valid"],
      [[40892, 40899], "valid"],
      [[40900, 40907], "valid"],
      [[40908, 40908], "valid"],
      [[40909, 40917], "valid"],
      [[40918, 40959], "disallowed"],
      [[40960, 42124], "valid"],
      [[42125, 42127], "disallowed"],
      [[42128, 42145], "valid", [], "NV8"],
      [[42146, 42147], "valid", [], "NV8"],
      [[42148, 42163], "valid", [], "NV8"],
      [[42164, 42164], "valid", [], "NV8"],
      [[42165, 42176], "valid", [], "NV8"],
      [[42177, 42177], "valid", [], "NV8"],
      [[42178, 42180], "valid", [], "NV8"],
      [[42181, 42181], "valid", [], "NV8"],
      [[42182, 42182], "valid", [], "NV8"],
      [[42183, 42191], "disallowed"],
      [[42192, 42237], "valid"],
      [[42238, 42239], "valid", [], "NV8"],
      [[42240, 42508], "valid"],
      [[42509, 42511], "valid", [], "NV8"],
      [[42512, 42539], "valid"],
      [[42540, 42559], "disallowed"],
      [[42560, 42560], "mapped", [42561]],
      [[42561, 42561], "valid"],
      [[42562, 42562], "mapped", [42563]],
      [[42563, 42563], "valid"],
      [[42564, 42564], "mapped", [42565]],
      [[42565, 42565], "valid"],
      [[42566, 42566], "mapped", [42567]],
      [[42567, 42567], "valid"],
      [[42568, 42568], "mapped", [42569]],
      [[42569, 42569], "valid"],
      [[42570, 42570], "mapped", [42571]],
      [[42571, 42571], "valid"],
      [[42572, 42572], "mapped", [42573]],
      [[42573, 42573], "valid"],
      [[42574, 42574], "mapped", [42575]],
      [[42575, 42575], "valid"],
      [[42576, 42576], "mapped", [42577]],
      [[42577, 42577], "valid"],
      [[42578, 42578], "mapped", [42579]],
      [[42579, 42579], "valid"],
      [[42580, 42580], "mapped", [42581]],
      [[42581, 42581], "valid"],
      [[42582, 42582], "mapped", [42583]],
      [[42583, 42583], "valid"],
      [[42584, 42584], "mapped", [42585]],
      [[42585, 42585], "valid"],
      [[42586, 42586], "mapped", [42587]],
      [[42587, 42587], "valid"],
      [[42588, 42588], "mapped", [42589]],
      [[42589, 42589], "valid"],
      [[42590, 42590], "mapped", [42591]],
      [[42591, 42591], "valid"],
      [[42592, 42592], "mapped", [42593]],
      [[42593, 42593], "valid"],
      [[42594, 42594], "mapped", [42595]],
      [[42595, 42595], "valid"],
      [[42596, 42596], "mapped", [42597]],
      [[42597, 42597], "valid"],
      [[42598, 42598], "mapped", [42599]],
      [[42599, 42599], "valid"],
      [[42600, 42600], "mapped", [42601]],
      [[42601, 42601], "valid"],
      [[42602, 42602], "mapped", [42603]],
      [[42603, 42603], "valid"],
      [[42604, 42604], "mapped", [42605]],
      [[42605, 42607], "valid"],
      [[42608, 42611], "valid", [], "NV8"],
      [[42612, 42619], "valid"],
      [[42620, 42621], "valid"],
      [[42622, 42622], "valid", [], "NV8"],
      [[42623, 42623], "valid"],
      [[42624, 42624], "mapped", [42625]],
      [[42625, 42625], "valid"],
      [[42626, 42626], "mapped", [42627]],
      [[42627, 42627], "valid"],
      [[42628, 42628], "mapped", [42629]],
      [[42629, 42629], "valid"],
      [[42630, 42630], "mapped", [42631]],
      [[42631, 42631], "valid"],
      [[42632, 42632], "mapped", [42633]],
      [[42633, 42633], "valid"],
      [[42634, 42634], "mapped", [42635]],
      [[42635, 42635], "valid"],
      [[42636, 42636], "mapped", [42637]],
      [[42637, 42637], "valid"],
      [[42638, 42638], "mapped", [42639]],
      [[42639, 42639], "valid"],
      [[42640, 42640], "mapped", [42641]],
      [[42641, 42641], "valid"],
      [[42642, 42642], "mapped", [42643]],
      [[42643, 42643], "valid"],
      [[42644, 42644], "mapped", [42645]],
      [[42645, 42645], "valid"],
      [[42646, 42646], "mapped", [42647]],
      [[42647, 42647], "valid"],
      [[42648, 42648], "mapped", [42649]],
      [[42649, 42649], "valid"],
      [[42650, 42650], "mapped", [42651]],
      [[42651, 42651], "valid"],
      [[42652, 42652], "mapped", [1098]],
      [[42653, 42653], "mapped", [1100]],
      [[42654, 42654], "valid"],
      [[42655, 42655], "valid"],
      [[42656, 42725], "valid"],
      [[42726, 42735], "valid", [], "NV8"],
      [[42736, 42737], "valid"],
      [[42738, 42743], "valid", [], "NV8"],
      [[42744, 42751], "disallowed"],
      [[42752, 42774], "valid", [], "NV8"],
      [[42775, 42778], "valid"],
      [[42779, 42783], "valid"],
      [[42784, 42785], "valid", [], "NV8"],
      [[42786, 42786], "mapped", [42787]],
      [[42787, 42787], "valid"],
      [[42788, 42788], "mapped", [42789]],
      [[42789, 42789], "valid"],
      [[42790, 42790], "mapped", [42791]],
      [[42791, 42791], "valid"],
      [[42792, 42792], "mapped", [42793]],
      [[42793, 42793], "valid"],
      [[42794, 42794], "mapped", [42795]],
      [[42795, 42795], "valid"],
      [[42796, 42796], "mapped", [42797]],
      [[42797, 42797], "valid"],
      [[42798, 42798], "mapped", [42799]],
      [[42799, 42801], "valid"],
      [[42802, 42802], "mapped", [42803]],
      [[42803, 42803], "valid"],
      [[42804, 42804], "mapped", [42805]],
      [[42805, 42805], "valid"],
      [[42806, 42806], "mapped", [42807]],
      [[42807, 42807], "valid"],
      [[42808, 42808], "mapped", [42809]],
      [[42809, 42809], "valid"],
      [[42810, 42810], "mapped", [42811]],
      [[42811, 42811], "valid"],
      [[42812, 42812], "mapped", [42813]],
      [[42813, 42813], "valid"],
      [[42814, 42814], "mapped", [42815]],
      [[42815, 42815], "valid"],
      [[42816, 42816], "mapped", [42817]],
      [[42817, 42817], "valid"],
      [[42818, 42818], "mapped", [42819]],
      [[42819, 42819], "valid"],
      [[42820, 42820], "mapped", [42821]],
      [[42821, 42821], "valid"],
      [[42822, 42822], "mapped", [42823]],
      [[42823, 42823], "valid"],
      [[42824, 42824], "mapped", [42825]],
      [[42825, 42825], "valid"],
      [[42826, 42826], "mapped", [42827]],
      [[42827, 42827], "valid"],
      [[42828, 42828], "mapped", [42829]],
      [[42829, 42829], "valid"],
      [[42830, 42830], "mapped", [42831]],
      [[42831, 42831], "valid"],
      [[42832, 42832], "mapped", [42833]],
      [[42833, 42833], "valid"],
      [[42834, 42834], "mapped", [42835]],
      [[42835, 42835], "valid"],
      [[42836, 42836], "mapped", [42837]],
      [[42837, 42837], "valid"],
      [[42838, 42838], "mapped", [42839]],
      [[42839, 42839], "valid"],
      [[42840, 42840], "mapped", [42841]],
      [[42841, 42841], "valid"],
      [[42842, 42842], "mapped", [42843]],
      [[42843, 42843], "valid"],
      [[42844, 42844], "mapped", [42845]],
      [[42845, 42845], "valid"],
      [[42846, 42846], "mapped", [42847]],
      [[42847, 42847], "valid"],
      [[42848, 42848], "mapped", [42849]],
      [[42849, 42849], "valid"],
      [[42850, 42850], "mapped", [42851]],
      [[42851, 42851], "valid"],
      [[42852, 42852], "mapped", [42853]],
      [[42853, 42853], "valid"],
      [[42854, 42854], "mapped", [42855]],
      [[42855, 42855], "valid"],
      [[42856, 42856], "mapped", [42857]],
      [[42857, 42857], "valid"],
      [[42858, 42858], "mapped", [42859]],
      [[42859, 42859], "valid"],
      [[42860, 42860], "mapped", [42861]],
      [[42861, 42861], "valid"],
      [[42862, 42862], "mapped", [42863]],
      [[42863, 42863], "valid"],
      [[42864, 42864], "mapped", [42863]],
      [[42865, 42872], "valid"],
      [[42873, 42873], "mapped", [42874]],
      [[42874, 42874], "valid"],
      [[42875, 42875], "mapped", [42876]],
      [[42876, 42876], "valid"],
      [[42877, 42877], "mapped", [7545]],
      [[42878, 42878], "mapped", [42879]],
      [[42879, 42879], "valid"],
      [[42880, 42880], "mapped", [42881]],
      [[42881, 42881], "valid"],
      [[42882, 42882], "mapped", [42883]],
      [[42883, 42883], "valid"],
      [[42884, 42884], "mapped", [42885]],
      [[42885, 42885], "valid"],
      [[42886, 42886], "mapped", [42887]],
      [[42887, 42888], "valid"],
      [[42889, 42890], "valid", [], "NV8"],
      [[42891, 42891], "mapped", [42892]],
      [[42892, 42892], "valid"],
      [[42893, 42893], "mapped", [613]],
      [[42894, 42894], "valid"],
      [[42895, 42895], "valid"],
      [[42896, 42896], "mapped", [42897]],
      [[42897, 42897], "valid"],
      [[42898, 42898], "mapped", [42899]],
      [[42899, 42899], "valid"],
      [[42900, 42901], "valid"],
      [[42902, 42902], "mapped", [42903]],
      [[42903, 42903], "valid"],
      [[42904, 42904], "mapped", [42905]],
      [[42905, 42905], "valid"],
      [[42906, 42906], "mapped", [42907]],
      [[42907, 42907], "valid"],
      [[42908, 42908], "mapped", [42909]],
      [[42909, 42909], "valid"],
      [[42910, 42910], "mapped", [42911]],
      [[42911, 42911], "valid"],
      [[42912, 42912], "mapped", [42913]],
      [[42913, 42913], "valid"],
      [[42914, 42914], "mapped", [42915]],
      [[42915, 42915], "valid"],
      [[42916, 42916], "mapped", [42917]],
      [[42917, 42917], "valid"],
      [[42918, 42918], "mapped", [42919]],
      [[42919, 42919], "valid"],
      [[42920, 42920], "mapped", [42921]],
      [[42921, 42921], "valid"],
      [[42922, 42922], "mapped", [614]],
      [[42923, 42923], "mapped", [604]],
      [[42924, 42924], "mapped", [609]],
      [[42925, 42925], "mapped", [620]],
      [[42926, 42927], "disallowed"],
      [[42928, 42928], "mapped", [670]],
      [[42929, 42929], "mapped", [647]],
      [[42930, 42930], "mapped", [669]],
      [[42931, 42931], "mapped", [43859]],
      [[42932, 42932], "mapped", [42933]],
      [[42933, 42933], "valid"],
      [[42934, 42934], "mapped", [42935]],
      [[42935, 42935], "valid"],
      [[42936, 42998], "disallowed"],
      [[42999, 42999], "valid"],
      [[43e3, 43e3], "mapped", [295]],
      [[43001, 43001], "mapped", [339]],
      [[43002, 43002], "valid"],
      [[43003, 43007], "valid"],
      [[43008, 43047], "valid"],
      [[43048, 43051], "valid", [], "NV8"],
      [[43052, 43055], "disallowed"],
      [[43056, 43065], "valid", [], "NV8"],
      [[43066, 43071], "disallowed"],
      [[43072, 43123], "valid"],
      [[43124, 43127], "valid", [], "NV8"],
      [[43128, 43135], "disallowed"],
      [[43136, 43204], "valid"],
      [[43205, 43213], "disallowed"],
      [[43214, 43215], "valid", [], "NV8"],
      [[43216, 43225], "valid"],
      [[43226, 43231], "disallowed"],
      [[43232, 43255], "valid"],
      [[43256, 43258], "valid", [], "NV8"],
      [[43259, 43259], "valid"],
      [[43260, 43260], "valid", [], "NV8"],
      [[43261, 43261], "valid"],
      [[43262, 43263], "disallowed"],
      [[43264, 43309], "valid"],
      [[43310, 43311], "valid", [], "NV8"],
      [[43312, 43347], "valid"],
      [[43348, 43358], "disallowed"],
      [[43359, 43359], "valid", [], "NV8"],
      [[43360, 43388], "valid", [], "NV8"],
      [[43389, 43391], "disallowed"],
      [[43392, 43456], "valid"],
      [[43457, 43469], "valid", [], "NV8"],
      [[43470, 43470], "disallowed"],
      [[43471, 43481], "valid"],
      [[43482, 43485], "disallowed"],
      [[43486, 43487], "valid", [], "NV8"],
      [[43488, 43518], "valid"],
      [[43519, 43519], "disallowed"],
      [[43520, 43574], "valid"],
      [[43575, 43583], "disallowed"],
      [[43584, 43597], "valid"],
      [[43598, 43599], "disallowed"],
      [[43600, 43609], "valid"],
      [[43610, 43611], "disallowed"],
      [[43612, 43615], "valid", [], "NV8"],
      [[43616, 43638], "valid"],
      [[43639, 43641], "valid", [], "NV8"],
      [[43642, 43643], "valid"],
      [[43644, 43647], "valid"],
      [[43648, 43714], "valid"],
      [[43715, 43738], "disallowed"],
      [[43739, 43741], "valid"],
      [[43742, 43743], "valid", [], "NV8"],
      [[43744, 43759], "valid"],
      [[43760, 43761], "valid", [], "NV8"],
      [[43762, 43766], "valid"],
      [[43767, 43776], "disallowed"],
      [[43777, 43782], "valid"],
      [[43783, 43784], "disallowed"],
      [[43785, 43790], "valid"],
      [[43791, 43792], "disallowed"],
      [[43793, 43798], "valid"],
      [[43799, 43807], "disallowed"],
      [[43808, 43814], "valid"],
      [[43815, 43815], "disallowed"],
      [[43816, 43822], "valid"],
      [[43823, 43823], "disallowed"],
      [[43824, 43866], "valid"],
      [[43867, 43867], "valid", [], "NV8"],
      [[43868, 43868], "mapped", [42791]],
      [[43869, 43869], "mapped", [43831]],
      [[43870, 43870], "mapped", [619]],
      [[43871, 43871], "mapped", [43858]],
      [[43872, 43875], "valid"],
      [[43876, 43877], "valid"],
      [[43878, 43887], "disallowed"],
      [[43888, 43888], "mapped", [5024]],
      [[43889, 43889], "mapped", [5025]],
      [[43890, 43890], "mapped", [5026]],
      [[43891, 43891], "mapped", [5027]],
      [[43892, 43892], "mapped", [5028]],
      [[43893, 43893], "mapped", [5029]],
      [[43894, 43894], "mapped", [5030]],
      [[43895, 43895], "mapped", [5031]],
      [[43896, 43896], "mapped", [5032]],
      [[43897, 43897], "mapped", [5033]],
      [[43898, 43898], "mapped", [5034]],
      [[43899, 43899], "mapped", [5035]],
      [[43900, 43900], "mapped", [5036]],
      [[43901, 43901], "mapped", [5037]],
      [[43902, 43902], "mapped", [5038]],
      [[43903, 43903], "mapped", [5039]],
      [[43904, 43904], "mapped", [5040]],
      [[43905, 43905], "mapped", [5041]],
      [[43906, 43906], "mapped", [5042]],
      [[43907, 43907], "mapped", [5043]],
      [[43908, 43908], "mapped", [5044]],
      [[43909, 43909], "mapped", [5045]],
      [[43910, 43910], "mapped", [5046]],
      [[43911, 43911], "mapped", [5047]],
      [[43912, 43912], "mapped", [5048]],
      [[43913, 43913], "mapped", [5049]],
      [[43914, 43914], "mapped", [5050]],
      [[43915, 43915], "mapped", [5051]],
      [[43916, 43916], "mapped", [5052]],
      [[43917, 43917], "mapped", [5053]],
      [[43918, 43918], "mapped", [5054]],
      [[43919, 43919], "mapped", [5055]],
      [[43920, 43920], "mapped", [5056]],
      [[43921, 43921], "mapped", [5057]],
      [[43922, 43922], "mapped", [5058]],
      [[43923, 43923], "mapped", [5059]],
      [[43924, 43924], "mapped", [5060]],
      [[43925, 43925], "mapped", [5061]],
      [[43926, 43926], "mapped", [5062]],
      [[43927, 43927], "mapped", [5063]],
      [[43928, 43928], "mapped", [5064]],
      [[43929, 43929], "mapped", [5065]],
      [[43930, 43930], "mapped", [5066]],
      [[43931, 43931], "mapped", [5067]],
      [[43932, 43932], "mapped", [5068]],
      [[43933, 43933], "mapped", [5069]],
      [[43934, 43934], "mapped", [5070]],
      [[43935, 43935], "mapped", [5071]],
      [[43936, 43936], "mapped", [5072]],
      [[43937, 43937], "mapped", [5073]],
      [[43938, 43938], "mapped", [5074]],
      [[43939, 43939], "mapped", [5075]],
      [[43940, 43940], "mapped", [5076]],
      [[43941, 43941], "mapped", [5077]],
      [[43942, 43942], "mapped", [5078]],
      [[43943, 43943], "mapped", [5079]],
      [[43944, 43944], "mapped", [5080]],
      [[43945, 43945], "mapped", [5081]],
      [[43946, 43946], "mapped", [5082]],
      [[43947, 43947], "mapped", [5083]],
      [[43948, 43948], "mapped", [5084]],
      [[43949, 43949], "mapped", [5085]],
      [[43950, 43950], "mapped", [5086]],
      [[43951, 43951], "mapped", [5087]],
      [[43952, 43952], "mapped", [5088]],
      [[43953, 43953], "mapped", [5089]],
      [[43954, 43954], "mapped", [5090]],
      [[43955, 43955], "mapped", [5091]],
      [[43956, 43956], "mapped", [5092]],
      [[43957, 43957], "mapped", [5093]],
      [[43958, 43958], "mapped", [5094]],
      [[43959, 43959], "mapped", [5095]],
      [[43960, 43960], "mapped", [5096]],
      [[43961, 43961], "mapped", [5097]],
      [[43962, 43962], "mapped", [5098]],
      [[43963, 43963], "mapped", [5099]],
      [[43964, 43964], "mapped", [5100]],
      [[43965, 43965], "mapped", [5101]],
      [[43966, 43966], "mapped", [5102]],
      [[43967, 43967], "mapped", [5103]],
      [[43968, 44010], "valid"],
      [[44011, 44011], "valid", [], "NV8"],
      [[44012, 44013], "valid"],
      [[44014, 44015], "disallowed"],
      [[44016, 44025], "valid"],
      [[44026, 44031], "disallowed"],
      [[44032, 55203], "valid"],
      [[55204, 55215], "disallowed"],
      [[55216, 55238], "valid", [], "NV8"],
      [[55239, 55242], "disallowed"],
      [[55243, 55291], "valid", [], "NV8"],
      [[55292, 55295], "disallowed"],
      [[55296, 57343], "disallowed"],
      [[57344, 63743], "disallowed"],
      [[63744, 63744], "mapped", [35912]],
      [[63745, 63745], "mapped", [26356]],
      [[63746, 63746], "mapped", [36554]],
      [[63747, 63747], "mapped", [36040]],
      [[63748, 63748], "mapped", [28369]],
      [[63749, 63749], "mapped", [20018]],
      [[63750, 63750], "mapped", [21477]],
      [[63751, 63752], "mapped", [40860]],
      [[63753, 63753], "mapped", [22865]],
      [[63754, 63754], "mapped", [37329]],
      [[63755, 63755], "mapped", [21895]],
      [[63756, 63756], "mapped", [22856]],
      [[63757, 63757], "mapped", [25078]],
      [[63758, 63758], "mapped", [30313]],
      [[63759, 63759], "mapped", [32645]],
      [[63760, 63760], "mapped", [34367]],
      [[63761, 63761], "mapped", [34746]],
      [[63762, 63762], "mapped", [35064]],
      [[63763, 63763], "mapped", [37007]],
      [[63764, 63764], "mapped", [27138]],
      [[63765, 63765], "mapped", [27931]],
      [[63766, 63766], "mapped", [28889]],
      [[63767, 63767], "mapped", [29662]],
      [[63768, 63768], "mapped", [33853]],
      [[63769, 63769], "mapped", [37226]],
      [[63770, 63770], "mapped", [39409]],
      [[63771, 63771], "mapped", [20098]],
      [[63772, 63772], "mapped", [21365]],
      [[63773, 63773], "mapped", [27396]],
      [[63774, 63774], "mapped", [29211]],
      [[63775, 63775], "mapped", [34349]],
      [[63776, 63776], "mapped", [40478]],
      [[63777, 63777], "mapped", [23888]],
      [[63778, 63778], "mapped", [28651]],
      [[63779, 63779], "mapped", [34253]],
      [[63780, 63780], "mapped", [35172]],
      [[63781, 63781], "mapped", [25289]],
      [[63782, 63782], "mapped", [33240]],
      [[63783, 63783], "mapped", [34847]],
      [[63784, 63784], "mapped", [24266]],
      [[63785, 63785], "mapped", [26391]],
      [[63786, 63786], "mapped", [28010]],
      [[63787, 63787], "mapped", [29436]],
      [[63788, 63788], "mapped", [37070]],
      [[63789, 63789], "mapped", [20358]],
      [[63790, 63790], "mapped", [20919]],
      [[63791, 63791], "mapped", [21214]],
      [[63792, 63792], "mapped", [25796]],
      [[63793, 63793], "mapped", [27347]],
      [[63794, 63794], "mapped", [29200]],
      [[63795, 63795], "mapped", [30439]],
      [[63796, 63796], "mapped", [32769]],
      [[63797, 63797], "mapped", [34310]],
      [[63798, 63798], "mapped", [34396]],
      [[63799, 63799], "mapped", [36335]],
      [[63800, 63800], "mapped", [38706]],
      [[63801, 63801], "mapped", [39791]],
      [[63802, 63802], "mapped", [40442]],
      [[63803, 63803], "mapped", [30860]],
      [[63804, 63804], "mapped", [31103]],
      [[63805, 63805], "mapped", [32160]],
      [[63806, 63806], "mapped", [33737]],
      [[63807, 63807], "mapped", [37636]],
      [[63808, 63808], "mapped", [40575]],
      [[63809, 63809], "mapped", [35542]],
      [[63810, 63810], "mapped", [22751]],
      [[63811, 63811], "mapped", [24324]],
      [[63812, 63812], "mapped", [31840]],
      [[63813, 63813], "mapped", [32894]],
      [[63814, 63814], "mapped", [29282]],
      [[63815, 63815], "mapped", [30922]],
      [[63816, 63816], "mapped", [36034]],
      [[63817, 63817], "mapped", [38647]],
      [[63818, 63818], "mapped", [22744]],
      [[63819, 63819], "mapped", [23650]],
      [[63820, 63820], "mapped", [27155]],
      [[63821, 63821], "mapped", [28122]],
      [[63822, 63822], "mapped", [28431]],
      [[63823, 63823], "mapped", [32047]],
      [[63824, 63824], "mapped", [32311]],
      [[63825, 63825], "mapped", [38475]],
      [[63826, 63826], "mapped", [21202]],
      [[63827, 63827], "mapped", [32907]],
      [[63828, 63828], "mapped", [20956]],
      [[63829, 63829], "mapped", [20940]],
      [[63830, 63830], "mapped", [31260]],
      [[63831, 63831], "mapped", [32190]],
      [[63832, 63832], "mapped", [33777]],
      [[63833, 63833], "mapped", [38517]],
      [[63834, 63834], "mapped", [35712]],
      [[63835, 63835], "mapped", [25295]],
      [[63836, 63836], "mapped", [27138]],
      [[63837, 63837], "mapped", [35582]],
      [[63838, 63838], "mapped", [20025]],
      [[63839, 63839], "mapped", [23527]],
      [[63840, 63840], "mapped", [24594]],
      [[63841, 63841], "mapped", [29575]],
      [[63842, 63842], "mapped", [30064]],
      [[63843, 63843], "mapped", [21271]],
      [[63844, 63844], "mapped", [30971]],
      [[63845, 63845], "mapped", [20415]],
      [[63846, 63846], "mapped", [24489]],
      [[63847, 63847], "mapped", [19981]],
      [[63848, 63848], "mapped", [27852]],
      [[63849, 63849], "mapped", [25976]],
      [[63850, 63850], "mapped", [32034]],
      [[63851, 63851], "mapped", [21443]],
      [[63852, 63852], "mapped", [22622]],
      [[63853, 63853], "mapped", [30465]],
      [[63854, 63854], "mapped", [33865]],
      [[63855, 63855], "mapped", [35498]],
      [[63856, 63856], "mapped", [27578]],
      [[63857, 63857], "mapped", [36784]],
      [[63858, 63858], "mapped", [27784]],
      [[63859, 63859], "mapped", [25342]],
      [[63860, 63860], "mapped", [33509]],
      [[63861, 63861], "mapped", [25504]],
      [[63862, 63862], "mapped", [30053]],
      [[63863, 63863], "mapped", [20142]],
      [[63864, 63864], "mapped", [20841]],
      [[63865, 63865], "mapped", [20937]],
      [[63866, 63866], "mapped", [26753]],
      [[63867, 63867], "mapped", [31975]],
      [[63868, 63868], "mapped", [33391]],
      [[63869, 63869], "mapped", [35538]],
      [[63870, 63870], "mapped", [37327]],
      [[63871, 63871], "mapped", [21237]],
      [[63872, 63872], "mapped", [21570]],
      [[63873, 63873], "mapped", [22899]],
      [[63874, 63874], "mapped", [24300]],
      [[63875, 63875], "mapped", [26053]],
      [[63876, 63876], "mapped", [28670]],
      [[63877, 63877], "mapped", [31018]],
      [[63878, 63878], "mapped", [38317]],
      [[63879, 63879], "mapped", [39530]],
      [[63880, 63880], "mapped", [40599]],
      [[63881, 63881], "mapped", [40654]],
      [[63882, 63882], "mapped", [21147]],
      [[63883, 63883], "mapped", [26310]],
      [[63884, 63884], "mapped", [27511]],
      [[63885, 63885], "mapped", [36706]],
      [[63886, 63886], "mapped", [24180]],
      [[63887, 63887], "mapped", [24976]],
      [[63888, 63888], "mapped", [25088]],
      [[63889, 63889], "mapped", [25754]],
      [[63890, 63890], "mapped", [28451]],
      [[63891, 63891], "mapped", [29001]],
      [[63892, 63892], "mapped", [29833]],
      [[63893, 63893], "mapped", [31178]],
      [[63894, 63894], "mapped", [32244]],
      [[63895, 63895], "mapped", [32879]],
      [[63896, 63896], "mapped", [36646]],
      [[63897, 63897], "mapped", [34030]],
      [[63898, 63898], "mapped", [36899]],
      [[63899, 63899], "mapped", [37706]],
      [[63900, 63900], "mapped", [21015]],
      [[63901, 63901], "mapped", [21155]],
      [[63902, 63902], "mapped", [21693]],
      [[63903, 63903], "mapped", [28872]],
      [[63904, 63904], "mapped", [35010]],
      [[63905, 63905], "mapped", [35498]],
      [[63906, 63906], "mapped", [24265]],
      [[63907, 63907], "mapped", [24565]],
      [[63908, 63908], "mapped", [25467]],
      [[63909, 63909], "mapped", [27566]],
      [[63910, 63910], "mapped", [31806]],
      [[63911, 63911], "mapped", [29557]],
      [[63912, 63912], "mapped", [20196]],
      [[63913, 63913], "mapped", [22265]],
      [[63914, 63914], "mapped", [23527]],
      [[63915, 63915], "mapped", [23994]],
      [[63916, 63916], "mapped", [24604]],
      [[63917, 63917], "mapped", [29618]],
      [[63918, 63918], "mapped", [29801]],
      [[63919, 63919], "mapped", [32666]],
      [[63920, 63920], "mapped", [32838]],
      [[63921, 63921], "mapped", [37428]],
      [[63922, 63922], "mapped", [38646]],
      [[63923, 63923], "mapped", [38728]],
      [[63924, 63924], "mapped", [38936]],
      [[63925, 63925], "mapped", [20363]],
      [[63926, 63926], "mapped", [31150]],
      [[63927, 63927], "mapped", [37300]],
      [[63928, 63928], "mapped", [38584]],
      [[63929, 63929], "mapped", [24801]],
      [[63930, 63930], "mapped", [20102]],
      [[63931, 63931], "mapped", [20698]],
      [[63932, 63932], "mapped", [23534]],
      [[63933, 63933], "mapped", [23615]],
      [[63934, 63934], "mapped", [26009]],
      [[63935, 63935], "mapped", [27138]],
      [[63936, 63936], "mapped", [29134]],
      [[63937, 63937], "mapped", [30274]],
      [[63938, 63938], "mapped", [34044]],
      [[63939, 63939], "mapped", [36988]],
      [[63940, 63940], "mapped", [40845]],
      [[63941, 63941], "mapped", [26248]],
      [[63942, 63942], "mapped", [38446]],
      [[63943, 63943], "mapped", [21129]],
      [[63944, 63944], "mapped", [26491]],
      [[63945, 63945], "mapped", [26611]],
      [[63946, 63946], "mapped", [27969]],
      [[63947, 63947], "mapped", [28316]],
      [[63948, 63948], "mapped", [29705]],
      [[63949, 63949], "mapped", [30041]],
      [[63950, 63950], "mapped", [30827]],
      [[63951, 63951], "mapped", [32016]],
      [[63952, 63952], "mapped", [39006]],
      [[63953, 63953], "mapped", [20845]],
      [[63954, 63954], "mapped", [25134]],
      [[63955, 63955], "mapped", [38520]],
      [[63956, 63956], "mapped", [20523]],
      [[63957, 63957], "mapped", [23833]],
      [[63958, 63958], "mapped", [28138]],
      [[63959, 63959], "mapped", [36650]],
      [[63960, 63960], "mapped", [24459]],
      [[63961, 63961], "mapped", [24900]],
      [[63962, 63962], "mapped", [26647]],
      [[63963, 63963], "mapped", [29575]],
      [[63964, 63964], "mapped", [38534]],
      [[63965, 63965], "mapped", [21033]],
      [[63966, 63966], "mapped", [21519]],
      [[63967, 63967], "mapped", [23653]],
      [[63968, 63968], "mapped", [26131]],
      [[63969, 63969], "mapped", [26446]],
      [[63970, 63970], "mapped", [26792]],
      [[63971, 63971], "mapped", [27877]],
      [[63972, 63972], "mapped", [29702]],
      [[63973, 63973], "mapped", [30178]],
      [[63974, 63974], "mapped", [32633]],
      [[63975, 63975], "mapped", [35023]],
      [[63976, 63976], "mapped", [35041]],
      [[63977, 63977], "mapped", [37324]],
      [[63978, 63978], "mapped", [38626]],
      [[63979, 63979], "mapped", [21311]],
      [[63980, 63980], "mapped", [28346]],
      [[63981, 63981], "mapped", [21533]],
      [[63982, 63982], "mapped", [29136]],
      [[63983, 63983], "mapped", [29848]],
      [[63984, 63984], "mapped", [34298]],
      [[63985, 63985], "mapped", [38563]],
      [[63986, 63986], "mapped", [40023]],
      [[63987, 63987], "mapped", [40607]],
      [[63988, 63988], "mapped", [26519]],
      [[63989, 63989], "mapped", [28107]],
      [[63990, 63990], "mapped", [33256]],
      [[63991, 63991], "mapped", [31435]],
      [[63992, 63992], "mapped", [31520]],
      [[63993, 63993], "mapped", [31890]],
      [[63994, 63994], "mapped", [29376]],
      [[63995, 63995], "mapped", [28825]],
      [[63996, 63996], "mapped", [35672]],
      [[63997, 63997], "mapped", [20160]],
      [[63998, 63998], "mapped", [33590]],
      [[63999, 63999], "mapped", [21050]],
      [[64e3, 64e3], "mapped", [20999]],
      [[64001, 64001], "mapped", [24230]],
      [[64002, 64002], "mapped", [25299]],
      [[64003, 64003], "mapped", [31958]],
      [[64004, 64004], "mapped", [23429]],
      [[64005, 64005], "mapped", [27934]],
      [[64006, 64006], "mapped", [26292]],
      [[64007, 64007], "mapped", [36667]],
      [[64008, 64008], "mapped", [34892]],
      [[64009, 64009], "mapped", [38477]],
      [[64010, 64010], "mapped", [35211]],
      [[64011, 64011], "mapped", [24275]],
      [[64012, 64012], "mapped", [20800]],
      [[64013, 64013], "mapped", [21952]],
      [[64014, 64015], "valid"],
      [[64016, 64016], "mapped", [22618]],
      [[64017, 64017], "valid"],
      [[64018, 64018], "mapped", [26228]],
      [[64019, 64020], "valid"],
      [[64021, 64021], "mapped", [20958]],
      [[64022, 64022], "mapped", [29482]],
      [[64023, 64023], "mapped", [30410]],
      [[64024, 64024], "mapped", [31036]],
      [[64025, 64025], "mapped", [31070]],
      [[64026, 64026], "mapped", [31077]],
      [[64027, 64027], "mapped", [31119]],
      [[64028, 64028], "mapped", [38742]],
      [[64029, 64029], "mapped", [31934]],
      [[64030, 64030], "mapped", [32701]],
      [[64031, 64031], "valid"],
      [[64032, 64032], "mapped", [34322]],
      [[64033, 64033], "valid"],
      [[64034, 64034], "mapped", [35576]],
      [[64035, 64036], "valid"],
      [[64037, 64037], "mapped", [36920]],
      [[64038, 64038], "mapped", [37117]],
      [[64039, 64041], "valid"],
      [[64042, 64042], "mapped", [39151]],
      [[64043, 64043], "mapped", [39164]],
      [[64044, 64044], "mapped", [39208]],
      [[64045, 64045], "mapped", [40372]],
      [[64046, 64046], "mapped", [37086]],
      [[64047, 64047], "mapped", [38583]],
      [[64048, 64048], "mapped", [20398]],
      [[64049, 64049], "mapped", [20711]],
      [[64050, 64050], "mapped", [20813]],
      [[64051, 64051], "mapped", [21193]],
      [[64052, 64052], "mapped", [21220]],
      [[64053, 64053], "mapped", [21329]],
      [[64054, 64054], "mapped", [21917]],
      [[64055, 64055], "mapped", [22022]],
      [[64056, 64056], "mapped", [22120]],
      [[64057, 64057], "mapped", [22592]],
      [[64058, 64058], "mapped", [22696]],
      [[64059, 64059], "mapped", [23652]],
      [[64060, 64060], "mapped", [23662]],
      [[64061, 64061], "mapped", [24724]],
      [[64062, 64062], "mapped", [24936]],
      [[64063, 64063], "mapped", [24974]],
      [[64064, 64064], "mapped", [25074]],
      [[64065, 64065], "mapped", [25935]],
      [[64066, 64066], "mapped", [26082]],
      [[64067, 64067], "mapped", [26257]],
      [[64068, 64068], "mapped", [26757]],
      [[64069, 64069], "mapped", [28023]],
      [[64070, 64070], "mapped", [28186]],
      [[64071, 64071], "mapped", [28450]],
      [[64072, 64072], "mapped", [29038]],
      [[64073, 64073], "mapped", [29227]],
      [[64074, 64074], "mapped", [29730]],
      [[64075, 64075], "mapped", [30865]],
      [[64076, 64076], "mapped", [31038]],
      [[64077, 64077], "mapped", [31049]],
      [[64078, 64078], "mapped", [31048]],
      [[64079, 64079], "mapped", [31056]],
      [[64080, 64080], "mapped", [31062]],
      [[64081, 64081], "mapped", [31069]],
      [[64082, 64082], "mapped", [31117]],
      [[64083, 64083], "mapped", [31118]],
      [[64084, 64084], "mapped", [31296]],
      [[64085, 64085], "mapped", [31361]],
      [[64086, 64086], "mapped", [31680]],
      [[64087, 64087], "mapped", [32244]],
      [[64088, 64088], "mapped", [32265]],
      [[64089, 64089], "mapped", [32321]],
      [[64090, 64090], "mapped", [32626]],
      [[64091, 64091], "mapped", [32773]],
      [[64092, 64092], "mapped", [33261]],
      [[64093, 64094], "mapped", [33401]],
      [[64095, 64095], "mapped", [33879]],
      [[64096, 64096], "mapped", [35088]],
      [[64097, 64097], "mapped", [35222]],
      [[64098, 64098], "mapped", [35585]],
      [[64099, 64099], "mapped", [35641]],
      [[64100, 64100], "mapped", [36051]],
      [[64101, 64101], "mapped", [36104]],
      [[64102, 64102], "mapped", [36790]],
      [[64103, 64103], "mapped", [36920]],
      [[64104, 64104], "mapped", [38627]],
      [[64105, 64105], "mapped", [38911]],
      [[64106, 64106], "mapped", [38971]],
      [[64107, 64107], "mapped", [24693]],
      [[64108, 64108], "mapped", [148206]],
      [[64109, 64109], "mapped", [33304]],
      [[64110, 64111], "disallowed"],
      [[64112, 64112], "mapped", [20006]],
      [[64113, 64113], "mapped", [20917]],
      [[64114, 64114], "mapped", [20840]],
      [[64115, 64115], "mapped", [20352]],
      [[64116, 64116], "mapped", [20805]],
      [[64117, 64117], "mapped", [20864]],
      [[64118, 64118], "mapped", [21191]],
      [[64119, 64119], "mapped", [21242]],
      [[64120, 64120], "mapped", [21917]],
      [[64121, 64121], "mapped", [21845]],
      [[64122, 64122], "mapped", [21913]],
      [[64123, 64123], "mapped", [21986]],
      [[64124, 64124], "mapped", [22618]],
      [[64125, 64125], "mapped", [22707]],
      [[64126, 64126], "mapped", [22852]],
      [[64127, 64127], "mapped", [22868]],
      [[64128, 64128], "mapped", [23138]],
      [[64129, 64129], "mapped", [23336]],
      [[64130, 64130], "mapped", [24274]],
      [[64131, 64131], "mapped", [24281]],
      [[64132, 64132], "mapped", [24425]],
      [[64133, 64133], "mapped", [24493]],
      [[64134, 64134], "mapped", [24792]],
      [[64135, 64135], "mapped", [24910]],
      [[64136, 64136], "mapped", [24840]],
      [[64137, 64137], "mapped", [24974]],
      [[64138, 64138], "mapped", [24928]],
      [[64139, 64139], "mapped", [25074]],
      [[64140, 64140], "mapped", [25140]],
      [[64141, 64141], "mapped", [25540]],
      [[64142, 64142], "mapped", [25628]],
      [[64143, 64143], "mapped", [25682]],
      [[64144, 64144], "mapped", [25942]],
      [[64145, 64145], "mapped", [26228]],
      [[64146, 64146], "mapped", [26391]],
      [[64147, 64147], "mapped", [26395]],
      [[64148, 64148], "mapped", [26454]],
      [[64149, 64149], "mapped", [27513]],
      [[64150, 64150], "mapped", [27578]],
      [[64151, 64151], "mapped", [27969]],
      [[64152, 64152], "mapped", [28379]],
      [[64153, 64153], "mapped", [28363]],
      [[64154, 64154], "mapped", [28450]],
      [[64155, 64155], "mapped", [28702]],
      [[64156, 64156], "mapped", [29038]],
      [[64157, 64157], "mapped", [30631]],
      [[64158, 64158], "mapped", [29237]],
      [[64159, 64159], "mapped", [29359]],
      [[64160, 64160], "mapped", [29482]],
      [[64161, 64161], "mapped", [29809]],
      [[64162, 64162], "mapped", [29958]],
      [[64163, 64163], "mapped", [30011]],
      [[64164, 64164], "mapped", [30237]],
      [[64165, 64165], "mapped", [30239]],
      [[64166, 64166], "mapped", [30410]],
      [[64167, 64167], "mapped", [30427]],
      [[64168, 64168], "mapped", [30452]],
      [[64169, 64169], "mapped", [30538]],
      [[64170, 64170], "mapped", [30528]],
      [[64171, 64171], "mapped", [30924]],
      [[64172, 64172], "mapped", [31409]],
      [[64173, 64173], "mapped", [31680]],
      [[64174, 64174], "mapped", [31867]],
      [[64175, 64175], "mapped", [32091]],
      [[64176, 64176], "mapped", [32244]],
      [[64177, 64177], "mapped", [32574]],
      [[64178, 64178], "mapped", [32773]],
      [[64179, 64179], "mapped", [33618]],
      [[64180, 64180], "mapped", [33775]],
      [[64181, 64181], "mapped", [34681]],
      [[64182, 64182], "mapped", [35137]],
      [[64183, 64183], "mapped", [35206]],
      [[64184, 64184], "mapped", [35222]],
      [[64185, 64185], "mapped", [35519]],
      [[64186, 64186], "mapped", [35576]],
      [[64187, 64187], "mapped", [35531]],
      [[64188, 64188], "mapped", [35585]],
      [[64189, 64189], "mapped", [35582]],
      [[64190, 64190], "mapped", [35565]],
      [[64191, 64191], "mapped", [35641]],
      [[64192, 64192], "mapped", [35722]],
      [[64193, 64193], "mapped", [36104]],
      [[64194, 64194], "mapped", [36664]],
      [[64195, 64195], "mapped", [36978]],
      [[64196, 64196], "mapped", [37273]],
      [[64197, 64197], "mapped", [37494]],
      [[64198, 64198], "mapped", [38524]],
      [[64199, 64199], "mapped", [38627]],
      [[64200, 64200], "mapped", [38742]],
      [[64201, 64201], "mapped", [38875]],
      [[64202, 64202], "mapped", [38911]],
      [[64203, 64203], "mapped", [38923]],
      [[64204, 64204], "mapped", [38971]],
      [[64205, 64205], "mapped", [39698]],
      [[64206, 64206], "mapped", [40860]],
      [[64207, 64207], "mapped", [141386]],
      [[64208, 64208], "mapped", [141380]],
      [[64209, 64209], "mapped", [144341]],
      [[64210, 64210], "mapped", [15261]],
      [[64211, 64211], "mapped", [16408]],
      [[64212, 64212], "mapped", [16441]],
      [[64213, 64213], "mapped", [152137]],
      [[64214, 64214], "mapped", [154832]],
      [[64215, 64215], "mapped", [163539]],
      [[64216, 64216], "mapped", [40771]],
      [[64217, 64217], "mapped", [40846]],
      [[64218, 64255], "disallowed"],
      [[64256, 64256], "mapped", [102, 102]],
      [[64257, 64257], "mapped", [102, 105]],
      [[64258, 64258], "mapped", [102, 108]],
      [[64259, 64259], "mapped", [102, 102, 105]],
      [[64260, 64260], "mapped", [102, 102, 108]],
      [[64261, 64262], "mapped", [115, 116]],
      [[64263, 64274], "disallowed"],
      [[64275, 64275], "mapped", [1396, 1398]],
      [[64276, 64276], "mapped", [1396, 1381]],
      [[64277, 64277], "mapped", [1396, 1387]],
      [[64278, 64278], "mapped", [1406, 1398]],
      [[64279, 64279], "mapped", [1396, 1389]],
      [[64280, 64284], "disallowed"],
      [[64285, 64285], "mapped", [1497, 1460]],
      [[64286, 64286], "valid"],
      [[64287, 64287], "mapped", [1522, 1463]],
      [[64288, 64288], "mapped", [1506]],
      [[64289, 64289], "mapped", [1488]],
      [[64290, 64290], "mapped", [1491]],
      [[64291, 64291], "mapped", [1492]],
      [[64292, 64292], "mapped", [1499]],
      [[64293, 64293], "mapped", [1500]],
      [[64294, 64294], "mapped", [1501]],
      [[64295, 64295], "mapped", [1512]],
      [[64296, 64296], "mapped", [1514]],
      [[64297, 64297], "disallowed_STD3_mapped", [43]],
      [[64298, 64298], "mapped", [1513, 1473]],
      [[64299, 64299], "mapped", [1513, 1474]],
      [[64300, 64300], "mapped", [1513, 1468, 1473]],
      [[64301, 64301], "mapped", [1513, 1468, 1474]],
      [[64302, 64302], "mapped", [1488, 1463]],
      [[64303, 64303], "mapped", [1488, 1464]],
      [[64304, 64304], "mapped", [1488, 1468]],
      [[64305, 64305], "mapped", [1489, 1468]],
      [[64306, 64306], "mapped", [1490, 1468]],
      [[64307, 64307], "mapped", [1491, 1468]],
      [[64308, 64308], "mapped", [1492, 1468]],
      [[64309, 64309], "mapped", [1493, 1468]],
      [[64310, 64310], "mapped", [1494, 1468]],
      [[64311, 64311], "disallowed"],
      [[64312, 64312], "mapped", [1496, 1468]],
      [[64313, 64313], "mapped", [1497, 1468]],
      [[64314, 64314], "mapped", [1498, 1468]],
      [[64315, 64315], "mapped", [1499, 1468]],
      [[64316, 64316], "mapped", [1500, 1468]],
      [[64317, 64317], "disallowed"],
      [[64318, 64318], "mapped", [1502, 1468]],
      [[64319, 64319], "disallowed"],
      [[64320, 64320], "mapped", [1504, 1468]],
      [[64321, 64321], "mapped", [1505, 1468]],
      [[64322, 64322], "disallowed"],
      [[64323, 64323], "mapped", [1507, 1468]],
      [[64324, 64324], "mapped", [1508, 1468]],
      [[64325, 64325], "disallowed"],
      [[64326, 64326], "mapped", [1510, 1468]],
      [[64327, 64327], "mapped", [1511, 1468]],
      [[64328, 64328], "mapped", [1512, 1468]],
      [[64329, 64329], "mapped", [1513, 1468]],
      [[64330, 64330], "mapped", [1514, 1468]],
      [[64331, 64331], "mapped", [1493, 1465]],
      [[64332, 64332], "mapped", [1489, 1471]],
      [[64333, 64333], "mapped", [1499, 1471]],
      [[64334, 64334], "mapped", [1508, 1471]],
      [[64335, 64335], "mapped", [1488, 1500]],
      [[64336, 64337], "mapped", [1649]],
      [[64338, 64341], "mapped", [1659]],
      [[64342, 64345], "mapped", [1662]],
      [[64346, 64349], "mapped", [1664]],
      [[64350, 64353], "mapped", [1658]],
      [[64354, 64357], "mapped", [1663]],
      [[64358, 64361], "mapped", [1657]],
      [[64362, 64365], "mapped", [1700]],
      [[64366, 64369], "mapped", [1702]],
      [[64370, 64373], "mapped", [1668]],
      [[64374, 64377], "mapped", [1667]],
      [[64378, 64381], "mapped", [1670]],
      [[64382, 64385], "mapped", [1671]],
      [[64386, 64387], "mapped", [1677]],
      [[64388, 64389], "mapped", [1676]],
      [[64390, 64391], "mapped", [1678]],
      [[64392, 64393], "mapped", [1672]],
      [[64394, 64395], "mapped", [1688]],
      [[64396, 64397], "mapped", [1681]],
      [[64398, 64401], "mapped", [1705]],
      [[64402, 64405], "mapped", [1711]],
      [[64406, 64409], "mapped", [1715]],
      [[64410, 64413], "mapped", [1713]],
      [[64414, 64415], "mapped", [1722]],
      [[64416, 64419], "mapped", [1723]],
      [[64420, 64421], "mapped", [1728]],
      [[64422, 64425], "mapped", [1729]],
      [[64426, 64429], "mapped", [1726]],
      [[64430, 64431], "mapped", [1746]],
      [[64432, 64433], "mapped", [1747]],
      [[64434, 64449], "valid", [], "NV8"],
      [[64450, 64466], "disallowed"],
      [[64467, 64470], "mapped", [1709]],
      [[64471, 64472], "mapped", [1735]],
      [[64473, 64474], "mapped", [1734]],
      [[64475, 64476], "mapped", [1736]],
      [[64477, 64477], "mapped", [1735, 1652]],
      [[64478, 64479], "mapped", [1739]],
      [[64480, 64481], "mapped", [1733]],
      [[64482, 64483], "mapped", [1737]],
      [[64484, 64487], "mapped", [1744]],
      [[64488, 64489], "mapped", [1609]],
      [[64490, 64491], "mapped", [1574, 1575]],
      [[64492, 64493], "mapped", [1574, 1749]],
      [[64494, 64495], "mapped", [1574, 1608]],
      [[64496, 64497], "mapped", [1574, 1735]],
      [[64498, 64499], "mapped", [1574, 1734]],
      [[64500, 64501], "mapped", [1574, 1736]],
      [[64502, 64504], "mapped", [1574, 1744]],
      [[64505, 64507], "mapped", [1574, 1609]],
      [[64508, 64511], "mapped", [1740]],
      [[64512, 64512], "mapped", [1574, 1580]],
      [[64513, 64513], "mapped", [1574, 1581]],
      [[64514, 64514], "mapped", [1574, 1605]],
      [[64515, 64515], "mapped", [1574, 1609]],
      [[64516, 64516], "mapped", [1574, 1610]],
      [[64517, 64517], "mapped", [1576, 1580]],
      [[64518, 64518], "mapped", [1576, 1581]],
      [[64519, 64519], "mapped", [1576, 1582]],
      [[64520, 64520], "mapped", [1576, 1605]],
      [[64521, 64521], "mapped", [1576, 1609]],
      [[64522, 64522], "mapped", [1576, 1610]],
      [[64523, 64523], "mapped", [1578, 1580]],
      [[64524, 64524], "mapped", [1578, 1581]],
      [[64525, 64525], "mapped", [1578, 1582]],
      [[64526, 64526], "mapped", [1578, 1605]],
      [[64527, 64527], "mapped", [1578, 1609]],
      [[64528, 64528], "mapped", [1578, 1610]],
      [[64529, 64529], "mapped", [1579, 1580]],
      [[64530, 64530], "mapped", [1579, 1605]],
      [[64531, 64531], "mapped", [1579, 1609]],
      [[64532, 64532], "mapped", [1579, 1610]],
      [[64533, 64533], "mapped", [1580, 1581]],
      [[64534, 64534], "mapped", [1580, 1605]],
      [[64535, 64535], "mapped", [1581, 1580]],
      [[64536, 64536], "mapped", [1581, 1605]],
      [[64537, 64537], "mapped", [1582, 1580]],
      [[64538, 64538], "mapped", [1582, 1581]],
      [[64539, 64539], "mapped", [1582, 1605]],
      [[64540, 64540], "mapped", [1587, 1580]],
      [[64541, 64541], "mapped", [1587, 1581]],
      [[64542, 64542], "mapped", [1587, 1582]],
      [[64543, 64543], "mapped", [1587, 1605]],
      [[64544, 64544], "mapped", [1589, 1581]],
      [[64545, 64545], "mapped", [1589, 1605]],
      [[64546, 64546], "mapped", [1590, 1580]],
      [[64547, 64547], "mapped", [1590, 1581]],
      [[64548, 64548], "mapped", [1590, 1582]],
      [[64549, 64549], "mapped", [1590, 1605]],
      [[64550, 64550], "mapped", [1591, 1581]],
      [[64551, 64551], "mapped", [1591, 1605]],
      [[64552, 64552], "mapped", [1592, 1605]],
      [[64553, 64553], "mapped", [1593, 1580]],
      [[64554, 64554], "mapped", [1593, 1605]],
      [[64555, 64555], "mapped", [1594, 1580]],
      [[64556, 64556], "mapped", [1594, 1605]],
      [[64557, 64557], "mapped", [1601, 1580]],
      [[64558, 64558], "mapped", [1601, 1581]],
      [[64559, 64559], "mapped", [1601, 1582]],
      [[64560, 64560], "mapped", [1601, 1605]],
      [[64561, 64561], "mapped", [1601, 1609]],
      [[64562, 64562], "mapped", [1601, 1610]],
      [[64563, 64563], "mapped", [1602, 1581]],
      [[64564, 64564], "mapped", [1602, 1605]],
      [[64565, 64565], "mapped", [1602, 1609]],
      [[64566, 64566], "mapped", [1602, 1610]],
      [[64567, 64567], "mapped", [1603, 1575]],
      [[64568, 64568], "mapped", [1603, 1580]],
      [[64569, 64569], "mapped", [1603, 1581]],
      [[64570, 64570], "mapped", [1603, 1582]],
      [[64571, 64571], "mapped", [1603, 1604]],
      [[64572, 64572], "mapped", [1603, 1605]],
      [[64573, 64573], "mapped", [1603, 1609]],
      [[64574, 64574], "mapped", [1603, 1610]],
      [[64575, 64575], "mapped", [1604, 1580]],
      [[64576, 64576], "mapped", [1604, 1581]],
      [[64577, 64577], "mapped", [1604, 1582]],
      [[64578, 64578], "mapped", [1604, 1605]],
      [[64579, 64579], "mapped", [1604, 1609]],
      [[64580, 64580], "mapped", [1604, 1610]],
      [[64581, 64581], "mapped", [1605, 1580]],
      [[64582, 64582], "mapped", [1605, 1581]],
      [[64583, 64583], "mapped", [1605, 1582]],
      [[64584, 64584], "mapped", [1605, 1605]],
      [[64585, 64585], "mapped", [1605, 1609]],
      [[64586, 64586], "mapped", [1605, 1610]],
      [[64587, 64587], "mapped", [1606, 1580]],
      [[64588, 64588], "mapped", [1606, 1581]],
      [[64589, 64589], "mapped", [1606, 1582]],
      [[64590, 64590], "mapped", [1606, 1605]],
      [[64591, 64591], "mapped", [1606, 1609]],
      [[64592, 64592], "mapped", [1606, 1610]],
      [[64593, 64593], "mapped", [1607, 1580]],
      [[64594, 64594], "mapped", [1607, 1605]],
      [[64595, 64595], "mapped", [1607, 1609]],
      [[64596, 64596], "mapped", [1607, 1610]],
      [[64597, 64597], "mapped", [1610, 1580]],
      [[64598, 64598], "mapped", [1610, 1581]],
      [[64599, 64599], "mapped", [1610, 1582]],
      [[64600, 64600], "mapped", [1610, 1605]],
      [[64601, 64601], "mapped", [1610, 1609]],
      [[64602, 64602], "mapped", [1610, 1610]],
      [[64603, 64603], "mapped", [1584, 1648]],
      [[64604, 64604], "mapped", [1585, 1648]],
      [[64605, 64605], "mapped", [1609, 1648]],
      [[64606, 64606], "disallowed_STD3_mapped", [32, 1612, 1617]],
      [[64607, 64607], "disallowed_STD3_mapped", [32, 1613, 1617]],
      [[64608, 64608], "disallowed_STD3_mapped", [32, 1614, 1617]],
      [[64609, 64609], "disallowed_STD3_mapped", [32, 1615, 1617]],
      [[64610, 64610], "disallowed_STD3_mapped", [32, 1616, 1617]],
      [[64611, 64611], "disallowed_STD3_mapped", [32, 1617, 1648]],
      [[64612, 64612], "mapped", [1574, 1585]],
      [[64613, 64613], "mapped", [1574, 1586]],
      [[64614, 64614], "mapped", [1574, 1605]],
      [[64615, 64615], "mapped", [1574, 1606]],
      [[64616, 64616], "mapped", [1574, 1609]],
      [[64617, 64617], "mapped", [1574, 1610]],
      [[64618, 64618], "mapped", [1576, 1585]],
      [[64619, 64619], "mapped", [1576, 1586]],
      [[64620, 64620], "mapped", [1576, 1605]],
      [[64621, 64621], "mapped", [1576, 1606]],
      [[64622, 64622], "mapped", [1576, 1609]],
      [[64623, 64623], "mapped", [1576, 1610]],
      [[64624, 64624], "mapped", [1578, 1585]],
      [[64625, 64625], "mapped", [1578, 1586]],
      [[64626, 64626], "mapped", [1578, 1605]],
      [[64627, 64627], "mapped", [1578, 1606]],
      [[64628, 64628], "mapped", [1578, 1609]],
      [[64629, 64629], "mapped", [1578, 1610]],
      [[64630, 64630], "mapped", [1579, 1585]],
      [[64631, 64631], "mapped", [1579, 1586]],
      [[64632, 64632], "mapped", [1579, 1605]],
      [[64633, 64633], "mapped", [1579, 1606]],
      [[64634, 64634], "mapped", [1579, 1609]],
      [[64635, 64635], "mapped", [1579, 1610]],
      [[64636, 64636], "mapped", [1601, 1609]],
      [[64637, 64637], "mapped", [1601, 1610]],
      [[64638, 64638], "mapped", [1602, 1609]],
      [[64639, 64639], "mapped", [1602, 1610]],
      [[64640, 64640], "mapped", [1603, 1575]],
      [[64641, 64641], "mapped", [1603, 1604]],
      [[64642, 64642], "mapped", [1603, 1605]],
      [[64643, 64643], "mapped", [1603, 1609]],
      [[64644, 64644], "mapped", [1603, 1610]],
      [[64645, 64645], "mapped", [1604, 1605]],
      [[64646, 64646], "mapped", [1604, 1609]],
      [[64647, 64647], "mapped", [1604, 1610]],
      [[64648, 64648], "mapped", [1605, 1575]],
      [[64649, 64649], "mapped", [1605, 1605]],
      [[64650, 64650], "mapped", [1606, 1585]],
      [[64651, 64651], "mapped", [1606, 1586]],
      [[64652, 64652], "mapped", [1606, 1605]],
      [[64653, 64653], "mapped", [1606, 1606]],
      [[64654, 64654], "mapped", [1606, 1609]],
      [[64655, 64655], "mapped", [1606, 1610]],
      [[64656, 64656], "mapped", [1609, 1648]],
      [[64657, 64657], "mapped", [1610, 1585]],
      [[64658, 64658], "mapped", [1610, 1586]],
      [[64659, 64659], "mapped", [1610, 1605]],
      [[64660, 64660], "mapped", [1610, 1606]],
      [[64661, 64661], "mapped", [1610, 1609]],
      [[64662, 64662], "mapped", [1610, 1610]],
      [[64663, 64663], "mapped", [1574, 1580]],
      [[64664, 64664], "mapped", [1574, 1581]],
      [[64665, 64665], "mapped", [1574, 1582]],
      [[64666, 64666], "mapped", [1574, 1605]],
      [[64667, 64667], "mapped", [1574, 1607]],
      [[64668, 64668], "mapped", [1576, 1580]],
      [[64669, 64669], "mapped", [1576, 1581]],
      [[64670, 64670], "mapped", [1576, 1582]],
      [[64671, 64671], "mapped", [1576, 1605]],
      [[64672, 64672], "mapped", [1576, 1607]],
      [[64673, 64673], "mapped", [1578, 1580]],
      [[64674, 64674], "mapped", [1578, 1581]],
      [[64675, 64675], "mapped", [1578, 1582]],
      [[64676, 64676], "mapped", [1578, 1605]],
      [[64677, 64677], "mapped", [1578, 1607]],
      [[64678, 64678], "mapped", [1579, 1605]],
      [[64679, 64679], "mapped", [1580, 1581]],
      [[64680, 64680], "mapped", [1580, 1605]],
      [[64681, 64681], "mapped", [1581, 1580]],
      [[64682, 64682], "mapped", [1581, 1605]],
      [[64683, 64683], "mapped", [1582, 1580]],
      [[64684, 64684], "mapped", [1582, 1605]],
      [[64685, 64685], "mapped", [1587, 1580]],
      [[64686, 64686], "mapped", [1587, 1581]],
      [[64687, 64687], "mapped", [1587, 1582]],
      [[64688, 64688], "mapped", [1587, 1605]],
      [[64689, 64689], "mapped", [1589, 1581]],
      [[64690, 64690], "mapped", [1589, 1582]],
      [[64691, 64691], "mapped", [1589, 1605]],
      [[64692, 64692], "mapped", [1590, 1580]],
      [[64693, 64693], "mapped", [1590, 1581]],
      [[64694, 64694], "mapped", [1590, 1582]],
      [[64695, 64695], "mapped", [1590, 1605]],
      [[64696, 64696], "mapped", [1591, 1581]],
      [[64697, 64697], "mapped", [1592, 1605]],
      [[64698, 64698], "mapped", [1593, 1580]],
      [[64699, 64699], "mapped", [1593, 1605]],
      [[64700, 64700], "mapped", [1594, 1580]],
      [[64701, 64701], "mapped", [1594, 1605]],
      [[64702, 64702], "mapped", [1601, 1580]],
      [[64703, 64703], "mapped", [1601, 1581]],
      [[64704, 64704], "mapped", [1601, 1582]],
      [[64705, 64705], "mapped", [1601, 1605]],
      [[64706, 64706], "mapped", [1602, 1581]],
      [[64707, 64707], "mapped", [1602, 1605]],
      [[64708, 64708], "mapped", [1603, 1580]],
      [[64709, 64709], "mapped", [1603, 1581]],
      [[64710, 64710], "mapped", [1603, 1582]],
      [[64711, 64711], "mapped", [1603, 1604]],
      [[64712, 64712], "mapped", [1603, 1605]],
      [[64713, 64713], "mapped", [1604, 1580]],
      [[64714, 64714], "mapped", [1604, 1581]],
      [[64715, 64715], "mapped", [1604, 1582]],
      [[64716, 64716], "mapped", [1604, 1605]],
      [[64717, 64717], "mapped", [1604, 1607]],
      [[64718, 64718], "mapped", [1605, 1580]],
      [[64719, 64719], "mapped", [1605, 1581]],
      [[64720, 64720], "mapped", [1605, 1582]],
      [[64721, 64721], "mapped", [1605, 1605]],
      [[64722, 64722], "mapped", [1606, 1580]],
      [[64723, 64723], "mapped", [1606, 1581]],
      [[64724, 64724], "mapped", [1606, 1582]],
      [[64725, 64725], "mapped", [1606, 1605]],
      [[64726, 64726], "mapped", [1606, 1607]],
      [[64727, 64727], "mapped", [1607, 1580]],
      [[64728, 64728], "mapped", [1607, 1605]],
      [[64729, 64729], "mapped", [1607, 1648]],
      [[64730, 64730], "mapped", [1610, 1580]],
      [[64731, 64731], "mapped", [1610, 1581]],
      [[64732, 64732], "mapped", [1610, 1582]],
      [[64733, 64733], "mapped", [1610, 1605]],
      [[64734, 64734], "mapped", [1610, 1607]],
      [[64735, 64735], "mapped", [1574, 1605]],
      [[64736, 64736], "mapped", [1574, 1607]],
      [[64737, 64737], "mapped", [1576, 1605]],
      [[64738, 64738], "mapped", [1576, 1607]],
      [[64739, 64739], "mapped", [1578, 1605]],
      [[64740, 64740], "mapped", [1578, 1607]],
      [[64741, 64741], "mapped", [1579, 1605]],
      [[64742, 64742], "mapped", [1579, 1607]],
      [[64743, 64743], "mapped", [1587, 1605]],
      [[64744, 64744], "mapped", [1587, 1607]],
      [[64745, 64745], "mapped", [1588, 1605]],
      [[64746, 64746], "mapped", [1588, 1607]],
      [[64747, 64747], "mapped", [1603, 1604]],
      [[64748, 64748], "mapped", [1603, 1605]],
      [[64749, 64749], "mapped", [1604, 1605]],
      [[64750, 64750], "mapped", [1606, 1605]],
      [[64751, 64751], "mapped", [1606, 1607]],
      [[64752, 64752], "mapped", [1610, 1605]],
      [[64753, 64753], "mapped", [1610, 1607]],
      [[64754, 64754], "mapped", [1600, 1614, 1617]],
      [[64755, 64755], "mapped", [1600, 1615, 1617]],
      [[64756, 64756], "mapped", [1600, 1616, 1617]],
      [[64757, 64757], "mapped", [1591, 1609]],
      [[64758, 64758], "mapped", [1591, 1610]],
      [[64759, 64759], "mapped", [1593, 1609]],
      [[64760, 64760], "mapped", [1593, 1610]],
      [[64761, 64761], "mapped", [1594, 1609]],
      [[64762, 64762], "mapped", [1594, 1610]],
      [[64763, 64763], "mapped", [1587, 1609]],
      [[64764, 64764], "mapped", [1587, 1610]],
      [[64765, 64765], "mapped", [1588, 1609]],
      [[64766, 64766], "mapped", [1588, 1610]],
      [[64767, 64767], "mapped", [1581, 1609]],
      [[64768, 64768], "mapped", [1581, 1610]],
      [[64769, 64769], "mapped", [1580, 1609]],
      [[64770, 64770], "mapped", [1580, 1610]],
      [[64771, 64771], "mapped", [1582, 1609]],
      [[64772, 64772], "mapped", [1582, 1610]],
      [[64773, 64773], "mapped", [1589, 1609]],
      [[64774, 64774], "mapped", [1589, 1610]],
      [[64775, 64775], "mapped", [1590, 1609]],
      [[64776, 64776], "mapped", [1590, 1610]],
      [[64777, 64777], "mapped", [1588, 1580]],
      [[64778, 64778], "mapped", [1588, 1581]],
      [[64779, 64779], "mapped", [1588, 1582]],
      [[64780, 64780], "mapped", [1588, 1605]],
      [[64781, 64781], "mapped", [1588, 1585]],
      [[64782, 64782], "mapped", [1587, 1585]],
      [[64783, 64783], "mapped", [1589, 1585]],
      [[64784, 64784], "mapped", [1590, 1585]],
      [[64785, 64785], "mapped", [1591, 1609]],
      [[64786, 64786], "mapped", [1591, 1610]],
      [[64787, 64787], "mapped", [1593, 1609]],
      [[64788, 64788], "mapped", [1593, 1610]],
      [[64789, 64789], "mapped", [1594, 1609]],
      [[64790, 64790], "mapped", [1594, 1610]],
      [[64791, 64791], "mapped", [1587, 1609]],
      [[64792, 64792], "mapped", [1587, 1610]],
      [[64793, 64793], "mapped", [1588, 1609]],
      [[64794, 64794], "mapped", [1588, 1610]],
      [[64795, 64795], "mapped", [1581, 1609]],
      [[64796, 64796], "mapped", [1581, 1610]],
      [[64797, 64797], "mapped", [1580, 1609]],
      [[64798, 64798], "mapped", [1580, 1610]],
      [[64799, 64799], "mapped", [1582, 1609]],
      [[64800, 64800], "mapped", [1582, 1610]],
      [[64801, 64801], "mapped", [1589, 1609]],
      [[64802, 64802], "mapped", [1589, 1610]],
      [[64803, 64803], "mapped", [1590, 1609]],
      [[64804, 64804], "mapped", [1590, 1610]],
      [[64805, 64805], "mapped", [1588, 1580]],
      [[64806, 64806], "mapped", [1588, 1581]],
      [[64807, 64807], "mapped", [1588, 1582]],
      [[64808, 64808], "mapped", [1588, 1605]],
      [[64809, 64809], "mapped", [1588, 1585]],
      [[64810, 64810], "mapped", [1587, 1585]],
      [[64811, 64811], "mapped", [1589, 1585]],
      [[64812, 64812], "mapped", [1590, 1585]],
      [[64813, 64813], "mapped", [1588, 1580]],
      [[64814, 64814], "mapped", [1588, 1581]],
      [[64815, 64815], "mapped", [1588, 1582]],
      [[64816, 64816], "mapped", [1588, 1605]],
      [[64817, 64817], "mapped", [1587, 1607]],
      [[64818, 64818], "mapped", [1588, 1607]],
      [[64819, 64819], "mapped", [1591, 1605]],
      [[64820, 64820], "mapped", [1587, 1580]],
      [[64821, 64821], "mapped", [1587, 1581]],
      [[64822, 64822], "mapped", [1587, 1582]],
      [[64823, 64823], "mapped", [1588, 1580]],
      [[64824, 64824], "mapped", [1588, 1581]],
      [[64825, 64825], "mapped", [1588, 1582]],
      [[64826, 64826], "mapped", [1591, 1605]],
      [[64827, 64827], "mapped", [1592, 1605]],
      [[64828, 64829], "mapped", [1575, 1611]],
      [[64830, 64831], "valid", [], "NV8"],
      [[64832, 64847], "disallowed"],
      [[64848, 64848], "mapped", [1578, 1580, 1605]],
      [[64849, 64850], "mapped", [1578, 1581, 1580]],
      [[64851, 64851], "mapped", [1578, 1581, 1605]],
      [[64852, 64852], "mapped", [1578, 1582, 1605]],
      [[64853, 64853], "mapped", [1578, 1605, 1580]],
      [[64854, 64854], "mapped", [1578, 1605, 1581]],
      [[64855, 64855], "mapped", [1578, 1605, 1582]],
      [[64856, 64857], "mapped", [1580, 1605, 1581]],
      [[64858, 64858], "mapped", [1581, 1605, 1610]],
      [[64859, 64859], "mapped", [1581, 1605, 1609]],
      [[64860, 64860], "mapped", [1587, 1581, 1580]],
      [[64861, 64861], "mapped", [1587, 1580, 1581]],
      [[64862, 64862], "mapped", [1587, 1580, 1609]],
      [[64863, 64864], "mapped", [1587, 1605, 1581]],
      [[64865, 64865], "mapped", [1587, 1605, 1580]],
      [[64866, 64867], "mapped", [1587, 1605, 1605]],
      [[64868, 64869], "mapped", [1589, 1581, 1581]],
      [[64870, 64870], "mapped", [1589, 1605, 1605]],
      [[64871, 64872], "mapped", [1588, 1581, 1605]],
      [[64873, 64873], "mapped", [1588, 1580, 1610]],
      [[64874, 64875], "mapped", [1588, 1605, 1582]],
      [[64876, 64877], "mapped", [1588, 1605, 1605]],
      [[64878, 64878], "mapped", [1590, 1581, 1609]],
      [[64879, 64880], "mapped", [1590, 1582, 1605]],
      [[64881, 64882], "mapped", [1591, 1605, 1581]],
      [[64883, 64883], "mapped", [1591, 1605, 1605]],
      [[64884, 64884], "mapped", [1591, 1605, 1610]],
      [[64885, 64885], "mapped", [1593, 1580, 1605]],
      [[64886, 64887], "mapped", [1593, 1605, 1605]],
      [[64888, 64888], "mapped", [1593, 1605, 1609]],
      [[64889, 64889], "mapped", [1594, 1605, 1605]],
      [[64890, 64890], "mapped", [1594, 1605, 1610]],
      [[64891, 64891], "mapped", [1594, 1605, 1609]],
      [[64892, 64893], "mapped", [1601, 1582, 1605]],
      [[64894, 64894], "mapped", [1602, 1605, 1581]],
      [[64895, 64895], "mapped", [1602, 1605, 1605]],
      [[64896, 64896], "mapped", [1604, 1581, 1605]],
      [[64897, 64897], "mapped", [1604, 1581, 1610]],
      [[64898, 64898], "mapped", [1604, 1581, 1609]],
      [[64899, 64900], "mapped", [1604, 1580, 1580]],
      [[64901, 64902], "mapped", [1604, 1582, 1605]],
      [[64903, 64904], "mapped", [1604, 1605, 1581]],
      [[64905, 64905], "mapped", [1605, 1581, 1580]],
      [[64906, 64906], "mapped", [1605, 1581, 1605]],
      [[64907, 64907], "mapped", [1605, 1581, 1610]],
      [[64908, 64908], "mapped", [1605, 1580, 1581]],
      [[64909, 64909], "mapped", [1605, 1580, 1605]],
      [[64910, 64910], "mapped", [1605, 1582, 1580]],
      [[64911, 64911], "mapped", [1605, 1582, 1605]],
      [[64912, 64913], "disallowed"],
      [[64914, 64914], "mapped", [1605, 1580, 1582]],
      [[64915, 64915], "mapped", [1607, 1605, 1580]],
      [[64916, 64916], "mapped", [1607, 1605, 1605]],
      [[64917, 64917], "mapped", [1606, 1581, 1605]],
      [[64918, 64918], "mapped", [1606, 1581, 1609]],
      [[64919, 64920], "mapped", [1606, 1580, 1605]],
      [[64921, 64921], "mapped", [1606, 1580, 1609]],
      [[64922, 64922], "mapped", [1606, 1605, 1610]],
      [[64923, 64923], "mapped", [1606, 1605, 1609]],
      [[64924, 64925], "mapped", [1610, 1605, 1605]],
      [[64926, 64926], "mapped", [1576, 1582, 1610]],
      [[64927, 64927], "mapped", [1578, 1580, 1610]],
      [[64928, 64928], "mapped", [1578, 1580, 1609]],
      [[64929, 64929], "mapped", [1578, 1582, 1610]],
      [[64930, 64930], "mapped", [1578, 1582, 1609]],
      [[64931, 64931], "mapped", [1578, 1605, 1610]],
      [[64932, 64932], "mapped", [1578, 1605, 1609]],
      [[64933, 64933], "mapped", [1580, 1605, 1610]],
      [[64934, 64934], "mapped", [1580, 1581, 1609]],
      [[64935, 64935], "mapped", [1580, 1605, 1609]],
      [[64936, 64936], "mapped", [1587, 1582, 1609]],
      [[64937, 64937], "mapped", [1589, 1581, 1610]],
      [[64938, 64938], "mapped", [1588, 1581, 1610]],
      [[64939, 64939], "mapped", [1590, 1581, 1610]],
      [[64940, 64940], "mapped", [1604, 1580, 1610]],
      [[64941, 64941], "mapped", [1604, 1605, 1610]],
      [[64942, 64942], "mapped", [1610, 1581, 1610]],
      [[64943, 64943], "mapped", [1610, 1580, 1610]],
      [[64944, 64944], "mapped", [1610, 1605, 1610]],
      [[64945, 64945], "mapped", [1605, 1605, 1610]],
      [[64946, 64946], "mapped", [1602, 1605, 1610]],
      [[64947, 64947], "mapped", [1606, 1581, 1610]],
      [[64948, 64948], "mapped", [1602, 1605, 1581]],
      [[64949, 64949], "mapped", [1604, 1581, 1605]],
      [[64950, 64950], "mapped", [1593, 1605, 1610]],
      [[64951, 64951], "mapped", [1603, 1605, 1610]],
      [[64952, 64952], "mapped", [1606, 1580, 1581]],
      [[64953, 64953], "mapped", [1605, 1582, 1610]],
      [[64954, 64954], "mapped", [1604, 1580, 1605]],
      [[64955, 64955], "mapped", [1603, 1605, 1605]],
      [[64956, 64956], "mapped", [1604, 1580, 1605]],
      [[64957, 64957], "mapped", [1606, 1580, 1581]],
      [[64958, 64958], "mapped", [1580, 1581, 1610]],
      [[64959, 64959], "mapped", [1581, 1580, 1610]],
      [[64960, 64960], "mapped", [1605, 1580, 1610]],
      [[64961, 64961], "mapped", [1601, 1605, 1610]],
      [[64962, 64962], "mapped", [1576, 1581, 1610]],
      [[64963, 64963], "mapped", [1603, 1605, 1605]],
      [[64964, 64964], "mapped", [1593, 1580, 1605]],
      [[64965, 64965], "mapped", [1589, 1605, 1605]],
      [[64966, 64966], "mapped", [1587, 1582, 1610]],
      [[64967, 64967], "mapped", [1606, 1580, 1610]],
      [[64968, 64975], "disallowed"],
      [[64976, 65007], "disallowed"],
      [[65008, 65008], "mapped", [1589, 1604, 1746]],
      [[65009, 65009], "mapped", [1602, 1604, 1746]],
      [[65010, 65010], "mapped", [1575, 1604, 1604, 1607]],
      [[65011, 65011], "mapped", [1575, 1603, 1576, 1585]],
      [[65012, 65012], "mapped", [1605, 1581, 1605, 1583]],
      [[65013, 65013], "mapped", [1589, 1604, 1593, 1605]],
      [[65014, 65014], "mapped", [1585, 1587, 1608, 1604]],
      [[65015, 65015], "mapped", [1593, 1604, 1610, 1607]],
      [[65016, 65016], "mapped", [1608, 1587, 1604, 1605]],
      [[65017, 65017], "mapped", [1589, 1604, 1609]],
      [
        [65018, 65018],
        "disallowed_STD3_mapped",
        [
          1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610,
          1607, 32, 1608, 1587, 1604, 1605,
        ],
      ],
      [
        [65019, 65019],
        "disallowed_STD3_mapped",
        [1580, 1604, 32, 1580, 1604, 1575, 1604, 1607],
      ],
      [[65020, 65020], "mapped", [1585, 1740, 1575, 1604]],
      [[65021, 65021], "valid", [], "NV8"],
      [[65022, 65023], "disallowed"],
      [[65024, 65039], "ignored"],
      [[65040, 65040], "disallowed_STD3_mapped", [44]],
      [[65041, 65041], "mapped", [12289]],
      [[65042, 65042], "disallowed"],
      [[65043, 65043], "disallowed_STD3_mapped", [58]],
      [[65044, 65044], "disallowed_STD3_mapped", [59]],
      [[65045, 65045], "disallowed_STD3_mapped", [33]],
      [[65046, 65046], "disallowed_STD3_mapped", [63]],
      [[65047, 65047], "mapped", [12310]],
      [[65048, 65048], "mapped", [12311]],
      [[65049, 65049], "disallowed"],
      [[65050, 65055], "disallowed"],
      [[65056, 65059], "valid"],
      [[65060, 65062], "valid"],
      [[65063, 65069], "valid"],
      [[65070, 65071], "valid"],
      [[65072, 65072], "disallowed"],
      [[65073, 65073], "mapped", [8212]],
      [[65074, 65074], "mapped", [8211]],
      [[65075, 65076], "disallowed_STD3_mapped", [95]],
      [[65077, 65077], "disallowed_STD3_mapped", [40]],
      [[65078, 65078], "disallowed_STD3_mapped", [41]],
      [[65079, 65079], "disallowed_STD3_mapped", [123]],
      [[65080, 65080], "disallowed_STD3_mapped", [125]],
      [[65081, 65081], "mapped", [12308]],
      [[65082, 65082], "mapped", [12309]],
      [[65083, 65083], "mapped", [12304]],
      [[65084, 65084], "mapped", [12305]],
      [[65085, 65085], "mapped", [12298]],
      [[65086, 65086], "mapped", [12299]],
      [[65087, 65087], "mapped", [12296]],
      [[65088, 65088], "mapped", [12297]],
      [[65089, 65089], "mapped", [12300]],
      [[65090, 65090], "mapped", [12301]],
      [[65091, 65091], "mapped", [12302]],
      [[65092, 65092], "mapped", [12303]],
      [[65093, 65094], "valid", [], "NV8"],
      [[65095, 65095], "disallowed_STD3_mapped", [91]],
      [[65096, 65096], "disallowed_STD3_mapped", [93]],
      [[65097, 65100], "disallowed_STD3_mapped", [32, 773]],
      [[65101, 65103], "disallowed_STD3_mapped", [95]],
      [[65104, 65104], "disallowed_STD3_mapped", [44]],
      [[65105, 65105], "mapped", [12289]],
      [[65106, 65106], "disallowed"],
      [[65107, 65107], "disallowed"],
      [[65108, 65108], "disallowed_STD3_mapped", [59]],
      [[65109, 65109], "disallowed_STD3_mapped", [58]],
      [[65110, 65110], "disallowed_STD3_mapped", [63]],
      [[65111, 65111], "disallowed_STD3_mapped", [33]],
      [[65112, 65112], "mapped", [8212]],
      [[65113, 65113], "disallowed_STD3_mapped", [40]],
      [[65114, 65114], "disallowed_STD3_mapped", [41]],
      [[65115, 65115], "disallowed_STD3_mapped", [123]],
      [[65116, 65116], "disallowed_STD3_mapped", [125]],
      [[65117, 65117], "mapped", [12308]],
      [[65118, 65118], "mapped", [12309]],
      [[65119, 65119], "disallowed_STD3_mapped", [35]],
      [[65120, 65120], "disallowed_STD3_mapped", [38]],
      [[65121, 65121], "disallowed_STD3_mapped", [42]],
      [[65122, 65122], "disallowed_STD3_mapped", [43]],
      [[65123, 65123], "mapped", [45]],
      [[65124, 65124], "disallowed_STD3_mapped", [60]],
      [[65125, 65125], "disallowed_STD3_mapped", [62]],
      [[65126, 65126], "disallowed_STD3_mapped", [61]],
      [[65127, 65127], "disallowed"],
      [[65128, 65128], "disallowed_STD3_mapped", [92]],
      [[65129, 65129], "disallowed_STD3_mapped", [36]],
      [[65130, 65130], "disallowed_STD3_mapped", [37]],
      [[65131, 65131], "disallowed_STD3_mapped", [64]],
      [[65132, 65135], "disallowed"],
      [[65136, 65136], "disallowed_STD3_mapped", [32, 1611]],
      [[65137, 65137], "mapped", [1600, 1611]],
      [[65138, 65138], "disallowed_STD3_mapped", [32, 1612]],
      [[65139, 65139], "valid"],
      [[65140, 65140], "disallowed_STD3_mapped", [32, 1613]],
      [[65141, 65141], "disallowed"],
      [[65142, 65142], "disallowed_STD3_mapped", [32, 1614]],
      [[65143, 65143], "mapped", [1600, 1614]],
      [[65144, 65144], "disallowed_STD3_mapped", [32, 1615]],
      [[65145, 65145], "mapped", [1600, 1615]],
      [[65146, 65146], "disallowed_STD3_mapped", [32, 1616]],
      [[65147, 65147], "mapped", [1600, 1616]],
      [[65148, 65148], "disallowed_STD3_mapped", [32, 1617]],
      [[65149, 65149], "mapped", [1600, 1617]],
      [[65150, 65150], "disallowed_STD3_mapped", [32, 1618]],
      [[65151, 65151], "mapped", [1600, 1618]],
      [[65152, 65152], "mapped", [1569]],
      [[65153, 65154], "mapped", [1570]],
      [[65155, 65156], "mapped", [1571]],
      [[65157, 65158], "mapped", [1572]],
      [[65159, 65160], "mapped", [1573]],
      [[65161, 65164], "mapped", [1574]],
      [[65165, 65166], "mapped", [1575]],
      [[65167, 65170], "mapped", [1576]],
      [[65171, 65172], "mapped", [1577]],
      [[65173, 65176], "mapped", [1578]],
      [[65177, 65180], "mapped", [1579]],
      [[65181, 65184], "mapped", [1580]],
      [[65185, 65188], "mapped", [1581]],
      [[65189, 65192], "mapped", [1582]],
      [[65193, 65194], "mapped", [1583]],
      [[65195, 65196], "mapped", [1584]],
      [[65197, 65198], "mapped", [1585]],
      [[65199, 65200], "mapped", [1586]],
      [[65201, 65204], "mapped", [1587]],
      [[65205, 65208], "mapped", [1588]],
      [[65209, 65212], "mapped", [1589]],
      [[65213, 65216], "mapped", [1590]],
      [[65217, 65220], "mapped", [1591]],
      [[65221, 65224], "mapped", [1592]],
      [[65225, 65228], "mapped", [1593]],
      [[65229, 65232], "mapped", [1594]],
      [[65233, 65236], "mapped", [1601]],
      [[65237, 65240], "mapped", [1602]],
      [[65241, 65244], "mapped", [1603]],
      [[65245, 65248], "mapped", [1604]],
      [[65249, 65252], "mapped", [1605]],
      [[65253, 65256], "mapped", [1606]],
      [[65257, 65260], "mapped", [1607]],
      [[65261, 65262], "mapped", [1608]],
      [[65263, 65264], "mapped", [1609]],
      [[65265, 65268], "mapped", [1610]],
      [[65269, 65270], "mapped", [1604, 1570]],
      [[65271, 65272], "mapped", [1604, 1571]],
      [[65273, 65274], "mapped", [1604, 1573]],
      [[65275, 65276], "mapped", [1604, 1575]],
      [[65277, 65278], "disallowed"],
      [[65279, 65279], "ignored"],
      [[65280, 65280], "disallowed"],
      [[65281, 65281], "disallowed_STD3_mapped", [33]],
      [[65282, 65282], "disallowed_STD3_mapped", [34]],
      [[65283, 65283], "disallowed_STD3_mapped", [35]],
      [[65284, 65284], "disallowed_STD3_mapped", [36]],
      [[65285, 65285], "disallowed_STD3_mapped", [37]],
      [[65286, 65286], "disallowed_STD3_mapped", [38]],
      [[65287, 65287], "disallowed_STD3_mapped", [39]],
      [[65288, 65288], "disallowed_STD3_mapped", [40]],
      [[65289, 65289], "disallowed_STD3_mapped", [41]],
      [[65290, 65290], "disallowed_STD3_mapped", [42]],
      [[65291, 65291], "disallowed_STD3_mapped", [43]],
      [[65292, 65292], "disallowed_STD3_mapped", [44]],
      [[65293, 65293], "mapped", [45]],
      [[65294, 65294], "mapped", [46]],
      [[65295, 65295], "disallowed_STD3_mapped", [47]],
      [[65296, 65296], "mapped", [48]],
      [[65297, 65297], "mapped", [49]],
      [[65298, 65298], "mapped", [50]],
      [[65299, 65299], "mapped", [51]],
      [[65300, 65300], "mapped", [52]],
      [[65301, 65301], "mapped", [53]],
      [[65302, 65302], "mapped", [54]],
      [[65303, 65303], "mapped", [55]],
      [[65304, 65304], "mapped", [56]],
      [[65305, 65305], "mapped", [57]],
      [[65306, 65306], "disallowed_STD3_mapped", [58]],
      [[65307, 65307], "disallowed_STD3_mapped", [59]],
      [[65308, 65308], "disallowed_STD3_mapped", [60]],
      [[65309, 65309], "disallowed_STD3_mapped", [61]],
      [[65310, 65310], "disallowed_STD3_mapped", [62]],
      [[65311, 65311], "disallowed_STD3_mapped", [63]],
      [[65312, 65312], "disallowed_STD3_mapped", [64]],
      [[65313, 65313], "mapped", [97]],
      [[65314, 65314], "mapped", [98]],
      [[65315, 65315], "mapped", [99]],
      [[65316, 65316], "mapped", [100]],
      [[65317, 65317], "mapped", [101]],
      [[65318, 65318], "mapped", [102]],
      [[65319, 65319], "mapped", [103]],
      [[65320, 65320], "mapped", [104]],
      [[65321, 65321], "mapped", [105]],
      [[65322, 65322], "mapped", [106]],
      [[65323, 65323], "mapped", [107]],
      [[65324, 65324], "mapped", [108]],
      [[65325, 65325], "mapped", [109]],
      [[65326, 65326], "mapped", [110]],
      [[65327, 65327], "mapped", [111]],
      [[65328, 65328], "mapped", [112]],
      [[65329, 65329], "mapped", [113]],
      [[65330, 65330], "mapped", [114]],
      [[65331, 65331], "mapped", [115]],
      [[65332, 65332], "mapped", [116]],
      [[65333, 65333], "mapped", [117]],
      [[65334, 65334], "mapped", [118]],
      [[65335, 65335], "mapped", [119]],
      [[65336, 65336], "mapped", [120]],
      [[65337, 65337], "mapped", [121]],
      [[65338, 65338], "mapped", [122]],
      [[65339, 65339], "disallowed_STD3_mapped", [91]],
      [[65340, 65340], "disallowed_STD3_mapped", [92]],
      [[65341, 65341], "disallowed_STD3_mapped", [93]],
      [[65342, 65342], "disallowed_STD3_mapped", [94]],
      [[65343, 65343], "disallowed_STD3_mapped", [95]],
      [[65344, 65344], "disallowed_STD3_mapped", [96]],
      [[65345, 65345], "mapped", [97]],
      [[65346, 65346], "mapped", [98]],
      [[65347, 65347], "mapped", [99]],
      [[65348, 65348], "mapped", [100]],
      [[65349, 65349], "mapped", [101]],
      [[65350, 65350], "mapped", [102]],
      [[65351, 65351], "mapped", [103]],
      [[65352, 65352], "mapped", [104]],
      [[65353, 65353], "mapped", [105]],
      [[65354, 65354], "mapped", [106]],
      [[65355, 65355], "mapped", [107]],
      [[65356, 65356], "mapped", [108]],
      [[65357, 65357], "mapped", [109]],
      [[65358, 65358], "mapped", [110]],
      [[65359, 65359], "mapped", [111]],
      [[65360, 65360], "mapped", [112]],
      [[65361, 65361], "mapped", [113]],
      [[65362, 65362], "mapped", [114]],
      [[65363, 65363], "mapped", [115]],
      [[65364, 65364], "mapped", [116]],
      [[65365, 65365], "mapped", [117]],
      [[65366, 65366], "mapped", [118]],
      [[65367, 65367], "mapped", [119]],
      [[65368, 65368], "mapped", [120]],
      [[65369, 65369], "mapped", [121]],
      [[65370, 65370], "mapped", [122]],
      [[65371, 65371], "disallowed_STD3_mapped", [123]],
      [[65372, 65372], "disallowed_STD3_mapped", [124]],
      [[65373, 65373], "disallowed_STD3_mapped", [125]],
      [[65374, 65374], "disallowed_STD3_mapped", [126]],
      [[65375, 65375], "mapped", [10629]],
      [[65376, 65376], "mapped", [10630]],
      [[65377, 65377], "mapped", [46]],
      [[65378, 65378], "mapped", [12300]],
      [[65379, 65379], "mapped", [12301]],
      [[65380, 65380], "mapped", [12289]],
      [[65381, 65381], "mapped", [12539]],
      [[65382, 65382], "mapped", [12530]],
      [[65383, 65383], "mapped", [12449]],
      [[65384, 65384], "mapped", [12451]],
      [[65385, 65385], "mapped", [12453]],
      [[65386, 65386], "mapped", [12455]],
      [[65387, 65387], "mapped", [12457]],
      [[65388, 65388], "mapped", [12515]],
      [[65389, 65389], "mapped", [12517]],
      [[65390, 65390], "mapped", [12519]],
      [[65391, 65391], "mapped", [12483]],
      [[65392, 65392], "mapped", [12540]],
      [[65393, 65393], "mapped", [12450]],
      [[65394, 65394], "mapped", [12452]],
      [[65395, 65395], "mapped", [12454]],
      [[65396, 65396], "mapped", [12456]],
      [[65397, 65397], "mapped", [12458]],
      [[65398, 65398], "mapped", [12459]],
      [[65399, 65399], "mapped", [12461]],
      [[65400, 65400], "mapped", [12463]],
      [[65401, 65401], "mapped", [12465]],
      [[65402, 65402], "mapped", [12467]],
      [[65403, 65403], "mapped", [12469]],
      [[65404, 65404], "mapped", [12471]],
      [[65405, 65405], "mapped", [12473]],
      [[65406, 65406], "mapped", [12475]],
      [[65407, 65407], "mapped", [12477]],
      [[65408, 65408], "mapped", [12479]],
      [[65409, 65409], "mapped", [12481]],
      [[65410, 65410], "mapped", [12484]],
      [[65411, 65411], "mapped", [12486]],
      [[65412, 65412], "mapped", [12488]],
      [[65413, 65413], "mapped", [12490]],
      [[65414, 65414], "mapped", [12491]],
      [[65415, 65415], "mapped", [12492]],
      [[65416, 65416], "mapped", [12493]],
      [[65417, 65417], "mapped", [12494]],
      [[65418, 65418], "mapped", [12495]],
      [[65419, 65419], "mapped", [12498]],
      [[65420, 65420], "mapped", [12501]],
      [[65421, 65421], "mapped", [12504]],
      [[65422, 65422], "mapped", [12507]],
      [[65423, 65423], "mapped", [12510]],
      [[65424, 65424], "mapped", [12511]],
      [[65425, 65425], "mapped", [12512]],
      [[65426, 65426], "mapped", [12513]],
      [[65427, 65427], "mapped", [12514]],
      [[65428, 65428], "mapped", [12516]],
      [[65429, 65429], "mapped", [12518]],
      [[65430, 65430], "mapped", [12520]],
      [[65431, 65431], "mapped", [12521]],
      [[65432, 65432], "mapped", [12522]],
      [[65433, 65433], "mapped", [12523]],
      [[65434, 65434], "mapped", [12524]],
      [[65435, 65435], "mapped", [12525]],
      [[65436, 65436], "mapped", [12527]],
      [[65437, 65437], "mapped", [12531]],
      [[65438, 65438], "mapped", [12441]],
      [[65439, 65439], "mapped", [12442]],
      [[65440, 65440], "disallowed"],
      [[65441, 65441], "mapped", [4352]],
      [[65442, 65442], "mapped", [4353]],
      [[65443, 65443], "mapped", [4522]],
      [[65444, 65444], "mapped", [4354]],
      [[65445, 65445], "mapped", [4524]],
      [[65446, 65446], "mapped", [4525]],
      [[65447, 65447], "mapped", [4355]],
      [[65448, 65448], "mapped", [4356]],
      [[65449, 65449], "mapped", [4357]],
      [[65450, 65450], "mapped", [4528]],
      [[65451, 65451], "mapped", [4529]],
      [[65452, 65452], "mapped", [4530]],
      [[65453, 65453], "mapped", [4531]],
      [[65454, 65454], "mapped", [4532]],
      [[65455, 65455], "mapped", [4533]],
      [[65456, 65456], "mapped", [4378]],
      [[65457, 65457], "mapped", [4358]],
      [[65458, 65458], "mapped", [4359]],
      [[65459, 65459], "mapped", [4360]],
      [[65460, 65460], "mapped", [4385]],
      [[65461, 65461], "mapped", [4361]],
      [[65462, 65462], "mapped", [4362]],
      [[65463, 65463], "mapped", [4363]],
      [[65464, 65464], "mapped", [4364]],
      [[65465, 65465], "mapped", [4365]],
      [[65466, 65466], "mapped", [4366]],
      [[65467, 65467], "mapped", [4367]],
      [[65468, 65468], "mapped", [4368]],
      [[65469, 65469], "mapped", [4369]],
      [[65470, 65470], "mapped", [4370]],
      [[65471, 65473], "disallowed"],
      [[65474, 65474], "mapped", [4449]],
      [[65475, 65475], "mapped", [4450]],
      [[65476, 65476], "mapped", [4451]],
      [[65477, 65477], "mapped", [4452]],
      [[65478, 65478], "mapped", [4453]],
      [[65479, 65479], "mapped", [4454]],
      [[65480, 65481], "disallowed"],
      [[65482, 65482], "mapped", [4455]],
      [[65483, 65483], "mapped", [4456]],
      [[65484, 65484], "mapped", [4457]],
      [[65485, 65485], "mapped", [4458]],
      [[65486, 65486], "mapped", [4459]],
      [[65487, 65487], "mapped", [4460]],
      [[65488, 65489], "disallowed"],
      [[65490, 65490], "mapped", [4461]],
      [[65491, 65491], "mapped", [4462]],
      [[65492, 65492], "mapped", [4463]],
      [[65493, 65493], "mapped", [4464]],
      [[65494, 65494], "mapped", [4465]],
      [[65495, 65495], "mapped", [4466]],
      [[65496, 65497], "disallowed"],
      [[65498, 65498], "mapped", [4467]],
      [[65499, 65499], "mapped", [4468]],
      [[65500, 65500], "mapped", [4469]],
      [[65501, 65503], "disallowed"],
      [[65504, 65504], "mapped", [162]],
      [[65505, 65505], "mapped", [163]],
      [[65506, 65506], "mapped", [172]],
      [[65507, 65507], "disallowed_STD3_mapped", [32, 772]],
      [[65508, 65508], "mapped", [166]],
      [[65509, 65509], "mapped", [165]],
      [[65510, 65510], "mapped", [8361]],
      [[65511, 65511], "disallowed"],
      [[65512, 65512], "mapped", [9474]],
      [[65513, 65513], "mapped", [8592]],
      [[65514, 65514], "mapped", [8593]],
      [[65515, 65515], "mapped", [8594]],
      [[65516, 65516], "mapped", [8595]],
      [[65517, 65517], "mapped", [9632]],
      [[65518, 65518], "mapped", [9675]],
      [[65519, 65528], "disallowed"],
      [[65529, 65531], "disallowed"],
      [[65532, 65532], "disallowed"],
      [[65533, 65533], "disallowed"],
      [[65534, 65535], "disallowed"],
      [[65536, 65547], "valid"],
      [[65548, 65548], "disallowed"],
      [[65549, 65574], "valid"],
      [[65575, 65575], "disallowed"],
      [[65576, 65594], "valid"],
      [[65595, 65595], "disallowed"],
      [[65596, 65597], "valid"],
      [[65598, 65598], "disallowed"],
      [[65599, 65613], "valid"],
      [[65614, 65615], "disallowed"],
      [[65616, 65629], "valid"],
      [[65630, 65663], "disallowed"],
      [[65664, 65786], "valid"],
      [[65787, 65791], "disallowed"],
      [[65792, 65794], "valid", [], "NV8"],
      [[65795, 65798], "disallowed"],
      [[65799, 65843], "valid", [], "NV8"],
      [[65844, 65846], "disallowed"],
      [[65847, 65855], "valid", [], "NV8"],
      [[65856, 65930], "valid", [], "NV8"],
      [[65931, 65932], "valid", [], "NV8"],
      [[65933, 65935], "disallowed"],
      [[65936, 65947], "valid", [], "NV8"],
      [[65948, 65951], "disallowed"],
      [[65952, 65952], "valid", [], "NV8"],
      [[65953, 65999], "disallowed"],
      [[66e3, 66044], "valid", [], "NV8"],
      [[66045, 66045], "valid"],
      [[66046, 66175], "disallowed"],
      [[66176, 66204], "valid"],
      [[66205, 66207], "disallowed"],
      [[66208, 66256], "valid"],
      [[66257, 66271], "disallowed"],
      [[66272, 66272], "valid"],
      [[66273, 66299], "valid", [], "NV8"],
      [[66300, 66303], "disallowed"],
      [[66304, 66334], "valid"],
      [[66335, 66335], "valid"],
      [[66336, 66339], "valid", [], "NV8"],
      [[66340, 66351], "disallowed"],
      [[66352, 66368], "valid"],
      [[66369, 66369], "valid", [], "NV8"],
      [[66370, 66377], "valid"],
      [[66378, 66378], "valid", [], "NV8"],
      [[66379, 66383], "disallowed"],
      [[66384, 66426], "valid"],
      [[66427, 66431], "disallowed"],
      [[66432, 66461], "valid"],
      [[66462, 66462], "disallowed"],
      [[66463, 66463], "valid", [], "NV8"],
      [[66464, 66499], "valid"],
      [[66500, 66503], "disallowed"],
      [[66504, 66511], "valid"],
      [[66512, 66517], "valid", [], "NV8"],
      [[66518, 66559], "disallowed"],
      [[66560, 66560], "mapped", [66600]],
      [[66561, 66561], "mapped", [66601]],
      [[66562, 66562], "mapped", [66602]],
      [[66563, 66563], "mapped", [66603]],
      [[66564, 66564], "mapped", [66604]],
      [[66565, 66565], "mapped", [66605]],
      [[66566, 66566], "mapped", [66606]],
      [[66567, 66567], "mapped", [66607]],
      [[66568, 66568], "mapped", [66608]],
      [[66569, 66569], "mapped", [66609]],
      [[66570, 66570], "mapped", [66610]],
      [[66571, 66571], "mapped", [66611]],
      [[66572, 66572], "mapped", [66612]],
      [[66573, 66573], "mapped", [66613]],
      [[66574, 66574], "mapped", [66614]],
      [[66575, 66575], "mapped", [66615]],
      [[66576, 66576], "mapped", [66616]],
      [[66577, 66577], "mapped", [66617]],
      [[66578, 66578], "mapped", [66618]],
      [[66579, 66579], "mapped", [66619]],
      [[66580, 66580], "mapped", [66620]],
      [[66581, 66581], "mapped", [66621]],
      [[66582, 66582], "mapped", [66622]],
      [[66583, 66583], "mapped", [66623]],
      [[66584, 66584], "mapped", [66624]],
      [[66585, 66585], "mapped", [66625]],
      [[66586, 66586], "mapped", [66626]],
      [[66587, 66587], "mapped", [66627]],
      [[66588, 66588], "mapped", [66628]],
      [[66589, 66589], "mapped", [66629]],
      [[66590, 66590], "mapped", [66630]],
      [[66591, 66591], "mapped", [66631]],
      [[66592, 66592], "mapped", [66632]],
      [[66593, 66593], "mapped", [66633]],
      [[66594, 66594], "mapped", [66634]],
      [[66595, 66595], "mapped", [66635]],
      [[66596, 66596], "mapped", [66636]],
      [[66597, 66597], "mapped", [66637]],
      [[66598, 66598], "mapped", [66638]],
      [[66599, 66599], "mapped", [66639]],
      [[66600, 66637], "valid"],
      [[66638, 66717], "valid"],
      [[66718, 66719], "disallowed"],
      [[66720, 66729], "valid"],
      [[66730, 66815], "disallowed"],
      [[66816, 66855], "valid"],
      [[66856, 66863], "disallowed"],
      [[66864, 66915], "valid"],
      [[66916, 66926], "disallowed"],
      [[66927, 66927], "valid", [], "NV8"],
      [[66928, 67071], "disallowed"],
      [[67072, 67382], "valid"],
      [[67383, 67391], "disallowed"],
      [[67392, 67413], "valid"],
      [[67414, 67423], "disallowed"],
      [[67424, 67431], "valid"],
      [[67432, 67583], "disallowed"],
      [[67584, 67589], "valid"],
      [[67590, 67591], "disallowed"],
      [[67592, 67592], "valid"],
      [[67593, 67593], "disallowed"],
      [[67594, 67637], "valid"],
      [[67638, 67638], "disallowed"],
      [[67639, 67640], "valid"],
      [[67641, 67643], "disallowed"],
      [[67644, 67644], "valid"],
      [[67645, 67646], "disallowed"],
      [[67647, 67647], "valid"],
      [[67648, 67669], "valid"],
      [[67670, 67670], "disallowed"],
      [[67671, 67679], "valid", [], "NV8"],
      [[67680, 67702], "valid"],
      [[67703, 67711], "valid", [], "NV8"],
      [[67712, 67742], "valid"],
      [[67743, 67750], "disallowed"],
      [[67751, 67759], "valid", [], "NV8"],
      [[67760, 67807], "disallowed"],
      [[67808, 67826], "valid"],
      [[67827, 67827], "disallowed"],
      [[67828, 67829], "valid"],
      [[67830, 67834], "disallowed"],
      [[67835, 67839], "valid", [], "NV8"],
      [[67840, 67861], "valid"],
      [[67862, 67865], "valid", [], "NV8"],
      [[67866, 67867], "valid", [], "NV8"],
      [[67868, 67870], "disallowed"],
      [[67871, 67871], "valid", [], "NV8"],
      [[67872, 67897], "valid"],
      [[67898, 67902], "disallowed"],
      [[67903, 67903], "valid", [], "NV8"],
      [[67904, 67967], "disallowed"],
      [[67968, 68023], "valid"],
      [[68024, 68027], "disallowed"],
      [[68028, 68029], "valid", [], "NV8"],
      [[68030, 68031], "valid"],
      [[68032, 68047], "valid", [], "NV8"],
      [[68048, 68049], "disallowed"],
      [[68050, 68095], "valid", [], "NV8"],
      [[68096, 68099], "valid"],
      [[68100, 68100], "disallowed"],
      [[68101, 68102], "valid"],
      [[68103, 68107], "disallowed"],
      [[68108, 68115], "valid"],
      [[68116, 68116], "disallowed"],
      [[68117, 68119], "valid"],
      [[68120, 68120], "disallowed"],
      [[68121, 68147], "valid"],
      [[68148, 68151], "disallowed"],
      [[68152, 68154], "valid"],
      [[68155, 68158], "disallowed"],
      [[68159, 68159], "valid"],
      [[68160, 68167], "valid", [], "NV8"],
      [[68168, 68175], "disallowed"],
      [[68176, 68184], "valid", [], "NV8"],
      [[68185, 68191], "disallowed"],
      [[68192, 68220], "valid"],
      [[68221, 68223], "valid", [], "NV8"],
      [[68224, 68252], "valid"],
      [[68253, 68255], "valid", [], "NV8"],
      [[68256, 68287], "disallowed"],
      [[68288, 68295], "valid"],
      [[68296, 68296], "valid", [], "NV8"],
      [[68297, 68326], "valid"],
      [[68327, 68330], "disallowed"],
      [[68331, 68342], "valid", [], "NV8"],
      [[68343, 68351], "disallowed"],
      [[68352, 68405], "valid"],
      [[68406, 68408], "disallowed"],
      [[68409, 68415], "valid", [], "NV8"],
      [[68416, 68437], "valid"],
      [[68438, 68439], "disallowed"],
      [[68440, 68447], "valid", [], "NV8"],
      [[68448, 68466], "valid"],
      [[68467, 68471], "disallowed"],
      [[68472, 68479], "valid", [], "NV8"],
      [[68480, 68497], "valid"],
      [[68498, 68504], "disallowed"],
      [[68505, 68508], "valid", [], "NV8"],
      [[68509, 68520], "disallowed"],
      [[68521, 68527], "valid", [], "NV8"],
      [[68528, 68607], "disallowed"],
      [[68608, 68680], "valid"],
      [[68681, 68735], "disallowed"],
      [[68736, 68736], "mapped", [68800]],
      [[68737, 68737], "mapped", [68801]],
      [[68738, 68738], "mapped", [68802]],
      [[68739, 68739], "mapped", [68803]],
      [[68740, 68740], "mapped", [68804]],
      [[68741, 68741], "mapped", [68805]],
      [[68742, 68742], "mapped", [68806]],
      [[68743, 68743], "mapped", [68807]],
      [[68744, 68744], "mapped", [68808]],
      [[68745, 68745], "mapped", [68809]],
      [[68746, 68746], "mapped", [68810]],
      [[68747, 68747], "mapped", [68811]],
      [[68748, 68748], "mapped", [68812]],
      [[68749, 68749], "mapped", [68813]],
      [[68750, 68750], "mapped", [68814]],
      [[68751, 68751], "mapped", [68815]],
      [[68752, 68752], "mapped", [68816]],
      [[68753, 68753], "mapped", [68817]],
      [[68754, 68754], "mapped", [68818]],
      [[68755, 68755], "mapped", [68819]],
      [[68756, 68756], "mapped", [68820]],
      [[68757, 68757], "mapped", [68821]],
      [[68758, 68758], "mapped", [68822]],
      [[68759, 68759], "mapped", [68823]],
      [[68760, 68760], "mapped", [68824]],
      [[68761, 68761], "mapped", [68825]],
      [[68762, 68762], "mapped", [68826]],
      [[68763, 68763], "mapped", [68827]],
      [[68764, 68764], "mapped", [68828]],
      [[68765, 68765], "mapped", [68829]],
      [[68766, 68766], "mapped", [68830]],
      [[68767, 68767], "mapped", [68831]],
      [[68768, 68768], "mapped", [68832]],
      [[68769, 68769], "mapped", [68833]],
      [[68770, 68770], "mapped", [68834]],
      [[68771, 68771], "mapped", [68835]],
      [[68772, 68772], "mapped", [68836]],
      [[68773, 68773], "mapped", [68837]],
      [[68774, 68774], "mapped", [68838]],
      [[68775, 68775], "mapped", [68839]],
      [[68776, 68776], "mapped", [68840]],
      [[68777, 68777], "mapped", [68841]],
      [[68778, 68778], "mapped", [68842]],
      [[68779, 68779], "mapped", [68843]],
      [[68780, 68780], "mapped", [68844]],
      [[68781, 68781], "mapped", [68845]],
      [[68782, 68782], "mapped", [68846]],
      [[68783, 68783], "mapped", [68847]],
      [[68784, 68784], "mapped", [68848]],
      [[68785, 68785], "mapped", [68849]],
      [[68786, 68786], "mapped", [68850]],
      [[68787, 68799], "disallowed"],
      [[68800, 68850], "valid"],
      [[68851, 68857], "disallowed"],
      [[68858, 68863], "valid", [], "NV8"],
      [[68864, 69215], "disallowed"],
      [[69216, 69246], "valid", [], "NV8"],
      [[69247, 69631], "disallowed"],
      [[69632, 69702], "valid"],
      [[69703, 69709], "valid", [], "NV8"],
      [[69710, 69713], "disallowed"],
      [[69714, 69733], "valid", [], "NV8"],
      [[69734, 69743], "valid"],
      [[69744, 69758], "disallowed"],
      [[69759, 69759], "valid"],
      [[69760, 69818], "valid"],
      [[69819, 69820], "valid", [], "NV8"],
      [[69821, 69821], "disallowed"],
      [[69822, 69825], "valid", [], "NV8"],
      [[69826, 69839], "disallowed"],
      [[69840, 69864], "valid"],
      [[69865, 69871], "disallowed"],
      [[69872, 69881], "valid"],
      [[69882, 69887], "disallowed"],
      [[69888, 69940], "valid"],
      [[69941, 69941], "disallowed"],
      [[69942, 69951], "valid"],
      [[69952, 69955], "valid", [], "NV8"],
      [[69956, 69967], "disallowed"],
      [[69968, 70003], "valid"],
      [[70004, 70005], "valid", [], "NV8"],
      [[70006, 70006], "valid"],
      [[70007, 70015], "disallowed"],
      [[70016, 70084], "valid"],
      [[70085, 70088], "valid", [], "NV8"],
      [[70089, 70089], "valid", [], "NV8"],
      [[70090, 70092], "valid"],
      [[70093, 70093], "valid", [], "NV8"],
      [[70094, 70095], "disallowed"],
      [[70096, 70105], "valid"],
      [[70106, 70106], "valid"],
      [[70107, 70107], "valid", [], "NV8"],
      [[70108, 70108], "valid"],
      [[70109, 70111], "valid", [], "NV8"],
      [[70112, 70112], "disallowed"],
      [[70113, 70132], "valid", [], "NV8"],
      [[70133, 70143], "disallowed"],
      [[70144, 70161], "valid"],
      [[70162, 70162], "disallowed"],
      [[70163, 70199], "valid"],
      [[70200, 70205], "valid", [], "NV8"],
      [[70206, 70271], "disallowed"],
      [[70272, 70278], "valid"],
      [[70279, 70279], "disallowed"],
      [[70280, 70280], "valid"],
      [[70281, 70281], "disallowed"],
      [[70282, 70285], "valid"],
      [[70286, 70286], "disallowed"],
      [[70287, 70301], "valid"],
      [[70302, 70302], "disallowed"],
      [[70303, 70312], "valid"],
      [[70313, 70313], "valid", [], "NV8"],
      [[70314, 70319], "disallowed"],
      [[70320, 70378], "valid"],
      [[70379, 70383], "disallowed"],
      [[70384, 70393], "valid"],
      [[70394, 70399], "disallowed"],
      [[70400, 70400], "valid"],
      [[70401, 70403], "valid"],
      [[70404, 70404], "disallowed"],
      [[70405, 70412], "valid"],
      [[70413, 70414], "disallowed"],
      [[70415, 70416], "valid"],
      [[70417, 70418], "disallowed"],
      [[70419, 70440], "valid"],
      [[70441, 70441], "disallowed"],
      [[70442, 70448], "valid"],
      [[70449, 70449], "disallowed"],
      [[70450, 70451], "valid"],
      [[70452, 70452], "disallowed"],
      [[70453, 70457], "valid"],
      [[70458, 70459], "disallowed"],
      [[70460, 70468], "valid"],
      [[70469, 70470], "disallowed"],
      [[70471, 70472], "valid"],
      [[70473, 70474], "disallowed"],
      [[70475, 70477], "valid"],
      [[70478, 70479], "disallowed"],
      [[70480, 70480], "valid"],
      [[70481, 70486], "disallowed"],
      [[70487, 70487], "valid"],
      [[70488, 70492], "disallowed"],
      [[70493, 70499], "valid"],
      [[70500, 70501], "disallowed"],
      [[70502, 70508], "valid"],
      [[70509, 70511], "disallowed"],
      [[70512, 70516], "valid"],
      [[70517, 70783], "disallowed"],
      [[70784, 70853], "valid"],
      [[70854, 70854], "valid", [], "NV8"],
      [[70855, 70855], "valid"],
      [[70856, 70863], "disallowed"],
      [[70864, 70873], "valid"],
      [[70874, 71039], "disallowed"],
      [[71040, 71093], "valid"],
      [[71094, 71095], "disallowed"],
      [[71096, 71104], "valid"],
      [[71105, 71113], "valid", [], "NV8"],
      [[71114, 71127], "valid", [], "NV8"],
      [[71128, 71133], "valid"],
      [[71134, 71167], "disallowed"],
      [[71168, 71232], "valid"],
      [[71233, 71235], "valid", [], "NV8"],
      [[71236, 71236], "valid"],
      [[71237, 71247], "disallowed"],
      [[71248, 71257], "valid"],
      [[71258, 71295], "disallowed"],
      [[71296, 71351], "valid"],
      [[71352, 71359], "disallowed"],
      [[71360, 71369], "valid"],
      [[71370, 71423], "disallowed"],
      [[71424, 71449], "valid"],
      [[71450, 71452], "disallowed"],
      [[71453, 71467], "valid"],
      [[71468, 71471], "disallowed"],
      [[71472, 71481], "valid"],
      [[71482, 71487], "valid", [], "NV8"],
      [[71488, 71839], "disallowed"],
      [[71840, 71840], "mapped", [71872]],
      [[71841, 71841], "mapped", [71873]],
      [[71842, 71842], "mapped", [71874]],
      [[71843, 71843], "mapped", [71875]],
      [[71844, 71844], "mapped", [71876]],
      [[71845, 71845], "mapped", [71877]],
      [[71846, 71846], "mapped", [71878]],
      [[71847, 71847], "mapped", [71879]],
      [[71848, 71848], "mapped", [71880]],
      [[71849, 71849], "mapped", [71881]],
      [[71850, 71850], "mapped", [71882]],
      [[71851, 71851], "mapped", [71883]],
      [[71852, 71852], "mapped", [71884]],
      [[71853, 71853], "mapped", [71885]],
      [[71854, 71854], "mapped", [71886]],
      [[71855, 71855], "mapped", [71887]],
      [[71856, 71856], "mapped", [71888]],
      [[71857, 71857], "mapped", [71889]],
      [[71858, 71858], "mapped", [71890]],
      [[71859, 71859], "mapped", [71891]],
      [[71860, 71860], "mapped", [71892]],
      [[71861, 71861], "mapped", [71893]],
      [[71862, 71862], "mapped", [71894]],
      [[71863, 71863], "mapped", [71895]],
      [[71864, 71864], "mapped", [71896]],
      [[71865, 71865], "mapped", [71897]],
      [[71866, 71866], "mapped", [71898]],
      [[71867, 71867], "mapped", [71899]],
      [[71868, 71868], "mapped", [71900]],
      [[71869, 71869], "mapped", [71901]],
      [[71870, 71870], "mapped", [71902]],
      [[71871, 71871], "mapped", [71903]],
      [[71872, 71913], "valid"],
      [[71914, 71922], "valid", [], "NV8"],
      [[71923, 71934], "disallowed"],
      [[71935, 71935], "valid"],
      [[71936, 72383], "disallowed"],
      [[72384, 72440], "valid"],
      [[72441, 73727], "disallowed"],
      [[73728, 74606], "valid"],
      [[74607, 74648], "valid"],
      [[74649, 74649], "valid"],
      [[74650, 74751], "disallowed"],
      [[74752, 74850], "valid", [], "NV8"],
      [[74851, 74862], "valid", [], "NV8"],
      [[74863, 74863], "disallowed"],
      [[74864, 74867], "valid", [], "NV8"],
      [[74868, 74868], "valid", [], "NV8"],
      [[74869, 74879], "disallowed"],
      [[74880, 75075], "valid"],
      [[75076, 77823], "disallowed"],
      [[77824, 78894], "valid"],
      [[78895, 82943], "disallowed"],
      [[82944, 83526], "valid"],
      [[83527, 92159], "disallowed"],
      [[92160, 92728], "valid"],
      [[92729, 92735], "disallowed"],
      [[92736, 92766], "valid"],
      [[92767, 92767], "disallowed"],
      [[92768, 92777], "valid"],
      [[92778, 92781], "disallowed"],
      [[92782, 92783], "valid", [], "NV8"],
      [[92784, 92879], "disallowed"],
      [[92880, 92909], "valid"],
      [[92910, 92911], "disallowed"],
      [[92912, 92916], "valid"],
      [[92917, 92917], "valid", [], "NV8"],
      [[92918, 92927], "disallowed"],
      [[92928, 92982], "valid"],
      [[92983, 92991], "valid", [], "NV8"],
      [[92992, 92995], "valid"],
      [[92996, 92997], "valid", [], "NV8"],
      [[92998, 93007], "disallowed"],
      [[93008, 93017], "valid"],
      [[93018, 93018], "disallowed"],
      [[93019, 93025], "valid", [], "NV8"],
      [[93026, 93026], "disallowed"],
      [[93027, 93047], "valid"],
      [[93048, 93052], "disallowed"],
      [[93053, 93071], "valid"],
      [[93072, 93951], "disallowed"],
      [[93952, 94020], "valid"],
      [[94021, 94031], "disallowed"],
      [[94032, 94078], "valid"],
      [[94079, 94094], "disallowed"],
      [[94095, 94111], "valid"],
      [[94112, 110591], "disallowed"],
      [[110592, 110593], "valid"],
      [[110594, 113663], "disallowed"],
      [[113664, 113770], "valid"],
      [[113771, 113775], "disallowed"],
      [[113776, 113788], "valid"],
      [[113789, 113791], "disallowed"],
      [[113792, 113800], "valid"],
      [[113801, 113807], "disallowed"],
      [[113808, 113817], "valid"],
      [[113818, 113819], "disallowed"],
      [[113820, 113820], "valid", [], "NV8"],
      [[113821, 113822], "valid"],
      [[113823, 113823], "valid", [], "NV8"],
      [[113824, 113827], "ignored"],
      [[113828, 118783], "disallowed"],
      [[118784, 119029], "valid", [], "NV8"],
      [[119030, 119039], "disallowed"],
      [[119040, 119078], "valid", [], "NV8"],
      [[119079, 119080], "disallowed"],
      [[119081, 119081], "valid", [], "NV8"],
      [[119082, 119133], "valid", [], "NV8"],
      [[119134, 119134], "mapped", [119127, 119141]],
      [[119135, 119135], "mapped", [119128, 119141]],
      [[119136, 119136], "mapped", [119128, 119141, 119150]],
      [[119137, 119137], "mapped", [119128, 119141, 119151]],
      [[119138, 119138], "mapped", [119128, 119141, 119152]],
      [[119139, 119139], "mapped", [119128, 119141, 119153]],
      [[119140, 119140], "mapped", [119128, 119141, 119154]],
      [[119141, 119154], "valid", [], "NV8"],
      [[119155, 119162], "disallowed"],
      [[119163, 119226], "valid", [], "NV8"],
      [[119227, 119227], "mapped", [119225, 119141]],
      [[119228, 119228], "mapped", [119226, 119141]],
      [[119229, 119229], "mapped", [119225, 119141, 119150]],
      [[119230, 119230], "mapped", [119226, 119141, 119150]],
      [[119231, 119231], "mapped", [119225, 119141, 119151]],
      [[119232, 119232], "mapped", [119226, 119141, 119151]],
      [[119233, 119261], "valid", [], "NV8"],
      [[119262, 119272], "valid", [], "NV8"],
      [[119273, 119295], "disallowed"],
      [[119296, 119365], "valid", [], "NV8"],
      [[119366, 119551], "disallowed"],
      [[119552, 119638], "valid", [], "NV8"],
      [[119639, 119647], "disallowed"],
      [[119648, 119665], "valid", [], "NV8"],
      [[119666, 119807], "disallowed"],
      [[119808, 119808], "mapped", [97]],
      [[119809, 119809], "mapped", [98]],
      [[119810, 119810], "mapped", [99]],
      [[119811, 119811], "mapped", [100]],
      [[119812, 119812], "mapped", [101]],
      [[119813, 119813], "mapped", [102]],
      [[119814, 119814], "mapped", [103]],
      [[119815, 119815], "mapped", [104]],
      [[119816, 119816], "mapped", [105]],
      [[119817, 119817], "mapped", [106]],
      [[119818, 119818], "mapped", [107]],
      [[119819, 119819], "mapped", [108]],
      [[119820, 119820], "mapped", [109]],
      [[119821, 119821], "mapped", [110]],
      [[119822, 119822], "mapped", [111]],
      [[119823, 119823], "mapped", [112]],
      [[119824, 119824], "mapped", [113]],
      [[119825, 119825], "mapped", [114]],
      [[119826, 119826], "mapped", [115]],
      [[119827, 119827], "mapped", [116]],
      [[119828, 119828], "mapped", [117]],
      [[119829, 119829], "mapped", [118]],
      [[119830, 119830], "mapped", [119]],
      [[119831, 119831], "mapped", [120]],
      [[119832, 119832], "mapped", [121]],
      [[119833, 119833], "mapped", [122]],
      [[119834, 119834], "mapped", [97]],
      [[119835, 119835], "mapped", [98]],
      [[119836, 119836], "mapped", [99]],
      [[119837, 119837], "mapped", [100]],
      [[119838, 119838], "mapped", [101]],
      [[119839, 119839], "mapped", [102]],
      [[119840, 119840], "mapped", [103]],
      [[119841, 119841], "mapped", [104]],
      [[119842, 119842], "mapped", [105]],
      [[119843, 119843], "mapped", [106]],
      [[119844, 119844], "mapped", [107]],
      [[119845, 119845], "mapped", [108]],
      [[119846, 119846], "mapped", [109]],
      [[119847, 119847], "mapped", [110]],
      [[119848, 119848], "mapped", [111]],
      [[119849, 119849], "mapped", [112]],
      [[119850, 119850], "mapped", [113]],
      [[119851, 119851], "mapped", [114]],
      [[119852, 119852], "mapped", [115]],
      [[119853, 119853], "mapped", [116]],
      [[119854, 119854], "mapped", [117]],
      [[119855, 119855], "mapped", [118]],
      [[119856, 119856], "mapped", [119]],
      [[119857, 119857], "mapped", [120]],
      [[119858, 119858], "mapped", [121]],
      [[119859, 119859], "mapped", [122]],
      [[119860, 119860], "mapped", [97]],
      [[119861, 119861], "mapped", [98]],
      [[119862, 119862], "mapped", [99]],
      [[119863, 119863], "mapped", [100]],
      [[119864, 119864], "mapped", [101]],
      [[119865, 119865], "mapped", [102]],
      [[119866, 119866], "mapped", [103]],
      [[119867, 119867], "mapped", [104]],
      [[119868, 119868], "mapped", [105]],
      [[119869, 119869], "mapped", [106]],
      [[119870, 119870], "mapped", [107]],
      [[119871, 119871], "mapped", [108]],
      [[119872, 119872], "mapped", [109]],
      [[119873, 119873], "mapped", [110]],
      [[119874, 119874], "mapped", [111]],
      [[119875, 119875], "mapped", [112]],
      [[119876, 119876], "mapped", [113]],
      [[119877, 119877], "mapped", [114]],
      [[119878, 119878], "mapped", [115]],
      [[119879, 119879], "mapped", [116]],
      [[119880, 119880], "mapped", [117]],
      [[119881, 119881], "mapped", [118]],
      [[119882, 119882], "mapped", [119]],
      [[119883, 119883], "mapped", [120]],
      [[119884, 119884], "mapped", [121]],
      [[119885, 119885], "mapped", [122]],
      [[119886, 119886], "mapped", [97]],
      [[119887, 119887], "mapped", [98]],
      [[119888, 119888], "mapped", [99]],
      [[119889, 119889], "mapped", [100]],
      [[119890, 119890], "mapped", [101]],
      [[119891, 119891], "mapped", [102]],
      [[119892, 119892], "mapped", [103]],
      [[119893, 119893], "disallowed"],
      [[119894, 119894], "mapped", [105]],
      [[119895, 119895], "mapped", [106]],
      [[119896, 119896], "mapped", [107]],
      [[119897, 119897], "mapped", [108]],
      [[119898, 119898], "mapped", [109]],
      [[119899, 119899], "mapped", [110]],
      [[119900, 119900], "mapped", [111]],
      [[119901, 119901], "mapped", [112]],
      [[119902, 119902], "mapped", [113]],
      [[119903, 119903], "mapped", [114]],
      [[119904, 119904], "mapped", [115]],
      [[119905, 119905], "mapped", [116]],
      [[119906, 119906], "mapped", [117]],
      [[119907, 119907], "mapped", [118]],
      [[119908, 119908], "mapped", [119]],
      [[119909, 119909], "mapped", [120]],
      [[119910, 119910], "mapped", [121]],
      [[119911, 119911], "mapped", [122]],
      [[119912, 119912], "mapped", [97]],
      [[119913, 119913], "mapped", [98]],
      [[119914, 119914], "mapped", [99]],
      [[119915, 119915], "mapped", [100]],
      [[119916, 119916], "mapped", [101]],
      [[119917, 119917], "mapped", [102]],
      [[119918, 119918], "mapped", [103]],
      [[119919, 119919], "mapped", [104]],
      [[119920, 119920], "mapped", [105]],
      [[119921, 119921], "mapped", [106]],
      [[119922, 119922], "mapped", [107]],
      [[119923, 119923], "mapped", [108]],
      [[119924, 119924], "mapped", [109]],
      [[119925, 119925], "mapped", [110]],
      [[119926, 119926], "mapped", [111]],
      [[119927, 119927], "mapped", [112]],
      [[119928, 119928], "mapped", [113]],
      [[119929, 119929], "mapped", [114]],
      [[119930, 119930], "mapped", [115]],
      [[119931, 119931], "mapped", [116]],
      [[119932, 119932], "mapped", [117]],
      [[119933, 119933], "mapped", [118]],
      [[119934, 119934], "mapped", [119]],
      [[119935, 119935], "mapped", [120]],
      [[119936, 119936], "mapped", [121]],
      [[119937, 119937], "mapped", [122]],
      [[119938, 119938], "mapped", [97]],
      [[119939, 119939], "mapped", [98]],
      [[119940, 119940], "mapped", [99]],
      [[119941, 119941], "mapped", [100]],
      [[119942, 119942], "mapped", [101]],
      [[119943, 119943], "mapped", [102]],
      [[119944, 119944], "mapped", [103]],
      [[119945, 119945], "mapped", [104]],
      [[119946, 119946], "mapped", [105]],
      [[119947, 119947], "mapped", [106]],
      [[119948, 119948], "mapped", [107]],
      [[119949, 119949], "mapped", [108]],
      [[119950, 119950], "mapped", [109]],
      [[119951, 119951], "mapped", [110]],
      [[119952, 119952], "mapped", [111]],
      [[119953, 119953], "mapped", [112]],
      [[119954, 119954], "mapped", [113]],
      [[119955, 119955], "mapped", [114]],
      [[119956, 119956], "mapped", [115]],
      [[119957, 119957], "mapped", [116]],
      [[119958, 119958], "mapped", [117]],
      [[119959, 119959], "mapped", [118]],
      [[119960, 119960], "mapped", [119]],
      [[119961, 119961], "mapped", [120]],
      [[119962, 119962], "mapped", [121]],
      [[119963, 119963], "mapped", [122]],
      [[119964, 119964], "mapped", [97]],
      [[119965, 119965], "disallowed"],
      [[119966, 119966], "mapped", [99]],
      [[119967, 119967], "mapped", [100]],
      [[119968, 119969], "disallowed"],
      [[119970, 119970], "mapped", [103]],
      [[119971, 119972], "disallowed"],
      [[119973, 119973], "mapped", [106]],
      [[119974, 119974], "mapped", [107]],
      [[119975, 119976], "disallowed"],
      [[119977, 119977], "mapped", [110]],
      [[119978, 119978], "mapped", [111]],
      [[119979, 119979], "mapped", [112]],
      [[119980, 119980], "mapped", [113]],
      [[119981, 119981], "disallowed"],
      [[119982, 119982], "mapped", [115]],
      [[119983, 119983], "mapped", [116]],
      [[119984, 119984], "mapped", [117]],
      [[119985, 119985], "mapped", [118]],
      [[119986, 119986], "mapped", [119]],
      [[119987, 119987], "mapped", [120]],
      [[119988, 119988], "mapped", [121]],
      [[119989, 119989], "mapped", [122]],
      [[119990, 119990], "mapped", [97]],
      [[119991, 119991], "mapped", [98]],
      [[119992, 119992], "mapped", [99]],
      [[119993, 119993], "mapped", [100]],
      [[119994, 119994], "disallowed"],
      [[119995, 119995], "mapped", [102]],
      [[119996, 119996], "disallowed"],
      [[119997, 119997], "mapped", [104]],
      [[119998, 119998], "mapped", [105]],
      [[119999, 119999], "mapped", [106]],
      [[12e4, 12e4], "mapped", [107]],
      [[120001, 120001], "mapped", [108]],
      [[120002, 120002], "mapped", [109]],
      [[120003, 120003], "mapped", [110]],
      [[120004, 120004], "disallowed"],
      [[120005, 120005], "mapped", [112]],
      [[120006, 120006], "mapped", [113]],
      [[120007, 120007], "mapped", [114]],
      [[120008, 120008], "mapped", [115]],
      [[120009, 120009], "mapped", [116]],
      [[120010, 120010], "mapped", [117]],
      [[120011, 120011], "mapped", [118]],
      [[120012, 120012], "mapped", [119]],
      [[120013, 120013], "mapped", [120]],
      [[120014, 120014], "mapped", [121]],
      [[120015, 120015], "mapped", [122]],
      [[120016, 120016], "mapped", [97]],
      [[120017, 120017], "mapped", [98]],
      [[120018, 120018], "mapped", [99]],
      [[120019, 120019], "mapped", [100]],
      [[120020, 120020], "mapped", [101]],
      [[120021, 120021], "mapped", [102]],
      [[120022, 120022], "mapped", [103]],
      [[120023, 120023], "mapped", [104]],
      [[120024, 120024], "mapped", [105]],
      [[120025, 120025], "mapped", [106]],
      [[120026, 120026], "mapped", [107]],
      [[120027, 120027], "mapped", [108]],
      [[120028, 120028], "mapped", [109]],
      [[120029, 120029], "mapped", [110]],
      [[120030, 120030], "mapped", [111]],
      [[120031, 120031], "mapped", [112]],
      [[120032, 120032], "mapped", [113]],
      [[120033, 120033], "mapped", [114]],
      [[120034, 120034], "mapped", [115]],
      [[120035, 120035], "mapped", [116]],
      [[120036, 120036], "mapped", [117]],
      [[120037, 120037], "mapped", [118]],
      [[120038, 120038], "mapped", [119]],
      [[120039, 120039], "mapped", [120]],
      [[120040, 120040], "mapped", [121]],
      [[120041, 120041], "mapped", [122]],
      [[120042, 120042], "mapped", [97]],
      [[120043, 120043], "mapped", [98]],
      [[120044, 120044], "mapped", [99]],
      [[120045, 120045], "mapped", [100]],
      [[120046, 120046], "mapped", [101]],
      [[120047, 120047], "mapped", [102]],
      [[120048, 120048], "mapped", [103]],
      [[120049, 120049], "mapped", [104]],
      [[120050, 120050], "mapped", [105]],
      [[120051, 120051], "mapped", [106]],
      [[120052, 120052], "mapped", [107]],
      [[120053, 120053], "mapped", [108]],
      [[120054, 120054], "mapped", [109]],
      [[120055, 120055], "mapped", [110]],
      [[120056, 120056], "mapped", [111]],
      [[120057, 120057], "mapped", [112]],
      [[120058, 120058], "mapped", [113]],
      [[120059, 120059], "mapped", [114]],
      [[120060, 120060], "mapped", [115]],
      [[120061, 120061], "mapped", [116]],
      [[120062, 120062], "mapped", [117]],
      [[120063, 120063], "mapped", [118]],
      [[120064, 120064], "mapped", [119]],
      [[120065, 120065], "mapped", [120]],
      [[120066, 120066], "mapped", [121]],
      [[120067, 120067], "mapped", [122]],
      [[120068, 120068], "mapped", [97]],
      [[120069, 120069], "mapped", [98]],
      [[120070, 120070], "disallowed"],
      [[120071, 120071], "mapped", [100]],
      [[120072, 120072], "mapped", [101]],
      [[120073, 120073], "mapped", [102]],
      [[120074, 120074], "mapped", [103]],
      [[120075, 120076], "disallowed"],
      [[120077, 120077], "mapped", [106]],
      [[120078, 120078], "mapped", [107]],
      [[120079, 120079], "mapped", [108]],
      [[120080, 120080], "mapped", [109]],
      [[120081, 120081], "mapped", [110]],
      [[120082, 120082], "mapped", [111]],
      [[120083, 120083], "mapped", [112]],
      [[120084, 120084], "mapped", [113]],
      [[120085, 120085], "disallowed"],
      [[120086, 120086], "mapped", [115]],
      [[120087, 120087], "mapped", [116]],
      [[120088, 120088], "mapped", [117]],
      [[120089, 120089], "mapped", [118]],
      [[120090, 120090], "mapped", [119]],
      [[120091, 120091], "mapped", [120]],
      [[120092, 120092], "mapped", [121]],
      [[120093, 120093], "disallowed"],
      [[120094, 120094], "mapped", [97]],
      [[120095, 120095], "mapped", [98]],
      [[120096, 120096], "mapped", [99]],
      [[120097, 120097], "mapped", [100]],
      [[120098, 120098], "mapped", [101]],
      [[120099, 120099], "mapped", [102]],
      [[120100, 120100], "mapped", [103]],
      [[120101, 120101], "mapped", [104]],
      [[120102, 120102], "mapped", [105]],
      [[120103, 120103], "mapped", [106]],
      [[120104, 120104], "mapped", [107]],
      [[120105, 120105], "mapped", [108]],
      [[120106, 120106], "mapped", [109]],
      [[120107, 120107], "mapped", [110]],
      [[120108, 120108], "mapped", [111]],
      [[120109, 120109], "mapped", [112]],
      [[120110, 120110], "mapped", [113]],
      [[120111, 120111], "mapped", [114]],
      [[120112, 120112], "mapped", [115]],
      [[120113, 120113], "mapped", [116]],
      [[120114, 120114], "mapped", [117]],
      [[120115, 120115], "mapped", [118]],
      [[120116, 120116], "mapped", [119]],
      [[120117, 120117], "mapped", [120]],
      [[120118, 120118], "mapped", [121]],
      [[120119, 120119], "mapped", [122]],
      [[120120, 120120], "mapped", [97]],
      [[120121, 120121], "mapped", [98]],
      [[120122, 120122], "disallowed"],
      [[120123, 120123], "mapped", [100]],
      [[120124, 120124], "mapped", [101]],
      [[120125, 120125], "mapped", [102]],
      [[120126, 120126], "mapped", [103]],
      [[120127, 120127], "disallowed"],
      [[120128, 120128], "mapped", [105]],
      [[120129, 120129], "mapped", [106]],
      [[120130, 120130], "mapped", [107]],
      [[120131, 120131], "mapped", [108]],
      [[120132, 120132], "mapped", [109]],
      [[120133, 120133], "disallowed"],
      [[120134, 120134], "mapped", [111]],
      [[120135, 120137], "disallowed"],
      [[120138, 120138], "mapped", [115]],
      [[120139, 120139], "mapped", [116]],
      [[120140, 120140], "mapped", [117]],
      [[120141, 120141], "mapped", [118]],
      [[120142, 120142], "mapped", [119]],
      [[120143, 120143], "mapped", [120]],
      [[120144, 120144], "mapped", [121]],
      [[120145, 120145], "disallowed"],
      [[120146, 120146], "mapped", [97]],
      [[120147, 120147], "mapped", [98]],
      [[120148, 120148], "mapped", [99]],
      [[120149, 120149], "mapped", [100]],
      [[120150, 120150], "mapped", [101]],
      [[120151, 120151], "mapped", [102]],
      [[120152, 120152], "mapped", [103]],
      [[120153, 120153], "mapped", [104]],
      [[120154, 120154], "mapped", [105]],
      [[120155, 120155], "mapped", [106]],
      [[120156, 120156], "mapped", [107]],
      [[120157, 120157], "mapped", [108]],
      [[120158, 120158], "mapped", [109]],
      [[120159, 120159], "mapped", [110]],
      [[120160, 120160], "mapped", [111]],
      [[120161, 120161], "mapped", [112]],
      [[120162, 120162], "mapped", [113]],
      [[120163, 120163], "mapped", [114]],
      [[120164, 120164], "mapped", [115]],
      [[120165, 120165], "mapped", [116]],
      [[120166, 120166], "mapped", [117]],
      [[120167, 120167], "mapped", [118]],
      [[120168, 120168], "mapped", [119]],
      [[120169, 120169], "mapped", [120]],
      [[120170, 120170], "mapped", [121]],
      [[120171, 120171], "mapped", [122]],
      [[120172, 120172], "mapped", [97]],
      [[120173, 120173], "mapped", [98]],
      [[120174, 120174], "mapped", [99]],
      [[120175, 120175], "mapped", [100]],
      [[120176, 120176], "mapped", [101]],
      [[120177, 120177], "mapped", [102]],
      [[120178, 120178], "mapped", [103]],
      [[120179, 120179], "mapped", [104]],
      [[120180, 120180], "mapped", [105]],
      [[120181, 120181], "mapped", [106]],
      [[120182, 120182], "mapped", [107]],
      [[120183, 120183], "mapped", [108]],
      [[120184, 120184], "mapped", [109]],
      [[120185, 120185], "mapped", [110]],
      [[120186, 120186], "mapped", [111]],
      [[120187, 120187], "mapped", [112]],
      [[120188, 120188], "mapped", [113]],
      [[120189, 120189], "mapped", [114]],
      [[120190, 120190], "mapped", [115]],
      [[120191, 120191], "mapped", [116]],
      [[120192, 120192], "mapped", [117]],
      [[120193, 120193], "mapped", [118]],
      [[120194, 120194], "mapped", [119]],
      [[120195, 120195], "mapped", [120]],
      [[120196, 120196], "mapped", [121]],
      [[120197, 120197], "mapped", [122]],
      [[120198, 120198], "mapped", [97]],
      [[120199, 120199], "mapped", [98]],
      [[120200, 120200], "mapped", [99]],
      [[120201, 120201], "mapped", [100]],
      [[120202, 120202], "mapped", [101]],
      [[120203, 120203], "mapped", [102]],
      [[120204, 120204], "mapped", [103]],
      [[120205, 120205], "mapped", [104]],
      [[120206, 120206], "mapped", [105]],
      [[120207, 120207], "mapped", [106]],
      [[120208, 120208], "mapped", [107]],
      [[120209, 120209], "mapped", [108]],
      [[120210, 120210], "mapped", [109]],
      [[120211, 120211], "mapped", [110]],
      [[120212, 120212], "mapped", [111]],
      [[120213, 120213], "mapped", [112]],
      [[120214, 120214], "mapped", [113]],
      [[120215, 120215], "mapped", [114]],
      [[120216, 120216], "mapped", [115]],
      [[120217, 120217], "mapped", [116]],
      [[120218, 120218], "mapped", [117]],
      [[120219, 120219], "mapped", [118]],
      [[120220, 120220], "mapped", [119]],
      [[120221, 120221], "mapped", [120]],
      [[120222, 120222], "mapped", [121]],
      [[120223, 120223], "mapped", [122]],
      [[120224, 120224], "mapped", [97]],
      [[120225, 120225], "mapped", [98]],
      [[120226, 120226], "mapped", [99]],
      [[120227, 120227], "mapped", [100]],
      [[120228, 120228], "mapped", [101]],
      [[120229, 120229], "mapped", [102]],
      [[120230, 120230], "mapped", [103]],
      [[120231, 120231], "mapped", [104]],
      [[120232, 120232], "mapped", [105]],
      [[120233, 120233], "mapped", [106]],
      [[120234, 120234], "mapped", [107]],
      [[120235, 120235], "mapped", [108]],
      [[120236, 120236], "mapped", [109]],
      [[120237, 120237], "mapped", [110]],
      [[120238, 120238], "mapped", [111]],
      [[120239, 120239], "mapped", [112]],
      [[120240, 120240], "mapped", [113]],
      [[120241, 120241], "mapped", [114]],
      [[120242, 120242], "mapped", [115]],
      [[120243, 120243], "mapped", [116]],
      [[120244, 120244], "mapped", [117]],
      [[120245, 120245], "mapped", [118]],
      [[120246, 120246], "mapped", [119]],
      [[120247, 120247], "mapped", [120]],
      [[120248, 120248], "mapped", [121]],
      [[120249, 120249], "mapped", [122]],
      [[120250, 120250], "mapped", [97]],
      [[120251, 120251], "mapped", [98]],
      [[120252, 120252], "mapped", [99]],
      [[120253, 120253], "mapped", [100]],
      [[120254, 120254], "mapped", [101]],
      [[120255, 120255], "mapped", [102]],
      [[120256, 120256], "mapped", [103]],
      [[120257, 120257], "mapped", [104]],
      [[120258, 120258], "mapped", [105]],
      [[120259, 120259], "mapped", [106]],
      [[120260, 120260], "mapped", [107]],
      [[120261, 120261], "mapped", [108]],
      [[120262, 120262], "mapped", [109]],
      [[120263, 120263], "mapped", [110]],
      [[120264, 120264], "mapped", [111]],
      [[120265, 120265], "mapped", [112]],
      [[120266, 120266], "mapped", [113]],
      [[120267, 120267], "mapped", [114]],
      [[120268, 120268], "mapped", [115]],
      [[120269, 120269], "mapped", [116]],
      [[120270, 120270], "mapped", [117]],
      [[120271, 120271], "mapped", [118]],
      [[120272, 120272], "mapped", [119]],
      [[120273, 120273], "mapped", [120]],
      [[120274, 120274], "mapped", [121]],
      [[120275, 120275], "mapped", [122]],
      [[120276, 120276], "mapped", [97]],
      [[120277, 120277], "mapped", [98]],
      [[120278, 120278], "mapped", [99]],
      [[120279, 120279], "mapped", [100]],
      [[120280, 120280], "mapped", [101]],
      [[120281, 120281], "mapped", [102]],
      [[120282, 120282], "mapped", [103]],
      [[120283, 120283], "mapped", [104]],
      [[120284, 120284], "mapped", [105]],
      [[120285, 120285], "mapped", [106]],
      [[120286, 120286], "mapped", [107]],
      [[120287, 120287], "mapped", [108]],
      [[120288, 120288], "mapped", [109]],
      [[120289, 120289], "mapped", [110]],
      [[120290, 120290], "mapped", [111]],
      [[120291, 120291], "mapped", [112]],
      [[120292, 120292], "mapped", [113]],
      [[120293, 120293], "mapped", [114]],
      [[120294, 120294], "mapped", [115]],
      [[120295, 120295], "mapped", [116]],
      [[120296, 120296], "mapped", [117]],
      [[120297, 120297], "mapped", [118]],
      [[120298, 120298], "mapped", [119]],
      [[120299, 120299], "mapped", [120]],
      [[120300, 120300], "mapped", [121]],
      [[120301, 120301], "mapped", [122]],
      [[120302, 120302], "mapped", [97]],
      [[120303, 120303], "mapped", [98]],
      [[120304, 120304], "mapped", [99]],
      [[120305, 120305], "mapped", [100]],
      [[120306, 120306], "mapped", [101]],
      [[120307, 120307], "mapped", [102]],
      [[120308, 120308], "mapped", [103]],
      [[120309, 120309], "mapped", [104]],
      [[120310, 120310], "mapped", [105]],
      [[120311, 120311], "mapped", [106]],
      [[120312, 120312], "mapped", [107]],
      [[120313, 120313], "mapped", [108]],
      [[120314, 120314], "mapped", [109]],
      [[120315, 120315], "mapped", [110]],
      [[120316, 120316], "mapped", [111]],
      [[120317, 120317], "mapped", [112]],
      [[120318, 120318], "mapped", [113]],
      [[120319, 120319], "mapped", [114]],
      [[120320, 120320], "mapped", [115]],
      [[120321, 120321], "mapped", [116]],
      [[120322, 120322], "mapped", [117]],
      [[120323, 120323], "mapped", [118]],
      [[120324, 120324], "mapped", [119]],
      [[120325, 120325], "mapped", [120]],
      [[120326, 120326], "mapped", [121]],
      [[120327, 120327], "mapped", [122]],
      [[120328, 120328], "mapped", [97]],
      [[120329, 120329], "mapped", [98]],
      [[120330, 120330], "mapped", [99]],
      [[120331, 120331], "mapped", [100]],
      [[120332, 120332], "mapped", [101]],
      [[120333, 120333], "mapped", [102]],
      [[120334, 120334], "mapped", [103]],
      [[120335, 120335], "mapped", [104]],
      [[120336, 120336], "mapped", [105]],
      [[120337, 120337], "mapped", [106]],
      [[120338, 120338], "mapped", [107]],
      [[120339, 120339], "mapped", [108]],
      [[120340, 120340], "mapped", [109]],
      [[120341, 120341], "mapped", [110]],
      [[120342, 120342], "mapped", [111]],
      [[120343, 120343], "mapped", [112]],
      [[120344, 120344], "mapped", [113]],
      [[120345, 120345], "mapped", [114]],
      [[120346, 120346], "mapped", [115]],
      [[120347, 120347], "mapped", [116]],
      [[120348, 120348], "mapped", [117]],
      [[120349, 120349], "mapped", [118]],
      [[120350, 120350], "mapped", [119]],
      [[120351, 120351], "mapped", [120]],
      [[120352, 120352], "mapped", [121]],
      [[120353, 120353], "mapped", [122]],
      [[120354, 120354], "mapped", [97]],
      [[120355, 120355], "mapped", [98]],
      [[120356, 120356], "mapped", [99]],
      [[120357, 120357], "mapped", [100]],
      [[120358, 120358], "mapped", [101]],
      [[120359, 120359], "mapped", [102]],
      [[120360, 120360], "mapped", [103]],
      [[120361, 120361], "mapped", [104]],
      [[120362, 120362], "mapped", [105]],
      [[120363, 120363], "mapped", [106]],
      [[120364, 120364], "mapped", [107]],
      [[120365, 120365], "mapped", [108]],
      [[120366, 120366], "mapped", [109]],
      [[120367, 120367], "mapped", [110]],
      [[120368, 120368], "mapped", [111]],
      [[120369, 120369], "mapped", [112]],
      [[120370, 120370], "mapped", [113]],
      [[120371, 120371], "mapped", [114]],
      [[120372, 120372], "mapped", [115]],
      [[120373, 120373], "mapped", [116]],
      [[120374, 120374], "mapped", [117]],
      [[120375, 120375], "mapped", [118]],
      [[120376, 120376], "mapped", [119]],
      [[120377, 120377], "mapped", [120]],
      [[120378, 120378], "mapped", [121]],
      [[120379, 120379], "mapped", [122]],
      [[120380, 120380], "mapped", [97]],
      [[120381, 120381], "mapped", [98]],
      [[120382, 120382], "mapped", [99]],
      [[120383, 120383], "mapped", [100]],
      [[120384, 120384], "mapped", [101]],
      [[120385, 120385], "mapped", [102]],
      [[120386, 120386], "mapped", [103]],
      [[120387, 120387], "mapped", [104]],
      [[120388, 120388], "mapped", [105]],
      [[120389, 120389], "mapped", [106]],
      [[120390, 120390], "mapped", [107]],
      [[120391, 120391], "mapped", [108]],
      [[120392, 120392], "mapped", [109]],
      [[120393, 120393], "mapped", [110]],
      [[120394, 120394], "mapped", [111]],
      [[120395, 120395], "mapped", [112]],
      [[120396, 120396], "mapped", [113]],
      [[120397, 120397], "mapped", [114]],
      [[120398, 120398], "mapped", [115]],
      [[120399, 120399], "mapped", [116]],
      [[120400, 120400], "mapped", [117]],
      [[120401, 120401], "mapped", [118]],
      [[120402, 120402], "mapped", [119]],
      [[120403, 120403], "mapped", [120]],
      [[120404, 120404], "mapped", [121]],
      [[120405, 120405], "mapped", [122]],
      [[120406, 120406], "mapped", [97]],
      [[120407, 120407], "mapped", [98]],
      [[120408, 120408], "mapped", [99]],
      [[120409, 120409], "mapped", [100]],
      [[120410, 120410], "mapped", [101]],
      [[120411, 120411], "mapped", [102]],
      [[120412, 120412], "mapped", [103]],
      [[120413, 120413], "mapped", [104]],
      [[120414, 120414], "mapped", [105]],
      [[120415, 120415], "mapped", [106]],
      [[120416, 120416], "mapped", [107]],
      [[120417, 120417], "mapped", [108]],
      [[120418, 120418], "mapped", [109]],
      [[120419, 120419], "mapped", [110]],
      [[120420, 120420], "mapped", [111]],
      [[120421, 120421], "mapped", [112]],
      [[120422, 120422], "mapped", [113]],
      [[120423, 120423], "mapped", [114]],
      [[120424, 120424], "mapped", [115]],
      [[120425, 120425], "mapped", [116]],
      [[120426, 120426], "mapped", [117]],
      [[120427, 120427], "mapped", [118]],
      [[120428, 120428], "mapped", [119]],
      [[120429, 120429], "mapped", [120]],
      [[120430, 120430], "mapped", [121]],
      [[120431, 120431], "mapped", [122]],
      [[120432, 120432], "mapped", [97]],
      [[120433, 120433], "mapped", [98]],
      [[120434, 120434], "mapped", [99]],
      [[120435, 120435], "mapped", [100]],
      [[120436, 120436], "mapped", [101]],
      [[120437, 120437], "mapped", [102]],
      [[120438, 120438], "mapped", [103]],
      [[120439, 120439], "mapped", [104]],
      [[120440, 120440], "mapped", [105]],
      [[120441, 120441], "mapped", [106]],
      [[120442, 120442], "mapped", [107]],
      [[120443, 120443], "mapped", [108]],
      [[120444, 120444], "mapped", [109]],
      [[120445, 120445], "mapped", [110]],
      [[120446, 120446], "mapped", [111]],
      [[120447, 120447], "mapped", [112]],
      [[120448, 120448], "mapped", [113]],
      [[120449, 120449], "mapped", [114]],
      [[120450, 120450], "mapped", [115]],
      [[120451, 120451], "mapped", [116]],
      [[120452, 120452], "mapped", [117]],
      [[120453, 120453], "mapped", [118]],
      [[120454, 120454], "mapped", [119]],
      [[120455, 120455], "mapped", [120]],
      [[120456, 120456], "mapped", [121]],
      [[120457, 120457], "mapped", [122]],
      [[120458, 120458], "mapped", [97]],
      [[120459, 120459], "mapped", [98]],
      [[120460, 120460], "mapped", [99]],
      [[120461, 120461], "mapped", [100]],
      [[120462, 120462], "mapped", [101]],
      [[120463, 120463], "mapped", [102]],
      [[120464, 120464], "mapped", [103]],
      [[120465, 120465], "mapped", [104]],
      [[120466, 120466], "mapped", [105]],
      [[120467, 120467], "mapped", [106]],
      [[120468, 120468], "mapped", [107]],
      [[120469, 120469], "mapped", [108]],
      [[120470, 120470], "mapped", [109]],
      [[120471, 120471], "mapped", [110]],
      [[120472, 120472], "mapped", [111]],
      [[120473, 120473], "mapped", [112]],
      [[120474, 120474], "mapped", [113]],
      [[120475, 120475], "mapped", [114]],
      [[120476, 120476], "mapped", [115]],
      [[120477, 120477], "mapped", [116]],
      [[120478, 120478], "mapped", [117]],
      [[120479, 120479], "mapped", [118]],
      [[120480, 120480], "mapped", [119]],
      [[120481, 120481], "mapped", [120]],
      [[120482, 120482], "mapped", [121]],
      [[120483, 120483], "mapped", [122]],
      [[120484, 120484], "mapped", [305]],
      [[120485, 120485], "mapped", [567]],
      [[120486, 120487], "disallowed"],
      [[120488, 120488], "mapped", [945]],
      [[120489, 120489], "mapped", [946]],
      [[120490, 120490], "mapped", [947]],
      [[120491, 120491], "mapped", [948]],
      [[120492, 120492], "mapped", [949]],
      [[120493, 120493], "mapped", [950]],
      [[120494, 120494], "mapped", [951]],
      [[120495, 120495], "mapped", [952]],
      [[120496, 120496], "mapped", [953]],
      [[120497, 120497], "mapped", [954]],
      [[120498, 120498], "mapped", [955]],
      [[120499, 120499], "mapped", [956]],
      [[120500, 120500], "mapped", [957]],
      [[120501, 120501], "mapped", [958]],
      [[120502, 120502], "mapped", [959]],
      [[120503, 120503], "mapped", [960]],
      [[120504, 120504], "mapped", [961]],
      [[120505, 120505], "mapped", [952]],
      [[120506, 120506], "mapped", [963]],
      [[120507, 120507], "mapped", [964]],
      [[120508, 120508], "mapped", [965]],
      [[120509, 120509], "mapped", [966]],
      [[120510, 120510], "mapped", [967]],
      [[120511, 120511], "mapped", [968]],
      [[120512, 120512], "mapped", [969]],
      [[120513, 120513], "mapped", [8711]],
      [[120514, 120514], "mapped", [945]],
      [[120515, 120515], "mapped", [946]],
      [[120516, 120516], "mapped", [947]],
      [[120517, 120517], "mapped", [948]],
      [[120518, 120518], "mapped", [949]],
      [[120519, 120519], "mapped", [950]],
      [[120520, 120520], "mapped", [951]],
      [[120521, 120521], "mapped", [952]],
      [[120522, 120522], "mapped", [953]],
      [[120523, 120523], "mapped", [954]],
      [[120524, 120524], "mapped", [955]],
      [[120525, 120525], "mapped", [956]],
      [[120526, 120526], "mapped", [957]],
      [[120527, 120527], "mapped", [958]],
      [[120528, 120528], "mapped", [959]],
      [[120529, 120529], "mapped", [960]],
      [[120530, 120530], "mapped", [961]],
      [[120531, 120532], "mapped", [963]],
      [[120533, 120533], "mapped", [964]],
      [[120534, 120534], "mapped", [965]],
      [[120535, 120535], "mapped", [966]],
      [[120536, 120536], "mapped", [967]],
      [[120537, 120537], "mapped", [968]],
      [[120538, 120538], "mapped", [969]],
      [[120539, 120539], "mapped", [8706]],
      [[120540, 120540], "mapped", [949]],
      [[120541, 120541], "mapped", [952]],
      [[120542, 120542], "mapped", [954]],
      [[120543, 120543], "mapped", [966]],
      [[120544, 120544], "mapped", [961]],
      [[120545, 120545], "mapped", [960]],
      [[120546, 120546], "mapped", [945]],
      [[120547, 120547], "mapped", [946]],
      [[120548, 120548], "mapped", [947]],
      [[120549, 120549], "mapped", [948]],
      [[120550, 120550], "mapped", [949]],
      [[120551, 120551], "mapped", [950]],
      [[120552, 120552], "mapped", [951]],
      [[120553, 120553], "mapped", [952]],
      [[120554, 120554], "mapped", [953]],
      [[120555, 120555], "mapped", [954]],
      [[120556, 120556], "mapped", [955]],
      [[120557, 120557], "mapped", [956]],
      [[120558, 120558], "mapped", [957]],
      [[120559, 120559], "mapped", [958]],
      [[120560, 120560], "mapped", [959]],
      [[120561, 120561], "mapped", [960]],
      [[120562, 120562], "mapped", [961]],
      [[120563, 120563], "mapped", [952]],
      [[120564, 120564], "mapped", [963]],
      [[120565, 120565], "mapped", [964]],
      [[120566, 120566], "mapped", [965]],
      [[120567, 120567], "mapped", [966]],
      [[120568, 120568], "mapped", [967]],
      [[120569, 120569], "mapped", [968]],
      [[120570, 120570], "mapped", [969]],
      [[120571, 120571], "mapped", [8711]],
      [[120572, 120572], "mapped", [945]],
      [[120573, 120573], "mapped", [946]],
      [[120574, 120574], "mapped", [947]],
      [[120575, 120575], "mapped", [948]],
      [[120576, 120576], "mapped", [949]],
      [[120577, 120577], "mapped", [950]],
      [[120578, 120578], "mapped", [951]],
      [[120579, 120579], "mapped", [952]],
      [[120580, 120580], "mapped", [953]],
      [[120581, 120581], "mapped", [954]],
      [[120582, 120582], "mapped", [955]],
      [[120583, 120583], "mapped", [956]],
      [[120584, 120584], "mapped", [957]],
      [[120585, 120585], "mapped", [958]],
      [[120586, 120586], "mapped", [959]],
      [[120587, 120587], "mapped", [960]],
      [[120588, 120588], "mapped", [961]],
      [[120589, 120590], "mapped", [963]],
      [[120591, 120591], "mapped", [964]],
      [[120592, 120592], "mapped", [965]],
      [[120593, 120593], "mapped", [966]],
      [[120594, 120594], "mapped", [967]],
      [[120595, 120595], "mapped", [968]],
      [[120596, 120596], "mapped", [969]],
      [[120597, 120597], "mapped", [8706]],
      [[120598, 120598], "mapped", [949]],
      [[120599, 120599], "mapped", [952]],
      [[120600, 120600], "mapped", [954]],
      [[120601, 120601], "mapped", [966]],
      [[120602, 120602], "mapped", [961]],
      [[120603, 120603], "mapped", [960]],
      [[120604, 120604], "mapped", [945]],
      [[120605, 120605], "mapped", [946]],
      [[120606, 120606], "mapped", [947]],
      [[120607, 120607], "mapped", [948]],
      [[120608, 120608], "mapped", [949]],
      [[120609, 120609], "mapped", [950]],
      [[120610, 120610], "mapped", [951]],
      [[120611, 120611], "mapped", [952]],
      [[120612, 120612], "mapped", [953]],
      [[120613, 120613], "mapped", [954]],
      [[120614, 120614], "mapped", [955]],
      [[120615, 120615], "mapped", [956]],
      [[120616, 120616], "mapped", [957]],
      [[120617, 120617], "mapped", [958]],
      [[120618, 120618], "mapped", [959]],
      [[120619, 120619], "mapped", [960]],
      [[120620, 120620], "mapped", [961]],
      [[120621, 120621], "mapped", [952]],
      [[120622, 120622], "mapped", [963]],
      [[120623, 120623], "mapped", [964]],
      [[120624, 120624], "mapped", [965]],
      [[120625, 120625], "mapped", [966]],
      [[120626, 120626], "mapped", [967]],
      [[120627, 120627], "mapped", [968]],
      [[120628, 120628], "mapped", [969]],
      [[120629, 120629], "mapped", [8711]],
      [[120630, 120630], "mapped", [945]],
      [[120631, 120631], "mapped", [946]],
      [[120632, 120632], "mapped", [947]],
      [[120633, 120633], "mapped", [948]],
      [[120634, 120634], "mapped", [949]],
      [[120635, 120635], "mapped", [950]],
      [[120636, 120636], "mapped", [951]],
      [[120637, 120637], "mapped", [952]],
      [[120638, 120638], "mapped", [953]],
      [[120639, 120639], "mapped", [954]],
      [[120640, 120640], "mapped", [955]],
      [[120641, 120641], "mapped", [956]],
      [[120642, 120642], "mapped", [957]],
      [[120643, 120643], "mapped", [958]],
      [[120644, 120644], "mapped", [959]],
      [[120645, 120645], "mapped", [960]],
      [[120646, 120646], "mapped", [961]],
      [[120647, 120648], "mapped", [963]],
      [[120649, 120649], "mapped", [964]],
      [[120650, 120650], "mapped", [965]],
      [[120651, 120651], "mapped", [966]],
      [[120652, 120652], "mapped", [967]],
      [[120653, 120653], "mapped", [968]],
      [[120654, 120654], "mapped", [969]],
      [[120655, 120655], "mapped", [8706]],
      [[120656, 120656], "mapped", [949]],
      [[120657, 120657], "mapped", [952]],
      [[120658, 120658], "mapped", [954]],
      [[120659, 120659], "mapped", [966]],
      [[120660, 120660], "mapped", [961]],
      [[120661, 120661], "mapped", [960]],
      [[120662, 120662], "mapped", [945]],
      [[120663, 120663], "mapped", [946]],
      [[120664, 120664], "mapped", [947]],
      [[120665, 120665], "mapped", [948]],
      [[120666, 120666], "mapped", [949]],
      [[120667, 120667], "mapped", [950]],
      [[120668, 120668], "mapped", [951]],
      [[120669, 120669], "mapped", [952]],
      [[120670, 120670], "mapped", [953]],
      [[120671, 120671], "mapped", [954]],
      [[120672, 120672], "mapped", [955]],
      [[120673, 120673], "mapped", [956]],
      [[120674, 120674], "mapped", [957]],
      [[120675, 120675], "mapped", [958]],
      [[120676, 120676], "mapped", [959]],
      [[120677, 120677], "mapped", [960]],
      [[120678, 120678], "mapped", [961]],
      [[120679, 120679], "mapped", [952]],
      [[120680, 120680], "mapped", [963]],
      [[120681, 120681], "mapped", [964]],
      [[120682, 120682], "mapped", [965]],
      [[120683, 120683], "mapped", [966]],
      [[120684, 120684], "mapped", [967]],
      [[120685, 120685], "mapped", [968]],
      [[120686, 120686], "mapped", [969]],
      [[120687, 120687], "mapped", [8711]],
      [[120688, 120688], "mapped", [945]],
      [[120689, 120689], "mapped", [946]],
      [[120690, 120690], "mapped", [947]],
      [[120691, 120691], "mapped", [948]],
      [[120692, 120692], "mapped", [949]],
      [[120693, 120693], "mapped", [950]],
      [[120694, 120694], "mapped", [951]],
      [[120695, 120695], "mapped", [952]],
      [[120696, 120696], "mapped", [953]],
      [[120697, 120697], "mapped", [954]],
      [[120698, 120698], "mapped", [955]],
      [[120699, 120699], "mapped", [956]],
      [[120700, 120700], "mapped", [957]],
      [[120701, 120701], "mapped", [958]],
      [[120702, 120702], "mapped", [959]],
      [[120703, 120703], "mapped", [960]],
      [[120704, 120704], "mapped", [961]],
      [[120705, 120706], "mapped", [963]],
      [[120707, 120707], "mapped", [964]],
      [[120708, 120708], "mapped", [965]],
      [[120709, 120709], "mapped", [966]],
      [[120710, 120710], "mapped", [967]],
      [[120711, 120711], "mapped", [968]],
      [[120712, 120712], "mapped", [969]],
      [[120713, 120713], "mapped", [8706]],
      [[120714, 120714], "mapped", [949]],
      [[120715, 120715], "mapped", [952]],
      [[120716, 120716], "mapped", [954]],
      [[120717, 120717], "mapped", [966]],
      [[120718, 120718], "mapped", [961]],
      [[120719, 120719], "mapped", [960]],
      [[120720, 120720], "mapped", [945]],
      [[120721, 120721], "mapped", [946]],
      [[120722, 120722], "mapped", [947]],
      [[120723, 120723], "mapped", [948]],
      [[120724, 120724], "mapped", [949]],
      [[120725, 120725], "mapped", [950]],
      [[120726, 120726], "mapped", [951]],
      [[120727, 120727], "mapped", [952]],
      [[120728, 120728], "mapped", [953]],
      [[120729, 120729], "mapped", [954]],
      [[120730, 120730], "mapped", [955]],
      [[120731, 120731], "mapped", [956]],
      [[120732, 120732], "mapped", [957]],
      [[120733, 120733], "mapped", [958]],
      [[120734, 120734], "mapped", [959]],
      [[120735, 120735], "mapped", [960]],
      [[120736, 120736], "mapped", [961]],
      [[120737, 120737], "mapped", [952]],
      [[120738, 120738], "mapped", [963]],
      [[120739, 120739], "mapped", [964]],
      [[120740, 120740], "mapped", [965]],
      [[120741, 120741], "mapped", [966]],
      [[120742, 120742], "mapped", [967]],
      [[120743, 120743], "mapped", [968]],
      [[120744, 120744], "mapped", [969]],
      [[120745, 120745], "mapped", [8711]],
      [[120746, 120746], "mapped", [945]],
      [[120747, 120747], "mapped", [946]],
      [[120748, 120748], "mapped", [947]],
      [[120749, 120749], "mapped", [948]],
      [[120750, 120750], "mapped", [949]],
      [[120751, 120751], "mapped", [950]],
      [[120752, 120752], "mapped", [951]],
      [[120753, 120753], "mapped", [952]],
      [[120754, 120754], "mapped", [953]],
      [[120755, 120755], "mapped", [954]],
      [[120756, 120756], "mapped", [955]],
      [[120757, 120757], "mapped", [956]],
      [[120758, 120758], "mapped", [957]],
      [[120759, 120759], "mapped", [958]],
      [[120760, 120760], "mapped", [959]],
      [[120761, 120761], "mapped", [960]],
      [[120762, 120762], "mapped", [961]],
      [[120763, 120764], "mapped", [963]],
      [[120765, 120765], "mapped", [964]],
      [[120766, 120766], "mapped", [965]],
      [[120767, 120767], "mapped", [966]],
      [[120768, 120768], "mapped", [967]],
      [[120769, 120769], "mapped", [968]],
      [[120770, 120770], "mapped", [969]],
      [[120771, 120771], "mapped", [8706]],
      [[120772, 120772], "mapped", [949]],
      [[120773, 120773], "mapped", [952]],
      [[120774, 120774], "mapped", [954]],
      [[120775, 120775], "mapped", [966]],
      [[120776, 120776], "mapped", [961]],
      [[120777, 120777], "mapped", [960]],
      [[120778, 120779], "mapped", [989]],
      [[120780, 120781], "disallowed"],
      [[120782, 120782], "mapped", [48]],
      [[120783, 120783], "mapped", [49]],
      [[120784, 120784], "mapped", [50]],
      [[120785, 120785], "mapped", [51]],
      [[120786, 120786], "mapped", [52]],
      [[120787, 120787], "mapped", [53]],
      [[120788, 120788], "mapped", [54]],
      [[120789, 120789], "mapped", [55]],
      [[120790, 120790], "mapped", [56]],
      [[120791, 120791], "mapped", [57]],
      [[120792, 120792], "mapped", [48]],
      [[120793, 120793], "mapped", [49]],
      [[120794, 120794], "mapped", [50]],
      [[120795, 120795], "mapped", [51]],
      [[120796, 120796], "mapped", [52]],
      [[120797, 120797], "mapped", [53]],
      [[120798, 120798], "mapped", [54]],
      [[120799, 120799], "mapped", [55]],
      [[120800, 120800], "mapped", [56]],
      [[120801, 120801], "mapped", [57]],
      [[120802, 120802], "mapped", [48]],
      [[120803, 120803], "mapped", [49]],
      [[120804, 120804], "mapped", [50]],
      [[120805, 120805], "mapped", [51]],
      [[120806, 120806], "mapped", [52]],
      [[120807, 120807], "mapped", [53]],
      [[120808, 120808], "mapped", [54]],
      [[120809, 120809], "mapped", [55]],
      [[120810, 120810], "mapped", [56]],
      [[120811, 120811], "mapped", [57]],
      [[120812, 120812], "mapped", [48]],
      [[120813, 120813], "mapped", [49]],
      [[120814, 120814], "mapped", [50]],
      [[120815, 120815], "mapped", [51]],
      [[120816, 120816], "mapped", [52]],
      [[120817, 120817], "mapped", [53]],
      [[120818, 120818], "mapped", [54]],
      [[120819, 120819], "mapped", [55]],
      [[120820, 120820], "mapped", [56]],
      [[120821, 120821], "mapped", [57]],
      [[120822, 120822], "mapped", [48]],
      [[120823, 120823], "mapped", [49]],
      [[120824, 120824], "mapped", [50]],
      [[120825, 120825], "mapped", [51]],
      [[120826, 120826], "mapped", [52]],
      [[120827, 120827], "mapped", [53]],
      [[120828, 120828], "mapped", [54]],
      [[120829, 120829], "mapped", [55]],
      [[120830, 120830], "mapped", [56]],
      [[120831, 120831], "mapped", [57]],
      [[120832, 121343], "valid", [], "NV8"],
      [[121344, 121398], "valid"],
      [[121399, 121402], "valid", [], "NV8"],
      [[121403, 121452], "valid"],
      [[121453, 121460], "valid", [], "NV8"],
      [[121461, 121461], "valid"],
      [[121462, 121475], "valid", [], "NV8"],
      [[121476, 121476], "valid"],
      [[121477, 121483], "valid", [], "NV8"],
      [[121484, 121498], "disallowed"],
      [[121499, 121503], "valid"],
      [[121504, 121504], "disallowed"],
      [[121505, 121519], "valid"],
      [[121520, 124927], "disallowed"],
      [[124928, 125124], "valid"],
      [[125125, 125126], "disallowed"],
      [[125127, 125135], "valid", [], "NV8"],
      [[125136, 125142], "valid"],
      [[125143, 126463], "disallowed"],
      [[126464, 126464], "mapped", [1575]],
      [[126465, 126465], "mapped", [1576]],
      [[126466, 126466], "mapped", [1580]],
      [[126467, 126467], "mapped", [1583]],
      [[126468, 126468], "disallowed"],
      [[126469, 126469], "mapped", [1608]],
      [[126470, 126470], "mapped", [1586]],
      [[126471, 126471], "mapped", [1581]],
      [[126472, 126472], "mapped", [1591]],
      [[126473, 126473], "mapped", [1610]],
      [[126474, 126474], "mapped", [1603]],
      [[126475, 126475], "mapped", [1604]],
      [[126476, 126476], "mapped", [1605]],
      [[126477, 126477], "mapped", [1606]],
      [[126478, 126478], "mapped", [1587]],
      [[126479, 126479], "mapped", [1593]],
      [[126480, 126480], "mapped", [1601]],
      [[126481, 126481], "mapped", [1589]],
      [[126482, 126482], "mapped", [1602]],
      [[126483, 126483], "mapped", [1585]],
      [[126484, 126484], "mapped", [1588]],
      [[126485, 126485], "mapped", [1578]],
      [[126486, 126486], "mapped", [1579]],
      [[126487, 126487], "mapped", [1582]],
      [[126488, 126488], "mapped", [1584]],
      [[126489, 126489], "mapped", [1590]],
      [[126490, 126490], "mapped", [1592]],
      [[126491, 126491], "mapped", [1594]],
      [[126492, 126492], "mapped", [1646]],
      [[126493, 126493], "mapped", [1722]],
      [[126494, 126494], "mapped", [1697]],
      [[126495, 126495], "mapped", [1647]],
      [[126496, 126496], "disallowed"],
      [[126497, 126497], "mapped", [1576]],
      [[126498, 126498], "mapped", [1580]],
      [[126499, 126499], "disallowed"],
      [[126500, 126500], "mapped", [1607]],
      [[126501, 126502], "disallowed"],
      [[126503, 126503], "mapped", [1581]],
      [[126504, 126504], "disallowed"],
      [[126505, 126505], "mapped", [1610]],
      [[126506, 126506], "mapped", [1603]],
      [[126507, 126507], "mapped", [1604]],
      [[126508, 126508], "mapped", [1605]],
      [[126509, 126509], "mapped", [1606]],
      [[126510, 126510], "mapped", [1587]],
      [[126511, 126511], "mapped", [1593]],
      [[126512, 126512], "mapped", [1601]],
      [[126513, 126513], "mapped", [1589]],
      [[126514, 126514], "mapped", [1602]],
      [[126515, 126515], "disallowed"],
      [[126516, 126516], "mapped", [1588]],
      [[126517, 126517], "mapped", [1578]],
      [[126518, 126518], "mapped", [1579]],
      [[126519, 126519], "mapped", [1582]],
      [[126520, 126520], "disallowed"],
      [[126521, 126521], "mapped", [1590]],
      [[126522, 126522], "disallowed"],
      [[126523, 126523], "mapped", [1594]],
      [[126524, 126529], "disallowed"],
      [[126530, 126530], "mapped", [1580]],
      [[126531, 126534], "disallowed"],
      [[126535, 126535], "mapped", [1581]],
      [[126536, 126536], "disallowed"],
      [[126537, 126537], "mapped", [1610]],
      [[126538, 126538], "disallowed"],
      [[126539, 126539], "mapped", [1604]],
      [[126540, 126540], "disallowed"],
      [[126541, 126541], "mapped", [1606]],
      [[126542, 126542], "mapped", [1587]],
      [[126543, 126543], "mapped", [1593]],
      [[126544, 126544], "disallowed"],
      [[126545, 126545], "mapped", [1589]],
      [[126546, 126546], "mapped", [1602]],
      [[126547, 126547], "disallowed"],
      [[126548, 126548], "mapped", [1588]],
      [[126549, 126550], "disallowed"],
      [[126551, 126551], "mapped", [1582]],
      [[126552, 126552], "disallowed"],
      [[126553, 126553], "mapped", [1590]],
      [[126554, 126554], "disallowed"],
      [[126555, 126555], "mapped", [1594]],
      [[126556, 126556], "disallowed"],
      [[126557, 126557], "mapped", [1722]],
      [[126558, 126558], "disallowed"],
      [[126559, 126559], "mapped", [1647]],
      [[126560, 126560], "disallowed"],
      [[126561, 126561], "mapped", [1576]],
      [[126562, 126562], "mapped", [1580]],
      [[126563, 126563], "disallowed"],
      [[126564, 126564], "mapped", [1607]],
      [[126565, 126566], "disallowed"],
      [[126567, 126567], "mapped", [1581]],
      [[126568, 126568], "mapped", [1591]],
      [[126569, 126569], "mapped", [1610]],
      [[126570, 126570], "mapped", [1603]],
      [[126571, 126571], "disallowed"],
      [[126572, 126572], "mapped", [1605]],
      [[126573, 126573], "mapped", [1606]],
      [[126574, 126574], "mapped", [1587]],
      [[126575, 126575], "mapped", [1593]],
      [[126576, 126576], "mapped", [1601]],
      [[126577, 126577], "mapped", [1589]],
      [[126578, 126578], "mapped", [1602]],
      [[126579, 126579], "disallowed"],
      [[126580, 126580], "mapped", [1588]],
      [[126581, 126581], "mapped", [1578]],
      [[126582, 126582], "mapped", [1579]],
      [[126583, 126583], "mapped", [1582]],
      [[126584, 126584], "disallowed"],
      [[126585, 126585], "mapped", [1590]],
      [[126586, 126586], "mapped", [1592]],
      [[126587, 126587], "mapped", [1594]],
      [[126588, 126588], "mapped", [1646]],
      [[126589, 126589], "disallowed"],
      [[126590, 126590], "mapped", [1697]],
      [[126591, 126591], "disallowed"],
      [[126592, 126592], "mapped", [1575]],
      [[126593, 126593], "mapped", [1576]],
      [[126594, 126594], "mapped", [1580]],
      [[126595, 126595], "mapped", [1583]],
      [[126596, 126596], "mapped", [1607]],
      [[126597, 126597], "mapped", [1608]],
      [[126598, 126598], "mapped", [1586]],
      [[126599, 126599], "mapped", [1581]],
      [[126600, 126600], "mapped", [1591]],
      [[126601, 126601], "mapped", [1610]],
      [[126602, 126602], "disallowed"],
      [[126603, 126603], "mapped", [1604]],
      [[126604, 126604], "mapped", [1605]],
      [[126605, 126605], "mapped", [1606]],
      [[126606, 126606], "mapped", [1587]],
      [[126607, 126607], "mapped", [1593]],
      [[126608, 126608], "mapped", [1601]],
      [[126609, 126609], "mapped", [1589]],
      [[126610, 126610], "mapped", [1602]],
      [[126611, 126611], "mapped", [1585]],
      [[126612, 126612], "mapped", [1588]],
      [[126613, 126613], "mapped", [1578]],
      [[126614, 126614], "mapped", [1579]],
      [[126615, 126615], "mapped", [1582]],
      [[126616, 126616], "mapped", [1584]],
      [[126617, 126617], "mapped", [1590]],
      [[126618, 126618], "mapped", [1592]],
      [[126619, 126619], "mapped", [1594]],
      [[126620, 126624], "disallowed"],
      [[126625, 126625], "mapped", [1576]],
      [[126626, 126626], "mapped", [1580]],
      [[126627, 126627], "mapped", [1583]],
      [[126628, 126628], "disallowed"],
      [[126629, 126629], "mapped", [1608]],
      [[126630, 126630], "mapped", [1586]],
      [[126631, 126631], "mapped", [1581]],
      [[126632, 126632], "mapped", [1591]],
      [[126633, 126633], "mapped", [1610]],
      [[126634, 126634], "disallowed"],
      [[126635, 126635], "mapped", [1604]],
      [[126636, 126636], "mapped", [1605]],
      [[126637, 126637], "mapped", [1606]],
      [[126638, 126638], "mapped", [1587]],
      [[126639, 126639], "mapped", [1593]],
      [[126640, 126640], "mapped", [1601]],
      [[126641, 126641], "mapped", [1589]],
      [[126642, 126642], "mapped", [1602]],
      [[126643, 126643], "mapped", [1585]],
      [[126644, 126644], "mapped", [1588]],
      [[126645, 126645], "mapped", [1578]],
      [[126646, 126646], "mapped", [1579]],
      [[126647, 126647], "mapped", [1582]],
      [[126648, 126648], "mapped", [1584]],
      [[126649, 126649], "mapped", [1590]],
      [[126650, 126650], "mapped", [1592]],
      [[126651, 126651], "mapped", [1594]],
      [[126652, 126703], "disallowed"],
      [[126704, 126705], "valid", [], "NV8"],
      [[126706, 126975], "disallowed"],
      [[126976, 127019], "valid", [], "NV8"],
      [[127020, 127023], "disallowed"],
      [[127024, 127123], "valid", [], "NV8"],
      [[127124, 127135], "disallowed"],
      [[127136, 127150], "valid", [], "NV8"],
      [[127151, 127152], "disallowed"],
      [[127153, 127166], "valid", [], "NV8"],
      [[127167, 127167], "valid", [], "NV8"],
      [[127168, 127168], "disallowed"],
      [[127169, 127183], "valid", [], "NV8"],
      [[127184, 127184], "disallowed"],
      [[127185, 127199], "valid", [], "NV8"],
      [[127200, 127221], "valid", [], "NV8"],
      [[127222, 127231], "disallowed"],
      [[127232, 127232], "disallowed"],
      [[127233, 127233], "disallowed_STD3_mapped", [48, 44]],
      [[127234, 127234], "disallowed_STD3_mapped", [49, 44]],
      [[127235, 127235], "disallowed_STD3_mapped", [50, 44]],
      [[127236, 127236], "disallowed_STD3_mapped", [51, 44]],
      [[127237, 127237], "disallowed_STD3_mapped", [52, 44]],
      [[127238, 127238], "disallowed_STD3_mapped", [53, 44]],
      [[127239, 127239], "disallowed_STD3_mapped", [54, 44]],
      [[127240, 127240], "disallowed_STD3_mapped", [55, 44]],
      [[127241, 127241], "disallowed_STD3_mapped", [56, 44]],
      [[127242, 127242], "disallowed_STD3_mapped", [57, 44]],
      [[127243, 127244], "valid", [], "NV8"],
      [[127245, 127247], "disallowed"],
      [[127248, 127248], "disallowed_STD3_mapped", [40, 97, 41]],
      [[127249, 127249], "disallowed_STD3_mapped", [40, 98, 41]],
      [[127250, 127250], "disallowed_STD3_mapped", [40, 99, 41]],
      [[127251, 127251], "disallowed_STD3_mapped", [40, 100, 41]],
      [[127252, 127252], "disallowed_STD3_mapped", [40, 101, 41]],
      [[127253, 127253], "disallowed_STD3_mapped", [40, 102, 41]],
      [[127254, 127254], "disallowed_STD3_mapped", [40, 103, 41]],
      [[127255, 127255], "disallowed_STD3_mapped", [40, 104, 41]],
      [[127256, 127256], "disallowed_STD3_mapped", [40, 105, 41]],
      [[127257, 127257], "disallowed_STD3_mapped", [40, 106, 41]],
      [[127258, 127258], "disallowed_STD3_mapped", [40, 107, 41]],
      [[127259, 127259], "disallowed_STD3_mapped", [40, 108, 41]],
      [[127260, 127260], "disallowed_STD3_mapped", [40, 109, 41]],
      [[127261, 127261], "disallowed_STD3_mapped", [40, 110, 41]],
      [[127262, 127262], "disallowed_STD3_mapped", [40, 111, 41]],
      [[127263, 127263], "disallowed_STD3_mapped", [40, 112, 41]],
      [[127264, 127264], "disallowed_STD3_mapped", [40, 113, 41]],
      [[127265, 127265], "disallowed_STD3_mapped", [40, 114, 41]],
      [[127266, 127266], "disallowed_STD3_mapped", [40, 115, 41]],
      [[127267, 127267], "disallowed_STD3_mapped", [40, 116, 41]],
      [[127268, 127268], "disallowed_STD3_mapped", [40, 117, 41]],
      [[127269, 127269], "disallowed_STD3_mapped", [40, 118, 41]],
      [[127270, 127270], "disallowed_STD3_mapped", [40, 119, 41]],
      [[127271, 127271], "disallowed_STD3_mapped", [40, 120, 41]],
      [[127272, 127272], "disallowed_STD3_mapped", [40, 121, 41]],
      [[127273, 127273], "disallowed_STD3_mapped", [40, 122, 41]],
      [[127274, 127274], "mapped", [12308, 115, 12309]],
      [[127275, 127275], "mapped", [99]],
      [[127276, 127276], "mapped", [114]],
      [[127277, 127277], "mapped", [99, 100]],
      [[127278, 127278], "mapped", [119, 122]],
      [[127279, 127279], "disallowed"],
      [[127280, 127280], "mapped", [97]],
      [[127281, 127281], "mapped", [98]],
      [[127282, 127282], "mapped", [99]],
      [[127283, 127283], "mapped", [100]],
      [[127284, 127284], "mapped", [101]],
      [[127285, 127285], "mapped", [102]],
      [[127286, 127286], "mapped", [103]],
      [[127287, 127287], "mapped", [104]],
      [[127288, 127288], "mapped", [105]],
      [[127289, 127289], "mapped", [106]],
      [[127290, 127290], "mapped", [107]],
      [[127291, 127291], "mapped", [108]],
      [[127292, 127292], "mapped", [109]],
      [[127293, 127293], "mapped", [110]],
      [[127294, 127294], "mapped", [111]],
      [[127295, 127295], "mapped", [112]],
      [[127296, 127296], "mapped", [113]],
      [[127297, 127297], "mapped", [114]],
      [[127298, 127298], "mapped", [115]],
      [[127299, 127299], "mapped", [116]],
      [[127300, 127300], "mapped", [117]],
      [[127301, 127301], "mapped", [118]],
      [[127302, 127302], "mapped", [119]],
      [[127303, 127303], "mapped", [120]],
      [[127304, 127304], "mapped", [121]],
      [[127305, 127305], "mapped", [122]],
      [[127306, 127306], "mapped", [104, 118]],
      [[127307, 127307], "mapped", [109, 118]],
      [[127308, 127308], "mapped", [115, 100]],
      [[127309, 127309], "mapped", [115, 115]],
      [[127310, 127310], "mapped", [112, 112, 118]],
      [[127311, 127311], "mapped", [119, 99]],
      [[127312, 127318], "valid", [], "NV8"],
      [[127319, 127319], "valid", [], "NV8"],
      [[127320, 127326], "valid", [], "NV8"],
      [[127327, 127327], "valid", [], "NV8"],
      [[127328, 127337], "valid", [], "NV8"],
      [[127338, 127338], "mapped", [109, 99]],
      [[127339, 127339], "mapped", [109, 100]],
      [[127340, 127343], "disallowed"],
      [[127344, 127352], "valid", [], "NV8"],
      [[127353, 127353], "valid", [], "NV8"],
      [[127354, 127354], "valid", [], "NV8"],
      [[127355, 127356], "valid", [], "NV8"],
      [[127357, 127358], "valid", [], "NV8"],
      [[127359, 127359], "valid", [], "NV8"],
      [[127360, 127369], "valid", [], "NV8"],
      [[127370, 127373], "valid", [], "NV8"],
      [[127374, 127375], "valid", [], "NV8"],
      [[127376, 127376], "mapped", [100, 106]],
      [[127377, 127386], "valid", [], "NV8"],
      [[127387, 127461], "disallowed"],
      [[127462, 127487], "valid", [], "NV8"],
      [[127488, 127488], "mapped", [12411, 12363]],
      [[127489, 127489], "mapped", [12467, 12467]],
      [[127490, 127490], "mapped", [12469]],
      [[127491, 127503], "disallowed"],
      [[127504, 127504], "mapped", [25163]],
      [[127505, 127505], "mapped", [23383]],
      [[127506, 127506], "mapped", [21452]],
      [[127507, 127507], "mapped", [12487]],
      [[127508, 127508], "mapped", [20108]],
      [[127509, 127509], "mapped", [22810]],
      [[127510, 127510], "mapped", [35299]],
      [[127511, 127511], "mapped", [22825]],
      [[127512, 127512], "mapped", [20132]],
      [[127513, 127513], "mapped", [26144]],
      [[127514, 127514], "mapped", [28961]],
      [[127515, 127515], "mapped", [26009]],
      [[127516, 127516], "mapped", [21069]],
      [[127517, 127517], "mapped", [24460]],
      [[127518, 127518], "mapped", [20877]],
      [[127519, 127519], "mapped", [26032]],
      [[127520, 127520], "mapped", [21021]],
      [[127521, 127521], "mapped", [32066]],
      [[127522, 127522], "mapped", [29983]],
      [[127523, 127523], "mapped", [36009]],
      [[127524, 127524], "mapped", [22768]],
      [[127525, 127525], "mapped", [21561]],
      [[127526, 127526], "mapped", [28436]],
      [[127527, 127527], "mapped", [25237]],
      [[127528, 127528], "mapped", [25429]],
      [[127529, 127529], "mapped", [19968]],
      [[127530, 127530], "mapped", [19977]],
      [[127531, 127531], "mapped", [36938]],
      [[127532, 127532], "mapped", [24038]],
      [[127533, 127533], "mapped", [20013]],
      [[127534, 127534], "mapped", [21491]],
      [[127535, 127535], "mapped", [25351]],
      [[127536, 127536], "mapped", [36208]],
      [[127537, 127537], "mapped", [25171]],
      [[127538, 127538], "mapped", [31105]],
      [[127539, 127539], "mapped", [31354]],
      [[127540, 127540], "mapped", [21512]],
      [[127541, 127541], "mapped", [28288]],
      [[127542, 127542], "mapped", [26377]],
      [[127543, 127543], "mapped", [26376]],
      [[127544, 127544], "mapped", [30003]],
      [[127545, 127545], "mapped", [21106]],
      [[127546, 127546], "mapped", [21942]],
      [[127547, 127551], "disallowed"],
      [[127552, 127552], "mapped", [12308, 26412, 12309]],
      [[127553, 127553], "mapped", [12308, 19977, 12309]],
      [[127554, 127554], "mapped", [12308, 20108, 12309]],
      [[127555, 127555], "mapped", [12308, 23433, 12309]],
      [[127556, 127556], "mapped", [12308, 28857, 12309]],
      [[127557, 127557], "mapped", [12308, 25171, 12309]],
      [[127558, 127558], "mapped", [12308, 30423, 12309]],
      [[127559, 127559], "mapped", [12308, 21213, 12309]],
      [[127560, 127560], "mapped", [12308, 25943, 12309]],
      [[127561, 127567], "disallowed"],
      [[127568, 127568], "mapped", [24471]],
      [[127569, 127569], "mapped", [21487]],
      [[127570, 127743], "disallowed"],
      [[127744, 127776], "valid", [], "NV8"],
      [[127777, 127788], "valid", [], "NV8"],
      [[127789, 127791], "valid", [], "NV8"],
      [[127792, 127797], "valid", [], "NV8"],
      [[127798, 127798], "valid", [], "NV8"],
      [[127799, 127868], "valid", [], "NV8"],
      [[127869, 127869], "valid", [], "NV8"],
      [[127870, 127871], "valid", [], "NV8"],
      [[127872, 127891], "valid", [], "NV8"],
      [[127892, 127903], "valid", [], "NV8"],
      [[127904, 127940], "valid", [], "NV8"],
      [[127941, 127941], "valid", [], "NV8"],
      [[127942, 127946], "valid", [], "NV8"],
      [[127947, 127950], "valid", [], "NV8"],
      [[127951, 127955], "valid", [], "NV8"],
      [[127956, 127967], "valid", [], "NV8"],
      [[127968, 127984], "valid", [], "NV8"],
      [[127985, 127991], "valid", [], "NV8"],
      [[127992, 127999], "valid", [], "NV8"],
      [[128e3, 128062], "valid", [], "NV8"],
      [[128063, 128063], "valid", [], "NV8"],
      [[128064, 128064], "valid", [], "NV8"],
      [[128065, 128065], "valid", [], "NV8"],
      [[128066, 128247], "valid", [], "NV8"],
      [[128248, 128248], "valid", [], "NV8"],
      [[128249, 128252], "valid", [], "NV8"],
      [[128253, 128254], "valid", [], "NV8"],
      [[128255, 128255], "valid", [], "NV8"],
      [[128256, 128317], "valid", [], "NV8"],
      [[128318, 128319], "valid", [], "NV8"],
      [[128320, 128323], "valid", [], "NV8"],
      [[128324, 128330], "valid", [], "NV8"],
      [[128331, 128335], "valid", [], "NV8"],
      [[128336, 128359], "valid", [], "NV8"],
      [[128360, 128377], "valid", [], "NV8"],
      [[128378, 128378], "disallowed"],
      [[128379, 128419], "valid", [], "NV8"],
      [[128420, 128420], "disallowed"],
      [[128421, 128506], "valid", [], "NV8"],
      [[128507, 128511], "valid", [], "NV8"],
      [[128512, 128512], "valid", [], "NV8"],
      [[128513, 128528], "valid", [], "NV8"],
      [[128529, 128529], "valid", [], "NV8"],
      [[128530, 128532], "valid", [], "NV8"],
      [[128533, 128533], "valid", [], "NV8"],
      [[128534, 128534], "valid", [], "NV8"],
      [[128535, 128535], "valid", [], "NV8"],
      [[128536, 128536], "valid", [], "NV8"],
      [[128537, 128537], "valid", [], "NV8"],
      [[128538, 128538], "valid", [], "NV8"],
      [[128539, 128539], "valid", [], "NV8"],
      [[128540, 128542], "valid", [], "NV8"],
      [[128543, 128543], "valid", [], "NV8"],
      [[128544, 128549], "valid", [], "NV8"],
      [[128550, 128551], "valid", [], "NV8"],
      [[128552, 128555], "valid", [], "NV8"],
      [[128556, 128556], "valid", [], "NV8"],
      [[128557, 128557], "valid", [], "NV8"],
      [[128558, 128559], "valid", [], "NV8"],
      [[128560, 128563], "valid", [], "NV8"],
      [[128564, 128564], "valid", [], "NV8"],
      [[128565, 128576], "valid", [], "NV8"],
      [[128577, 128578], "valid", [], "NV8"],
      [[128579, 128580], "valid", [], "NV8"],
      [[128581, 128591], "valid", [], "NV8"],
      [[128592, 128639], "valid", [], "NV8"],
      [[128640, 128709], "valid", [], "NV8"],
      [[128710, 128719], "valid", [], "NV8"],
      [[128720, 128720], "valid", [], "NV8"],
      [[128721, 128735], "disallowed"],
      [[128736, 128748], "valid", [], "NV8"],
      [[128749, 128751], "disallowed"],
      [[128752, 128755], "valid", [], "NV8"],
      [[128756, 128767], "disallowed"],
      [[128768, 128883], "valid", [], "NV8"],
      [[128884, 128895], "disallowed"],
      [[128896, 128980], "valid", [], "NV8"],
      [[128981, 129023], "disallowed"],
      [[129024, 129035], "valid", [], "NV8"],
      [[129036, 129039], "disallowed"],
      [[129040, 129095], "valid", [], "NV8"],
      [[129096, 129103], "disallowed"],
      [[129104, 129113], "valid", [], "NV8"],
      [[129114, 129119], "disallowed"],
      [[129120, 129159], "valid", [], "NV8"],
      [[129160, 129167], "disallowed"],
      [[129168, 129197], "valid", [], "NV8"],
      [[129198, 129295], "disallowed"],
      [[129296, 129304], "valid", [], "NV8"],
      [[129305, 129407], "disallowed"],
      [[129408, 129412], "valid", [], "NV8"],
      [[129413, 129471], "disallowed"],
      [[129472, 129472], "valid", [], "NV8"],
      [[129473, 131069], "disallowed"],
      [[131070, 131071], "disallowed"],
      [[131072, 173782], "valid"],
      [[173783, 173823], "disallowed"],
      [[173824, 177972], "valid"],
      [[177973, 177983], "disallowed"],
      [[177984, 178205], "valid"],
      [[178206, 178207], "disallowed"],
      [[178208, 183969], "valid"],
      [[183970, 194559], "disallowed"],
      [[194560, 194560], "mapped", [20029]],
      [[194561, 194561], "mapped", [20024]],
      [[194562, 194562], "mapped", [20033]],
      [[194563, 194563], "mapped", [131362]],
      [[194564, 194564], "mapped", [20320]],
      [[194565, 194565], "mapped", [20398]],
      [[194566, 194566], "mapped", [20411]],
      [[194567, 194567], "mapped", [20482]],
      [[194568, 194568], "mapped", [20602]],
      [[194569, 194569], "mapped", [20633]],
      [[194570, 194570], "mapped", [20711]],
      [[194571, 194571], "mapped", [20687]],
      [[194572, 194572], "mapped", [13470]],
      [[194573, 194573], "mapped", [132666]],
      [[194574, 194574], "mapped", [20813]],
      [[194575, 194575], "mapped", [20820]],
      [[194576, 194576], "mapped", [20836]],
      [[194577, 194577], "mapped", [20855]],
      [[194578, 194578], "mapped", [132380]],
      [[194579, 194579], "mapped", [13497]],
      [[194580, 194580], "mapped", [20839]],
      [[194581, 194581], "mapped", [20877]],
      [[194582, 194582], "mapped", [132427]],
      [[194583, 194583], "mapped", [20887]],
      [[194584, 194584], "mapped", [20900]],
      [[194585, 194585], "mapped", [20172]],
      [[194586, 194586], "mapped", [20908]],
      [[194587, 194587], "mapped", [20917]],
      [[194588, 194588], "mapped", [168415]],
      [[194589, 194589], "mapped", [20981]],
      [[194590, 194590], "mapped", [20995]],
      [[194591, 194591], "mapped", [13535]],
      [[194592, 194592], "mapped", [21051]],
      [[194593, 194593], "mapped", [21062]],
      [[194594, 194594], "mapped", [21106]],
      [[194595, 194595], "mapped", [21111]],
      [[194596, 194596], "mapped", [13589]],
      [[194597, 194597], "mapped", [21191]],
      [[194598, 194598], "mapped", [21193]],
      [[194599, 194599], "mapped", [21220]],
      [[194600, 194600], "mapped", [21242]],
      [[194601, 194601], "mapped", [21253]],
      [[194602, 194602], "mapped", [21254]],
      [[194603, 194603], "mapped", [21271]],
      [[194604, 194604], "mapped", [21321]],
      [[194605, 194605], "mapped", [21329]],
      [[194606, 194606], "mapped", [21338]],
      [[194607, 194607], "mapped", [21363]],
      [[194608, 194608], "mapped", [21373]],
      [[194609, 194611], "mapped", [21375]],
      [[194612, 194612], "mapped", [133676]],
      [[194613, 194613], "mapped", [28784]],
      [[194614, 194614], "mapped", [21450]],
      [[194615, 194615], "mapped", [21471]],
      [[194616, 194616], "mapped", [133987]],
      [[194617, 194617], "mapped", [21483]],
      [[194618, 194618], "mapped", [21489]],
      [[194619, 194619], "mapped", [21510]],
      [[194620, 194620], "mapped", [21662]],
      [[194621, 194621], "mapped", [21560]],
      [[194622, 194622], "mapped", [21576]],
      [[194623, 194623], "mapped", [21608]],
      [[194624, 194624], "mapped", [21666]],
      [[194625, 194625], "mapped", [21750]],
      [[194626, 194626], "mapped", [21776]],
      [[194627, 194627], "mapped", [21843]],
      [[194628, 194628], "mapped", [21859]],
      [[194629, 194630], "mapped", [21892]],
      [[194631, 194631], "mapped", [21913]],
      [[194632, 194632], "mapped", [21931]],
      [[194633, 194633], "mapped", [21939]],
      [[194634, 194634], "mapped", [21954]],
      [[194635, 194635], "mapped", [22294]],
      [[194636, 194636], "mapped", [22022]],
      [[194637, 194637], "mapped", [22295]],
      [[194638, 194638], "mapped", [22097]],
      [[194639, 194639], "mapped", [22132]],
      [[194640, 194640], "mapped", [20999]],
      [[194641, 194641], "mapped", [22766]],
      [[194642, 194642], "mapped", [22478]],
      [[194643, 194643], "mapped", [22516]],
      [[194644, 194644], "mapped", [22541]],
      [[194645, 194645], "mapped", [22411]],
      [[194646, 194646], "mapped", [22578]],
      [[194647, 194647], "mapped", [22577]],
      [[194648, 194648], "mapped", [22700]],
      [[194649, 194649], "mapped", [136420]],
      [[194650, 194650], "mapped", [22770]],
      [[194651, 194651], "mapped", [22775]],
      [[194652, 194652], "mapped", [22790]],
      [[194653, 194653], "mapped", [22810]],
      [[194654, 194654], "mapped", [22818]],
      [[194655, 194655], "mapped", [22882]],
      [[194656, 194656], "mapped", [136872]],
      [[194657, 194657], "mapped", [136938]],
      [[194658, 194658], "mapped", [23020]],
      [[194659, 194659], "mapped", [23067]],
      [[194660, 194660], "mapped", [23079]],
      [[194661, 194661], "mapped", [23e3]],
      [[194662, 194662], "mapped", [23142]],
      [[194663, 194663], "mapped", [14062]],
      [[194664, 194664], "disallowed"],
      [[194665, 194665], "mapped", [23304]],
      [[194666, 194667], "mapped", [23358]],
      [[194668, 194668], "mapped", [137672]],
      [[194669, 194669], "mapped", [23491]],
      [[194670, 194670], "mapped", [23512]],
      [[194671, 194671], "mapped", [23527]],
      [[194672, 194672], "mapped", [23539]],
      [[194673, 194673], "mapped", [138008]],
      [[194674, 194674], "mapped", [23551]],
      [[194675, 194675], "mapped", [23558]],
      [[194676, 194676], "disallowed"],
      [[194677, 194677], "mapped", [23586]],
      [[194678, 194678], "mapped", [14209]],
      [[194679, 194679], "mapped", [23648]],
      [[194680, 194680], "mapped", [23662]],
      [[194681, 194681], "mapped", [23744]],
      [[194682, 194682], "mapped", [23693]],
      [[194683, 194683], "mapped", [138724]],
      [[194684, 194684], "mapped", [23875]],
      [[194685, 194685], "mapped", [138726]],
      [[194686, 194686], "mapped", [23918]],
      [[194687, 194687], "mapped", [23915]],
      [[194688, 194688], "mapped", [23932]],
      [[194689, 194689], "mapped", [24033]],
      [[194690, 194690], "mapped", [24034]],
      [[194691, 194691], "mapped", [14383]],
      [[194692, 194692], "mapped", [24061]],
      [[194693, 194693], "mapped", [24104]],
      [[194694, 194694], "mapped", [24125]],
      [[194695, 194695], "mapped", [24169]],
      [[194696, 194696], "mapped", [14434]],
      [[194697, 194697], "mapped", [139651]],
      [[194698, 194698], "mapped", [14460]],
      [[194699, 194699], "mapped", [24240]],
      [[194700, 194700], "mapped", [24243]],
      [[194701, 194701], "mapped", [24246]],
      [[194702, 194702], "mapped", [24266]],
      [[194703, 194703], "mapped", [172946]],
      [[194704, 194704], "mapped", [24318]],
      [[194705, 194706], "mapped", [140081]],
      [[194707, 194707], "mapped", [33281]],
      [[194708, 194709], "mapped", [24354]],
      [[194710, 194710], "mapped", [14535]],
      [[194711, 194711], "mapped", [144056]],
      [[194712, 194712], "mapped", [156122]],
      [[194713, 194713], "mapped", [24418]],
      [[194714, 194714], "mapped", [24427]],
      [[194715, 194715], "mapped", [14563]],
      [[194716, 194716], "mapped", [24474]],
      [[194717, 194717], "mapped", [24525]],
      [[194718, 194718], "mapped", [24535]],
      [[194719, 194719], "mapped", [24569]],
      [[194720, 194720], "mapped", [24705]],
      [[194721, 194721], "mapped", [14650]],
      [[194722, 194722], "mapped", [14620]],
      [[194723, 194723], "mapped", [24724]],
      [[194724, 194724], "mapped", [141012]],
      [[194725, 194725], "mapped", [24775]],
      [[194726, 194726], "mapped", [24904]],
      [[194727, 194727], "mapped", [24908]],
      [[194728, 194728], "mapped", [24910]],
      [[194729, 194729], "mapped", [24908]],
      [[194730, 194730], "mapped", [24954]],
      [[194731, 194731], "mapped", [24974]],
      [[194732, 194732], "mapped", [25010]],
      [[194733, 194733], "mapped", [24996]],
      [[194734, 194734], "mapped", [25007]],
      [[194735, 194735], "mapped", [25054]],
      [[194736, 194736], "mapped", [25074]],
      [[194737, 194737], "mapped", [25078]],
      [[194738, 194738], "mapped", [25104]],
      [[194739, 194739], "mapped", [25115]],
      [[194740, 194740], "mapped", [25181]],
      [[194741, 194741], "mapped", [25265]],
      [[194742, 194742], "mapped", [25300]],
      [[194743, 194743], "mapped", [25424]],
      [[194744, 194744], "mapped", [142092]],
      [[194745, 194745], "mapped", [25405]],
      [[194746, 194746], "mapped", [25340]],
      [[194747, 194747], "mapped", [25448]],
      [[194748, 194748], "mapped", [25475]],
      [[194749, 194749], "mapped", [25572]],
      [[194750, 194750], "mapped", [142321]],
      [[194751, 194751], "mapped", [25634]],
      [[194752, 194752], "mapped", [25541]],
      [[194753, 194753], "mapped", [25513]],
      [[194754, 194754], "mapped", [14894]],
      [[194755, 194755], "mapped", [25705]],
      [[194756, 194756], "mapped", [25726]],
      [[194757, 194757], "mapped", [25757]],
      [[194758, 194758], "mapped", [25719]],
      [[194759, 194759], "mapped", [14956]],
      [[194760, 194760], "mapped", [25935]],
      [[194761, 194761], "mapped", [25964]],
      [[194762, 194762], "mapped", [143370]],
      [[194763, 194763], "mapped", [26083]],
      [[194764, 194764], "mapped", [26360]],
      [[194765, 194765], "mapped", [26185]],
      [[194766, 194766], "mapped", [15129]],
      [[194767, 194767], "mapped", [26257]],
      [[194768, 194768], "mapped", [15112]],
      [[194769, 194769], "mapped", [15076]],
      [[194770, 194770], "mapped", [20882]],
      [[194771, 194771], "mapped", [20885]],
      [[194772, 194772], "mapped", [26368]],
      [[194773, 194773], "mapped", [26268]],
      [[194774, 194774], "mapped", [32941]],
      [[194775, 194775], "mapped", [17369]],
      [[194776, 194776], "mapped", [26391]],
      [[194777, 194777], "mapped", [26395]],
      [[194778, 194778], "mapped", [26401]],
      [[194779, 194779], "mapped", [26462]],
      [[194780, 194780], "mapped", [26451]],
      [[194781, 194781], "mapped", [144323]],
      [[194782, 194782], "mapped", [15177]],
      [[194783, 194783], "mapped", [26618]],
      [[194784, 194784], "mapped", [26501]],
      [[194785, 194785], "mapped", [26706]],
      [[194786, 194786], "mapped", [26757]],
      [[194787, 194787], "mapped", [144493]],
      [[194788, 194788], "mapped", [26766]],
      [[194789, 194789], "mapped", [26655]],
      [[194790, 194790], "mapped", [26900]],
      [[194791, 194791], "mapped", [15261]],
      [[194792, 194792], "mapped", [26946]],
      [[194793, 194793], "mapped", [27043]],
      [[194794, 194794], "mapped", [27114]],
      [[194795, 194795], "mapped", [27304]],
      [[194796, 194796], "mapped", [145059]],
      [[194797, 194797], "mapped", [27355]],
      [[194798, 194798], "mapped", [15384]],
      [[194799, 194799], "mapped", [27425]],
      [[194800, 194800], "mapped", [145575]],
      [[194801, 194801], "mapped", [27476]],
      [[194802, 194802], "mapped", [15438]],
      [[194803, 194803], "mapped", [27506]],
      [[194804, 194804], "mapped", [27551]],
      [[194805, 194805], "mapped", [27578]],
      [[194806, 194806], "mapped", [27579]],
      [[194807, 194807], "mapped", [146061]],
      [[194808, 194808], "mapped", [138507]],
      [[194809, 194809], "mapped", [146170]],
      [[194810, 194810], "mapped", [27726]],
      [[194811, 194811], "mapped", [146620]],
      [[194812, 194812], "mapped", [27839]],
      [[194813, 194813], "mapped", [27853]],
      [[194814, 194814], "mapped", [27751]],
      [[194815, 194815], "mapped", [27926]],
      [[194816, 194816], "mapped", [27966]],
      [[194817, 194817], "mapped", [28023]],
      [[194818, 194818], "mapped", [27969]],
      [[194819, 194819], "mapped", [28009]],
      [[194820, 194820], "mapped", [28024]],
      [[194821, 194821], "mapped", [28037]],
      [[194822, 194822], "mapped", [146718]],
      [[194823, 194823], "mapped", [27956]],
      [[194824, 194824], "mapped", [28207]],
      [[194825, 194825], "mapped", [28270]],
      [[194826, 194826], "mapped", [15667]],
      [[194827, 194827], "mapped", [28363]],
      [[194828, 194828], "mapped", [28359]],
      [[194829, 194829], "mapped", [147153]],
      [[194830, 194830], "mapped", [28153]],
      [[194831, 194831], "mapped", [28526]],
      [[194832, 194832], "mapped", [147294]],
      [[194833, 194833], "mapped", [147342]],
      [[194834, 194834], "mapped", [28614]],
      [[194835, 194835], "mapped", [28729]],
      [[194836, 194836], "mapped", [28702]],
      [[194837, 194837], "mapped", [28699]],
      [[194838, 194838], "mapped", [15766]],
      [[194839, 194839], "mapped", [28746]],
      [[194840, 194840], "mapped", [28797]],
      [[194841, 194841], "mapped", [28791]],
      [[194842, 194842], "mapped", [28845]],
      [[194843, 194843], "mapped", [132389]],
      [[194844, 194844], "mapped", [28997]],
      [[194845, 194845], "mapped", [148067]],
      [[194846, 194846], "mapped", [29084]],
      [[194847, 194847], "disallowed"],
      [[194848, 194848], "mapped", [29224]],
      [[194849, 194849], "mapped", [29237]],
      [[194850, 194850], "mapped", [29264]],
      [[194851, 194851], "mapped", [149e3]],
      [[194852, 194852], "mapped", [29312]],
      [[194853, 194853], "mapped", [29333]],
      [[194854, 194854], "mapped", [149301]],
      [[194855, 194855], "mapped", [149524]],
      [[194856, 194856], "mapped", [29562]],
      [[194857, 194857], "mapped", [29579]],
      [[194858, 194858], "mapped", [16044]],
      [[194859, 194859], "mapped", [29605]],
      [[194860, 194861], "mapped", [16056]],
      [[194862, 194862], "mapped", [29767]],
      [[194863, 194863], "mapped", [29788]],
      [[194864, 194864], "mapped", [29809]],
      [[194865, 194865], "mapped", [29829]],
      [[194866, 194866], "mapped", [29898]],
      [[194867, 194867], "mapped", [16155]],
      [[194868, 194868], "mapped", [29988]],
      [[194869, 194869], "mapped", [150582]],
      [[194870, 194870], "mapped", [30014]],
      [[194871, 194871], "mapped", [150674]],
      [[194872, 194872], "mapped", [30064]],
      [[194873, 194873], "mapped", [139679]],
      [[194874, 194874], "mapped", [30224]],
      [[194875, 194875], "mapped", [151457]],
      [[194876, 194876], "mapped", [151480]],
      [[194877, 194877], "mapped", [151620]],
      [[194878, 194878], "mapped", [16380]],
      [[194879, 194879], "mapped", [16392]],
      [[194880, 194880], "mapped", [30452]],
      [[194881, 194881], "mapped", [151795]],
      [[194882, 194882], "mapped", [151794]],
      [[194883, 194883], "mapped", [151833]],
      [[194884, 194884], "mapped", [151859]],
      [[194885, 194885], "mapped", [30494]],
      [[194886, 194887], "mapped", [30495]],
      [[194888, 194888], "mapped", [30538]],
      [[194889, 194889], "mapped", [16441]],
      [[194890, 194890], "mapped", [30603]],
      [[194891, 194891], "mapped", [16454]],
      [[194892, 194892], "mapped", [16534]],
      [[194893, 194893], "mapped", [152605]],
      [[194894, 194894], "mapped", [30798]],
      [[194895, 194895], "mapped", [30860]],
      [[194896, 194896], "mapped", [30924]],
      [[194897, 194897], "mapped", [16611]],
      [[194898, 194898], "mapped", [153126]],
      [[194899, 194899], "mapped", [31062]],
      [[194900, 194900], "mapped", [153242]],
      [[194901, 194901], "mapped", [153285]],
      [[194902, 194902], "mapped", [31119]],
      [[194903, 194903], "mapped", [31211]],
      [[194904, 194904], "mapped", [16687]],
      [[194905, 194905], "mapped", [31296]],
      [[194906, 194906], "mapped", [31306]],
      [[194907, 194907], "mapped", [31311]],
      [[194908, 194908], "mapped", [153980]],
      [[194909, 194910], "mapped", [154279]],
      [[194911, 194911], "disallowed"],
      [[194912, 194912], "mapped", [16898]],
      [[194913, 194913], "mapped", [154539]],
      [[194914, 194914], "mapped", [31686]],
      [[194915, 194915], "mapped", [31689]],
      [[194916, 194916], "mapped", [16935]],
      [[194917, 194917], "mapped", [154752]],
      [[194918, 194918], "mapped", [31954]],
      [[194919, 194919], "mapped", [17056]],
      [[194920, 194920], "mapped", [31976]],
      [[194921, 194921], "mapped", [31971]],
      [[194922, 194922], "mapped", [32e3]],
      [[194923, 194923], "mapped", [155526]],
      [[194924, 194924], "mapped", [32099]],
      [[194925, 194925], "mapped", [17153]],
      [[194926, 194926], "mapped", [32199]],
      [[194927, 194927], "mapped", [32258]],
      [[194928, 194928], "mapped", [32325]],
      [[194929, 194929], "mapped", [17204]],
      [[194930, 194930], "mapped", [156200]],
      [[194931, 194931], "mapped", [156231]],
      [[194932, 194932], "mapped", [17241]],
      [[194933, 194933], "mapped", [156377]],
      [[194934, 194934], "mapped", [32634]],
      [[194935, 194935], "mapped", [156478]],
      [[194936, 194936], "mapped", [32661]],
      [[194937, 194937], "mapped", [32762]],
      [[194938, 194938], "mapped", [32773]],
      [[194939, 194939], "mapped", [156890]],
      [[194940, 194940], "mapped", [156963]],
      [[194941, 194941], "mapped", [32864]],
      [[194942, 194942], "mapped", [157096]],
      [[194943, 194943], "mapped", [32880]],
      [[194944, 194944], "mapped", [144223]],
      [[194945, 194945], "mapped", [17365]],
      [[194946, 194946], "mapped", [32946]],
      [[194947, 194947], "mapped", [33027]],
      [[194948, 194948], "mapped", [17419]],
      [[194949, 194949], "mapped", [33086]],
      [[194950, 194950], "mapped", [23221]],
      [[194951, 194951], "mapped", [157607]],
      [[194952, 194952], "mapped", [157621]],
      [[194953, 194953], "mapped", [144275]],
      [[194954, 194954], "mapped", [144284]],
      [[194955, 194955], "mapped", [33281]],
      [[194956, 194956], "mapped", [33284]],
      [[194957, 194957], "mapped", [36766]],
      [[194958, 194958], "mapped", [17515]],
      [[194959, 194959], "mapped", [33425]],
      [[194960, 194960], "mapped", [33419]],
      [[194961, 194961], "mapped", [33437]],
      [[194962, 194962], "mapped", [21171]],
      [[194963, 194963], "mapped", [33457]],
      [[194964, 194964], "mapped", [33459]],
      [[194965, 194965], "mapped", [33469]],
      [[194966, 194966], "mapped", [33510]],
      [[194967, 194967], "mapped", [158524]],
      [[194968, 194968], "mapped", [33509]],
      [[194969, 194969], "mapped", [33565]],
      [[194970, 194970], "mapped", [33635]],
      [[194971, 194971], "mapped", [33709]],
      [[194972, 194972], "mapped", [33571]],
      [[194973, 194973], "mapped", [33725]],
      [[194974, 194974], "mapped", [33767]],
      [[194975, 194975], "mapped", [33879]],
      [[194976, 194976], "mapped", [33619]],
      [[194977, 194977], "mapped", [33738]],
      [[194978, 194978], "mapped", [33740]],
      [[194979, 194979], "mapped", [33756]],
      [[194980, 194980], "mapped", [158774]],
      [[194981, 194981], "mapped", [159083]],
      [[194982, 194982], "mapped", [158933]],
      [[194983, 194983], "mapped", [17707]],
      [[194984, 194984], "mapped", [34033]],
      [[194985, 194985], "mapped", [34035]],
      [[194986, 194986], "mapped", [34070]],
      [[194987, 194987], "mapped", [160714]],
      [[194988, 194988], "mapped", [34148]],
      [[194989, 194989], "mapped", [159532]],
      [[194990, 194990], "mapped", [17757]],
      [[194991, 194991], "mapped", [17761]],
      [[194992, 194992], "mapped", [159665]],
      [[194993, 194993], "mapped", [159954]],
      [[194994, 194994], "mapped", [17771]],
      [[194995, 194995], "mapped", [34384]],
      [[194996, 194996], "mapped", [34396]],
      [[194997, 194997], "mapped", [34407]],
      [[194998, 194998], "mapped", [34409]],
      [[194999, 194999], "mapped", [34473]],
      [[195e3, 195e3], "mapped", [34440]],
      [[195001, 195001], "mapped", [34574]],
      [[195002, 195002], "mapped", [34530]],
      [[195003, 195003], "mapped", [34681]],
      [[195004, 195004], "mapped", [34600]],
      [[195005, 195005], "mapped", [34667]],
      [[195006, 195006], "mapped", [34694]],
      [[195007, 195007], "disallowed"],
      [[195008, 195008], "mapped", [34785]],
      [[195009, 195009], "mapped", [34817]],
      [[195010, 195010], "mapped", [17913]],
      [[195011, 195011], "mapped", [34912]],
      [[195012, 195012], "mapped", [34915]],
      [[195013, 195013], "mapped", [161383]],
      [[195014, 195014], "mapped", [35031]],
      [[195015, 195015], "mapped", [35038]],
      [[195016, 195016], "mapped", [17973]],
      [[195017, 195017], "mapped", [35066]],
      [[195018, 195018], "mapped", [13499]],
      [[195019, 195019], "mapped", [161966]],
      [[195020, 195020], "mapped", [162150]],
      [[195021, 195021], "mapped", [18110]],
      [[195022, 195022], "mapped", [18119]],
      [[195023, 195023], "mapped", [35488]],
      [[195024, 195024], "mapped", [35565]],
      [[195025, 195025], "mapped", [35722]],
      [[195026, 195026], "mapped", [35925]],
      [[195027, 195027], "mapped", [162984]],
      [[195028, 195028], "mapped", [36011]],
      [[195029, 195029], "mapped", [36033]],
      [[195030, 195030], "mapped", [36123]],
      [[195031, 195031], "mapped", [36215]],
      [[195032, 195032], "mapped", [163631]],
      [[195033, 195033], "mapped", [133124]],
      [[195034, 195034], "mapped", [36299]],
      [[195035, 195035], "mapped", [36284]],
      [[195036, 195036], "mapped", [36336]],
      [[195037, 195037], "mapped", [133342]],
      [[195038, 195038], "mapped", [36564]],
      [[195039, 195039], "mapped", [36664]],
      [[195040, 195040], "mapped", [165330]],
      [[195041, 195041], "mapped", [165357]],
      [[195042, 195042], "mapped", [37012]],
      [[195043, 195043], "mapped", [37105]],
      [[195044, 195044], "mapped", [37137]],
      [[195045, 195045], "mapped", [165678]],
      [[195046, 195046], "mapped", [37147]],
      [[195047, 195047], "mapped", [37432]],
      [[195048, 195048], "mapped", [37591]],
      [[195049, 195049], "mapped", [37592]],
      [[195050, 195050], "mapped", [37500]],
      [[195051, 195051], "mapped", [37881]],
      [[195052, 195052], "mapped", [37909]],
      [[195053, 195053], "mapped", [166906]],
      [[195054, 195054], "mapped", [38283]],
      [[195055, 195055], "mapped", [18837]],
      [[195056, 195056], "mapped", [38327]],
      [[195057, 195057], "mapped", [167287]],
      [[195058, 195058], "mapped", [18918]],
      [[195059, 195059], "mapped", [38595]],
      [[195060, 195060], "mapped", [23986]],
      [[195061, 195061], "mapped", [38691]],
      [[195062, 195062], "mapped", [168261]],
      [[195063, 195063], "mapped", [168474]],
      [[195064, 195064], "mapped", [19054]],
      [[195065, 195065], "mapped", [19062]],
      [[195066, 195066], "mapped", [38880]],
      [[195067, 195067], "mapped", [168970]],
      [[195068, 195068], "mapped", [19122]],
      [[195069, 195069], "mapped", [169110]],
      [[195070, 195071], "mapped", [38923]],
      [[195072, 195072], "mapped", [38953]],
      [[195073, 195073], "mapped", [169398]],
      [[195074, 195074], "mapped", [39138]],
      [[195075, 195075], "mapped", [19251]],
      [[195076, 195076], "mapped", [39209]],
      [[195077, 195077], "mapped", [39335]],
      [[195078, 195078], "mapped", [39362]],
      [[195079, 195079], "mapped", [39422]],
      [[195080, 195080], "mapped", [19406]],
      [[195081, 195081], "mapped", [170800]],
      [[195082, 195082], "mapped", [39698]],
      [[195083, 195083], "mapped", [4e4]],
      [[195084, 195084], "mapped", [40189]],
      [[195085, 195085], "mapped", [19662]],
      [[195086, 195086], "mapped", [19693]],
      [[195087, 195087], "mapped", [40295]],
      [[195088, 195088], "mapped", [172238]],
      [[195089, 195089], "mapped", [19704]],
      [[195090, 195090], "mapped", [172293]],
      [[195091, 195091], "mapped", [172558]],
      [[195092, 195092], "mapped", [172689]],
      [[195093, 195093], "mapped", [40635]],
      [[195094, 195094], "mapped", [19798]],
      [[195095, 195095], "mapped", [40697]],
      [[195096, 195096], "mapped", [40702]],
      [[195097, 195097], "mapped", [40709]],
      [[195098, 195098], "mapped", [40719]],
      [[195099, 195099], "mapped", [40726]],
      [[195100, 195100], "mapped", [40763]],
      [[195101, 195101], "mapped", [173568]],
      [[195102, 196605], "disallowed"],
      [[196606, 196607], "disallowed"],
      [[196608, 262141], "disallowed"],
      [[262142, 262143], "disallowed"],
      [[262144, 327677], "disallowed"],
      [[327678, 327679], "disallowed"],
      [[327680, 393213], "disallowed"],
      [[393214, 393215], "disallowed"],
      [[393216, 458749], "disallowed"],
      [[458750, 458751], "disallowed"],
      [[458752, 524285], "disallowed"],
      [[524286, 524287], "disallowed"],
      [[524288, 589821], "disallowed"],
      [[589822, 589823], "disallowed"],
      [[589824, 655357], "disallowed"],
      [[655358, 655359], "disallowed"],
      [[655360, 720893], "disallowed"],
      [[720894, 720895], "disallowed"],
      [[720896, 786429], "disallowed"],
      [[786430, 786431], "disallowed"],
      [[786432, 851965], "disallowed"],
      [[851966, 851967], "disallowed"],
      [[851968, 917501], "disallowed"],
      [[917502, 917503], "disallowed"],
      [[917504, 917504], "disallowed"],
      [[917505, 917505], "disallowed"],
      [[917506, 917535], "disallowed"],
      [[917536, 917631], "disallowed"],
      [[917632, 917759], "disallowed"],
      [[917760, 917999], "ignored"],
      [[918e3, 983037], "disallowed"],
      [[983038, 983039], "disallowed"],
      [[983040, 1048573], "disallowed"],
      [[1048574, 1048575], "disallowed"],
      [[1048576, 1114109], "disallowed"],
      [[1114110, 1114111], "disallowed"],
    ];
  },
});
var require_tr46 = /* @__PURE__ */ __commonJS3({
  "../../../node_modules/tr46/index.js": (exports, module) => {
    var punycode$1 = __require2("punycode");
    var mappingTable = require_mappingTable();
    var PROCESSING_OPTIONS = {
      TRANSITIONAL: 0,
      NONTRANSITIONAL: 1,
    };
    function normalize(str) {
      return str
        .split("\0")
        .map(function (s2) {
          return s2.normalize("NFC");
        })
        .join("\0");
    }
    function findStatus(val) {
      var start = 0;
      var end = mappingTable.length - 1;
      while (start <= end) {
        var mid = Math.floor((start + end) / 2);
        var target = mappingTable[mid];
        if (target[0][0] <= val && target[0][1] >= val) return target;
        else if (target[0][0] > val) end = mid - 1;
        else start = mid + 1;
      }
      return null;
    }
    var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    function countSymbols$1(string5) {
      return string5.replace(regexAstralSymbols, "_").length;
    }
    function mapChars(domain_name, useSTD3, processing_option) {
      var hasError = false;
      var processed = "";
      var len = countSymbols$1(domain_name);
      for (var i2 = 0; i2 < len; ++i2) {
        var codePoint = domain_name.codePointAt(i2);
        var status = findStatus(codePoint);
        switch (status[1]) {
          case "disallowed":
            hasError = true;
            processed += String.fromCodePoint(codePoint);
            break;
          case "ignored":
            break;
          case "mapped":
            processed += String.fromCodePoint.apply(String, status[2]);
            break;
          case "deviation":
            if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL)
              processed += String.fromCodePoint.apply(String, status[2]);
            else processed += String.fromCodePoint(codePoint);
            break;
          case "valid":
            processed += String.fromCodePoint(codePoint);
            break;
          case "disallowed_STD3_mapped":
            if (useSTD3) {
              hasError = true;
              processed += String.fromCodePoint(codePoint);
            } else processed += String.fromCodePoint.apply(String, status[2]);
            break;
          case "disallowed_STD3_valid":
            if (useSTD3) hasError = true;
            processed += String.fromCodePoint(codePoint);
            break;
        }
      }
      return {
        string: processed,
        error: hasError,
      };
    }
    var combiningMarksRegex =
      /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
    function validateLabel(label, processing_option) {
      if (label.substr(0, 4) === "xn--") {
        label = punycode$1.toUnicode(label);
        processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;
      }
      var error45 = false;
      if (
        normalize(label) !== label ||
        (label[3] === "-" && label[4] === "-") ||
        label[0] === "-" ||
        label[label.length - 1] === "-" ||
        label.indexOf(".") !== -1 ||
        label.search(combiningMarksRegex) === 0
      )
        error45 = true;
      var len = countSymbols$1(label);
      for (var i2 = 0; i2 < len; ++i2) {
        var status = findStatus(label.codePointAt(i2));
        if (
          (processing === PROCESSING_OPTIONS.TRANSITIONAL &&
            status[1] !== "valid") ||
          (processing === PROCESSING_OPTIONS.NONTRANSITIONAL &&
            status[1] !== "valid" &&
            status[1] !== "deviation")
        ) {
          error45 = true;
          break;
        }
      }
      return {
        label,
        error: error45,
      };
    }
    function processing(domain_name, useSTD3, processing_option) {
      var result = mapChars(domain_name, useSTD3, processing_option);
      result.string = normalize(result.string);
      var labels = result.string.split(".");
      for (var i2 = 0; i2 < labels.length; ++i2)
        try {
          var validation = validateLabel(labels[i2]);
          labels[i2] = validation.label;
          result.error = result.error || validation.error;
        } catch (e2) {
          result.error = true;
        }
      return {
        string: labels.join("."),
        error: result.error,
      };
    }
    module.exports.toASCII = function (
      domain_name,
      useSTD3,
      processing_option,
      verifyDnsLength,
    ) {
      var result = processing(domain_name, useSTD3, processing_option);
      var labels = result.string.split(".");
      labels = labels.map(function (l2) {
        try {
          return punycode$1.toASCII(l2);
        } catch (e2) {
          result.error = true;
          return l2;
        }
      });
      if (verifyDnsLength) {
        var total = labels.slice(0, labels.length - 1).join(".").length;
        if (total.length > 253 || total.length === 0) result.error = true;
        for (var i2 = 0; i2 < labels.length; ++i2)
          if (labels.length > 63 || labels.length === 0) {
            result.error = true;
            break;
          }
      }
      if (result.error) return null;
      return labels.join(".");
    };
    module.exports.toUnicode = function (domain_name, useSTD3) {
      var result = processing(
        domain_name,
        useSTD3,
        PROCESSING_OPTIONS.NONTRANSITIONAL,
      );
      return {
        domain: result.string,
        error: result.error,
      };
    };
    module.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
  },
});
var require_url_state_machine = /* @__PURE__ */ __commonJS3({
  "../../../node_modules/whatwg-url/lib/url-state-machine.js": (
    exports,
    module,
  ) => {
    const punycode = __require2("punycode");
    const tr46 = require_tr46();
    const specialSchemes = {
      ftp: 21,
      file: null,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443,
    };
    const failure = Symbol("failure");
    function countSymbols(str) {
      return punycode.ucs2.decode(str).length;
    }
    function at(input, idx) {
      const c2 = input[idx];
      return isNaN(c2) ? void 0 : String.fromCodePoint(c2);
    }
    function isASCIIDigit(c2) {
      return c2 >= 48 && c2 <= 57;
    }
    function isASCIIAlpha(c2) {
      return (c2 >= 65 && c2 <= 90) || (c2 >= 97 && c2 <= 122);
    }
    function isASCIIAlphanumeric(c2) {
      return isASCIIAlpha(c2) || isASCIIDigit(c2);
    }
    function isASCIIHex(c2) {
      return (
        isASCIIDigit(c2) || (c2 >= 65 && c2 <= 70) || (c2 >= 97 && c2 <= 102)
      );
    }
    function isSingleDot(buffer) {
      return buffer === "." || buffer.toLowerCase() === "%2e";
    }
    function isDoubleDot(buffer) {
      buffer = buffer.toLowerCase();
      return (
        buffer === ".." ||
        buffer === "%2e." ||
        buffer === ".%2e" ||
        buffer === "%2e%2e"
      );
    }
    function isWindowsDriveLetterCodePoints(cp1, cp2) {
      return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
    }
    function isWindowsDriveLetterString(string5) {
      return (
        string5.length === 2 &&
        isASCIIAlpha(string5.codePointAt(0)) &&
        (string5[1] === ":" || string5[1] === "|")
      );
    }
    function isNormalizedWindowsDriveLetterString(string5) {
      return (
        string5.length === 2 &&
        isASCIIAlpha(string5.codePointAt(0)) &&
        string5[1] === ":"
      );
    }
    function containsForbiddenHostCodePoint(string5) {
      return (
        string5.search(
          /\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/,
        ) !== -1
      );
    }
    function containsForbiddenHostCodePointExcludingPercent(string5) {
      return (
        string5.search(
          /\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/,
        ) !== -1
      );
    }
    function isSpecialScheme(scheme) {
      return specialSchemes[scheme] !== void 0;
    }
    function isSpecial(url2) {
      return isSpecialScheme(url2.scheme);
    }
    function defaultPort(scheme) {
      return specialSchemes[scheme];
    }
    function percentEncode(c2) {
      let hex3 = c2.toString(16).toUpperCase();
      if (hex3.length === 1) hex3 = "0" + hex3;
      return "%" + hex3;
    }
    function utf8PercentEncode(c2) {
      const buf = new Buffer(c2);
      let str = "";
      for (let i2 = 0; i2 < buf.length; ++i2) str += percentEncode(buf[i2]);
      return str;
    }
    function utf8PercentDecode(str) {
      const input = new Buffer(str);
      const output = [];
      for (let i2 = 0; i2 < input.length; ++i2)
        if (input[i2] !== 37) output.push(input[i2]);
        else if (
          input[i2] === 37 &&
          isASCIIHex(input[i2 + 1]) &&
          isASCIIHex(input[i2 + 2])
        ) {
          output.push(parseInt(input.slice(i2 + 1, i2 + 3).toString(), 16));
          i2 += 2;
        } else output.push(input[i2]);
      return new Buffer(output).toString();
    }
    function isC0ControlPercentEncode(c2) {
      return c2 <= 31 || c2 > 126;
    }
    const extraPathPercentEncodeSet = /* @__PURE__ */ new Set([
      32, 34, 35, 60, 62, 63, 96, 123, 125,
    ]);
    function isPathPercentEncode(c2) {
      return isC0ControlPercentEncode(c2) || extraPathPercentEncodeSet.has(c2);
    }
    const extraUserinfoPercentEncodeSet = /* @__PURE__ */ new Set([
      47, 58, 59, 61, 64, 91, 92, 93, 94, 124,
    ]);
    function isUserinfoPercentEncode(c2) {
      return isPathPercentEncode(c2) || extraUserinfoPercentEncodeSet.has(c2);
    }
    function percentEncodeChar(c2, encodeSetPredicate) {
      const cStr = String.fromCodePoint(c2);
      if (encodeSetPredicate(c2)) return utf8PercentEncode(cStr);
      return cStr;
    }
    function parseIPv4Number(input) {
      let R = 10;
      if (
        input.length >= 2 &&
        input.charAt(0) === "0" &&
        input.charAt(1).toLowerCase() === "x"
      ) {
        input = input.substring(2);
        R = 16;
      } else if (input.length >= 2 && input.charAt(0) === "0") {
        input = input.substring(1);
        R = 8;
      }
      if (input === "") return 0;
      const regex = R === 10 ? /[^0-9]/ : R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/;
      if (regex.test(input)) return failure;
      return parseInt(input, R);
    }
    function parseIPv4(input) {
      const parts = input.split(".");
      if (parts[parts.length - 1] === "") {
        if (parts.length > 1) parts.pop();
      }
      if (parts.length > 4) return input;
      const numbers = [];
      for (const part of parts) {
        if (part === "") return input;
        const n = parseIPv4Number(part);
        if (n === failure) return input;
        numbers.push(n);
      }
      for (let i2 = 0; i2 < numbers.length - 1; ++i2)
        if (numbers[i2] > 255) return failure;
      if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length))
        return failure;
      let ipv44 = numbers.pop();
      let counter = 0;
      for (const n of numbers) {
        ipv44 += n * Math.pow(256, 3 - counter);
        ++counter;
      }
      return ipv44;
    }
    function serializeIPv4(address) {
      let output = "";
      let n = address;
      for (let i2 = 1; i2 <= 4; ++i2) {
        output = String(n % 256) + output;
        if (i2 !== 4) output = "." + output;
        n = Math.floor(n / 256);
      }
      return output;
    }
    function parseIPv6(input) {
      const address = [0, 0, 0, 0, 0, 0, 0, 0];
      let pieceIndex = 0;
      let compress = null;
      let pointer = 0;
      input = punycode.ucs2.decode(input);
      if (input[pointer] === 58) {
        if (input[pointer + 1] !== 58) return failure;
        pointer += 2;
        ++pieceIndex;
        compress = pieceIndex;
      }
      while (pointer < input.length) {
        if (pieceIndex === 8) return failure;
        if (input[pointer] === 58) {
          if (compress !== null) return failure;
          ++pointer;
          ++pieceIndex;
          compress = pieceIndex;
          continue;
        }
        let value = 0;
        let length = 0;
        while (length < 4 && isASCIIHex(input[pointer])) {
          value = value * 16 + parseInt(at(input, pointer), 16);
          ++pointer;
          ++length;
        }
        if (input[pointer] === 46) {
          if (length === 0) return failure;
          pointer -= length;
          if (pieceIndex > 6) return failure;
          let numbersSeen = 0;
          while (input[pointer] !== void 0) {
            let ipv4Piece = null;
            if (numbersSeen > 0)
              if (input[pointer] === 46 && numbersSeen < 4) ++pointer;
              else return failure;
            if (!isASCIIDigit(input[pointer])) return failure;
            while (isASCIIDigit(input[pointer])) {
              const number4 = parseInt(at(input, pointer));
              if (ipv4Piece === null) ipv4Piece = number4;
              else if (ipv4Piece === 0) return failure;
              else ipv4Piece = ipv4Piece * 10 + number4;
              if (ipv4Piece > 255) return failure;
              ++pointer;
            }
            address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
            ++numbersSeen;
            if (numbersSeen === 2 || numbersSeen === 4) ++pieceIndex;
          }
          if (numbersSeen !== 4) return failure;
          break;
        } else if (input[pointer] === 58) {
          ++pointer;
          if (input[pointer] === void 0) return failure;
        } else if (input[pointer] !== void 0) return failure;
        address[pieceIndex] = value;
        ++pieceIndex;
      }
      if (compress !== null) {
        let swaps = pieceIndex - compress;
        pieceIndex = 7;
        while (pieceIndex !== 0 && swaps > 0) {
          const temp = address[compress + swaps - 1];
          address[compress + swaps - 1] = address[pieceIndex];
          address[pieceIndex] = temp;
          --pieceIndex;
          --swaps;
        }
      } else if (compress === null && pieceIndex !== 8) return failure;
      return address;
    }
    function serializeIPv6(address) {
      let output = "";
      const seqResult = findLongestZeroSequence(address);
      const compress = seqResult.idx;
      let ignore0 = false;
      for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
        if (ignore0 && address[pieceIndex] === 0) continue;
        else if (ignore0) ignore0 = false;
        if (compress === pieceIndex) {
          const separator = pieceIndex === 0 ? "::" : ":";
          output += separator;
          ignore0 = true;
          continue;
        }
        output += address[pieceIndex].toString(16);
        if (pieceIndex !== 7) output += ":";
      }
      return output;
    }
    function parseHost(input, isSpecialArg) {
      if (input[0] === "[") {
        if (input[input.length - 1] !== "]") return failure;
        return parseIPv6(input.substring(1, input.length - 1));
      }
      if (!isSpecialArg) return parseOpaqueHost(input);
      const domain2 = utf8PercentDecode(input);
      const asciiDomain = tr46.toASCII(
        domain2,
        false,
        tr46.PROCESSING_OPTIONS.NONTRANSITIONAL,
        false,
      );
      if (asciiDomain === null) return failure;
      if (containsForbiddenHostCodePoint(asciiDomain)) return failure;
      const ipv4Host = parseIPv4(asciiDomain);
      if (typeof ipv4Host === "number" || ipv4Host === failure) return ipv4Host;
      return asciiDomain;
    }
    function parseOpaqueHost(input) {
      if (containsForbiddenHostCodePointExcludingPercent(input)) return failure;
      let output = "";
      const decoded = punycode.ucs2.decode(input);
      for (let i2 = 0; i2 < decoded.length; ++i2)
        output += percentEncodeChar(decoded[i2], isC0ControlPercentEncode);
      return output;
    }
    function findLongestZeroSequence(arr) {
      let maxIdx = null;
      let maxLen = 1;
      let currStart = null;
      let currLen = 0;
      for (let i2 = 0; i2 < arr.length; ++i2)
        if (arr[i2] !== 0) {
          if (currLen > maxLen) {
            maxIdx = currStart;
            maxLen = currLen;
          }
          currStart = null;
          currLen = 0;
        } else {
          if (currStart === null) currStart = i2;
          ++currLen;
        }
      if (currLen > maxLen) {
        maxIdx = currStart;
        maxLen = currLen;
      }
      return {
        idx: maxIdx,
        len: maxLen,
      };
    }
    function serializeHost(host) {
      if (typeof host === "number") return serializeIPv4(host);
      if (host instanceof Array) return "[" + serializeIPv6(host) + "]";
      return host;
    }
    function trimControlChars(url2) {
      return url2.replace(
        /^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g,
        "",
      );
    }
    function trimTabAndNewline(url2) {
      return url2.replace(/\u0009|\u000A|\u000D/g, "");
    }
    function shortenPath(url2) {
      const path = url2.path;
      if (path.length === 0) return;
      if (
        url2.scheme === "file" &&
        path.length === 1 &&
        isNormalizedWindowsDriveLetter(path[0])
      )
        return;
      path.pop();
    }
    function includesCredentials(url2) {
      return url2.username !== "" || url2.password !== "";
    }
    function cannotHaveAUsernamePasswordPort(url2) {
      return (
        url2.host === null ||
        url2.host === "" ||
        url2.cannotBeABaseURL ||
        url2.scheme === "file"
      );
    }
    function isNormalizedWindowsDriveLetter(string5) {
      return /^[A-Za-z]:$/.test(string5);
    }
    function URLStateMachine(
      input,
      base,
      encodingOverride,
      url2,
      stateOverride,
    ) {
      this.pointer = 0;
      this.input = input;
      this.base = base || null;
      this.encodingOverride = encodingOverride || "utf-8";
      this.stateOverride = stateOverride;
      this.url = url2;
      this.failure = false;
      this.parseError = false;
      if (!this.url) {
        this.url = {
          scheme: "",
          username: "",
          password: "",
          host: null,
          port: null,
          path: [],
          query: null,
          fragment: null,
          cannotBeABaseURL: false,
        };
        const res$1 = trimControlChars(this.input);
        if (res$1 !== this.input) this.parseError = true;
        this.input = res$1;
      }
      const res = trimTabAndNewline(this.input);
      if (res !== this.input) this.parseError = true;
      this.input = res;
      this.state = stateOverride || "scheme start";
      this.buffer = "";
      this.atFlag = false;
      this.arrFlag = false;
      this.passwordTokenSeenFlag = false;
      this.input = punycode.ucs2.decode(this.input);
      for (; this.pointer <= this.input.length; ++this.pointer) {
        const c2 = this.input[this.pointer];
        const cStr = isNaN(c2) ? void 0 : String.fromCodePoint(c2);
        const ret = this["parse " + this.state](c2, cStr);
        if (!ret) break;
        else if (ret === failure) {
          this.failure = true;
          break;
        }
      }
    }
    URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(
      c2,
      cStr,
    ) {
      if (isASCIIAlpha(c2)) {
        this.buffer += cStr.toLowerCase();
        this.state = "scheme";
      } else if (!this.stateOverride) {
        this.state = "no scheme";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse scheme"] = function parseScheme(c2, cStr) {
      if (isASCIIAlphanumeric(c2) || c2 === 43 || c2 === 45 || c2 === 46)
        this.buffer += cStr.toLowerCase();
      else if (c2 === 58) {
        if (this.stateOverride) {
          if (isSpecial(this.url) && !isSpecialScheme(this.buffer))
            return false;
          if (!isSpecial(this.url) && isSpecialScheme(this.buffer))
            return false;
          if (
            (includesCredentials(this.url) || this.url.port !== null) &&
            this.buffer === "file"
          )
            return false;
          if (
            this.url.scheme === "file" &&
            (this.url.host === "" || this.url.host === null)
          )
            return false;
        }
        this.url.scheme = this.buffer;
        this.buffer = "";
        if (this.stateOverride) return false;
        if (this.url.scheme === "file") {
          if (
            this.input[this.pointer + 1] !== 47 ||
            this.input[this.pointer + 2] !== 47
          )
            this.parseError = true;
          this.state = "file";
        } else if (
          isSpecial(this.url) &&
          this.base !== null &&
          this.base.scheme === this.url.scheme
        )
          this.state = "special relative or authority";
        else if (isSpecial(this.url)) this.state = "special authority slashes";
        else if (this.input[this.pointer + 1] === 47) {
          this.state = "path or authority";
          ++this.pointer;
        } else {
          this.url.cannotBeABaseURL = true;
          this.url.path.push("");
          this.state = "cannot-be-a-base-URL path";
        }
      } else if (!this.stateOverride) {
        this.buffer = "";
        this.state = "no scheme";
        this.pointer = -1;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c2) {
      if (this.base === null || (this.base.cannotBeABaseURL && c2 !== 35))
        return failure;
      else if (this.base.cannotBeABaseURL && c2 === 35) {
        this.url.scheme = this.base.scheme;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.url.cannotBeABaseURL = true;
        this.state = "fragment";
      } else if (this.base.scheme === "file") {
        this.state = "file";
        --this.pointer;
      } else {
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special relative or authority"] =
      function parseSpecialRelativeOrAuthority(c2) {
        if (c2 === 47 && this.input[this.pointer + 1] === 47) {
          this.state = "special authority ignore slashes";
          ++this.pointer;
        } else {
          this.parseError = true;
          this.state = "relative";
          --this.pointer;
        }
        return true;
      };
    URLStateMachine.prototype["parse path or authority"] =
      function parsePathOrAuthority(c2) {
        if (c2 === 47) this.state = "authority";
        else {
          this.state = "path";
          --this.pointer;
        }
        return true;
      };
    URLStateMachine.prototype["parse relative"] = function parseRelative(c2) {
      this.url.scheme = this.base.scheme;
      if (isNaN(c2)) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
      } else if (c2 === 47) this.state = "relative slash";
      else if (c2 === 63) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = "";
        this.state = "query";
      } else if (c2 === 35) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.state = "fragment";
      } else if (isSpecial(this.url) && c2 === 92) {
        this.parseError = true;
        this.state = "relative slash";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice(0, this.base.path.length - 1);
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative slash"] =
      function parseRelativeSlash(c2) {
        if (isSpecial(this.url) && (c2 === 47 || c2 === 92)) {
          if (c2 === 92) this.parseError = true;
          this.state = "special authority ignore slashes";
        } else if (c2 === 47) this.state = "authority";
        else {
          this.url.username = this.base.username;
          this.url.password = this.base.password;
          this.url.host = this.base.host;
          this.url.port = this.base.port;
          this.state = "path";
          --this.pointer;
        }
        return true;
      };
    URLStateMachine.prototype["parse special authority slashes"] =
      function parseSpecialAuthoritySlashes(c2) {
        if (c2 === 47 && this.input[this.pointer + 1] === 47) {
          this.state = "special authority ignore slashes";
          ++this.pointer;
        } else {
          this.parseError = true;
          this.state = "special authority ignore slashes";
          --this.pointer;
        }
        return true;
      };
    URLStateMachine.prototype["parse special authority ignore slashes"] =
      function parseSpecialAuthorityIgnoreSlashes(c2) {
        if (c2 !== 47 && c2 !== 92) {
          this.state = "authority";
          --this.pointer;
        } else this.parseError = true;
        return true;
      };
    URLStateMachine.prototype["parse authority"] = function parseAuthority(
      c2,
      cStr,
    ) {
      if (c2 === 64) {
        this.parseError = true;
        if (this.atFlag) this.buffer = "%40" + this.buffer;
        this.atFlag = true;
        const len = countSymbols(this.buffer);
        for (let pointer = 0; pointer < len; ++pointer) {
          const codePoint = this.buffer.codePointAt(pointer);
          if (codePoint === 58 && !this.passwordTokenSeenFlag) {
            this.passwordTokenSeenFlag = true;
            continue;
          }
          const encodedCodePoints = percentEncodeChar(
            codePoint,
            isUserinfoPercentEncode,
          );
          if (this.passwordTokenSeenFlag)
            this.url.password += encodedCodePoints;
          else this.url.username += encodedCodePoints;
        }
        this.buffer = "";
      } else if (
        isNaN(c2) ||
        c2 === 47 ||
        c2 === 63 ||
        c2 === 35 ||
        (isSpecial(this.url) && c2 === 92)
      ) {
        if (this.atFlag && this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        this.pointer -= countSymbols(this.buffer) + 1;
        this.buffer = "";
        this.state = "host";
      } else this.buffer += cStr;
      return true;
    };
    URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype[
      "parse host"
    ] = function parseHostName(c2, cStr) {
      if (this.stateOverride && this.url.scheme === "file") {
        --this.pointer;
        this.state = "file host";
      } else if (c2 === 58 && !this.arrFlag) {
        if (this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) return failure;
        this.url.host = host;
        this.buffer = "";
        this.state = "port";
        if (this.stateOverride === "hostname") return false;
      } else if (
        isNaN(c2) ||
        c2 === 47 ||
        c2 === 63 ||
        c2 === 35 ||
        (isSpecial(this.url) && c2 === 92)
      ) {
        --this.pointer;
        if (isSpecial(this.url) && this.buffer === "") {
          this.parseError = true;
          return failure;
        } else if (
          this.stateOverride &&
          this.buffer === "" &&
          (includesCredentials(this.url) || this.url.port !== null)
        ) {
          this.parseError = true;
          return false;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) return failure;
        this.url.host = host;
        this.buffer = "";
        this.state = "path start";
        if (this.stateOverride) return false;
      } else {
        if (c2 === 91) this.arrFlag = true;
        else if (c2 === 93) this.arrFlag = false;
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse port"] = function parsePort(c2, cStr) {
      if (isASCIIDigit(c2)) this.buffer += cStr;
      else if (
        isNaN(c2) ||
        c2 === 47 ||
        c2 === 63 ||
        c2 === 35 ||
        (isSpecial(this.url) && c2 === 92) ||
        this.stateOverride
      ) {
        if (this.buffer !== "") {
          const port = parseInt(this.buffer);
          if (port > Math.pow(2, 16) - 1) {
            this.parseError = true;
            return failure;
          }
          this.url.port = port === defaultPort(this.url.scheme) ? null : port;
          this.buffer = "";
        }
        if (this.stateOverride) return false;
        this.state = "path start";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    const fileOtherwiseCodePoints = /* @__PURE__ */ new Set([47, 92, 63, 35]);
    URLStateMachine.prototype["parse file"] = function parseFile(c2) {
      this.url.scheme = "file";
      if (c2 === 47 || c2 === 92) {
        if (c2 === 92) this.parseError = true;
        this.state = "file slash";
      } else if (this.base !== null && this.base.scheme === "file")
        if (isNaN(c2)) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
        } else if (c2 === 63) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = "";
          this.state = "query";
        } else if (c2 === 35) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
          this.url.fragment = "";
          this.state = "fragment";
        } else {
          if (
            this.input.length - this.pointer - 1 === 0 ||
            !isWindowsDriveLetterCodePoints(c2, this.input[this.pointer + 1]) ||
            (this.input.length - this.pointer - 1 >= 2 &&
              !fileOtherwiseCodePoints.has(this.input[this.pointer + 2]))
          ) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            shortenPath(this.url);
          } else this.parseError = true;
          this.state = "path";
          --this.pointer;
        }
      else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file slash"] = function parseFileSlash(
      c2,
    ) {
      if (c2 === 47 || c2 === 92) {
        if (c2 === 92) this.parseError = true;
        this.state = "file host";
      } else {
        if (this.base !== null && this.base.scheme === "file")
          if (isNormalizedWindowsDriveLetterString(this.base.path[0]))
            this.url.path.push(this.base.path[0]);
          else this.url.host = this.base.host;
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file host"] = function parseFileHost(
      c2,
      cStr,
    ) {
      if (isNaN(c2) || c2 === 47 || c2 === 92 || c2 === 63 || c2 === 35) {
        --this.pointer;
        if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
          this.parseError = true;
          this.state = "path";
        } else if (this.buffer === "") {
          this.url.host = "";
          if (this.stateOverride) return false;
          this.state = "path start";
        } else {
          let host = parseHost(this.buffer, isSpecial(this.url));
          if (host === failure) return failure;
          if (host === "localhost") host = "";
          this.url.host = host;
          if (this.stateOverride) return false;
          this.buffer = "";
          this.state = "path start";
        }
      } else this.buffer += cStr;
      return true;
    };
    URLStateMachine.prototype["parse path start"] = function parsePathStart(
      c2,
    ) {
      if (isSpecial(this.url)) {
        if (c2 === 92) this.parseError = true;
        this.state = "path";
        if (c2 !== 47 && c2 !== 92) --this.pointer;
      } else if (!this.stateOverride && c2 === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (!this.stateOverride && c2 === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (c2 !== void 0) {
        this.state = "path";
        if (c2 !== 47) --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse path"] = function parsePath(c2) {
      if (
        isNaN(c2) ||
        c2 === 47 ||
        (isSpecial(this.url) && c2 === 92) ||
        (!this.stateOverride && (c2 === 63 || c2 === 35))
      ) {
        if (isSpecial(this.url) && c2 === 92) this.parseError = true;
        if (isDoubleDot(this.buffer)) {
          shortenPath(this.url);
          if (c2 !== 47 && !(isSpecial(this.url) && c2 === 92))
            this.url.path.push("");
        } else if (
          isSingleDot(this.buffer) &&
          c2 !== 47 &&
          !(isSpecial(this.url) && c2 === 92)
        )
          this.url.path.push("");
        else if (!isSingleDot(this.buffer)) {
          if (
            this.url.scheme === "file" &&
            this.url.path.length === 0 &&
            isWindowsDriveLetterString(this.buffer)
          ) {
            if (this.url.host !== "" && this.url.host !== null) {
              this.parseError = true;
              this.url.host = "";
            }
            this.buffer = this.buffer[0] + ":";
          }
          this.url.path.push(this.buffer);
        }
        this.buffer = "";
        if (
          this.url.scheme === "file" &&
          (c2 === void 0 || c2 === 63 || c2 === 35)
        )
          while (this.url.path.length > 1 && this.url.path[0] === "") {
            this.parseError = true;
            this.url.path.shift();
          }
        if (c2 === 63) {
          this.url.query = "";
          this.state = "query";
        }
        if (c2 === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (
          c2 === 37 &&
          (!isASCIIHex(this.input[this.pointer + 1]) ||
            !isASCIIHex(this.input[this.pointer + 2]))
        )
          this.parseError = true;
        this.buffer += percentEncodeChar(c2, isPathPercentEncode);
      }
      return true;
    };
    URLStateMachine.prototype["parse cannot-be-a-base-URL path"] =
      function parseCannotBeABaseURLPath(c2) {
        if (c2 === 63) {
          this.url.query = "";
          this.state = "query";
        } else if (c2 === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        } else {
          if (!isNaN(c2) && c2 !== 37) this.parseError = true;
          if (
            c2 === 37 &&
            (!isASCIIHex(this.input[this.pointer + 1]) ||
              !isASCIIHex(this.input[this.pointer + 2]))
          )
            this.parseError = true;
          if (!isNaN(c2))
            this.url.path[0] =
              this.url.path[0] +
              percentEncodeChar(c2, isC0ControlPercentEncode);
        }
        return true;
      };
    URLStateMachine.prototype["parse query"] = function parseQuery(c2, cStr) {
      if (isNaN(c2) || (!this.stateOverride && c2 === 35)) {
        if (
          !isSpecial(this.url) ||
          this.url.scheme === "ws" ||
          this.url.scheme === "wss"
        )
          this.encodingOverride = "utf-8";
        const buffer = new Buffer(this.buffer);
        for (let i2 = 0; i2 < buffer.length; ++i2)
          if (
            buffer[i2] < 33 ||
            buffer[i2] > 126 ||
            buffer[i2] === 34 ||
            buffer[i2] === 35 ||
            buffer[i2] === 60 ||
            buffer[i2] === 62
          )
            this.url.query += percentEncode(buffer[i2]);
          else this.url.query += String.fromCodePoint(buffer[i2]);
        this.buffer = "";
        if (c2 === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (
          c2 === 37 &&
          (!isASCIIHex(this.input[this.pointer + 1]) ||
            !isASCIIHex(this.input[this.pointer + 2]))
        )
          this.parseError = true;
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse fragment"] = function parseFragment(c2) {
      if (isNaN(c2)) {
      } else if (c2 === 0) this.parseError = true;
      else {
        if (
          c2 === 37 &&
          (!isASCIIHex(this.input[this.pointer + 1]) ||
            !isASCIIHex(this.input[this.pointer + 2]))
        )
          this.parseError = true;
        this.url.fragment += percentEncodeChar(c2, isC0ControlPercentEncode);
      }
      return true;
    };
    function serializeURL(url2, excludeFragment) {
      let output = url2.scheme + ":";
      if (url2.host !== null) {
        output += "//";
        if (url2.username !== "" || url2.password !== "") {
          output += url2.username;
          if (url2.password !== "") output += ":" + url2.password;
          output += "@";
        }
        output += serializeHost(url2.host);
        if (url2.port !== null) output += ":" + url2.port;
      } else if (url2.host === null && url2.scheme === "file") output += "//";
      if (url2.cannotBeABaseURL) output += url2.path[0];
      else for (const string5 of url2.path) output += "/" + string5;
      if (url2.query !== null) output += "?" + url2.query;
      if (!excludeFragment && url2.fragment !== null)
        output += "#" + url2.fragment;
      return output;
    }
    function serializeOrigin(tuple2) {
      let result = tuple2.scheme + "://";
      result += serializeHost(tuple2.host);
      if (tuple2.port !== null) result += ":" + tuple2.port;
      return result;
    }
    module.exports.serializeURL = serializeURL;
    module.exports.serializeURLOrigin = function (url2) {
      switch (url2.scheme) {
        case "blob":
          try {
            return module.exports.serializeURLOrigin(
              module.exports.parseURL(url2.path[0]),
            );
          } catch (e2) {
            return "null";
          }
        case "ftp":
        case "gopher":
        case "http":
        case "https":
        case "ws":
        case "wss":
          return serializeOrigin({
            scheme: url2.scheme,
            host: url2.host,
            port: url2.port,
          });
        case "file":
          return "file://";
        default:
          return "null";
      }
    };
    module.exports.basicURLParse = function (input, options) {
      if (options === void 0) options = {};
      const usm$1 = new URLStateMachine(
        input,
        options.baseURL,
        options.encodingOverride,
        options.url,
        options.stateOverride,
      );
      if (usm$1.failure) return "failure";
      return usm$1.url;
    };
    module.exports.setTheUsername = function (url2, username) {
      url2.username = "";
      const decoded = punycode.ucs2.decode(username);
      for (let i2 = 0; i2 < decoded.length; ++i2)
        url2.username += percentEncodeChar(
          decoded[i2],
          isUserinfoPercentEncode,
        );
    };
    module.exports.setThePassword = function (url2, password) {
      url2.password = "";
      const decoded = punycode.ucs2.decode(password);
      for (let i2 = 0; i2 < decoded.length; ++i2)
        url2.password += percentEncodeChar(
          decoded[i2],
          isUserinfoPercentEncode,
        );
    };
    module.exports.serializeHost = serializeHost;
    module.exports.cannotHaveAUsernamePasswordPort =
      cannotHaveAUsernamePasswordPort;
    module.exports.serializeInteger = function (integer2) {
      return String(integer2);
    };
    module.exports.parseURL = function (input, options) {
      if (options === void 0) options = {};
      return module.exports.basicURLParse(input, {
        baseURL: options.baseURL,
        encodingOverride: options.encodingOverride,
      });
    };
  },
});
var require_URL_impl = /* @__PURE__ */ __commonJS3({
  "../../../node_modules/whatwg-url/lib/URL-impl.js": (exports) => {
    const usm = require_url_state_machine();
    exports.implementation = class URLImpl {
      constructor(constructorArgs) {
        const url2 = constructorArgs[0];
        const base = constructorArgs[1];
        let parsedBase = null;
        if (base !== void 0) {
          parsedBase = usm.basicURLParse(base);
          if (parsedBase === "failure") throw new TypeError("Invalid base URL");
        }
        const parsedURL = usm.basicURLParse(url2, { baseURL: parsedBase });
        if (parsedURL === "failure") throw new TypeError("Invalid URL");
        this._url = parsedURL;
      }
      get href() {
        return usm.serializeURL(this._url);
      }
      set href(v2) {
        const parsedURL = usm.basicURLParse(v2);
        if (parsedURL === "failure") throw new TypeError("Invalid URL");
        this._url = parsedURL;
      }
      get origin() {
        return usm.serializeURLOrigin(this._url);
      }
      get protocol() {
        return this._url.scheme + ":";
      }
      set protocol(v2) {
        usm.basicURLParse(v2 + ":", {
          url: this._url,
          stateOverride: "scheme start",
        });
      }
      get username() {
        return this._url.username;
      }
      set username(v2) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) return;
        usm.setTheUsername(this._url, v2);
      }
      get password() {
        return this._url.password;
      }
      set password(v2) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) return;
        usm.setThePassword(this._url, v2);
      }
      get host() {
        const url2 = this._url;
        if (url2.host === null) return "";
        if (url2.port === null) return usm.serializeHost(url2.host);
        return (
          usm.serializeHost(url2.host) + ":" + usm.serializeInteger(url2.port)
        );
      }
      set host(v2) {
        if (this._url.cannotBeABaseURL) return;
        usm.basicURLParse(v2, {
          url: this._url,
          stateOverride: "host",
        });
      }
      get hostname() {
        if (this._url.host === null) return "";
        return usm.serializeHost(this._url.host);
      }
      set hostname(v2) {
        if (this._url.cannotBeABaseURL) return;
        usm.basicURLParse(v2, {
          url: this._url,
          stateOverride: "hostname",
        });
      }
      get port() {
        if (this._url.port === null) return "";
        return usm.serializeInteger(this._url.port);
      }
      set port(v2) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) return;
        if (v2 === "") this._url.port = null;
        else
          usm.basicURLParse(v2, {
            url: this._url,
            stateOverride: "port",
          });
      }
      get pathname() {
        if (this._url.cannotBeABaseURL) return this._url.path[0];
        if (this._url.path.length === 0) return "";
        return "/" + this._url.path.join("/");
      }
      set pathname(v2) {
        if (this._url.cannotBeABaseURL) return;
        this._url.path = [];
        usm.basicURLParse(v2, {
          url: this._url,
          stateOverride: "path start",
        });
      }
      get search() {
        if (this._url.query === null || this._url.query === "") return "";
        return "?" + this._url.query;
      }
      set search(v2) {
        const url2 = this._url;
        if (v2 === "") {
          url2.query = null;
          return;
        }
        const input = v2[0] === "?" ? v2.substring(1) : v2;
        url2.query = "";
        usm.basicURLParse(input, {
          url: url2,
          stateOverride: "query",
        });
      }
      get hash() {
        if (this._url.fragment === null || this._url.fragment === "") return "";
        return "#" + this._url.fragment;
      }
      set hash(v2) {
        if (v2 === "") {
          this._url.fragment = null;
          return;
        }
        const input = v2[0] === "#" ? v2.substring(1) : v2;
        this._url.fragment = "";
        usm.basicURLParse(input, {
          url: this._url,
          stateOverride: "fragment",
        });
      }
      toJSON() {
        return this.href;
      }
    };
  },
});
var require_URL = /* @__PURE__ */ __commonJS3({
  "../../../node_modules/whatwg-url/lib/URL.js": (exports, module) => {
    const conversions = require_lib$1();
    const utils = require_utils();
    const Impl = require_URL_impl();
    const impl = utils.implSymbol;
    function URL$2(url2) {
      if (!this || this[impl] || !(this instanceof URL$2))
        throw new TypeError(
          "Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.",
        );
      if (arguments.length < 1)
        throw new TypeError(
          "Failed to construct 'URL': 1 argument required, but only " +
            arguments.length +
            " present.",
        );
      const args = [];
      for (let i2 = 0; i2 < arguments.length && i2 < 2; ++i2)
        args[i2] = arguments[i2];
      args[0] = conversions["USVString"](args[0]);
      if (args[1] !== void 0) args[1] = conversions["USVString"](args[1]);
      module.exports.setup(this, args);
    }
    URL$2.prototype.toJSON = function toJSON() {
      if (!this || !module.exports.is(this))
        throw new TypeError("Illegal invocation");
      const args = [];
      for (let i2 = 0; i2 < arguments.length && i2 < 0; ++i2)
        args[i2] = arguments[i2];
      return this[impl].toJSON.apply(this[impl], args);
    };
    Object.defineProperty(URL$2.prototype, "href", {
      get() {
        return this[impl].href;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].href = V;
      },
      enumerable: true,
      configurable: true,
    });
    URL$2.prototype.toString = function () {
      if (!this || !module.exports.is(this))
        throw new TypeError("Illegal invocation");
      return this.href;
    };
    Object.defineProperty(URL$2.prototype, "origin", {
      get() {
        return this[impl].origin;
      },
      enumerable: true,
      configurable: true,
    });
    Object.defineProperty(URL$2.prototype, "protocol", {
      get() {
        return this[impl].protocol;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].protocol = V;
      },
      enumerable: true,
      configurable: true,
    });
    Object.defineProperty(URL$2.prototype, "username", {
      get() {
        return this[impl].username;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].username = V;
      },
      enumerable: true,
      configurable: true,
    });
    Object.defineProperty(URL$2.prototype, "password", {
      get() {
        return this[impl].password;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].password = V;
      },
      enumerable: true,
      configurable: true,
    });
    Object.defineProperty(URL$2.prototype, "host", {
      get() {
        return this[impl].host;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].host = V;
      },
      enumerable: true,
      configurable: true,
    });
    Object.defineProperty(URL$2.prototype, "hostname", {
      get() {
        return this[impl].hostname;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].hostname = V;
      },
      enumerable: true,
      configurable: true,
    });
    Object.defineProperty(URL$2.prototype, "port", {
      get() {
        return this[impl].port;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].port = V;
      },
      enumerable: true,
      configurable: true,
    });
    Object.defineProperty(URL$2.prototype, "pathname", {
      get() {
        return this[impl].pathname;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].pathname = V;
      },
      enumerable: true,
      configurable: true,
    });
    Object.defineProperty(URL$2.prototype, "search", {
      get() {
        return this[impl].search;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].search = V;
      },
      enumerable: true,
      configurable: true,
    });
    Object.defineProperty(URL$2.prototype, "hash", {
      get() {
        return this[impl].hash;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].hash = V;
      },
      enumerable: true,
      configurable: true,
    });
    module.exports = {
      is(obj) {
        return !!obj && obj[impl] instanceof Impl.implementation;
      },
      create(constructorArgs, privateData) {
        let obj = Object.create(URL$2.prototype);
        this.setup(obj, constructorArgs, privateData);
        return obj;
      },
      setup(obj, constructorArgs, privateData) {
        if (!privateData) privateData = {};
        privateData.wrapper = obj;
        obj[impl] = new Impl.implementation(constructorArgs, privateData);
        obj[impl][utils.wrapperSymbol] = obj;
      },
      interface: URL$2,
      expose: {
        Window: { URL: URL$2 },
        Worker: { URL: URL$2 },
      },
    };
  },
});
var require_public_api = /* @__PURE__ */ __commonJS3({
  "../../../node_modules/whatwg-url/lib/public-api.js": (exports) => {
    exports.URL = require_URL().interface;
    exports.serializeURL = require_url_state_machine().serializeURL;
    exports.serializeURLOrigin = require_url_state_machine().serializeURLOrigin;
    exports.basicURLParse = require_url_state_machine().basicURLParse;
    exports.setTheUsername = require_url_state_machine().setTheUsername;
    exports.setThePassword = require_url_state_machine().setThePassword;
    exports.serializeHost = require_url_state_machine().serializeHost;
    exports.serializeInteger = require_url_state_machine().serializeInteger;
    exports.parseURL = require_url_state_machine().parseURL;
  },
});
var require_lib8 = /* @__PURE__ */ __commonJS3({
  "../../../node_modules/node-fetch/lib/index.js": (exports, module) => {
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex
        ? ex["default"]
        : ex;
    }
    var Stream = _interopDefault(__require2("stream"));
    var http = _interopDefault(__require2("http"));
    var Url = _interopDefault(__require2("url"));
    var whatwgUrl = _interopDefault(require_public_api());
    var https = _interopDefault(__require2("https"));
    var zlib = _interopDefault(__require2("zlib"));
    const Readable = Stream.Readable;
    const BUFFER = Symbol("buffer");
    const TYPE = Symbol("type");
    var Blob2 = class Blob3 {
      constructor() {
        this[TYPE] = "";
        const blobParts = arguments[0];
        const options = arguments[1];
        const buffers = [];
        let size = 0;
        if (blobParts) {
          const a2 = blobParts;
          const length = Number(a2.length);
          for (let i2 = 0; i2 < length; i2++) {
            const element = a2[i2];
            let buffer;
            if (element instanceof Buffer) buffer = element;
            else if (ArrayBuffer.isView(element))
              buffer = Buffer.from(
                element.buffer,
                element.byteOffset,
                element.byteLength,
              );
            else if (element instanceof ArrayBuffer)
              buffer = Buffer.from(element);
            else if (element instanceof Blob3) buffer = element[BUFFER];
            else
              buffer = Buffer.from(
                typeof element === "string" ? element : String(element),
              );
            size += buffer.length;
            buffers.push(buffer);
          }
        }
        this[BUFFER] = Buffer.concat(buffers);
        let type =
          options &&
          options.type !== void 0 &&
          String(options.type).toLowerCase();
        if (type && !/[^\u0020-\u007E]/.test(type)) this[TYPE] = type;
      }
      get size() {
        return this[BUFFER].length;
      }
      get type() {
        return this[TYPE];
      }
      text() {
        return Promise.resolve(this[BUFFER].toString());
      }
      arrayBuffer() {
        const buf = this[BUFFER];
        const ab = buf.buffer.slice(
          buf.byteOffset,
          buf.byteOffset + buf.byteLength,
        );
        return Promise.resolve(ab);
      }
      stream() {
        const readable = new Readable();
        readable._read = function () {};
        readable.push(this[BUFFER]);
        readable.push(null);
        return readable;
      }
      toString() {
        return "[object Blob]";
      }
      slice() {
        const size = this.size;
        const start = arguments[0];
        const end = arguments[1];
        let relativeStart, relativeEnd;
        if (start === void 0) relativeStart = 0;
        else if (start < 0) relativeStart = Math.max(size + start, 0);
        else relativeStart = Math.min(start, size);
        if (end === void 0) relativeEnd = size;
        else if (end < 0) relativeEnd = Math.max(size + end, 0);
        else relativeEnd = Math.min(end, size);
        const span = Math.max(relativeEnd - relativeStart, 0);
        const buffer = this[BUFFER];
        const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
        const blob = new Blob3([], { type: arguments[2] });
        blob[BUFFER] = slicedBuffer;
        return blob;
      }
    };
    Object.defineProperties(Blob2.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true },
    });
    Object.defineProperty(Blob2.prototype, Symbol.toStringTag, {
      value: "Blob",
      writable: false,
      enumerable: false,
      configurable: true,
    });
    function FetchError(message, type, systemError) {
      Error.call(this, message);
      this.message = message;
      this.type = type;
      if (systemError) this.code = this.errno = systemError.code;
      Error.captureStackTrace(this, this.constructor);
    }
    FetchError.prototype = Object.create(Error.prototype);
    FetchError.prototype.constructor = FetchError;
    FetchError.prototype.name = "FetchError";
    let convert;
    try {
      convert = __require2("encoding").convert;
    } catch (e2) {}
    const INTERNALS = Symbol("Body internals");
    const PassThrough = Stream.PassThrough;
    function Body(body) {
      var _this = this;
      var _ref =
          arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        _ref$size = _ref.size;
      let size = _ref$size === void 0 ? 0 : _ref$size;
      var _ref$timeout = _ref.timeout;
      let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
      if (body == null) body = null;
      else if (isURLSearchParams(body)) body = Buffer.from(body.toString());
      else if (isBlob(body));
      else if (Buffer.isBuffer(body));
      else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]")
        body = Buffer.from(body);
      else if (ArrayBuffer.isView(body))
        body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
      else if (body instanceof Stream);
      else body = Buffer.from(String(body));
      this[INTERNALS] = {
        body,
        disturbed: false,
        error: null,
      };
      this.size = size;
      this.timeout = timeout;
      if (body instanceof Stream)
        body.on("error", function (err2) {
          const error45 =
            err2.name === "AbortError"
              ? err2
              : new FetchError(
                  `Invalid response body while trying to fetch ${_this.url}: ${err2.message}`,
                  "system",
                  err2,
                );
          _this[INTERNALS].error = error45;
        });
    }
    Body.prototype = {
      get body() {
        return this[INTERNALS].body;
      },
      get bodyUsed() {
        return this[INTERNALS].disturbed;
      },
      arrayBuffer() {
        return consumeBody.call(this).then(function (buf) {
          return buf.buffer.slice(
            buf.byteOffset,
            buf.byteOffset + buf.byteLength,
          );
        });
      },
      blob() {
        let ct = (this.headers && this.headers.get("content-type")) || "";
        return consumeBody.call(this).then(function (buf) {
          return Object.assign(new Blob2([], { type: ct.toLowerCase() }), {
            [BUFFER]: buf,
          });
        });
      },
      json() {
        var _this2 = this;
        return consumeBody.call(this).then(function (buffer) {
          try {
            return JSON.parse(buffer.toString());
          } catch (err2) {
            return Body.Promise.reject(
              new FetchError(
                `invalid json response body at ${_this2.url} reason: ${err2.message}`,
                "invalid-json",
              ),
            );
          }
        });
      },
      text() {
        return consumeBody.call(this).then(function (buffer) {
          return buffer.toString();
        });
      },
      buffer() {
        return consumeBody.call(this);
      },
      textConverted() {
        var _this3 = this;
        return consumeBody.call(this).then(function (buffer) {
          return convertBody(buffer, _this3.headers);
        });
      },
    };
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true },
    });
    Body.mixIn = function (proto) {
      for (const name$1 of Object.getOwnPropertyNames(Body.prototype))
        if (!(name$1 in proto)) {
          const desc = Object.getOwnPropertyDescriptor(Body.prototype, name$1);
          Object.defineProperty(proto, name$1, desc);
        }
    };
    function consumeBody() {
      var _this4 = this;
      if (this[INTERNALS].disturbed)
        return Body.Promise.reject(
          /* @__PURE__ */ new TypeError(`body used already for: ${this.url}`),
        );
      this[INTERNALS].disturbed = true;
      if (this[INTERNALS].error)
        return Body.Promise.reject(this[INTERNALS].error);
      let body = this.body;
      if (body === null) return Body.Promise.resolve(Buffer.alloc(0));
      if (isBlob(body)) body = body.stream();
      if (Buffer.isBuffer(body)) return Body.Promise.resolve(body);
      if (!(body instanceof Stream))
        return Body.Promise.resolve(Buffer.alloc(0));
      let accum = [];
      let accumBytes = 0;
      let abort = false;
      return new Body.Promise(function (resolve2, reject) {
        let resTimeout;
        if (_this4.timeout)
          resTimeout = setTimeout(function () {
            abort = true;
            reject(
              new FetchError(
                `Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`,
                "body-timeout",
              ),
            );
          }, _this4.timeout);
        body.on("error", function (err2) {
          if (err2.name === "AbortError") {
            abort = true;
            reject(err2);
          } else
            reject(
              new FetchError(
                `Invalid response body while trying to fetch ${_this4.url}: ${err2.message}`,
                "system",
                err2,
              ),
            );
        });
        body.on("data", function (chunk) {
          if (abort || chunk === null) return;
          if (_this4.size && accumBytes + chunk.length > _this4.size) {
            abort = true;
            reject(
              new FetchError(
                `content size at ${_this4.url} over limit: ${_this4.size}`,
                "max-size",
              ),
            );
            return;
          }
          accumBytes += chunk.length;
          accum.push(chunk);
        });
        body.on("end", function () {
          if (abort) return;
          clearTimeout(resTimeout);
          try {
            resolve2(Buffer.concat(accum, accumBytes));
          } catch (err2) {
            reject(
              new FetchError(
                `Could not create Buffer from response body for ${_this4.url}: ${err2.message}`,
                "system",
                err2,
              ),
            );
          }
        });
      });
    }
    function convertBody(buffer, headers) {
      if (typeof convert !== "function")
        throw new Error(
          "The package `encoding` must be installed to use the textConverted() function",
        );
      const ct = headers.get("content-type");
      let charset = "utf-8";
      let res, str;
      if (ct) res = /charset=([^;]*)/i.exec(ct);
      str = buffer.slice(0, 1024).toString();
      if (!res && str) res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
      if (!res && str) {
        res =
          /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(
            str,
          );
        if (!res) {
          res =
            /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(
              str,
            );
          if (res) res.pop();
        }
        if (res) res = /charset=(.*)/i.exec(res.pop());
      }
      if (!res && str) res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
      if (res) {
        charset = res.pop();
        if (charset === "gb2312" || charset === "gbk") charset = "gb18030";
      }
      return convert(buffer, "UTF-8", charset).toString();
    }
    function isURLSearchParams(obj) {
      if (
        typeof obj !== "object" ||
        typeof obj.append !== "function" ||
        typeof obj.delete !== "function" ||
        typeof obj.get !== "function" ||
        typeof obj.getAll !== "function" ||
        typeof obj.has !== "function" ||
        typeof obj.set !== "function"
      )
        return false;
      return (
        obj.constructor.name === "URLSearchParams" ||
        Object.prototype.toString.call(obj) === "[object URLSearchParams]" ||
        typeof obj.sort === "function"
      );
    }
    function isBlob(obj) {
      return (
        typeof obj === "object" &&
        typeof obj.arrayBuffer === "function" &&
        typeof obj.type === "string" &&
        typeof obj.stream === "function" &&
        typeof obj.constructor === "function" &&
        typeof obj.constructor.name === "string" &&
        /^(Blob|File)$/.test(obj.constructor.name) &&
        /^(Blob|File)$/.test(obj[Symbol.toStringTag])
      );
    }
    function clone3(instance) {
      let p1, p2;
      let body = instance.body;
      if (instance.bodyUsed)
        throw new Error("cannot clone body after it is used");
      if (body instanceof Stream && typeof body.getBoundary !== "function") {
        p1 = new PassThrough();
        p2 = new PassThrough();
        body.pipe(p1);
        body.pipe(p2);
        instance[INTERNALS].body = p1;
        body = p2;
      }
      return body;
    }
    function extractContentType(body) {
      if (body === null) return null;
      else if (typeof body === "string") return "text/plain;charset=UTF-8";
      else if (isURLSearchParams(body))
        return "application/x-www-form-urlencoded;charset=UTF-8";
      else if (isBlob(body)) return body.type || null;
      else if (Buffer.isBuffer(body)) return null;
      else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]")
        return null;
      else if (ArrayBuffer.isView(body)) return null;
      else if (typeof body.getBoundary === "function")
        return `multipart/form-data;boundary=${body.getBoundary()}`;
      else if (body instanceof Stream) return null;
      else return "text/plain;charset=UTF-8";
    }
    function getTotalBytes(instance) {
      const body = instance.body;
      if (body === null) return 0;
      else if (isBlob(body)) return body.size;
      else if (Buffer.isBuffer(body)) return body.length;
      else if (body && typeof body.getLengthSync === "function") {
        if (
          (body._lengthRetrievers && body._lengthRetrievers.length == 0) ||
          (body.hasKnownLength && body.hasKnownLength())
        )
          return body.getLengthSync();
        return null;
      } else return null;
    }
    function writeToStream(dest, instance) {
      const body = instance.body;
      if (body === null) dest.end();
      else if (isBlob(body)) body.stream().pipe(dest);
      else if (Buffer.isBuffer(body)) {
        dest.write(body);
        dest.end();
      } else body.pipe(dest);
    }
    Body.Promise = global.Promise;
    const invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
    const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    function validateName(name$1) {
      name$1 = `${name$1}`;
      if (invalidTokenRegex.test(name$1) || name$1 === "")
        throw new TypeError(`${name$1} is not a legal HTTP header name`);
    }
    function validateValue(value) {
      value = `${value}`;
      if (invalidHeaderCharRegex.test(value))
        throw new TypeError(`${value} is not a legal HTTP header value`);
    }
    function find(map2, name$1) {
      name$1 = name$1.toLowerCase();
      for (const key in map2) if (key.toLowerCase() === name$1) return key;
      return void 0;
    }
    const MAP = Symbol("map");
    var Headers$1 = class Headers$12 {
      /**
       * Headers class
       *
       * @param   Object  headers  Response headers
       * @return  Void
       */
      constructor() {
        let init =
          arguments.length > 0 && arguments[0] !== void 0
            ? arguments[0]
            : void 0;
        this[MAP] = /* @__PURE__ */ Object.create(null);
        if (init instanceof Headers$12) {
          const rawHeaders = init.raw();
          const headerNames = Object.keys(rawHeaders);
          for (const headerName of headerNames)
            for (const value of rawHeaders[headerName])
              this.append(headerName, value);
          return;
        }
        if (init == null);
        else if (typeof init === "object") {
          const method = init[Symbol.iterator];
          if (method != null) {
            if (typeof method !== "function")
              throw new TypeError("Header pairs must be iterable");
            const pairs = [];
            for (const pair of init) {
              if (
                typeof pair !== "object" ||
                typeof pair[Symbol.iterator] !== "function"
              )
                throw new TypeError("Each header pair must be iterable");
              pairs.push(Array.from(pair));
            }
            for (const pair of pairs) {
              if (pair.length !== 2)
                throw new TypeError(
                  "Each header pair must be a name/value tuple",
                );
              this.append(pair[0], pair[1]);
            }
          } else
            for (const key of Object.keys(init)) {
              const value = init[key];
              this.append(key, value);
            }
        } else throw new TypeError("Provided initializer must be an object");
      }
      /**
       * Return combined header value given name
       *
       * @param   String  name  Header name
       * @return  Mixed
       */
      get(name$1) {
        name$1 = `${name$1}`;
        validateName(name$1);
        const key = find(this[MAP], name$1);
        if (key === void 0) return null;
        return this[MAP][key].join(", ");
      }
      /**
       * Iterate over all headers
       *
       * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
       * @param   Boolean   thisArg   `this` context for callback function
       * @return  Void
       */
      forEach(callback) {
        let thisArg =
          arguments.length > 1 && arguments[1] !== void 0
            ? arguments[1]
            : void 0;
        let pairs = getHeaders(this);
        let i2 = 0;
        while (i2 < pairs.length) {
          var _pairs$i = pairs[i2];
          const name$1 = _pairs$i[0],
            value = _pairs$i[1];
          callback.call(thisArg, value, name$1, this);
          pairs = getHeaders(this);
          i2++;
        }
      }
      /**
       * Overwrite header values given name
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      set(name$1, value) {
        name$1 = `${name$1}`;
        value = `${value}`;
        validateName(name$1);
        validateValue(value);
        const key = find(this[MAP], name$1);
        this[MAP][key !== void 0 ? key : name$1] = [value];
      }
      /**
       * Append a value onto existing header
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      append(name$1, value) {
        name$1 = `${name$1}`;
        value = `${value}`;
        validateName(name$1);
        validateValue(value);
        const key = find(this[MAP], name$1);
        if (key !== void 0) this[MAP][key].push(value);
        else this[MAP][name$1] = [value];
      }
      /**
       * Check for header name existence
       *
       * @param   String   name  Header name
       * @return  Boolean
       */
      has(name$1) {
        name$1 = `${name$1}`;
        validateName(name$1);
        return find(this[MAP], name$1) !== void 0;
      }
      /**
       * Delete all header values given name
       *
       * @param   String  name  Header name
       * @return  Void
       */
      delete(name$1) {
        name$1 = `${name$1}`;
        validateName(name$1);
        const key = find(this[MAP], name$1);
        if (key !== void 0) delete this[MAP][key];
      }
      /**
       * Return raw headers (non-spec api)
       *
       * @return  Object
       */
      raw() {
        return this[MAP];
      }
      /**
       * Get an iterator on keys.
       *
       * @return  Iterator
       */
      keys() {
        return createHeadersIterator(this, "key");
      }
      /**
       * Get an iterator on values.
       *
       * @return  Iterator
       */
      values() {
        return createHeadersIterator(this, "value");
      }
      /**
       * Get an iterator on entries.
       *
       * This is the default iterator of the Headers object.
       *
       * @return  Iterator
       */
      [Symbol.iterator]() {
        return createHeadersIterator(this, "key+value");
      }
    };
    Headers$1.prototype.entries = Headers$1.prototype[Symbol.iterator];
    Object.defineProperty(Headers$1.prototype, Symbol.toStringTag, {
      value: "Headers",
      writable: false,
      enumerable: false,
      configurable: true,
    });
    Object.defineProperties(Headers$1.prototype, {
      get: { enumerable: true },
      forEach: { enumerable: true },
      set: { enumerable: true },
      append: { enumerable: true },
      has: { enumerable: true },
      delete: { enumerable: true },
      keys: { enumerable: true },
      values: { enumerable: true },
      entries: { enumerable: true },
    });
    function getHeaders(headers) {
      let kind =
        arguments.length > 1 && arguments[1] !== void 0
          ? arguments[1]
          : "key+value";
      const keys = Object.keys(headers[MAP]).sort();
      return keys.map(
        kind === "key"
          ? function (k) {
              return k.toLowerCase();
            }
          : kind === "value"
            ? function (k) {
                return headers[MAP][k].join(", ");
              }
            : function (k) {
                return [k.toLowerCase(), headers[MAP][k].join(", ")];
              },
      );
    }
    const INTERNAL = Symbol("internal");
    function createHeadersIterator(target, kind) {
      const iterator = Object.create(HeadersIteratorPrototype);
      iterator[INTERNAL] = {
        target,
        kind,
        index: 0,
      };
      return iterator;
    }
    const HeadersIteratorPrototype = Object.setPrototypeOf(
      {
        next() {
          if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype)
            throw new TypeError("Value of `this` is not a HeadersIterator");
          var _INTERNAL = this[INTERNAL];
          const target = _INTERNAL.target,
            kind = _INTERNAL.kind,
            index = _INTERNAL.index;
          const values = getHeaders(target, kind);
          const len = values.length;
          if (index >= len)
            return {
              value: void 0,
              done: true,
            };
          this[INTERNAL].index = index + 1;
          return {
            value: values[index],
            done: false,
          };
        },
      },
      Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())),
    );
    Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
      value: "HeadersIterator",
      writable: false,
      enumerable: false,
      configurable: true,
    });
    function exportNodeCompatibleHeaders(headers) {
      const obj = Object.assign({ __proto__: null }, headers[MAP]);
      const hostHeaderKey = find(headers[MAP], "Host");
      if (hostHeaderKey !== void 0) obj[hostHeaderKey] = obj[hostHeaderKey][0];
      return obj;
    }
    function createHeadersLenient(obj) {
      const headers = new Headers$1();
      for (const name$1 of Object.keys(obj)) {
        if (invalidTokenRegex.test(name$1)) continue;
        if (Array.isArray(obj[name$1]))
          for (const val of obj[name$1]) {
            if (invalidHeaderCharRegex.test(val)) continue;
            if (headers[MAP][name$1] === void 0) headers[MAP][name$1] = [val];
            else headers[MAP][name$1].push(val);
          }
        else if (!invalidHeaderCharRegex.test(obj[name$1]))
          headers[MAP][name$1] = [obj[name$1]];
      }
      return headers;
    }
    const INTERNALS$1 = Symbol("Response internals");
    const STATUS_CODES = http.STATUS_CODES;
    var Response2 = class Response3 {
      constructor() {
        let body =
          arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        let opts =
          arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        Body.call(this, body, opts);
        const status = opts.status || 200;
        const headers = new Headers$1(opts.headers);
        if (body != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body);
          if (contentType) headers.append("Content-Type", contentType);
        }
        this[INTERNALS$1] = {
          url: opts.url,
          status,
          statusText: opts.statusText || STATUS_CODES[status],
          headers,
          counter: opts.counter,
        };
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      /**
       * Convenience property representing if the request ended normally
       */
      get ok() {
        return (
          this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300
        );
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      /**
       * Clone this response
       *
       * @return  Response
       */
      clone() {
        return new Response3(clone3(this), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected,
        });
      }
    };
    Body.mixIn(Response2.prototype);
    Object.defineProperties(Response2.prototype, {
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true },
    });
    Object.defineProperty(Response2.prototype, Symbol.toStringTag, {
      value: "Response",
      writable: false,
      enumerable: false,
      configurable: true,
    });
    const INTERNALS$2 = Symbol("Request internals");
    const URL2 = Url.URL || whatwgUrl.URL;
    const parse_url = Url.parse;
    const format_url = Url.format;
    function parseURL(urlStr) {
      if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr))
        urlStr = new URL2(urlStr).toString();
      return parse_url(urlStr);
    }
    const streamDestructionSupported = "destroy" in Stream.Readable.prototype;
    function isRequest(input) {
      return (
        typeof input === "object" && typeof input[INTERNALS$2] === "object"
      );
    }
    function isAbortSignal(signal) {
      const proto =
        signal && typeof signal === "object" && Object.getPrototypeOf(signal);
      return !!(proto && proto.constructor.name === "AbortSignal");
    }
    var Request2 = class Request3 {
      constructor(input) {
        let init =
          arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        let parsedURL;
        if (!isRequest(input)) {
          if (input && input.href) parsedURL = parseURL(input.href);
          else parsedURL = parseURL(`${input}`);
          input = {};
        } else parsedURL = parseURL(input.url);
        let method = init.method || input.method || "GET";
        method = method.toUpperCase();
        if (
          (init.body != null || (isRequest(input) && input.body !== null)) &&
          (method === "GET" || method === "HEAD")
        )
          throw new TypeError("Request with GET/HEAD method cannot have body");
        let inputBody =
          init.body != null
            ? init.body
            : isRequest(input) && input.body !== null
              ? clone3(input)
              : null;
        Body.call(this, inputBody, {
          timeout: init.timeout || input.timeout || 0,
          size: init.size || input.size || 0,
        });
        const headers = new Headers$1(init.headers || input.headers || {});
        if (inputBody != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody);
          if (contentType) headers.append("Content-Type", contentType);
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init) signal = init.signal;
        if (signal != null && !isAbortSignal(signal))
          throw new TypeError(
            "Expected signal to be an instanceof AbortSignal",
          );
        this[INTERNALS$2] = {
          method,
          redirect: init.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal,
        };
        this.follow =
          init.follow !== void 0
            ? init.follow
            : input.follow !== void 0
              ? input.follow
              : 20;
        this.compress =
          init.compress !== void 0
            ? init.compress
            : input.compress !== void 0
              ? input.compress
              : true;
        this.counter = init.counter || input.counter || 0;
        this.agent = init.agent || input.agent;
      }
      get method() {
        return this[INTERNALS$2].method;
      }
      get url() {
        return format_url(this[INTERNALS$2].parsedURL);
      }
      get headers() {
        return this[INTERNALS$2].headers;
      }
      get redirect() {
        return this[INTERNALS$2].redirect;
      }
      get signal() {
        return this[INTERNALS$2].signal;
      }
      /**
       * Clone this request
       *
       * @return  Request
       */
      clone() {
        return new Request3(this);
      }
    };
    Body.mixIn(Request2.prototype);
    Object.defineProperty(Request2.prototype, Symbol.toStringTag, {
      value: "Request",
      writable: false,
      enumerable: false,
      configurable: true,
    });
    Object.defineProperties(Request2.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true },
    });
    function getNodeRequestOptions(request2) {
      const parsedURL = request2[INTERNALS$2].parsedURL;
      const headers = new Headers$1(request2[INTERNALS$2].headers);
      if (!headers.has("Accept")) headers.set("Accept", "*/*");
      if (!parsedURL.protocol || !parsedURL.hostname)
        throw new TypeError("Only absolute URLs are supported");
      if (!/^https?:$/.test(parsedURL.protocol))
        throw new TypeError("Only HTTP(S) protocols are supported");
      if (
        request2.signal &&
        request2.body instanceof Stream.Readable &&
        !streamDestructionSupported
      )
        throw new Error(
          "Cancellation of streamed requests with AbortSignal is not supported in node < 8",
        );
      let contentLengthValue = null;
      if (request2.body == null && /^(POST|PUT)$/i.test(request2.method))
        contentLengthValue = "0";
      if (request2.body != null) {
        const totalBytes = getTotalBytes(request2);
        if (typeof totalBytes === "number")
          contentLengthValue = String(totalBytes);
      }
      if (contentLengthValue) headers.set("Content-Length", contentLengthValue);
      if (!headers.has("User-Agent"))
        headers.set(
          "User-Agent",
          "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)",
        );
      if (request2.compress && !headers.has("Accept-Encoding"))
        headers.set("Accept-Encoding", "gzip,deflate");
      let agent2 = request2.agent;
      if (typeof agent2 === "function") agent2 = agent2(parsedURL);
      return Object.assign({}, parsedURL, {
        method: request2.method,
        headers: exportNodeCompatibleHeaders(headers),
        agent: agent2,
      });
    }
    function AbortError2(message) {
      Error.call(this, message);
      this.type = "aborted";
      this.message = message;
      Error.captureStackTrace(this, this.constructor);
    }
    AbortError2.prototype = Object.create(Error.prototype);
    AbortError2.prototype.constructor = AbortError2;
    AbortError2.prototype.name = "AbortError";
    const URL$1 = Url.URL || whatwgUrl.URL;
    const PassThrough$1 = Stream.PassThrough;
    const isDomainOrSubdomain = function isDomainOrSubdomain$1(
      destination,
      original,
    ) {
      const orig = new URL$1(original).hostname;
      const dest = new URL$1(destination).hostname;
      return (
        orig === dest ||
        (orig[orig.length - dest.length - 1] === "." && orig.endsWith(dest))
      );
    };
    const isSameProtocol = function isSameProtocol$1(destination, original) {
      const orig = new URL$1(original).protocol;
      const dest = new URL$1(destination).protocol;
      return orig === dest;
    };
    function fetch$2(url2, opts) {
      if (!fetch$2.Promise)
        throw new Error(
          "native promise missing, set fetch.Promise to your favorite alternative",
        );
      Body.Promise = fetch$2.Promise;
      return new fetch$2.Promise(function (resolve2, reject) {
        const request2 = new Request2(url2, opts);
        const options = getNodeRequestOptions(request2);
        const send = (options.protocol === "https:" ? https : http).request;
        const signal = request2.signal;
        let response = null;
        const abort = function abort$1() {
          let error45 = new AbortError2("The user aborted a request.");
          reject(error45);
          if (request2.body && request2.body instanceof Stream.Readable)
            destroyStream(request2.body, error45);
          if (!response || !response.body) return;
          response.body.emit("error", error45);
        };
        if (signal && signal.aborted) {
          abort();
          return;
        }
        const abortAndFinalize = function abortAndFinalize$1() {
          abort();
          finalize();
        };
        const req = send(options);
        let reqTimeout;
        if (signal) signal.addEventListener("abort", abortAndFinalize);
        function finalize() {
          req.abort();
          if (signal) signal.removeEventListener("abort", abortAndFinalize);
          clearTimeout(reqTimeout);
        }
        if (request2.timeout)
          req.once("socket", function (socket) {
            reqTimeout = setTimeout(function () {
              reject(
                new FetchError(
                  `network timeout at: ${request2.url}`,
                  "request-timeout",
                ),
              );
              finalize();
            }, request2.timeout);
          });
        req.on("error", function (err2) {
          reject(
            new FetchError(
              `request to ${request2.url} failed, reason: ${err2.message}`,
              "system",
              err2,
            ),
          );
          if (response && response.body) destroyStream(response.body, err2);
          finalize();
        });
        fixResponseChunkedTransferBadEnding(req, function (err2) {
          if (signal && signal.aborted) return;
          if (response && response.body) destroyStream(response.body, err2);
        });
        if (parseInt(process.version.substring(1)) < 14)
          req.on("socket", function (s2) {
            s2.addListener("close", function (hadError) {
              const hasDataListener = s2.listenerCount("data") > 0;
              if (
                response &&
                hasDataListener &&
                !hadError &&
                !(signal && signal.aborted)
              ) {
                const err2 = /* @__PURE__ */ new Error("Premature close");
                err2.code = "ERR_STREAM_PREMATURE_CLOSE";
                response.body.emit("error", err2);
              }
            });
          });
        req.on("response", function (res) {
          clearTimeout(reqTimeout);
          const headers = createHeadersLenient(res.headers);
          if (fetch$2.isRedirect(res.statusCode)) {
            const location = headers.get("Location");
            let locationURL = null;
            try {
              locationURL =
                location === null
                  ? null
                  : new URL$1(location, request2.url).toString();
            } catch (err2) {
              if (request2.redirect !== "manual") {
                reject(
                  new FetchError(
                    `uri requested responds with an invalid redirect URL: ${location}`,
                    "invalid-redirect",
                  ),
                );
                finalize();
                return;
              }
            }
            switch (request2.redirect) {
              case "error":
                reject(
                  new FetchError(
                    `uri requested responds with a redirect, redirect mode is set to error: ${request2.url}`,
                    "no-redirect",
                  ),
                );
                finalize();
                return;
              case "manual":
                if (locationURL !== null)
                  try {
                    headers.set("Location", locationURL);
                  } catch (err2) {
                    reject(err2);
                  }
                break;
              case "follow":
                if (locationURL === null) break;
                if (request2.counter >= request2.follow) {
                  reject(
                    new FetchError(
                      `maximum redirect reached at: ${request2.url}`,
                      "max-redirect",
                    ),
                  );
                  finalize();
                  return;
                }
                const requestOpts = {
                  headers: new Headers$1(request2.headers),
                  follow: request2.follow,
                  counter: request2.counter + 1,
                  agent: request2.agent,
                  compress: request2.compress,
                  method: request2.method,
                  body: request2.body,
                  signal: request2.signal,
                  timeout: request2.timeout,
                  size: request2.size,
                };
                if (
                  !isDomainOrSubdomain(request2.url, locationURL) ||
                  !isSameProtocol(request2.url, locationURL)
                )
                  for (const name$1 of [
                    "authorization",
                    "www-authenticate",
                    "cookie",
                    "cookie2",
                  ])
                    requestOpts.headers.delete(name$1);
                if (
                  res.statusCode !== 303 &&
                  request2.body &&
                  getTotalBytes(request2) === null
                ) {
                  reject(
                    new FetchError(
                      "Cannot follow redirect with body being a readable stream",
                      "unsupported-redirect",
                    ),
                  );
                  finalize();
                  return;
                }
                if (
                  res.statusCode === 303 ||
                  ((res.statusCode === 301 || res.statusCode === 302) &&
                    request2.method === "POST")
                ) {
                  requestOpts.method = "GET";
                  requestOpts.body = void 0;
                  requestOpts.headers.delete("content-length");
                }
                resolve2(fetch$2(new Request2(locationURL, requestOpts)));
                finalize();
                return;
            }
          }
          res.once("end", function () {
            if (signal) signal.removeEventListener("abort", abortAndFinalize);
          });
          let body = res.pipe(new PassThrough$1());
          const response_options = {
            url: request2.url,
            status: res.statusCode,
            statusText: res.statusMessage,
            headers,
            size: request2.size,
            timeout: request2.timeout,
            counter: request2.counter,
          };
          const codings = headers.get("Content-Encoding");
          if (
            !request2.compress ||
            request2.method === "HEAD" ||
            codings === null ||
            res.statusCode === 204 ||
            res.statusCode === 304
          ) {
            response = new Response2(body, response_options);
            resolve2(response);
            return;
          }
          const zlibOptions = {
            flush: zlib.Z_SYNC_FLUSH,
            finishFlush: zlib.Z_SYNC_FLUSH,
          };
          if (codings == "gzip" || codings == "x-gzip") {
            body = body.pipe(zlib.createGunzip(zlibOptions));
            response = new Response2(body, response_options);
            resolve2(response);
            return;
          }
          if (codings == "deflate" || codings == "x-deflate") {
            const raw = res.pipe(new PassThrough$1());
            raw.once("data", function (chunk) {
              if ((chunk[0] & 15) === 8) body = body.pipe(zlib.createInflate());
              else body = body.pipe(zlib.createInflateRaw());
              response = new Response2(body, response_options);
              resolve2(response);
            });
            raw.on("end", function () {
              if (!response) {
                response = new Response2(body, response_options);
                resolve2(response);
              }
            });
            return;
          }
          if (
            codings == "br" &&
            typeof zlib.createBrotliDecompress === "function"
          ) {
            body = body.pipe(zlib.createBrotliDecompress());
            response = new Response2(body, response_options);
            resolve2(response);
            return;
          }
          response = new Response2(body, response_options);
          resolve2(response);
        });
        writeToStream(req, request2);
      });
    }
    function fixResponseChunkedTransferBadEnding(request2, errorCallback) {
      let socket;
      request2.on("socket", function (s2) {
        socket = s2;
      });
      request2.on("response", function (response) {
        const headers = response.headers;
        if (
          headers["transfer-encoding"] === "chunked" &&
          !headers["content-length"]
        )
          response.once("close", function (hadError) {
            const hasDataListener = socket && socket.listenerCount("data") > 0;
            if (hasDataListener && !hadError) {
              const err2 = /* @__PURE__ */ new Error("Premature close");
              err2.code = "ERR_STREAM_PREMATURE_CLOSE";
              errorCallback(err2);
            }
          });
      });
    }
    function destroyStream(stream, err2) {
      if (stream.destroy) stream.destroy(err2);
      else {
        stream.emit("error", err2);
        stream.end();
      }
    }
    fetch$2.isRedirect = function (code) {
      return (
        code === 301 ||
        code === 302 ||
        code === 303 ||
        code === 307 ||
        code === 308
      );
    };
    fetch$2.Promise = global.Promise;
    module.exports = exports = fetch$2;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = exports;
    exports.Headers = Headers$1;
    exports.Request = Request2;
    exports.Response = Response2;
    exports.FetchError = FetchError;
    exports.AbortError = AbortError2;
  },
});
var require_node_ponyfill = /* @__PURE__ */ __commonJS3({
  "../../../node_modules/cross-fetch/dist/node-ponyfill.js": (
    exports,
    module,
  ) => {
    const nodeFetch = require_lib8();
    const realFetch = nodeFetch.default || nodeFetch;
    const fetch$1 = function (url2, options) {
      if (/^\/\//.test(url2)) url2 = "https:" + url2;
      return realFetch.call(this, url2, options);
    };
    fetch$1.ponyfill = true;
    module.exports = exports = fetch$1;
    exports.fetch = fetch$1;
    exports.Headers = nodeFetch.Headers;
    exports.Request = nodeFetch.Request;
    exports.Response = nodeFetch.Response;
    exports.default = fetch$1;
  },
});
var import_node_ponyfill = /* @__PURE__ */ __toESM3(require_node_ponyfill(), 1);
var ignoreOverride2 = Symbol(
  "Let zodToJsonSchema decide on which parser to use",
);
var defaultOptions2 = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: true,
  rejectedAdditionalProperties: false,
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: false,
  definitions: {},
  errorMessages: false,
  markdownDescription: false,
  patternStrategy: "escape",
  applyRegexFlags: false,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref",
  openAiAnyTypeName: "OpenAiAnyType",
};
var getDefaultOptions2 = (options) =>
  typeof options === "string"
    ? {
        ...defaultOptions2,
        name: options,
      }
    : {
        ...defaultOptions2,
        ...options,
      };
var getRefs2 = (options) => {
  const _options = getDefaultOptions2(options);
  const currentPath =
    _options.name !== void 0
      ? [..._options.basePath, _options.definitionPath, _options.name]
      : _options.basePath;
  return {
    ..._options,
    flags: { hasReferencedOpenAiAnyType: false },
    currentPath,
    propertyPath: void 0,
    seen: new Map(
      Object.entries(_options.definitions).map(([name$1, def]) => [
        def._def,
        {
          def: def._def,
          path: [..._options.basePath, _options.definitionPath, name$1],
          jsonSchema: void 0,
        },
      ]),
    ),
  };
};
function addErrorMessage(res, key, errorMessage, refs) {
  if (!refs?.errorMessages) return;
  if (errorMessage)
    res.errorMessage = {
      ...res.errorMessage,
      [key]: errorMessage,
    };
}
function setResponseValueAndErrors(res, key, value, errorMessage, refs) {
  res[key] = value;
  addErrorMessage(res, key, errorMessage, refs);
}
var getRelativePath2 = (pathA, pathB) => {
  let i2 = 0;
  for (; i2 < pathA.length && i2 < pathB.length; i2++)
    if (pathA[i2] !== pathB[i2]) break;
  return [(pathA.length - i2).toString(), ...pathB.slice(i2)].join("/");
};
function parseAnyDef2(refs) {
  if (refs.target !== "openAi") return {};
  const anyDefinitionPath = [
    ...refs.basePath,
    refs.definitionPath,
    refs.openAiAnyTypeName,
  ];
  refs.flags.hasReferencedOpenAiAnyType = true;
  return {
    $ref:
      refs.$refStrategy === "relative"
        ? getRelativePath2(anyDefinitionPath, refs.currentPath)
        : anyDefinitionPath.join("/"),
  };
}
function parseArrayDef2(def, refs) {
  const res = { type: "array" };
  if (
    def.type?._def &&
    def.type?._def?.typeName !== ZodFirstPartyTypeKind.ZodAny
  )
    res.items = parseDef2(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"],
    });
  if (def.minLength)
    setResponseValueAndErrors(
      res,
      "minItems",
      def.minLength.value,
      def.minLength.message,
      refs,
    );
  if (def.maxLength)
    setResponseValueAndErrors(
      res,
      "maxItems",
      def.maxLength.value,
      def.maxLength.message,
      refs,
    );
  if (def.exactLength) {
    setResponseValueAndErrors(
      res,
      "minItems",
      def.exactLength.value,
      def.exactLength.message,
      refs,
    );
    setResponseValueAndErrors(
      res,
      "maxItems",
      def.exactLength.value,
      def.exactLength.message,
      refs,
    );
  }
  return res;
}
function parseBigintDef2(def, refs) {
  const res = {
    type: "integer",
    format: "int64",
  };
  if (!def.checks) return res;
  for (const check2 of def.checks)
    switch (check2.kind) {
      case "min":
        if (refs.target === "jsonSchema7")
          if (check2.inclusive)
            setResponseValueAndErrors(
              res,
              "minimum",
              check2.value,
              check2.message,
              refs,
            );
          else
            setResponseValueAndErrors(
              res,
              "exclusiveMinimum",
              check2.value,
              check2.message,
              refs,
            );
        else {
          if (!check2.inclusive) res.exclusiveMinimum = true;
          setResponseValueAndErrors(
            res,
            "minimum",
            check2.value,
            check2.message,
            refs,
          );
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7")
          if (check2.inclusive)
            setResponseValueAndErrors(
              res,
              "maximum",
              check2.value,
              check2.message,
              refs,
            );
          else
            setResponseValueAndErrors(
              res,
              "exclusiveMaximum",
              check2.value,
              check2.message,
              refs,
            );
        else {
          if (!check2.inclusive) res.exclusiveMaximum = true;
          setResponseValueAndErrors(
            res,
            "maximum",
            check2.value,
            check2.message,
            refs,
          );
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(
          res,
          "multipleOf",
          check2.value,
          check2.message,
          refs,
        );
        break;
    }
  return res;
}
function parseBooleanDef2() {
  return { type: "boolean" };
}
function parseBrandedDef2(_def, refs) {
  return parseDef2(_def.type._def, refs);
}
var parseCatchDef2 = (def, refs) => {
  return parseDef2(def.innerType._def, refs);
};
function parseDateDef2(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy ?? refs.dateStrategy;
  if (Array.isArray(strategy))
    return {
      anyOf: strategy.map((item, i2) => parseDateDef2(def, refs, item)),
    };
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time",
      };
    case "format:date":
      return {
        type: "string",
        format: "date",
      };
    case "integer":
      return integerDateParser2(def, refs);
  }
}
var integerDateParser2 = (def, refs) => {
  const res = {
    type: "integer",
    format: "unix-time",
  };
  if (refs.target === "openApi3") return res;
  for (const check2 of def.checks)
    switch (check2.kind) {
      case "min":
        setResponseValueAndErrors(
          res,
          "minimum",
          check2.value,
          check2.message,
          refs,
        );
        break;
      case "max":
        setResponseValueAndErrors(
          res,
          "maximum",
          check2.value,
          check2.message,
          refs,
        );
        break;
    }
  return res;
};
function parseDefaultDef2(_def, refs) {
  return {
    ...parseDef2(_def.innerType._def, refs),
    default: _def.defaultValue(),
  };
}
function parseEffectsDef2(_def, refs) {
  return refs.effectStrategy === "input"
    ? parseDef2(_def.schema._def, refs)
    : parseAnyDef2(refs);
}
function parseEnumDef2(def) {
  return {
    type: "string",
    enum: Array.from(def.values),
  };
}
var isJsonSchema7AllOfType2 = (type) => {
  if ("type" in type && type.type === "string") return false;
  return "allOf" in type;
};
function parseIntersectionDef2(def, refs) {
  const allOf = [
    parseDef2(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"],
    }),
    parseDef2(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"],
    }),
  ].filter((x) => !!x);
  let unevaluatedProperties =
    refs.target === "jsonSchema2019-09"
      ? { unevaluatedProperties: false }
      : void 0;
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType2(schema)) {
      mergedAllOf.push(...schema.allOf);
      if (schema.unevaluatedProperties === void 0)
        unevaluatedProperties = void 0;
    } else {
      let nestedSchema = schema;
      if (
        "additionalProperties" in schema &&
        schema.additionalProperties === false
      ) {
        const { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      } else unevaluatedProperties = void 0;
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length
    ? {
        allOf: mergedAllOf,
        ...unevaluatedProperties,
      }
    : void 0;
}
function parseLiteralDef2(def, refs) {
  const parsedType7 = typeof def.value;
  if (
    parsedType7 !== "bigint" &&
    parsedType7 !== "number" &&
    parsedType7 !== "boolean" &&
    parsedType7 !== "string"
  )
    return { type: Array.isArray(def.value) ? "array" : "object" };
  if (refs.target === "openApi3")
    return {
      type: parsedType7 === "bigint" ? "integer" : parsedType7,
      enum: [def.value],
    };
  return {
    type: parsedType7 === "bigint" ? "integer" : parsedType7,
    const: def.value,
  };
}
var emojiRegex3 = void 0;
var zodPatterns2 = {
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  email:
    /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  emoji: () => {
    if (emojiRegex3 === void 0)
      emojiRegex3 = RegExp(
        "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
        "u",
      );
    return emojiRegex3;
  },
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr:
    /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr:
    /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url:
    /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/,
};
function parseStringDef2(def, refs) {
  const res = { type: "string" };
  if (def.checks)
    for (const check2 of def.checks)
      switch (check2.kind) {
        case "min":
          setResponseValueAndErrors(
            res,
            "minLength",
            typeof res.minLength === "number"
              ? Math.max(res.minLength, check2.value)
              : check2.value,
            check2.message,
            refs,
          );
          break;
        case "max":
          setResponseValueAndErrors(
            res,
            "maxLength",
            typeof res.maxLength === "number"
              ? Math.min(res.maxLength, check2.value)
              : check2.value,
            check2.message,
            refs,
          );
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat2(res, "email", check2.message, refs);
              break;
            case "format:idn-email":
              addFormat2(res, "idn-email", check2.message, refs);
              break;
            case "pattern:zod":
              addPattern2(res, zodPatterns2.email, check2.message, refs);
              break;
          }
          break;
        case "url":
          addFormat2(res, "uri", check2.message, refs);
          break;
        case "uuid":
          addFormat2(res, "uuid", check2.message, refs);
          break;
        case "regex":
          addPattern2(res, check2.regex, check2.message, refs);
          break;
        case "cuid":
          addPattern2(res, zodPatterns2.cuid, check2.message, refs);
          break;
        case "cuid2":
          addPattern2(res, zodPatterns2.cuid2, check2.message, refs);
          break;
        case "startsWith":
          addPattern2(
            res,
            RegExp(`^${escapeLiteralCheckValue2(check2.value, refs)}`),
            check2.message,
            refs,
          );
          break;
        case "endsWith":
          addPattern2(
            res,
            RegExp(`${escapeLiteralCheckValue2(check2.value, refs)}$`),
            check2.message,
            refs,
          );
          break;
        case "datetime":
          addFormat2(res, "date-time", check2.message, refs);
          break;
        case "date":
          addFormat2(res, "date", check2.message, refs);
          break;
        case "time":
          addFormat2(res, "time", check2.message, refs);
          break;
        case "duration":
          addFormat2(res, "duration", check2.message, refs);
          break;
        case "length":
          setResponseValueAndErrors(
            res,
            "minLength",
            typeof res.minLength === "number"
              ? Math.max(res.minLength, check2.value)
              : check2.value,
            check2.message,
            refs,
          );
          setResponseValueAndErrors(
            res,
            "maxLength",
            typeof res.maxLength === "number"
              ? Math.min(res.maxLength, check2.value)
              : check2.value,
            check2.message,
            refs,
          );
          break;
        case "includes":
          addPattern2(
            res,
            RegExp(escapeLiteralCheckValue2(check2.value, refs)),
            check2.message,
            refs,
          );
          break;
        case "ip":
          if (check2.version !== "v6")
            addFormat2(res, "ipv4", check2.message, refs);
          if (check2.version !== "v4")
            addFormat2(res, "ipv6", check2.message, refs);
          break;
        case "base64url":
          addPattern2(res, zodPatterns2.base64url, check2.message, refs);
          break;
        case "jwt":
          addPattern2(res, zodPatterns2.jwt, check2.message, refs);
          break;
        case "cidr":
          if (check2.version !== "v6")
            addPattern2(res, zodPatterns2.ipv4Cidr, check2.message, refs);
          if (check2.version !== "v4")
            addPattern2(res, zodPatterns2.ipv6Cidr, check2.message, refs);
          break;
        case "emoji":
          addPattern2(res, zodPatterns2.emoji(), check2.message, refs);
          break;
        case "ulid":
          addPattern2(res, zodPatterns2.ulid, check2.message, refs);
          break;
        case "base64":
          switch (refs.base64Strategy) {
            case "format:binary":
              addFormat2(res, "binary", check2.message, refs);
              break;
            case "contentEncoding:base64":
              setResponseValueAndErrors(
                res,
                "contentEncoding",
                "base64",
                check2.message,
                refs,
              );
              break;
            case "pattern:zod":
              addPattern2(res, zodPatterns2.base64, check2.message, refs);
              break;
          }
          break;
        case "nanoid":
          addPattern2(res, zodPatterns2.nanoid, check2.message, refs);
        case "toLowerCase":
        case "toUpperCase":
        case "trim":
          break;
        default:
          /* @__PURE__ */ ((_2) => {})(check2);
      }
  return res;
}
function escapeLiteralCheckValue2(literal3, refs) {
  return refs.patternStrategy === "escape"
    ? escapeNonAlphaNumeric2(literal3)
    : literal3;
}
var ALPHA_NUMERIC2 = /* @__PURE__ */ new Set(
  "ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789",
);
function escapeNonAlphaNumeric2(source) {
  let result = "";
  for (let i2 = 0; i2 < source.length; i2++) {
    if (!ALPHA_NUMERIC2.has(source[i2])) result += "\\";
    result += source[i2];
  }
  return result;
}
function addFormat2(schema, value, message, refs) {
  if (schema.format || schema.anyOf?.some((x) => x.format)) {
    if (!schema.anyOf) schema.anyOf = [];
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format,
        ...(schema.errorMessage &&
          refs.errorMessages && {
            errorMessage: { format: schema.errorMessage.format },
          }),
      });
      delete schema.format;
      if (schema.errorMessage) {
        delete schema.errorMessage.format;
        if (Object.keys(schema.errorMessage).length === 0)
          delete schema.errorMessage;
      }
    }
    schema.anyOf.push({
      format: value,
      ...(message &&
        refs.errorMessages && { errorMessage: { format: message } }),
    });
  } else setResponseValueAndErrors(schema, "format", value, message, refs);
}
function addPattern2(schema, regex, message, refs) {
  if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {
    if (!schema.allOf) schema.allOf = [];
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern,
        ...(schema.errorMessage &&
          refs.errorMessages && {
            errorMessage: { pattern: schema.errorMessage.pattern },
          }),
      });
      delete schema.pattern;
      if (schema.errorMessage) {
        delete schema.errorMessage.pattern;
        if (Object.keys(schema.errorMessage).length === 0)
          delete schema.errorMessage;
      }
    }
    schema.allOf.push({
      pattern: stringifyRegExpWithFlags2(regex, refs),
      ...(message &&
        refs.errorMessages && { errorMessage: { pattern: message } }),
    });
  } else
    setResponseValueAndErrors(
      schema,
      "pattern",
      stringifyRegExpWithFlags2(regex, refs),
      message,
      refs,
    );
}
function stringifyRegExpWithFlags2(regex, refs) {
  if (!refs.applyRegexFlags || !regex.flags) return regex.source;
  const flags = {
    i: regex.flags.includes("i"),
    m: regex.flags.includes("m"),
    s: regex.flags.includes("s"),
  };
  const source = flags.i ? regex.source.toLowerCase() : regex.source;
  let pattern = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i2 = 0; i2 < source.length; i2++) {
    if (isEscaped) {
      pattern += source[i2];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i2].match(/[a-z]/)) {
          if (inCharRange) {
            pattern += source[i2];
            pattern += `${source[i2 - 2]}-${source[i2]}`.toUpperCase();
            inCharRange = false;
          } else if (source[i2 + 1] === "-" && source[i2 + 2]?.match(/[a-z]/)) {
            pattern += source[i2];
            inCharRange = true;
          } else pattern += `${source[i2]}${source[i2].toUpperCase()}`;
          continue;
        }
      } else if (source[i2].match(/[a-z]/)) {
        pattern += `[${source[i2]}${source[i2].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i2] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i2] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i2] === ".") {
      pattern += inCharGroup
        ? `${source[i2]}\r
`
        : `[${source[i2]}\r
]`;
      continue;
    }
    pattern += source[i2];
    if (source[i2] === "\\") isEscaped = true;
    else if (inCharGroup && source[i2] === "]") inCharGroup = false;
    else if (!inCharGroup && source[i2] === "[") inCharGroup = true;
  }
  try {
    new RegExp(pattern);
  } catch {
    console.warn(
      `Could not convert regex pattern at ${refs.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`,
    );
    return regex.source;
  }
  return pattern;
}
function parseRecordDef2(def, refs) {
  if (refs.target === "openAi")
    console.warn(
      "Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.",
    );
  if (
    refs.target === "openApi3" &&
    def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum
  )
    return {
      type: "object",
      required: def.keyType._def.values,
      properties: def.keyType._def.values.reduce(
        (acc, key) => ({
          ...acc,
          [key]:
            parseDef2(def.valueType._def, {
              ...refs,
              currentPath: [...refs.currentPath, "properties", key],
            }) ?? parseAnyDef2(refs),
        }),
        {},
      ),
      additionalProperties: refs.rejectedAdditionalProperties,
    };
  const schema = {
    type: "object",
    additionalProperties:
      parseDef2(def.valueType._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalProperties"],
      }) ?? refs.allowedAdditionalProperties,
  };
  if (refs.target === "openApi3") return schema;
  if (
    def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodString &&
    def.keyType._def.checks?.length
  ) {
    const { type, ...keyType } = parseStringDef2(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType,
    };
  } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum)
    return {
      ...schema,
      propertyNames: { enum: def.keyType._def.values },
    };
  else if (
    def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodBranded &&
    def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString &&
    def.keyType._def.type._def.checks?.length
  ) {
    const { type, ...keyType } = parseBrandedDef2(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType,
    };
  }
  return schema;
}
function parseMapDef2(def, refs) {
  if (refs.mapStrategy === "record") return parseRecordDef2(def, refs);
  const keys =
    parseDef2(def.keyType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items", "items", "0"],
    }) || parseAnyDef2(refs);
  const values =
    parseDef2(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items", "items", "1"],
    }) || parseAnyDef2(refs);
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2,
    },
  };
}
function parseNativeEnumDef2(def) {
  const object4 = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object4[object4[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object4[key]);
  const parsedTypes = Array.from(
    new Set(actualValues.map((values) => typeof values)),
  );
  return {
    type:
      parsedTypes.length === 1
        ? parsedTypes[0] === "string"
          ? "string"
          : "number"
        : ["string", "number"],
    enum: actualValues,
  };
}
function parseNeverDef2(refs) {
  return refs.target === "openAi"
    ? void 0
    : {
        not: parseAnyDef2({
          ...refs,
          currentPath: [...refs.currentPath, "not"],
        }),
      };
}
function parseNullDef2(refs) {
  return refs.target === "openApi3"
    ? {
        enum: ["null"],
        nullable: true,
      }
    : { type: "null" };
}
var primitiveMappings2 = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null",
};
function parseUnionDef2(def, refs) {
  if (refs.target === "openApi3") return asAnyOf2(def, refs);
  const options =
    def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (
    options.every(
      (x) =>
        x._def.typeName in primitiveMappings2 &&
        (!x._def.checks || !x._def.checks.length),
    )
  ) {
    const types = options.reduce((types$1, x) => {
      const type = primitiveMappings2[x._def.typeName];
      return type && !types$1.includes(type) ? [...types$1, type] : types$1;
    }, []);
    return { type: types.length > 1 ? types : types[0] };
  } else if (
    options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)
  ) {
    const types = options.reduce((acc, x) => {
      const type = typeof x._def.value;
      switch (type) {
        case "string":
        case "number":
        case "boolean":
          return [...acc, type];
        case "bigint":
          return [...acc, "integer"];
        case "object":
          if (x._def.value === null) return [...acc, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return acc;
      }
    }, []);
    if (types.length === options.length) {
      const uniqueTypes = types.filter((x, i2, a2) => a2.indexOf(x) === i2);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce((acc, x) => {
          return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
        }, []),
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum"))
    return {
      type: "string",
      enum: options.reduce(
        (acc, x) => [
          ...acc,
          ...x._def.values.filter((x$1) => !acc.includes(x$1)),
        ],
        [],
      ),
    };
  return asAnyOf2(def, refs);
}
var asAnyOf2 = (def, refs) => {
  const anyOf = (
    def.options instanceof Map ? Array.from(def.options.values()) : def.options
  )
    .map((x, i2) =>
      parseDef2(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "anyOf", `${i2}`],
      }),
    )
    .filter(
      (x) =>
        !!x &&
        (!refs.strictUnions ||
          (typeof x === "object" && Object.keys(x).length > 0)),
    );
  return anyOf.length ? { anyOf } : void 0;
};
function parseNullableDef2(def, refs) {
  if (
    ["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(
      def.innerType._def.typeName,
    ) &&
    (!def.innerType._def.checks || !def.innerType._def.checks.length)
  ) {
    if (refs.target === "openApi3")
      return {
        type: primitiveMappings2[def.innerType._def.typeName],
        nullable: true,
      };
    return { type: [primitiveMappings2[def.innerType._def.typeName], "null"] };
  }
  if (refs.target === "openApi3") {
    const base$1 = parseDef2(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath],
    });
    if (base$1 && "$ref" in base$1)
      return {
        allOf: [base$1],
        nullable: true,
      };
    return (
      base$1 && {
        ...base$1,
        nullable: true,
      }
    );
  }
  const base = parseDef2(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"],
  });
  return base && { anyOf: [base, { type: "null" }] };
}
function parseNumberDef2(def, refs) {
  const res = { type: "number" };
  if (!def.checks) return res;
  for (const check2 of def.checks)
    switch (check2.kind) {
      case "int":
        res.type = "integer";
        addErrorMessage(res, "type", check2.message, refs);
        break;
      case "min":
        if (refs.target === "jsonSchema7")
          if (check2.inclusive)
            setResponseValueAndErrors(
              res,
              "minimum",
              check2.value,
              check2.message,
              refs,
            );
          else
            setResponseValueAndErrors(
              res,
              "exclusiveMinimum",
              check2.value,
              check2.message,
              refs,
            );
        else {
          if (!check2.inclusive) res.exclusiveMinimum = true;
          setResponseValueAndErrors(
            res,
            "minimum",
            check2.value,
            check2.message,
            refs,
          );
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7")
          if (check2.inclusive)
            setResponseValueAndErrors(
              res,
              "maximum",
              check2.value,
              check2.message,
              refs,
            );
          else
            setResponseValueAndErrors(
              res,
              "exclusiveMaximum",
              check2.value,
              check2.message,
              refs,
            );
        else {
          if (!check2.inclusive) res.exclusiveMaximum = true;
          setResponseValueAndErrors(
            res,
            "maximum",
            check2.value,
            check2.message,
            refs,
          );
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(
          res,
          "multipleOf",
          check2.value,
          check2.message,
          refs,
        );
        break;
    }
  return res;
}
function parseObjectDef2(def, refs) {
  const forceOptionalIntoNullable = refs.target === "openAi";
  const result = {
    type: "object",
    properties: {},
  };
  const required3 = [];
  const shape = def.shape();
  for (const propName in shape) {
    let propDef = shape[propName];
    if (propDef === void 0 || propDef._def === void 0) continue;
    let propOptional = safeIsOptional2(propDef);
    if (propOptional && forceOptionalIntoNullable) {
      if (propDef._def.typeName === "ZodOptional")
        propDef = propDef._def.innerType;
      if (!propDef.isNullable()) propDef = propDef.nullable();
      propOptional = false;
    }
    const parsedDef = parseDef2(propDef._def, {
      ...refs,
      currentPath: [...refs.currentPath, "properties", propName],
      propertyPath: [...refs.currentPath, "properties", propName],
    });
    if (parsedDef === void 0) continue;
    result.properties[propName] = parsedDef;
    if (!propOptional) required3.push(propName);
  }
  if (required3.length) result.required = required3;
  const additionalProperties = decideAdditionalProperties2(def, refs);
  if (additionalProperties !== void 0)
    result.additionalProperties = additionalProperties;
  return result;
}
function decideAdditionalProperties2(def, refs) {
  if (def.catchall._def.typeName !== "ZodNever")
    return parseDef2(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"],
    });
  switch (def.unknownKeys) {
    case "passthrough":
      return refs.allowedAdditionalProperties;
    case "strict":
      return refs.rejectedAdditionalProperties;
    case "strip":
      return refs.removeAdditionalStrategy === "strict"
        ? refs.allowedAdditionalProperties
        : refs.rejectedAdditionalProperties;
  }
}
function safeIsOptional2(schema) {
  try {
    return schema.isOptional();
  } catch {
    return true;
  }
}
var parseOptionalDef2 = (def, refs) => {
  if (refs.currentPath.toString() === refs.propertyPath?.toString())
    return parseDef2(def.innerType._def, refs);
  const innerSchema = parseDef2(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "1"],
  });
  return innerSchema
    ? { anyOf: [{ not: parseAnyDef2(refs) }, innerSchema] }
    : parseAnyDef2(refs);
};
var parsePipelineDef2 = (def, refs) => {
  if (refs.pipeStrategy === "input") return parseDef2(def.in._def, refs);
  else if (refs.pipeStrategy === "output") return parseDef2(def.out._def, refs);
  const a2 = parseDef2(def.in._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", "0"],
  });
  const b2 = parseDef2(def.out._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", a2 ? "1" : "0"],
  });
  return { allOf: [a2, b2].filter((x) => x !== void 0) };
};
function parsePromiseDef2(def, refs) {
  return parseDef2(def.type._def, refs);
}
function parseSetDef2(def, refs) {
  const items = parseDef2(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"],
  });
  const schema = {
    type: "array",
    uniqueItems: true,
    items,
  };
  if (def.minSize)
    setResponseValueAndErrors(
      schema,
      "minItems",
      def.minSize.value,
      def.minSize.message,
      refs,
    );
  if (def.maxSize)
    setResponseValueAndErrors(
      schema,
      "maxItems",
      def.maxSize.value,
      def.maxSize.message,
      refs,
    );
  return schema;
}
function parseTupleDef2(def, refs) {
  if (def.rest)
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items
        .map((x, i2) =>
          parseDef2(x._def, {
            ...refs,
            currentPath: [...refs.currentPath, "items", `${i2}`],
          }),
        )
        .reduce((acc, x) => (x === void 0 ? acc : [...acc, x]), []),
      additionalItems: parseDef2(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"],
      }),
    };
  else
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items
        .map((x, i2) =>
          parseDef2(x._def, {
            ...refs,
            currentPath: [...refs.currentPath, "items", `${i2}`],
          }),
        )
        .reduce((acc, x) => (x === void 0 ? acc : [...acc, x]), []),
    };
}
function parseUndefinedDef2(refs) {
  return { not: parseAnyDef2(refs) };
}
function parseUnknownDef2(refs) {
  return parseAnyDef2(refs);
}
var parseReadonlyDef2 = (def, refs) => {
  return parseDef2(def.innerType._def, refs);
};
var selectParser2 = (def, typeName, refs) => {
  switch (typeName) {
    case ZodFirstPartyTypeKind.ZodString:
      return parseStringDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodNumber:
      return parseNumberDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodObject:
      return parseObjectDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodBigInt:
      return parseBigintDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodBoolean:
      return parseBooleanDef2();
    case ZodFirstPartyTypeKind.ZodDate:
      return parseDateDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodUndefined:
      return parseUndefinedDef2(refs);
    case ZodFirstPartyTypeKind.ZodNull:
      return parseNullDef2(refs);
    case ZodFirstPartyTypeKind.ZodArray:
      return parseArrayDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodUnion:
    case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      return parseUnionDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodIntersection:
      return parseIntersectionDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodTuple:
      return parseTupleDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodRecord:
      return parseRecordDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodLiteral:
      return parseLiteralDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodEnum:
      return parseEnumDef2(def);
    case ZodFirstPartyTypeKind.ZodNativeEnum:
      return parseNativeEnumDef2(def);
    case ZodFirstPartyTypeKind.ZodNullable:
      return parseNullableDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodOptional:
      return parseOptionalDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodMap:
      return parseMapDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodSet:
      return parseSetDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodLazy:
      return () => def.getter()._def;
    case ZodFirstPartyTypeKind.ZodPromise:
      return parsePromiseDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodNaN:
    case ZodFirstPartyTypeKind.ZodNever:
      return parseNeverDef2(refs);
    case ZodFirstPartyTypeKind.ZodEffects:
      return parseEffectsDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodAny:
      return parseAnyDef2(refs);
    case ZodFirstPartyTypeKind.ZodUnknown:
      return parseUnknownDef2(refs);
    case ZodFirstPartyTypeKind.ZodDefault:
      return parseDefaultDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodBranded:
      return parseBrandedDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodReadonly:
      return parseReadonlyDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodCatch:
      return parseCatchDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodPipeline:
      return parsePipelineDef2(def, refs);
    case ZodFirstPartyTypeKind.ZodFunction:
    case ZodFirstPartyTypeKind.ZodVoid:
    case ZodFirstPartyTypeKind.ZodSymbol:
      return void 0;
    default:
      return /* @__PURE__ */ ((_2) => void 0)(typeName);
  }
};
function parseDef2(def, refs, forceResolution = false) {
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = refs.override?.(
      def,
      refs,
      seenItem,
      forceResolution,
    );
    if (overrideResult !== ignoreOverride2) return overrideResult;
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref2(seenItem, refs);
    if (seenSchema !== void 0) return seenSchema;
  }
  const newItem = {
    def,
    path: refs.currentPath,
    jsonSchema: void 0,
  };
  refs.seen.set(def, newItem);
  const jsonSchemaOrGetter = selectParser2(def, def.typeName, refs);
  const jsonSchema2 =
    typeof jsonSchemaOrGetter === "function"
      ? parseDef2(jsonSchemaOrGetter(), refs)
      : jsonSchemaOrGetter;
  if (jsonSchema2) addMeta2(def, refs, jsonSchema2);
  if (refs.postProcess) {
    const postProcessResult = refs.postProcess(jsonSchema2, def, refs);
    newItem.jsonSchema = jsonSchema2;
    return postProcessResult;
  }
  newItem.jsonSchema = jsonSchema2;
  return jsonSchema2;
}
var get$ref2 = (item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "relative":
      return { $ref: getRelativePath2(refs.currentPath, item.path) };
    case "none":
    case "seen":
      if (
        item.path.length < refs.currentPath.length &&
        item.path.every((value, index) => refs.currentPath[index] === value)
      ) {
        console.warn(
          `Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`,
        );
        return parseAnyDef2(refs);
      }
      return refs.$refStrategy === "seen" ? parseAnyDef2(refs) : void 0;
  }
};
var addMeta2 = (def, refs, jsonSchema2) => {
  if (def.description) {
    jsonSchema2.description = def.description;
    if (refs.markdownDescription)
      jsonSchema2.markdownDescription = def.description;
  }
  return jsonSchema2;
};
var zodToJsonSchema2 = (schema, options) => {
  const refs = getRefs2(options);
  let definitions =
    typeof options === "object" && options.definitions
      ? Object.entries(options.definitions).reduce(
          (acc, [name$2, schema$1]) => ({
            ...acc,
            [name$2]:
              parseDef2(
                schema$1._def,
                {
                  ...refs,
                  currentPath: [...refs.basePath, refs.definitionPath, name$2],
                },
                true,
              ) ?? parseAnyDef2(refs),
          }),
          {},
        )
      : void 0;
  const name$1 =
    typeof options === "string"
      ? options
      : options?.nameStrategy === "title"
        ? void 0
        : options?.name;
  const main =
    parseDef2(
      schema._def,
      name$1 === void 0
        ? refs
        : {
            ...refs,
            currentPath: [...refs.basePath, refs.definitionPath, name$1],
          },
      false,
    ) ?? parseAnyDef2(refs);
  const title =
    typeof options === "object" &&
    options.name !== void 0 &&
    options.nameStrategy === "title"
      ? options.name
      : void 0;
  if (title !== void 0) main.title = title;
  if (refs.flags.hasReferencedOpenAiAnyType) {
    if (!definitions) definitions = {};
    if (!definitions[refs.openAiAnyTypeName])
      definitions[refs.openAiAnyTypeName] = {
        type: ["string", "number", "integer", "boolean", "array", "null"],
        items: {
          $ref:
            refs.$refStrategy === "relative"
              ? "1"
              : [
                  ...refs.basePath,
                  refs.definitionPath,
                  refs.openAiAnyTypeName,
                ].join("/"),
        },
      };
  }
  const combined =
    name$1 === void 0
      ? definitions
        ? {
            ...main,
            [refs.definitionPath]: definitions,
          }
        : main
      : {
          $ref: [
            ...(refs.$refStrategy === "relative" ? [] : refs.basePath),
            refs.definitionPath,
            name$1,
          ].join("/"),
          [refs.definitionPath]: {
            ...definitions,
            [name$1]: main,
          },
        };
  if (refs.target === "jsonSchema7")
    combined.$schema = "http://json-schema.org/draft-07/schema#";
  else if (refs.target === "jsonSchema2019-09" || refs.target === "openAi")
    combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
  if (
    refs.target === "openAi" &&
    ("anyOf" in combined ||
      "oneOf" in combined ||
      "allOf" in combined ||
      ("type" in combined && Array.isArray(combined.type)))
  )
    console.warn(
      "Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.",
    );
  return combined;
};
var package_default = {
  name: "exa-js",
  version: "1.9.3",
  description: "Exa SDK for Node.js and the browser",
  publishConfig: { access: "public" },
  files: ["dist"],
  main: "./dist/index.js",
  module: "./dist/index.mjs",
  exports: {
    ".": {
      types: "./dist/index.d.ts",
      require: "./dist/index.js",
      module: "./dist/index.mjs",
      import: "./dist/index.mjs",
    },
    "./package.json": "./package.json",
  },
  types: "./dist/index.d.ts",
  scripts: {
    "build-fast": "tsup src/index.ts --format cjs,esm",
    build: "tsup",
    test: "vitest run",
    typecheck: "tsc --noEmit",
    "typecheck:src": "tsc --noEmit src/**/*.ts",
    "typecheck:examples": "tsc --noEmit examples/**/*.ts",
    "generate:types:websets":
      "openapi-typescript https://raw.githubusercontent.com/exa-labs/openapi-spec/refs/heads/master/exa-websets-spec.yaml  --enum --root-types --alphabetize --root-types-no-schema-prefix --output ./src/websets/openapi.ts && npm run format:websets",
    format: 'prettier --write "src/**/*.ts" "examples/**/*.ts"',
    "format:websets": "prettier --write src/websets/openapi.ts",
    "build:beta": "cross-env NPM_CONFIG_TAG=beta npm run build",
    "version:beta": "npm version prerelease --preid=beta",
    "version:stable": "npm version patch",
    "publish:beta":
      "npm run version:beta && npm run build:beta && npm publish --tag beta",
    "publish:stable": "npm run version:stable && npm run build && npm publish",
    prepublishOnly: "npm run build",
  },
  license: "MIT",
  devDependencies: {
    "@types/node": "~22.14.0",
    "cross-env": "~7.0.3",
    "openapi-typescript": "~7.6.1",
    prettier: "~3.5.3",
    "ts-node": "~10.9.2",
    tsup: "~8.4.0",
    typescript: "~5.8.3",
    vitest: "~3.1.1",
  },
  dependencies: {
    "cross-fetch": "~4.1.0",
    dotenv: "~16.4.7",
    openai: "^5.0.1",
    zod: "^3.22.0",
    "zod-to-json-schema": "^3.20.0",
  },
  directories: { test: "test" },
  repository: {
    type: "git",
    url: "git+https://github.com/exa-labs/exa-js.git",
  },
  keywords: [
    "exa",
    "metaphor",
    "search",
    "AI",
    "LLMs",
    "RAG",
    "retrieval",
    "augmented",
    "generation",
  ],
  author: "jeffzwang",
  bugs: { url: "https://github.com/exa-labs/exa-js/issues" },
  homepage: "https://github.com/exa-labs/exa-js#readme",
};
var ExaError = class extends Error {
  /**
   * Create a new ExaError
   * @param message Error message
   * @param statusCode HTTP status code
   * @param timestamp ISO timestamp from API
   * @param path Path that caused the error
   */
  constructor(message, statusCode, timestamp, path) {
    super(message);
    this.name = "ExaError";
    this.statusCode = statusCode;
    this.timestamp = timestamp ?? /* @__PURE__ */ new Date().toISOString();
    this.path = path;
  }
};
function isZodSchema(obj) {
  return obj instanceof ZodType;
}
function zodToJsonSchema$1(schema) {
  return zodToJsonSchema2(schema, { $refStrategy: "none" });
}
var ResearchBaseClient = class {
  constructor(client) {
    this.client = client;
  }
  async request(endpoint2, method = "POST", data, params) {
    return this.client.request(
      `/research/v1${endpoint2}`,
      method,
      data,
      params,
    );
  }
  async rawRequest(endpoint2, method = "POST", data, params) {
    return this.client.rawRequest(
      `/research/v1${endpoint2}`,
      method,
      data,
      params,
    );
  }
  buildPaginationParams(pagination) {
    const params = {};
    if (!pagination) return params;
    if (pagination.cursor) params.cursor = pagination.cursor;
    if (pagination.limit) params.limit = pagination.limit;
    return params;
  }
};
var ResearchClient = class extends ResearchBaseClient {
  constructor(client) {
    super(client);
  }
  async create(params) {
    const { instructions, model, outputSchema: outputSchema2 } = params;
    let schema = outputSchema2;
    if (schema && isZodSchema(schema)) schema = zodToJsonSchema$1(schema);
    const payload = {
      instructions,
      model: model ?? "exa-research",
    };
    if (schema) payload.outputSchema = schema;
    return this.request("", "POST", payload);
  }
  get(researchId, options) {
    if (options?.stream) {
      const promise2 = async () => {
        const params = { stream: "true" };
        if (options.events !== void 0)
          params.events = options.events.toString();
        const resp = await this.rawRequest(
          `/${researchId}`,
          "GET",
          void 0,
          params,
        );
        if (!resp.body) throw new Error("No response body for SSE stream");
        const reader = resp.body.getReader();
        const decoder = new TextDecoder();
        let buffer = "";
        function processPart(part) {
          const lines = part.split("\n");
          let data = lines.slice(1).join("\n");
          if (data.startsWith("data:")) data = data.slice(5).trimStart();
          try {
            return JSON.parse(data);
          } catch (e2) {
            return null;
          }
        }
        async function* streamEvents() {
          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            buffer += decoder.decode(value, { stream: true });
            let parts = buffer.split("\n\n");
            buffer = parts.pop() ?? "";
            for (const part of parts) {
              const processed = processPart(part);
              if (processed) yield processed;
            }
          }
          if (buffer.trim()) {
            const processed = processPart(buffer.trim());
            if (processed) yield processed;
          }
        }
        return streamEvents();
      };
      return promise2();
    } else {
      const params = { stream: "false" };
      if (options?.events !== void 0) params.events = options.events.toString();
      return this.request(`/${researchId}`, "GET", void 0, params);
    }
  }
  async list(options) {
    const params = this.buildPaginationParams(options);
    return this.request("", "GET", void 0, params);
  }
  async pollUntilFinished(researchId, options) {
    const pollInterval = options?.pollInterval ?? 1e3;
    const timeoutMs = options?.timeoutMs ?? 600 * 1e3;
    const maxConsecutiveFailures = 5;
    const startTime = Date.now();
    let consecutiveFailures = 0;
    while (true) {
      try {
        const research = await this.get(researchId, {
          events: options?.events,
        });
        consecutiveFailures = 0;
        if (
          research.status === "completed" ||
          research.status === "failed" ||
          research.status === "canceled"
        )
          return research;
      } catch (err2) {
        consecutiveFailures += 1;
        if (consecutiveFailures >= maxConsecutiveFailures)
          throw new Error(
            `Polling failed ${maxConsecutiveFailures} times in a row for research ${researchId}: ${err2}`,
          );
      }
      if (Date.now() - startTime > timeoutMs)
        throw new Error(
          `Polling timeout: Research ${researchId} did not complete within ${timeoutMs}ms`,
        );
      await new Promise((resolve2) => setTimeout(resolve2, pollInterval));
    }
  }
};
var WebsetsBaseClient = class {
  /**
   * Initialize a new Websets base client
   * @param client The Exa client instance
   */
  constructor(client) {
    this.client = client;
  }
  /**
   * Make a request to the Websets API
   * @param endpoint The endpoint path
   * @param method The HTTP method
   * @param data Optional request body data
   * @param params Optional query parameters
   * @returns The response JSON
   * @throws ExaError with API error details if the request fails
   */
  async request(endpoint2, method = "POST", data, params, headers) {
    return this.client.request(
      `/websets${endpoint2}`,
      method,
      data,
      params,
      headers,
    );
  }
  /**
   * Helper to build pagination parameters
   * @param pagination The pagination parameters
   * @returns QueryParams object with pagination parameters
   */
  buildPaginationParams(pagination) {
    const params = {};
    if (!pagination) return params;
    if (pagination.cursor) params.cursor = pagination.cursor;
    if (pagination.limit) params.limit = pagination.limit;
    return params;
  }
};
var WebsetEnrichmentsClient = class extends WebsetsBaseClient {
  /**
   * Create an Enrichment for a Webset
   * @param websetId The ID of the Webset
   * @param params The enrichment parameters
   * @returns The created Webset Enrichment
   */
  async create(websetId, params) {
    return this.request(`/v0/websets/${websetId}/enrichments`, "POST", params);
  }
  /**
   * Get an Enrichment by ID
   * @param websetId The ID of the Webset
   * @param id The ID of the Enrichment
   * @returns The Webset Enrichment
   */
  async get(websetId, id) {
    return this.request(`/v0/websets/${websetId}/enrichments/${id}`, "GET");
  }
  /**
   * Delete an Enrichment
   * @param websetId The ID of the Webset
   * @param id The ID of the Enrichment
   * @returns The deleted Webset Enrichment
   */
  async delete(websetId, id) {
    return this.request(`/v0/websets/${websetId}/enrichments/${id}`, "DELETE");
  }
  /**
   * Update an Enrichment
   * @param websetId The ID of the Webset
   * @param id The ID of the Enrichment
   * @param params The enrichment update parameters
   * @returns Promise that resolves when the update is complete
   */
  async update(websetId, id, params) {
    return this.request(
      `/v0/websets/${websetId}/enrichments/${id}`,
      "PATCH",
      params,
    );
  }
  /**
   * Cancel a running Enrichment
   * @param websetId The ID of the Webset
   * @param id The ID of the Enrichment
   * @returns The canceled Webset Enrichment
   */
  async cancel(websetId, id) {
    return this.request(
      `/v0/websets/${websetId}/enrichments/${id}/cancel`,
      "POST",
    );
  }
};
var EventsClient = class extends WebsetsBaseClient {
  /**
   * Initialize a new Events client
   * @param client The Exa client instance
   */
  constructor(client) {
    super(client);
  }
  /**
   * List all Events
   * @param options Optional filtering and pagination options
   * @returns The list of Events
   */
  async list(options) {
    const params = {
      cursor: options?.cursor,
      limit: options?.limit,
      types: options?.types,
    };
    return this.request("/v0/events", "GET", void 0, params);
  }
  /**
   * Get an Event by ID
   * @param id The ID of the Event
   * @returns The Event
   */
  async get(id) {
    return this.request(`/v0/events/${id}`, "GET");
  }
};
var ImportsClient = class extends WebsetsBaseClient {
  async create(params, csv) {
    if (csv === void 0) return this.request("/v0/imports", "POST", params);
    let csvBuffer;
    if (typeof csv === "string") csvBuffer = Buffer.from(csv, "utf8");
    else if (Buffer.isBuffer(csv)) csvBuffer = csv;
    else
      throw new ExaError(
        "Invalid CSV data input. Must be string or Buffer",
        400,
      );
    const sizeInBytes = csvBuffer.length;
    const sizeInMB = Math.max(1, Math.ceil(sizeInBytes / (1024 * 1024)));
    const csvText = csvBuffer.toString("utf8");
    const lines = csvText.split("\n").filter((line) => line.trim().length > 0);
    const recordCount = Math.max(0, lines.length - 1);
    if (sizeInMB > 50)
      throw new ExaError(
        `CSV file too large: ${sizeInMB}MB. Maximum size is 50MB.`,
        400,
      );
    if (recordCount === 0)
      throw new ExaError(
        "CSV file appears to have no data records (only header or empty)",
        400,
      );
    const createParams = {
      title: params.title,
      format: "csv",
      entity: params.entity,
      size: sizeInBytes,
      count: recordCount,
      metadata: params.metadata,
      csv: params.csv,
    };
    const importResponse = await this.request(
      "/v0/imports",
      "POST",
      createParams,
    );
    try {
      const uploadResponse = await fetch(importResponse.uploadUrl, {
        method: "PUT",
        body: csvBuffer,
      });
      if (!uploadResponse.ok) {
        const errorText = await uploadResponse.text();
        throw new ExaError(
          `Upload failed: ${uploadResponse.status} ${uploadResponse.statusText}. ${errorText}`,
          400,
        );
      }
    } catch (error45) {
      if (error45 instanceof ExaError) throw error45;
      throw new ExaError(`Failed to upload CSV data: ${error45.message}`, 400);
    }
    return importResponse;
  }
  /**
   * Get an Import by ID
   * @param id The ID of the Import
   * @returns The Import
   */
  async get(id) {
    return this.request(`/v0/imports/${id}`, "GET");
  }
  /**
   * List all Imports
   * @param options Pagination options
   * @returns The list of Imports
   */
  async list(options) {
    const params = this.buildPaginationParams(options);
    return this.request("/v0/imports", "GET", void 0, params);
  }
  /**
   * Update an Import
   * @param id The ID of the Import
   * @param params The import update parameters
   * @returns The updated Import
   */
  async update(id, params) {
    return this.request(`/v0/imports/${id}`, "PATCH", params);
  }
  /**
   * Delete an Import
   * @param id The ID of the Import
   * @returns The deleted Import
   */
  async delete(id) {
    return this.request(`/v0/imports/${id}`, "DELETE");
  }
  /**
   * Wait until an Import is completed or failed
   * @param id The ID of the Import
   * @param options Configuration options for timeout and polling
   * @returns The Import once it reaches a final state (completed or failed)
   * @throws Error if the Import does not complete within the timeout or fails
   */
  async waitUntilCompleted(id, options) {
    const timeout = options?.timeout ?? 1800 * 1e3;
    const pollInterval = options?.pollInterval ?? 2e3;
    const onPoll = options?.onPoll;
    const startTime = Date.now();
    while (true) {
      const importItem = await this.get(id);
      if (onPoll) onPoll(importItem.status);
      if (importItem.status === "completed") return importItem;
      if (importItem.status === "failed")
        throw new ExaError(
          `Import ${id} failed: ${importItem.failedMessage || "Unknown error"}`,
          400,
        );
      if (Date.now() - startTime > timeout)
        throw new ExaError(
          `Import ${id} did not complete within ${timeout}ms. Current status: ${importItem.status}`,
          408,
        );
      await new Promise((resolve2) => setTimeout(resolve2, pollInterval));
    }
  }
};
var WebsetItemsClient = class extends WebsetsBaseClient {
  /**
   * List all Items for a Webset
   * @param websetId The ID of the Webset
   * @param params - Optional pagination and filtering parameters
   * @returns A promise that resolves with the list of Items
   */
  list(websetId, params) {
    const queryParams = {
      ...this.buildPaginationParams(params),
      sourceId: params?.sourceId,
    };
    return this.request(
      `/v0/websets/${websetId}/items`,
      "GET",
      void 0,
      queryParams,
    );
  }
  /**
   * Iterate through all Items in a Webset, handling pagination automatically
   * @param websetId The ID of the Webset
   * @param options Pagination options
   * @returns Async generator of Webset Items
   */
  async *listAll(websetId, options) {
    let cursor = void 0;
    const pageOptions = options ? { ...options } : {};
    while (true) {
      pageOptions.cursor = cursor;
      const response = await this.list(websetId, pageOptions);
      for (const item of response.data) yield item;
      if (!response.hasMore || !response.nextCursor) break;
      cursor = response.nextCursor;
    }
  }
  /**
   * Collect all items from a Webset into an array
   * @param websetId The ID of the Webset
   * @param options Pagination options
   * @returns Promise resolving to an array of all Webset Items
   */
  async getAll(websetId, options) {
    const items = [];
    for await (const item of this.listAll(websetId, options)) items.push(item);
    return items;
  }
  /**
   * Get an Item by ID
   * @param websetId The ID of the Webset
   * @param id The ID of the Item
   * @returns The Webset Item
   */
  async get(websetId, id) {
    return this.request(`/v0/websets/${websetId}/items/${id}`, "GET");
  }
  /**
   * Delete an Item
   * @param websetId The ID of the Webset
   * @param id The ID of the Item
   * @returns The deleted Webset Item
   */
  async delete(websetId, id) {
    return this.request(`/v0/websets/${websetId}/items/${id}`, "DELETE");
  }
};
var WebsetMonitorRunsClient = class extends WebsetsBaseClient {
  /**
   * List all runs for a Monitor
   * @param monitorId The ID of the Monitor
   * @param options Pagination options
   * @returns The list of Monitor runs
   */
  async list(monitorId, options) {
    const params = this.buildPaginationParams(options);
    return this.request(
      `/v0/monitors/${monitorId}/runs`,
      "GET",
      void 0,
      params,
    );
  }
  /**
   * Get a specific Monitor run
   * @param monitorId The ID of the Monitor
   * @param runId The ID of the Monitor run
   * @returns The Monitor run
   */
  async get(monitorId, runId) {
    return this.request(`/v0/monitors/${monitorId}/runs/${runId}`, "GET");
  }
};
var WebsetMonitorsClient = class extends WebsetsBaseClient {
  constructor(client) {
    super(client);
    this.runs = new WebsetMonitorRunsClient(client);
  }
  /**
   * Create a Monitor
   * @param params The monitor parameters
   * @returns The created Monitor
   */
  async create(params) {
    return this.request("/v0/monitors", "POST", params);
  }
  /**
   * Get a Monitor by ID
   * @param id The ID of the Monitor
   * @returns The Monitor
   */
  async get(id) {
    return this.request(`/v0/monitors/${id}`, "GET");
  }
  /**
   * List all Monitors
   * @param options Pagination and filtering options
   * @returns The list of Monitors
   */
  async list(options) {
    const params = {
      cursor: options?.cursor,
      limit: options?.limit,
      websetId: options?.websetId,
    };
    return this.request("/v0/monitors", "GET", void 0, params);
  }
  /**
   * Update a Monitor
   * @param id The ID of the Monitor
   * @param params The monitor update parameters (status, metadata)
   * @returns The updated Monitor
   */
  async update(id, params) {
    return this.request(`/v0/monitors/${id}`, "PATCH", params);
  }
  /**
   * Delete a Monitor
   * @param id The ID of the Monitor
   * @returns The deleted Monitor
   */
  async delete(id) {
    return this.request(`/v0/monitors/${id}`, "DELETE");
  }
};
var WebsetSearchesClient = class extends WebsetsBaseClient {
  /**
   * Create a new Search for the Webset
   * @param websetId The ID of the Webset
   * @param params The search parameters
   * @returns The created Webset Search
   */
  async create(websetId, params, options) {
    return this.request(
      `/v0/websets/${websetId}/searches`,
      "POST",
      params,
      void 0,
      options?.headers,
    );
  }
  /**
   * Get a Search by ID
   * @param websetId The ID of the Webset
   * @param id The ID of the Search
   * @returns The Webset Search
   */
  async get(websetId, id) {
    return this.request(`/v0/websets/${websetId}/searches/${id}`, "GET");
  }
  /**
   * Cancel a running Search
   * @param websetId The ID of the Webset
   * @param id The ID of the Search
   * @returns The canceled Webset Search
   */
  async cancel(websetId, id) {
    return this.request(
      `/v0/websets/${websetId}/searches/${id}/cancel`,
      "POST",
    );
  }
};
var WebsetWebhooksClient = class extends WebsetsBaseClient {
  /**
   * Create a Webhook
   * @param params The webhook parameters
   * @returns The created Webhook
   */
  async create(params) {
    return this.request("/v0/webhooks", "POST", params);
  }
  /**
   * Get a Webhook by ID
   * @param id The ID of the Webhook
   * @returns The Webhook
   */
  async get(id) {
    return this.request(`/v0/webhooks/${id}`, "GET");
  }
  /**
   * List all Webhooks
   * @param options Pagination options
   * @returns The list of Webhooks
   */
  async list(options) {
    const params = this.buildPaginationParams(options);
    return this.request("/v0/webhooks", "GET", void 0, params);
  }
  /**
   * Iterate through all Webhooks, handling pagination automatically
   * @param options Pagination options
   * @returns Async generator of Webhooks
   */
  async *listAll(options) {
    let cursor = void 0;
    const pageOptions = options ? { ...options } : {};
    while (true) {
      pageOptions.cursor = cursor;
      const response = await this.list(pageOptions);
      for (const webhook of response.data) yield webhook;
      if (!response.hasMore || !response.nextCursor) break;
      cursor = response.nextCursor;
    }
  }
  /**
   * Collect all Webhooks into an array
   * @param options Pagination options
   * @returns Promise resolving to an array of all Webhooks
   */
  async getAll(options) {
    const webhooks = [];
    for await (const webhook of this.listAll(options)) webhooks.push(webhook);
    return webhooks;
  }
  /**
   * Update a Webhook
   * @param id The ID of the Webhook
   * @param params The webhook update parameters (events, metadata, url)
   * @returns The updated Webhook
   */
  async update(id, params) {
    return this.request(`/v0/webhooks/${id}`, "PATCH", params);
  }
  /**
   * Delete a Webhook
   * @param id The ID of the Webhook
   * @returns The deleted Webhook
   */
  async delete(id) {
    return this.request(`/v0/webhooks/${id}`, "DELETE");
  }
  /**
   * List all attempts for a Webhook
   * @param id The ID of the Webhook
   * @param options Pagination and filtering options
   * @returns The list of Webhook attempts
   */
  async listAttempts(id, options) {
    const params = {
      cursor: options?.cursor,
      limit: options?.limit,
      eventType: options?.eventType,
      successful: options?.successful,
    };
    return this.request(`/v0/webhooks/${id}/attempts`, "GET", void 0, params);
  }
  /**
   * Iterate through all attempts for a Webhook, handling pagination automatically
   * @param id The ID of the Webhook
   * @param options Pagination and filtering options
   * @returns Async generator of Webhook attempts
   */
  async *listAllAttempts(id, options) {
    let cursor = void 0;
    const pageOptions = options ? { ...options } : {};
    while (true) {
      pageOptions.cursor = cursor;
      const response = await this.listAttempts(id, pageOptions);
      for (const attempt of response.data) yield attempt;
      if (!response.hasMore || !response.nextCursor) break;
      cursor = response.nextCursor;
    }
  }
  /**
   * Collect all attempts for a Webhook into an array
   * @param id The ID of the Webhook
   * @param options Pagination and filtering options
   * @returns Promise resolving to an array of all Webhook attempts
   */
  async getAllAttempts(id, options) {
    const attempts = [];
    for await (const attempt of this.listAllAttempts(id, options))
      attempts.push(attempt);
    return attempts;
  }
};
var WebsetsClient = class extends WebsetsBaseClient {
  /**
   * Initialize a new Websets client
   * @param client The Exa client instance
   */
  constructor(client) {
    super(client);
    this.events = new EventsClient(client);
    this.imports = new ImportsClient(client);
    this.items = new WebsetItemsClient(client);
    this.searches = new WebsetSearchesClient(client);
    this.enrichments = new WebsetEnrichmentsClient(client);
    this.monitors = new WebsetMonitorsClient(client);
    this.webhooks = new WebsetWebhooksClient(client);
  }
  /**
   * Create a new Webset
   * @param params The Webset creation parameters
   * @returns The created Webset
   */
  async create(params, options) {
    return this.request(
      "/v0/websets",
      "POST",
      params,
      void 0,
      options?.headers,
    );
  }
  /**
   * Preview a webset
   * @param params The preview parameters
   * @returns The preview response showing how the query will be decomposed
   */
  async preview(params) {
    return this.request("/v0/websets/preview", "POST", params);
  }
  /**
   * Get a Webset by ID
   * @param id The ID of the Webset
   * @param expand Optional array of relations to expand
   * @returns The Webset
   */
  async get(id, expand2) {
    const params = {};
    if (expand2) params.expand = expand2;
    return this.request(`/v0/websets/${id}`, "GET", void 0, params);
  }
  /**
   * List all Websets
   * @param options Pagination options (filtering by status is not supported by API)
   * @returns The list of Websets
   */
  async list(options) {
    const params = this.buildPaginationParams(options);
    return this.request("/v0/websets", "GET", void 0, params);
  }
  /**
   * Iterate through all Websets, handling pagination automatically
   * @param options Pagination options
   * @returns Async generator of Websets
   */
  async *listAll(options) {
    let cursor = void 0;
    const pageOptions = options ? { ...options } : {};
    while (true) {
      pageOptions.cursor = cursor;
      const response = await this.list(pageOptions);
      for (const webset of response.data) yield webset;
      if (!response.hasMore || !response.nextCursor) break;
      cursor = response.nextCursor;
    }
  }
  /**
   * Collect all Websets into an array
   * @param options Pagination options
   * @returns Promise resolving to an array of all Websets
   */
  async getAll(options) {
    const websets = [];
    for await (const webset of this.listAll(options)) websets.push(webset);
    return websets;
  }
  /**
   * Update a Webset
   * @param id The ID of the Webset
   * @param params The Webset update parameters
   * @returns The updated Webset
   */
  async update(id, params) {
    return this.request(`/v0/websets/${id}`, "POST", params);
  }
  /**
   * Delete a Webset
   * @param id The ID of the Webset
   * @returns The deleted Webset
   */
  async delete(id) {
    return this.request(`/v0/websets/${id}`, "DELETE");
  }
  /**
   * Cancel a running Webset
   * @param id The ID or external ID of the Webset
   * @returns The canceled Webset (as returned by the API)
   */
  async cancel(id) {
    return this.request(`/v0/websets/${id}/cancel`, "POST");
  }
  /**
   * Wait until a Webset is idle
   * @param id The ID of the Webset
   * @param options Configuration options for timeout and polling
   * @returns The Webset once it becomes idle
   * @throws Error if the Webset does not become idle within the timeout
   */
  async waitUntilIdle(id, options) {
    let timeout;
    let pollInterval = 1e3;
    let onPoll;
    if (typeof options === "number") timeout = options;
    else if (options) {
      timeout = options.timeout;
      pollInterval = options.pollInterval || 1e3;
      onPoll = options.onPoll;
    }
    const startTime = Date.now();
    while (true) {
      const webset = await this.get(id);
      if (onPoll) onPoll(webset.status);
      if (webset.status === "idle") return webset;
      if (timeout && Date.now() - startTime > timeout)
        throw new ExaError(
          `Webset ${id} did not reach idle state within ${timeout}ms. Current status: ${webset.status}`,
          408,
        );
      await new Promise((resolve2) => setTimeout(resolve2, pollInterval));
    }
  }
};
var fetchImpl =
  typeof global !== "undefined" && global.fetch
    ? global.fetch
    : import_node_ponyfill.default;
var HeadersImpl =
  typeof global !== "undefined" && global.Headers
    ? global.Headers
    : import_node_ponyfill.Headers;
var Exa2 = class {
  /**
   * Helper method to separate out the contents-specific options from the rest.
   */
  extractContentsOptions(options) {
    const {
      text: text2,
      highlights,
      summary,
      subpages,
      subpageTarget,
      extras,
      livecrawl,
      livecrawlTimeout,
      context,
      ...rest
    } = options;
    const contentsOptions = {};
    if (
      text2 === void 0 &&
      summary === void 0 &&
      highlights === void 0 &&
      extras === void 0
    )
      contentsOptions.text = true;
    if (text2 !== void 0) contentsOptions.text = text2;
    if (summary !== void 0)
      if (
        typeof summary === "object" &&
        summary !== null &&
        "schema" in summary &&
        summary.schema &&
        isZodSchema(summary.schema)
      )
        contentsOptions.summary = {
          ...summary,
          schema: zodToJsonSchema$1(summary.schema),
        };
      else contentsOptions.summary = summary;
    if (highlights !== void 0) contentsOptions.highlights = highlights;
    if (subpages !== void 0) contentsOptions.subpages = subpages;
    if (subpageTarget !== void 0) contentsOptions.subpageTarget = subpageTarget;
    if (extras !== void 0) contentsOptions.extras = extras;
    if (livecrawl !== void 0) contentsOptions.livecrawl = livecrawl;
    if (livecrawlTimeout !== void 0)
      contentsOptions.livecrawlTimeout = livecrawlTimeout;
    if (context !== void 0) contentsOptions.context = context;
    return {
      contentsOptions,
      restOptions: rest,
    };
  }
  /**
   * Constructs the Exa API client.
   * @param {string} apiKey - The API key for authentication.
   * @param {string} [baseURL] - The base URL of the Exa API.
   */
  constructor(apiKey, baseURL = "https://api.exa.ai") {
    this.baseURL = baseURL;
    if (!apiKey) {
      apiKey = process.env.EXASEARCH_API_KEY;
      if (!apiKey)
        throw new ExaError(
          "API key must be provided as an argument or as an environment variable (EXASEARCH_API_KEY)",
          401,
        );
    }
    this.headers = new HeadersImpl({
      "x-api-key": apiKey,
      "Content-Type": "application/json",
      "User-Agent": `exa-node ${package_default.version}`,
    });
    this.websets = new WebsetsClient(this);
    this.research = new ResearchClient(this);
  }
  /**
   * Makes a request to the Exa API.
   * @param {string} endpoint - The API endpoint to call.
   * @param {string} method - The HTTP method to use.
   * @param {any} [body] - The request body for POST requests.
   * @param {Record<string, any>} [params] - The query parameters.
   * @returns {Promise<any>} The response from the API.
   * @throws {ExaError} When any API request fails with structured error information
   */
  async request(endpoint2, method, body, params, headers) {
    let url2 = this.baseURL + endpoint2;
    if (params && Object.keys(params).length > 0) {
      const searchParams = new URLSearchParams();
      for (const [key, value] of Object.entries(params))
        if (Array.isArray(value))
          for (const item of value) searchParams.append(key, item);
        else if (value !== void 0) searchParams.append(key, String(value));
      url2 += `?${searchParams.toString()}`;
    }
    let combinedHeaders = {};
    if (this.headers instanceof HeadersImpl)
      this.headers.forEach((value, key) => {
        combinedHeaders[key] = value;
      });
    else combinedHeaders = { ...this.headers };
    if (headers)
      combinedHeaders = {
        ...combinedHeaders,
        ...headers,
      };
    console.log(url2);
    const response = await fetchImpl(url2, {
      method,
      headers: combinedHeaders,
      body: body ? JSON.stringify(body) : void 0,
    });
    if (!response.ok) {
      const errorData = await response.json();
      if (!errorData.statusCode) errorData.statusCode = response.status;
      if (!errorData.timestamp)
        errorData.timestamp = /* @__PURE__ */ new Date().toISOString();
      if (!errorData.path) errorData.path = endpoint2;
      let message = errorData.error || "Unknown error";
      if (errorData.message)
        message += (message.length > 0 ? ". " : "") + errorData.message;
      throw new ExaError(
        message,
        response.status,
        errorData.timestamp,
        errorData.path,
      );
    }
    const contentType = response.headers.get("content-type") || "";
    if (contentType.includes("text/event-stream"))
      return await this.parseSSEStream(response);
    return await response.json();
  }
  async rawRequest(endpoint2, method = "POST", body, queryParams) {
    let url2 = this.baseURL + endpoint2;
    if (queryParams) {
      const searchParams = new URLSearchParams();
      for (const [key, value] of Object.entries(queryParams))
        if (Array.isArray(value))
          for (const item of value) searchParams.append(key, String(item));
        else if (value !== void 0) searchParams.append(key, String(value));
      url2 += `?${searchParams.toString()}`;
    }
    const response = await fetchImpl(url2, {
      method,
      headers: this.headers,
      body: body ? JSON.stringify(body) : void 0,
    });
    return response;
  }
  /**
   * Performs a search with an Exa prompt-engineered query.
   *
   * @param {string} query - The query string.
   * @param {RegularSearchOptions} [options] - Additional search options
   * @returns {Promise<SearchResponse<{}>>} A list of relevant search results.
   */
  async search(query, options) {
    return await this.request("/search", "POST", {
      query,
      ...options,
    });
  }
  /**
   * Performs a search with an Exa prompt-engineered query and returns the contents of the documents.
   *
   * @param {string} query - The query string.
   * @param {RegularSearchOptions & T} [options] - Additional search + contents options
   * @returns {Promise<SearchResponse<T>>} A list of relevant search results with requested contents.
   */
  async searchAndContents(query, options) {
    const { contentsOptions, restOptions } =
      options === void 0
        ? {
            contentsOptions: { text: true },
            restOptions: {},
          }
        : this.extractContentsOptions(options);
    return await this.request("/search", "POST", {
      query,
      contents: contentsOptions,
      ...restOptions,
    });
  }
  /**
   * Finds similar links to the provided URL.
   * @param {string} url - The URL for which to find similar links.
   * @param {FindSimilarOptions} [options] - Additional options for finding similar links.
   * @returns {Promise<SearchResponse<{}>>} A list of similar search results.
   */
  async findSimilar(url2, options) {
    return await this.request("/findSimilar", "POST", {
      url: url2,
      ...options,
    });
  }
  /**
   * Finds similar links to the provided URL and returns the contents of the documents.
   * @param {string} url - The URL for which to find similar links.
   * @param {FindSimilarOptions & T} [options] - Additional options for finding similar links + contents.
   * @returns {Promise<SearchResponse<T>>} A list of similar search results, including requested contents.
   */
  async findSimilarAndContents(url2, options) {
    const { contentsOptions, restOptions } =
      options === void 0
        ? {
            contentsOptions: { text: true },
            restOptions: {},
          }
        : this.extractContentsOptions(options);
    return await this.request("/findSimilar", "POST", {
      url: url2,
      contents: contentsOptions,
      ...restOptions,
    });
  }
  /**
   * Retrieves contents of documents based on URLs.
   * @param {string | string[] | SearchResult[]} urls - A URL or array of URLs, or an array of SearchResult objects.
   * @param {ContentsOptions} [options] - Additional options for retrieving document contents.
   * @returns {Promise<SearchResponse<T>>} A list of document contents for the requested URLs.
   */
  async getContents(urls, options) {
    if (!urls || (Array.isArray(urls) && urls.length === 0))
      throw new ExaError("Must provide at least one URL", 400);
    let requestUrls;
    if (typeof urls === "string") requestUrls = [urls];
    else if (typeof urls[0] === "string") requestUrls = urls;
    else requestUrls = urls.map((result) => result.url);
    const payload = {
      urls: requestUrls,
      ...options,
    };
    return await this.request("/contents", "POST", payload);
  }
  async answer(query, options) {
    if (options?.stream)
      throw new ExaError(
        "For streaming responses, please use streamAnswer() instead:\n\nfor await (const chunk of exa.streamAnswer(query)) {\n  // Handle chunks\n}",
        400,
      );
    let outputSchema2 = options?.outputSchema;
    if (outputSchema2 && isZodSchema(outputSchema2))
      outputSchema2 = zodToJsonSchema$1(outputSchema2);
    const requestBody = {
      query,
      stream: false,
      text: options?.text ?? false,
      model: options?.model ?? "exa",
      systemPrompt: options?.systemPrompt,
      outputSchema: outputSchema2,
      userLocation: options?.userLocation,
    };
    return await this.request("/answer", "POST", requestBody);
  }
  async *streamAnswer(query, options) {
    let outputSchema2 = options?.outputSchema;
    if (outputSchema2 && isZodSchema(outputSchema2))
      outputSchema2 = zodToJsonSchema$1(outputSchema2);
    const body = {
      query,
      text: options?.text ?? false,
      stream: true,
      model: options?.model ?? "exa",
      systemPrompt: options?.systemPrompt,
      outputSchema: outputSchema2,
    };
    const response = await fetchImpl(this.baseURL + "/answer", {
      method: "POST",
      headers: this.headers,
      body: JSON.stringify(body),
    });
    if (!response.ok) {
      const message = await response.text();
      throw new ExaError(
        message,
        response.status,
        /* @__PURE__ */ new Date().toISOString(),
      );
    }
    const reader = response.body?.getReader();
    if (!reader)
      throw new ExaError(
        "No response body available for streaming.",
        500,
        /* @__PURE__ */ new Date().toISOString(),
      );
    const decoder = new TextDecoder();
    let buffer = "";
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split("\n");
        buffer = lines.pop() || "";
        for (const line of lines) {
          if (!line.startsWith("data: ")) continue;
          const jsonStr = line.replace(/^data:\s*/, "").trim();
          if (!jsonStr || jsonStr === "[DONE]") continue;
          let chunkData;
          try {
            chunkData = JSON.parse(jsonStr);
          } catch (err2) {
            continue;
          }
          const chunk = this.processChunk(chunkData);
          if (chunk.content || chunk.citations) yield chunk;
        }
      }
      if (buffer.startsWith("data: ")) {
        const leftover = buffer.replace(/^data:\s*/, "").trim();
        if (leftover && leftover !== "[DONE]")
          try {
            const chunkData = JSON.parse(leftover);
            const chunk = this.processChunk(chunkData);
            if (chunk.content || chunk.citations) yield chunk;
          } catch (e2) {}
      }
    } finally {
      reader.releaseLock();
    }
  }
  processChunk(chunkData) {
    let content;
    let citations;
    if (chunkData.choices && chunkData.choices[0] && chunkData.choices[0].delta)
      content = chunkData.choices[0].delta.content;
    if (chunkData.citations && chunkData.citations !== "null")
      citations = chunkData.citations.map((c2) => ({
        id: c2.id,
        url: c2.url,
        title: c2.title,
        publishedDate: c2.publishedDate,
        author: c2.author,
        text: c2.text,
      }));
    return {
      content,
      citations,
    };
  }
  async parseSSEStream(response) {
    const reader = response.body?.getReader();
    if (!reader)
      throw new ExaError(
        "No response body available for streaming.",
        500,
        /* @__PURE__ */ new Date().toISOString(),
      );
    const decoder = new TextDecoder();
    let buffer = "";
    return new Promise(async (resolve2, reject) => {
      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split("\n");
          buffer = lines.pop() || "";
          for (const line of lines) {
            if (!line.startsWith("data: ")) continue;
            const jsonStr = line.replace(/^data:\s*/, "").trim();
            if (!jsonStr || jsonStr === "[DONE]") continue;
            let chunk;
            try {
              chunk = JSON.parse(jsonStr);
            } catch {
              continue;
            }
            switch (chunk.tag) {
              case "complete":
                reader.releaseLock();
                resolve2(chunk.data);
                return;
              case "error": {
                const message = chunk.error?.message || "Unknown error";
                reader.releaseLock();
                reject(
                  new ExaError(
                    message,
                    500,
                    /* @__PURE__ */ new Date().toISOString(),
                  ),
                );
                return;
              }
              default:
                break;
            }
          }
        }
        reject(
          new ExaError(
            "Stream ended without a completion event.",
            500,
            /* @__PURE__ */ new Date().toISOString(),
          ),
        );
      } catch (err2) {
        reject(err2);
      } finally {
        try {
          reader.releaseLock();
        } catch {}
      }
    });
  }
};
var exa = () => {
  let exaClient;
  if (process.env.EXA_API_KEY) exaClient = new Exa2(process.env.EXA_API_KEY);
  else if (process.env.BLINK_INVOCATION_AUTH_TOKEN)
    exaClient = new Exa2(
      process.env.BLINK_INVOCATION_AUTH_TOKEN,
      "https://blink.so/api/tools/exa",
    );
  else if (process.env.BLINK_TOKEN)
    exaClient = new Exa2(
      process.env.BLINK_TOKEN,
      "https://blink.so/api/tools/exa",
    );
  else {
    console.warn(
      `You must set the EXA_API_KEY environment variable or be authenticated with Blink to use the web search SDK.`,
    );
    throw new Error(
      "The EXA_API_KEY environment variable or a Blink token must be set to use the web search SDK.",
    );
  }
  return exaClient;
};
var tools2 = {
  web_search: tool2({
    description:
      "Perform a search query on the web, and retrieve the most relevant URLs/web data.",
    inputSchema: external_exports.object({ query: external_exports.string() }),
    execute: async ({ query }) => {
      const results = await exa().searchAndContents(query, {
        numResults: 5,
        type: "auto",
        text: { maxCharacters: 3e3 },
        livecrawl: "preferred",
      });
      return results;
    },
  }),
};

// node_modules/@blink-sdk/slackbot/dist/webhook-BYGoz5jG.js
var import_slack_edge = __toESM(require_dist3(), 1);
function formatSlackMessage(text2) {
  const maxLength = 3e3;
  if (text2.length > maxLength) text2 = text2.slice(0, maxLength);
  text2 = text2.replace(/\[([^\]]+)\]\(([^)]+)\)/g, "<$2|$1>");
  text2 = text2.replace(/\*\*([^*]+)\*\*/g, "*$1*");
  text2 = text2.replace(
    /(?<!<)@(U|W)[A-Z0-9]{8,}(?!>)/g,
    (match) => `<${match}>`,
  );
  text2 = text2.replace(
    /(^|[^A-Z0-9<@])((?:U|W)[A-Z0-9]{8,})(?![A-Z0-9>])/g,
    (m2, prefix, id) => `${prefix}<@${id}>`,
  );
  text2 = text2.replace(/<@([a-z0-9._-]+)>/gi, (m2, u2) =>
    /^[UW][A-Z0-9]{8,}$/.test(u2) ? m2 : `@${u2}`,
  );
  return text2;
}
var getTokenStorageKey = (teamId) => `slackbot_token_${teamId}`;
var ensureSecrets = () => {
  const createError = (name18) => {
    return /* @__PURE__ */ new Error(`${name18} is not set`);
  };
  if (!process.env.SLACK_CLIENT_ID) throw createError("SLACK_CLIENT_ID");
  if (!process.env.SLACK_CLIENT_SECRET)
    throw createError("SLACK_CLIENT_SECRET");
  if (!process.env.SLACK_SIGNING_SECRET)
    throw createError("SLACK_SIGNING_SECRET");
  return {
    clientId: process.env.SLACK_CLIENT_ID,
    clientSecret: process.env.SLACK_CLIENT_SECRET,
    signingSecret: process.env.SLACK_SIGNING_SECRET,
  };
};
async function getRefreshedToken(teamId) {
  const token = await getToken(teamId);
  if (!token) return void 0;
  if (token.expiresAt > Date.now()) return token;
  const client = new import_slack_edge.SlackAPIClient();
  const { clientId, clientSecret } = ensureSecrets();
  const response = await client.oauth.v2.access({
    client_id: clientId,
    client_secret: clientSecret,
    refresh_token: token.refreshToken,
    grant_type: "refresh_token",
  });
  if (!response.ok)
    throw new Error(
      `Failed to refresh token for team ${teamId}: ${response.error}`,
    );
  return saveToken(response);
}
async function getToken(teamId) {
  const token = await S2.storage.kv.get(getTokenStorageKey(teamId));
  if (!token) return void 0;
  return JSON.parse(token);
}
async function saveToken(oauthResponse) {
  const ensureProperty = (name18) => {
    if (!oauthResponse[name18])
      throw new Error(
        `${name18} was not returned from the Slack OAuth exchange. This is a bug in the Slack SDK. Please report this to https://github.com/coder/blink/issues.`,
      );
    return oauthResponse[name18];
  };
  const teamId = ensureProperty("team").id;
  if (!teamId)
    throw new Error(
      "team.id was not returned from the Slack OAuth exchange. This is a bug in the Slack SDK. Please report this to https://github.com/coder/blink/issues.",
    );
  const tokenData = {
    accessToken: ensureProperty("access_token"),
    refreshToken: ensureProperty("refresh_token"),
    expiresAt: Date.now() + ensureProperty("expires_in") * 1e3,
    scopes: ensureProperty("scope").split(","),
    botId: ensureProperty("app_id"),
    botUserId: ensureProperty("bot_user_id"),
  };
  await S2.storage.kv.set(
    getTokenStorageKey(teamId),
    JSON.stringify(tokenData),
  );
  return tokenData;
}
var isOAuthRequest = (request2) => {
  const url2 = new URL(request2.url);
  return Boolean(url2.searchParams.get("code"));
};
var handleOAuthRequest = async (request2, options) => {
  const url2 = new URL(request2.url);
  const code = url2.searchParams.get("code");
  if (!code)
    return new Response("No authorization code provided", { status: 400 });
  const client = new import_slack_edge.SlackAPIClient();
  try {
    const secrets = ensureSecrets();
    const response = await client.oauth.v2.access({
      client_id: secrets.clientId,
      client_secret: secrets.clientSecret,
      code,
    });
    if (!options?.disableLogging)
      console.log(
        `Slack bot authorized for team: ${response.team?.name} (${response.team?.id})`,
      );
    await saveToken(response);
  } catch (error45) {
    const message =
      error45 instanceof Error ? error45.message : "Unknown error";
    return new Response(message, { status: 400 });
  }
  return new Response(
    "The Slack bot has been authorized. It can now be installed in your workspace.",
    { status: 200 },
  );
};
var isWebhook = (request2) => {
  return request2.headers.get("x-slack-signature") !== null;
};
var handleWebhook = async (request2, options) => {
  const app = createSlackApp(options);
  app.event("message", createMessageEventHandler());
  if (!options?.logUnhandledEvents) {
    const silentHandler = async () => {};
    allEventTypes.forEach((event) => {
      app.event(event, silentHandler);
    });
  }
  return app.run(request2);
};
var createSlackApp = (options) => {
  const secrets = ensureSecrets();
  const app = new import_slack_edge.SlackApp({
    env: { SLACK_SIGNING_SECRET: secrets.signingSecret },
    authorize: async ({ context }) => {
      if (!context.teamId)
        throw new Error("No team ID provided as part of the Slack webhook.");
      const bot = await getRefreshedToken(context.teamId);
      if (!bot) {
        if (!options?.disableWarnOnMissingToken)
          console.warn(
            `Missing bot token for team "${context.teamId}". Install the app from https://api.slack.com/apps in the "Manage Distribution" section.`,
          );
        throw new Error(`Missing bot token for team ${context.teamId}`);
      }
      return {
        botId: bot.botId,
        botUserId: bot.botUserId,
        botToken: bot.accessToken,
        botScopes: bot.scopes,
      };
    },
  }).afterAuthorize(async (req) => {
    if (process.env.SLACK_API_BASE_URL)
      req.context.client = new import_slack_edge.SlackAPIClient(
        req.context.botToken,
        { baseUrl: process.env.SLACK_API_BASE_URL },
      );
  });
  return app;
};
var createMessageEventHandler = (options) => {
  return async (event) => {
    const { payload, context } = event;
    if (payload.subtype !== void 0) return;
    if (!context.teamId) return;
    const parts = ["slack", context.teamId, payload.channel, "thread"];
    if (payload.thread_ts) parts.push(payload.thread_ts);
    else if (payload.ts) parts.push(payload.ts);
    let message;
    if (options?.createMessage) message = await options.createMessage(event);
    else {
      const userinfo = await context.client.users
        .info({ user: payload.user })
        .then((user) => {
          return {
            real_name: user.user?.profile?.real_name ?? "N/A",
            display_name: user.user?.profile?.display_name ?? "N/A",
          };
        })
        .catch(() => ({
          real_name: "N/A",
          display_name: "N/A",
        }));
      let createdAt = /* @__PURE__ */ new Date();
      try {
        createdAt = /* @__PURE__ */ new Date(parseFloat(payload.ts) * 1e3);
      } catch (err2) {}
      message = {
        role: "user",
        parts: [
          {
            type: "text",
            text: `From Slack User: <@${payload.user}>
Message Timestamp Raw: ${payload.ts} (use for reactions)
Message Timestamp Formatted: ${createdAt.toLocaleString()}
User Real Name: ${userinfo.real_name}
User Display Name: ${userinfo.display_name}

The user is chatting in Slack. You *must* respond with a "slackbot_send_message" tool.`,
          },
          {
            type: "text",
            text: payload.text,
          },
        ],
      };
    }
    const metadata = {
      ts: payload.ts,
      threadTs: payload.thread_ts,
      channel: payload.channel,
      teamId: context.teamId,
    };
    const chatID = parts.join("-");
    const send = async (behavior) => {
      await S2.chat.message(
        chatID,
        {
          ...message,
          metadata: {
            ...(message.metadata ?? {}),
            ...metadata,
          },
        },
        { behavior },
      );
    };
    const mentioned = payload.text.includes(`<@${context.botUserId}>`);
    if (!options?.respondToAll && !mentioned) {
      try {
        await send("append");
      } catch (err2) {}
      return;
    }
    await S2.chat.upsert(chatID);
    await send("enqueue");
    await context.client.assistant.threads.setStatus({
      channel_id: payload.channel,
      thread_ts: payload.thread_ts || payload.ts,
      status: "is typing...",
    });
  };
};
var allEventTypes = [
  "app_requested",
  "app_installed",
  "app_uninstalled_team",
  "app_deleted",
  "app_home_opened",
  "app_mention",
  "app_uninstalled",
  "assistant_thread_started",
  "assistant_thread_context_changed",
  "channel_archive",
  "channel_created",
  "channel_deleted",
  "channel_history_changed",
  "channel_id_changed",
  "channel_left",
  "channel_rename",
  "channel_shared",
  "channel_unarchive",
  "channel_unshared",
  "dnd_updated",
  "dnd_updated_user",
  "email_domain_changed",
  "emoji_changed",
  "file_change",
  "file_created",
  "file_deleted",
  "file_public",
  "file_shared",
  "file_unshared",
  "function_executed",
  "grid_migration_finished",
  "grid_migration_started",
  "group_archive",
  "group_close",
  "group_deleted",
  "group_history_changed",
  "group_left",
  "group_open",
  "group_rename",
  "group_unarchive",
  "im_close",
  "im_created",
  "im_history_changed",
  "im_open",
  "invite_requested",
  "link_shared",
  "member_joined_channel",
  "member_left_channel",
  "message",
  "message_metadata_deleted",
  "message_metadata_posted",
  "message_metadata_updated",
  "pin_added",
  "pin_removed",
  "reaction_added",
  "reaction_removed",
  "shared_channel_invite_received",
  "shared_channel_invite_accepted",
  "shared_channel_invite_approved",
  "shared_channel_invite_declined",
  "shared_channel_invite_requested",
  "star_added",
  "star_removed",
  "subteam_created",
  "subteam_members_changed",
  "subteam_self_added",
  "subteam_self_removed",
  "subteam_updated",
  "team_access_granted",
  "team_access_revoked",
  "team_domain_change",
  "team_join",
  "team_rename",
  "tokens_revoked",
  "user_change",
  "user_huddle_changed",
  "user_profile_changed",
  "user_status_changed",
  "workflow_deleted",
  "workflow_published",
  "workflow_unpublished",
  "workflow_step_deleted",
  "workflow_step_execute",
];

// node_modules/@blink-sdk/slackbot/dist/index.js
var import_slack_edge2 = __toESM(require_dist3(), 1);
var NEVER2 = Object.freeze({ status: "aborted" });
function $constructor2(name18, initializer$2, params) {
  function init(inst, def) {
    var _a19;
    Object.defineProperty(inst, "_zod", {
      value: inst._zod ?? {},
      enumerable: false,
    });
    (_a19 = inst._zod).traits ?? (_a19.traits = /* @__PURE__ */ new Set());
    inst._zod.traits.add(name18);
    initializer$2(inst, def);
    for (const k in _2.prototype)
      if (!(k in inst))
        Object.defineProperty(inst, k, { value: _2.prototype[k].bind(inst) });
    inst._zod.constr = _2;
    inst._zod.def = def;
  }
  const Parent = params?.Parent ?? Object;
  class Definition extends Parent {}
  Object.defineProperty(Definition, "name", { value: name18 });
  function _2(def) {
    var _a19;
    const inst = params?.Parent ? new Definition() : this;
    init(inst, def);
    (_a19 = inst._zod).deferred ?? (_a19.deferred = []);
    for (const fn of inst._zod.deferred) fn();
    return inst;
  }
  Object.defineProperty(_2, "init", { value: init });
  Object.defineProperty(_2, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent) return true;
      return inst?._zod?.traits?.has(name18);
    },
  });
  Object.defineProperty(_2, "name", { value: name18 });
  return _2;
}
var $brand2 = Symbol("zod_brand");
var $ZodAsyncError2 = class extends Error {
  constructor() {
    super(
      `Encountered Promise during synchronous parse. Use .parseAsync() instead.`,
    );
  }
};
var $ZodEncodeError2 = class extends Error {
  constructor(name18) {
    super(`Encountered unidirectional transform during encode: ${name18}`);
    this.name = "ZodEncodeError";
  }
};
var globalConfig2 = {};
function config2(newConfig) {
  if (newConfig) Object.assign(globalConfig2, newConfig);
  return globalConfig2;
}
function getEnumValues2(entries) {
  const numericValues = Object.values(entries).filter(
    (v2) => typeof v2 === "number",
  );
  const values = Object.entries(entries)
    .filter(([k, _2]) => numericValues.indexOf(+k) === -1)
    .map(([_2, v2]) => v2);
  return values;
}
function jsonStringifyReplacer2(_2, value) {
  if (typeof value === "bigint") return value.toString();
  return value;
}
function cached2(getter) {
  return {
    get value() {
      {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    },
  };
}
function nullish3(input) {
  return input === null || input === void 0;
}
function cleanRegex2(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
var EVALUATING2 = Symbol("evaluating");
function defineLazy2(object$1, key, getter) {
  let value = void 0;
  Object.defineProperty(object$1, key, {
    get() {
      if (value === EVALUATING2) return void 0;
      if (value === void 0) {
        value = EVALUATING2;
        value = getter();
      }
      return value;
    },
    set(v2) {
      Object.defineProperty(object$1, key, { value: v2 });
    },
    configurable: true,
  });
}
function assignProp2(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true,
  });
}
function mergeDefs2(...defs) {
  const mergedDescriptors = {};
  for (const def of defs) {
    const descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
function esc2(str) {
  return JSON.stringify(str);
}
var captureStackTrace2 =
  "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {};
function isObject2(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
var allowsEval2 = cached2(() => {
  if (
    typeof navigator !== "undefined" &&
    navigator?.userAgent?.includes("Cloudflare")
  )
    return false;
  try {
    const F = Function;
    new F("");
    return true;
  } catch (_2) {
    return false;
  }
});
function isPlainObject4(o2) {
  if (isObject2(o2) === false) return false;
  const ctor = o2.constructor;
  if (ctor === void 0) return true;
  const prot = ctor.prototype;
  if (isObject2(prot) === false) return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false)
    return false;
  return true;
}
function shallowClone2(o2) {
  if (isPlainObject4(o2)) return { ...o2 };
  if (Array.isArray(o2)) return [...o2];
  return o2;
}
var propertyKeyTypes2 = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
function escapeRegex2(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone2(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent) cl._zod.parent = inst;
  return cl;
}
function normalizeParams2(_params) {
  const params = _params;
  if (!params) return {};
  if (typeof params === "string") return { error: () => params };
  if (params?.message !== void 0) {
    if (params?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return {
      ...params,
      error: () => params.error,
    };
  return params;
}
function optionalKeys2(shape) {
  return Object.keys(shape).filter((k) => {
    return (
      shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional"
    );
  });
}
var NUMBER_FORMAT_RANGES2 = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE],
};
function pick2(schema, mask) {
  const currDef = schema._zod.def;
  const def = mergeDefs2(schema._zod.def, {
    get shape() {
      const newShape = {};
      for (const key in mask) {
        if (!(key in currDef.shape))
          throw new Error(`Unrecognized key: "${key}"`);
        if (!mask[key]) continue;
        newShape[key] = currDef.shape[key];
      }
      assignProp2(this, "shape", newShape);
      return newShape;
    },
    checks: [],
  });
  return clone2(schema, def);
}
function omit3(schema, mask) {
  const currDef = schema._zod.def;
  const def = mergeDefs2(schema._zod.def, {
    get shape() {
      const newShape = { ...schema._zod.def.shape };
      for (const key in mask) {
        if (!(key in currDef.shape))
          throw new Error(`Unrecognized key: "${key}"`);
        if (!mask[key]) continue;
        delete newShape[key];
      }
      assignProp2(this, "shape", newShape);
      return newShape;
    },
    checks: [],
  });
  return clone2(schema, def);
}
function extend2(schema, shape) {
  if (!isPlainObject4(shape))
    throw new Error("Invalid input to extend: expected a plain object");
  const checks = schema._zod.def.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks)
    throw new Error(
      "Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.",
    );
  const def = mergeDefs2(schema._zod.def, {
    get shape() {
      const _shape = {
        ...schema._zod.def.shape,
        ...shape,
      };
      assignProp2(this, "shape", _shape);
      return _shape;
    },
    checks: [],
  });
  return clone2(schema, def);
}
function safeExtend2(schema, shape) {
  if (!isPlainObject4(shape))
    throw new Error("Invalid input to safeExtend: expected a plain object");
  const def = {
    ...schema._zod.def,
    get shape() {
      const _shape = {
        ...schema._zod.def.shape,
        ...shape,
      };
      assignProp2(this, "shape", _shape);
      return _shape;
    },
    checks: schema._zod.def.checks,
  };
  return clone2(schema, def);
}
function merge3(a2, b2) {
  const def = mergeDefs2(a2._zod.def, {
    get shape() {
      const _shape = {
        ...a2._zod.def.shape,
        ...b2._zod.def.shape,
      };
      assignProp2(this, "shape", _shape);
      return _shape;
    },
    get catchall() {
      return b2._zod.def.catchall;
    },
    checks: [],
  });
  return clone2(a2, def);
}
function partial2(Class2, schema, mask) {
  const def = mergeDefs2(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask)
        for (const key in mask) {
          if (!(key in oldShape)) throw new Error(`Unrecognized key: "${key}"`);
          if (!mask[key]) continue;
          shape[key] = Class2
            ? new Class2({
                type: "optional",
                innerType: oldShape[key],
              })
            : oldShape[key];
        }
      else
        for (const key in oldShape)
          shape[key] = Class2
            ? new Class2({
                type: "optional",
                innerType: oldShape[key],
              })
            : oldShape[key];
      assignProp2(this, "shape", shape);
      return shape;
    },
    checks: [],
  });
  return clone2(schema, def);
}
function required2(Class2, schema, mask) {
  const def = mergeDefs2(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask)
        for (const key in mask) {
          if (!(key in shape)) throw new Error(`Unrecognized key: "${key}"`);
          if (!mask[key]) continue;
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key],
          });
        }
      else
        for (const key in oldShape)
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key],
          });
      assignProp2(this, "shape", shape);
      return shape;
    },
    checks: [],
  });
  return clone2(schema, def);
}
function aborted2(x, startIndex = 0) {
  if (x.aborted === true) return true;
  for (let i2 = startIndex; i2 < x.issues.length; i2++)
    if (x.issues[i2]?.continue !== true) return true;
  return false;
}
function prefixIssues2(path, issues) {
  return issues.map((iss) => {
    var _a19;
    (_a19 = iss).path ?? (_a19.path = []);
    iss.path.unshift(path);
    return iss;
  });
}
function unwrapMessage2(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue2(iss, ctx, config$1) {
  const full = {
    ...iss,
    path: iss.path ?? [],
  };
  if (!iss.message) {
    const message =
      unwrapMessage2(iss.inst?._zod.def?.error?.(iss)) ??
      unwrapMessage2(ctx?.error?.(iss)) ??
      unwrapMessage2(config$1.customError?.(iss)) ??
      unwrapMessage2(config$1.localeError?.(iss)) ??
      "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) delete full.input;
  return full;
}
function getLengthableOrigin2(input) {
  if (Array.isArray(input)) return "array";
  if (typeof input === "string") return "string";
  return "unknown";
}
function issue2(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string")
    return {
      message: iss,
      code: "custom",
      input,
      inst,
    };
  return { ...iss };
}
var initializer$1 = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false,
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false,
  });
  inst.message = JSON.stringify(def, jsonStringifyReplacer2, 2);
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false,
  });
};
var $ZodError2 = $constructor2("$ZodError", initializer$1);
var $ZodRealError2 = $constructor2("$ZodError", initializer$1, {
  Parent: Error,
});
function flattenError2(error45, mapper = (issue$1) => issue$1.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error45.issues)
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else formErrors.push(mapper(sub));
  return {
    formErrors,
    fieldErrors,
  };
}
function formatError2(error45, _mapper) {
  const mapper =
    _mapper ||
    function (issue$1) {
      return issue$1.message;
    };
  const fieldErrors = { _errors: [] };
  const processError = (error$1) => {
    for (const issue$1 of error$1.issues)
      if (issue$1.code === "invalid_union" && issue$1.errors.length)
        issue$1.errors.map((issues) => processError({ issues }));
      else if (issue$1.code === "invalid_key")
        processError({ issues: issue$1.issues });
      else if (issue$1.code === "invalid_element")
        processError({ issues: issue$1.issues });
      else if (issue$1.path.length === 0)
        fieldErrors._errors.push(mapper(issue$1));
      else {
        let curr = fieldErrors;
        let i2 = 0;
        while (i2 < issue$1.path.length) {
          const el = issue$1.path[i2];
          const terminal = i2 === issue$1.path.length - 1;
          if (!terminal) curr[el] = curr[el] || { _errors: [] };
          else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue$1));
          }
          curr = curr[el];
          i2++;
        }
      }
  };
  processError(error45);
  return fieldErrors;
}
var _parse3 = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run(
    {
      value,
      issues: [],
    },
    ctx,
  );
  if (result instanceof Promise) throw new $ZodAsyncError2();
  if (result.issues.length) {
    const e2 = new (_params?.Err ?? _Err)(
      result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())),
    );
    captureStackTrace2(e2, _params?.callee);
    throw e2;
  }
  return result.value;
};
var _parseAsync2 = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run(
    {
      value,
      issues: [],
    },
    ctx,
  );
  if (result instanceof Promise) result = await result;
  if (result.issues.length) {
    const e2 = new (params?.Err ?? _Err)(
      result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())),
    );
    captureStackTrace2(e2, params?.callee);
    throw e2;
  }
  return result.value;
};
var _safeParse2 = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx
    ? {
        ..._ctx,
        async: false,
      }
    : { async: false };
  const result = schema._zod.run(
    {
      value,
      issues: [],
    },
    ctx,
  );
  if (result instanceof Promise) throw new $ZodAsyncError2();
  return result.issues.length
    ? {
        success: false,
        error: new (_Err ?? $ZodError2)(
          result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())),
        ),
      }
    : {
        success: true,
        data: result.value,
      };
};
var safeParse$1 = /* @__PURE__ */ _safeParse2($ZodRealError2);
var _safeParseAsync2 = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run(
    {
      value,
      issues: [],
    },
    ctx,
  );
  if (result instanceof Promise) result = await result;
  return result.issues.length
    ? {
        success: false,
        error: new _Err(
          result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())),
        ),
      }
    : {
        success: true,
        data: result.value,
      };
};
var safeParseAsync$1 = /* @__PURE__ */ _safeParseAsync2($ZodRealError2);
var _encode2 = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx
    ? Object.assign(_ctx, { direction: "backward" })
    : { direction: "backward" };
  return _parse3(_Err)(schema, value, ctx);
};
var _decode2 = (_Err) => (schema, value, _ctx) => {
  return _parse3(_Err)(schema, value, _ctx);
};
var _encodeAsync2 = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx
    ? Object.assign(_ctx, { direction: "backward" })
    : { direction: "backward" };
  return _parseAsync2(_Err)(schema, value, ctx);
};
var _decodeAsync2 = (_Err) => async (schema, value, _ctx) => {
  return _parseAsync2(_Err)(schema, value, _ctx);
};
var _safeEncode2 = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx
    ? Object.assign(_ctx, { direction: "backward" })
    : { direction: "backward" };
  return _safeParse2(_Err)(schema, value, ctx);
};
var _safeDecode2 = (_Err) => (schema, value, _ctx) => {
  return _safeParse2(_Err)(schema, value, _ctx);
};
var _safeEncodeAsync2 = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx
    ? Object.assign(_ctx, { direction: "backward" })
    : { direction: "backward" };
  return _safeParseAsync2(_Err)(schema, value, ctx);
};
var _safeDecodeAsync2 = (_Err) => async (schema, value, _ctx) => {
  return _safeParseAsync2(_Err)(schema, value, _ctx);
};
var cuid4 = /^[cC][^\s-]{8,}$/;
var cuid23 = /^[0-9a-z]+$/;
var ulid3 = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var xid3 = /^[0-9a-vA-V]{20}$/;
var ksuid3 = /^[A-Za-z0-9]{27}$/;
var nanoid3 = /^[a-zA-Z0-9_-]{21}$/;
var duration$1 =
  /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var guid3 =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var uuid3 = (version$1) => {
  if (!version$1)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
  return /* @__PURE__ */ new RegExp(
    `^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version$1}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`,
  );
};
var email3 =
  /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
var _emoji$1 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji3() {
  return new RegExp(_emoji$1, "u");
}
var ipv43 =
  /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv63 =
  /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
var cidrv43 =
  /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var cidrv63 =
  /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base643 =
  /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var base64url3 = /^[A-Za-z0-9_-]*$/;
var hostname3 =
  /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
var e1643 = /^\+(?:[0-9]){6,14}[0-9]$/;
var dateSource2 = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
var date$1 = /* @__PURE__ */ new RegExp(`^${dateSource2}$`);
function timeSource2(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex =
    typeof args.precision === "number"
      ? args.precision === -1
        ? `${hhmm}`
        : args.precision === 0
          ? `${hhmm}:[0-5]\\d`
          : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}`
      : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time$1(args) {
  return /* @__PURE__ */ new RegExp(`^${timeSource2(args)}$`);
}
function datetime$1(args) {
  const time$2 = timeSource2({ precision: args.precision });
  const opts = ["Z"];
  if (args.local) opts.push("");
  if (args.offset) opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
  const timeRegex2 = `${time$2}(?:${opts.join("|")})`;
  return /* @__PURE__ */ new RegExp(`^${dateSource2}T(?:${timeRegex2})$`);
}
var string$1 = (params) => {
  const regex = params
    ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}`
    : `[\\s\\S]*`;
  return /* @__PURE__ */ new RegExp(`^${regex}$`);
};
var boolean$1 = /^(?:true|false)$/i;
var lowercase2 = /^[^A-Z]*$/;
var uppercase2 = /^[^a-z]*$/;
var $ZodCheck2 = /* @__PURE__ */ $constructor2("$ZodCheck", (inst, def) => {
  var _a19;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a19 = inst._zod).onattach ?? (_a19.onattach = []);
});
var $ZodCheckMaxLength2 = /* @__PURE__ */ $constructor2(
  "$ZodCheckMaxLength",
  (inst, def) => {
    var _a19;
    $ZodCheck2.init(inst, def);
    (_a19 = inst._zod.def).when ??
      (_a19.when = (payload) => {
        const val = payload.value;
        return !nullish3(val) && val.length !== void 0;
      });
    inst._zod.onattach.push((inst$1) => {
      const curr = inst$1._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
      if (def.maximum < curr) inst$1._zod.bag.maximum = def.maximum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const length = input.length;
      if (length <= def.maximum) return;
      const origin = getLengthableOrigin2(input);
      payload.issues.push({
        origin,
        code: "too_big",
        maximum: def.maximum,
        inclusive: true,
        input,
        inst,
        continue: !def.abort,
      });
    };
  },
);
var $ZodCheckMinLength2 = /* @__PURE__ */ $constructor2(
  "$ZodCheckMinLength",
  (inst, def) => {
    var _a19;
    $ZodCheck2.init(inst, def);
    (_a19 = inst._zod.def).when ??
      (_a19.when = (payload) => {
        const val = payload.value;
        return !nullish3(val) && val.length !== void 0;
      });
    inst._zod.onattach.push((inst$1) => {
      const curr = inst$1._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
      if (def.minimum > curr) inst$1._zod.bag.minimum = def.minimum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const length = input.length;
      if (length >= def.minimum) return;
      const origin = getLengthableOrigin2(input);
      payload.issues.push({
        origin,
        code: "too_small",
        minimum: def.minimum,
        inclusive: true,
        input,
        inst,
        continue: !def.abort,
      });
    };
  },
);
var $ZodCheckLengthEquals2 = /* @__PURE__ */ $constructor2(
  "$ZodCheckLengthEquals",
  (inst, def) => {
    var _a19;
    $ZodCheck2.init(inst, def);
    (_a19 = inst._zod.def).when ??
      (_a19.when = (payload) => {
        const val = payload.value;
        return !nullish3(val) && val.length !== void 0;
      });
    inst._zod.onattach.push((inst$1) => {
      const bag = inst$1._zod.bag;
      bag.minimum = def.length;
      bag.maximum = def.length;
      bag.length = def.length;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const length = input.length;
      if (length === def.length) return;
      const origin = getLengthableOrigin2(input);
      const tooBig = length > def.length;
      payload.issues.push({
        origin,
        ...(tooBig
          ? {
              code: "too_big",
              maximum: def.length,
            }
          : {
              code: "too_small",
              minimum: def.length,
            }),
        inclusive: true,
        exact: true,
        input: payload.value,
        inst,
        continue: !def.abort,
      });
    };
  },
);
var $ZodCheckStringFormat2 = /* @__PURE__ */ $constructor2(
  "$ZodCheckStringFormat",
  (inst, def) => {
    var _a19, _b9;
    $ZodCheck2.init(inst, def);
    inst._zod.onattach.push((inst$1) => {
      const bag = inst$1._zod.bag;
      bag.format = def.format;
      if (def.pattern) {
        bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
        bag.patterns.add(def.pattern);
      }
    });
    if (def.pattern)
      (_a19 = inst._zod).check ??
        (_a19.check = (payload) => {
          def.pattern.lastIndex = 0;
          if (def.pattern.test(payload.value)) return;
          payload.issues.push({
            origin: "string",
            code: "invalid_format",
            format: def.format,
            input: payload.value,
            ...(def.pattern ? { pattern: def.pattern.toString() } : {}),
            inst,
            continue: !def.abort,
          });
        });
    else (_b9 = inst._zod).check ?? (_b9.check = () => {});
  },
);
var $ZodCheckRegex2 = /* @__PURE__ */ $constructor2(
  "$ZodCheckRegex",
  (inst, def) => {
    $ZodCheckStringFormat2.init(inst, def);
    inst._zod.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value)) return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: "regex",
        input: payload.value,
        pattern: def.pattern.toString(),
        inst,
        continue: !def.abort,
      });
    };
  },
);
var $ZodCheckLowerCase2 = /* @__PURE__ */ $constructor2(
  "$ZodCheckLowerCase",
  (inst, def) => {
    def.pattern ?? (def.pattern = lowercase2);
    $ZodCheckStringFormat2.init(inst, def);
  },
);
var $ZodCheckUpperCase2 = /* @__PURE__ */ $constructor2(
  "$ZodCheckUpperCase",
  (inst, def) => {
    def.pattern ?? (def.pattern = uppercase2);
    $ZodCheckStringFormat2.init(inst, def);
  },
);
var $ZodCheckIncludes2 = /* @__PURE__ */ $constructor2(
  "$ZodCheckIncludes",
  (inst, def) => {
    $ZodCheck2.init(inst, def);
    const escapedRegex = escapeRegex2(def.includes);
    const pattern = new RegExp(
      typeof def.position === "number"
        ? `^.{${def.position}}${escapedRegex}`
        : escapedRegex,
    );
    def.pattern = pattern;
    inst._zod.onattach.push((inst$1) => {
      const bag = inst$1._zod.bag;
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(pattern);
    });
    inst._zod.check = (payload) => {
      if (payload.value.includes(def.includes, def.position)) return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: "includes",
        includes: def.includes,
        input: payload.value,
        inst,
        continue: !def.abort,
      });
    };
  },
);
var $ZodCheckStartsWith2 = /* @__PURE__ */ $constructor2(
  "$ZodCheckStartsWith",
  (inst, def) => {
    $ZodCheck2.init(inst, def);
    const pattern = /* @__PURE__ */ new RegExp(
      `^${escapeRegex2(def.prefix)}.*`,
    );
    def.pattern ?? (def.pattern = pattern);
    inst._zod.onattach.push((inst$1) => {
      const bag = inst$1._zod.bag;
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(pattern);
    });
    inst._zod.check = (payload) => {
      if (payload.value.startsWith(def.prefix)) return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: "starts_with",
        prefix: def.prefix,
        input: payload.value,
        inst,
        continue: !def.abort,
      });
    };
  },
);
var $ZodCheckEndsWith2 = /* @__PURE__ */ $constructor2(
  "$ZodCheckEndsWith",
  (inst, def) => {
    $ZodCheck2.init(inst, def);
    const pattern = /* @__PURE__ */ new RegExp(
      `.*${escapeRegex2(def.suffix)}$`,
    );
    def.pattern ?? (def.pattern = pattern);
    inst._zod.onattach.push((inst$1) => {
      const bag = inst$1._zod.bag;
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(pattern);
    });
    inst._zod.check = (payload) => {
      if (payload.value.endsWith(def.suffix)) return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: "ends_with",
        suffix: def.suffix,
        input: payload.value,
        inst,
        continue: !def.abort,
      });
    };
  },
);
var $ZodCheckOverwrite2 = /* @__PURE__ */ $constructor2(
  "$ZodCheckOverwrite",
  (inst, def) => {
    $ZodCheck2.init(inst, def);
    inst._zod.check = (payload) => {
      payload.value = def.tx(payload.value);
    };
  },
);
var Doc2 = class {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this) this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split("\n").filter((x) => x);
    const minIndent = Math.min(
      ...lines.map((x) => x.length - x.trimStart().length),
    );
    const dedented = lines
      .map((x) => x.slice(minIndent))
      .map((x) => " ".repeat(this.indent * 2) + x);
    for (const line of dedented) this.content.push(line);
  }
  compile() {
    const F = Function;
    const args = this?.args;
    const content = this?.content ?? [``];
    const lines = [...content.map((x) => `  ${x}`)];
    return new F(...args, lines.join("\n"));
  }
};
var version2 = {
  major: 4,
  minor: 1,
  patch: 11,
};
var $ZodType2 = /* @__PURE__ */ $constructor2("$ZodType", (inst, def) => {
  var _a19;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version2;
  const checks = [...(inst._zod.def.checks ?? [])];
  if (inst._zod.traits.has("$ZodCheck")) checks.unshift(inst);
  for (const ch of checks) for (const fn of ch._zod.onattach) fn(inst);
  if (checks.length === 0) {
    (_a19 = inst._zod).deferred ?? (_a19.deferred = []);
    inst._zod.deferred?.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = (payload, checks$1, ctx) => {
      let isAborted2 = aborted2(payload);
      let asyncResult;
      for (const ch of checks$1) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun) continue;
        } else if (isAborted2) continue;
        const currLen = payload.issues.length;
        const _2 = ch._zod.check(payload);
        if (_2 instanceof Promise && ctx?.async === false)
          throw new $ZodAsyncError2();
        if (asyncResult || _2 instanceof Promise)
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _2;
            const nextLen = payload.issues.length;
            if (nextLen === currLen) return;
            if (!isAborted2) isAborted2 = aborted2(payload, currLen);
          });
        else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen) continue;
          if (!isAborted2) isAborted2 = aborted2(payload, currLen);
        }
      }
      if (asyncResult)
        return asyncResult.then(() => {
          return payload;
        });
      return payload;
    };
    const handleCanaryResult = (canary, payload, ctx) => {
      if (aborted2(canary)) {
        canary.aborted = true;
        return canary;
      }
      const checkResult = runChecks(payload, checks, ctx);
      if (checkResult instanceof Promise) {
        if (ctx.async === false) throw new $ZodAsyncError2();
        return checkResult.then((checkResult$1) =>
          inst._zod.parse(checkResult$1, ctx),
        );
      }
      return inst._zod.parse(checkResult, ctx);
    };
    inst._zod.run = (payload, ctx) => {
      if (ctx.skipChecks) return inst._zod.parse(payload, ctx);
      if (ctx.direction === "backward") {
        const canary = inst._zod.parse(
          {
            value: payload.value,
            issues: [],
          },
          {
            ...ctx,
            skipChecks: true,
          },
        );
        if (canary instanceof Promise)
          return canary.then((canary$1) => {
            return handleCanaryResult(canary$1, payload, ctx);
          });
        return handleCanaryResult(canary, payload, ctx);
      }
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false) throw new $ZodAsyncError2();
        return result.then((result$1) => runChecks(result$1, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  inst["~standard"] = {
    validate: (value) => {
      try {
        const r2 = safeParse$1(inst, value);
        return r2.success ? { value: r2.data } : { issues: r2.error?.issues };
      } catch (_2) {
        return safeParseAsync$1(inst, value).then((r2) =>
          r2.success ? { value: r2.data } : { issues: r2.error?.issues },
        );
      }
    },
    vendor: "zod",
    version: 1,
  };
});
var $ZodString2 = /* @__PURE__ */ $constructor2("$ZodString", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.pattern =
    [...(inst?._zod.bag?.patterns ?? [])].pop() ?? string$1(inst._zod.bag);
  inst._zod.parse = (payload, _2) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_$1) {}
    if (typeof payload.value === "string") return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst,
    });
    return payload;
  };
});
var $ZodStringFormat2 = /* @__PURE__ */ $constructor2(
  "$ZodStringFormat",
  (inst, def) => {
    $ZodCheckStringFormat2.init(inst, def);
    $ZodString2.init(inst, def);
  },
);
var $ZodGUID2 = /* @__PURE__ */ $constructor2("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid3);
  $ZodStringFormat2.init(inst, def);
});
var $ZodUUID2 = /* @__PURE__ */ $constructor2("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8,
    };
    const v2 = versionMap[def.version];
    if (v2 === void 0)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid3(v2));
  } else def.pattern ?? (def.pattern = uuid3());
  $ZodStringFormat2.init(inst, def);
});
var $ZodEmail2 = /* @__PURE__ */ $constructor2("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email3);
  $ZodStringFormat2.init(inst, def);
});
var $ZodURL2 = /* @__PURE__ */ $constructor2("$ZodURL", (inst, def) => {
  $ZodStringFormat2.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const trimmed = payload.value.trim();
      const url2 = new URL(trimmed);
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url2.hostname))
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: hostname3.source,
            input: payload.value,
            inst,
            continue: !def.abort,
          });
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (
          !def.protocol.test(
            url2.protocol.endsWith(":")
              ? url2.protocol.slice(0, -1)
              : url2.protocol,
          )
        )
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort,
          });
      }
      if (def.normalize) payload.value = url2.href;
      else payload.value = trimmed;
      return;
    } catch (_2) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort,
      });
    }
  };
});
var $ZodEmoji2 = /* @__PURE__ */ $constructor2("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji3());
  $ZodStringFormat2.init(inst, def);
});
var $ZodNanoID2 = /* @__PURE__ */ $constructor2("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid3);
  $ZodStringFormat2.init(inst, def);
});
var $ZodCUID3 = /* @__PURE__ */ $constructor2("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid4);
  $ZodStringFormat2.init(inst, def);
});
var $ZodCUID22 = /* @__PURE__ */ $constructor2("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid23);
  $ZodStringFormat2.init(inst, def);
});
var $ZodULID2 = /* @__PURE__ */ $constructor2("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid3);
  $ZodStringFormat2.init(inst, def);
});
var $ZodXID2 = /* @__PURE__ */ $constructor2("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid3);
  $ZodStringFormat2.init(inst, def);
});
var $ZodKSUID2 = /* @__PURE__ */ $constructor2("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid3);
  $ZodStringFormat2.init(inst, def);
});
var $ZodISODateTime2 = /* @__PURE__ */ $constructor2(
  "$ZodISODateTime",
  (inst, def) => {
    def.pattern ?? (def.pattern = datetime$1(def));
    $ZodStringFormat2.init(inst, def);
  },
);
var $ZodISODate2 = /* @__PURE__ */ $constructor2("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date$1);
  $ZodStringFormat2.init(inst, def);
});
var $ZodISOTime2 = /* @__PURE__ */ $constructor2("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time$1(def));
  $ZodStringFormat2.init(inst, def);
});
var $ZodISODuration2 = /* @__PURE__ */ $constructor2(
  "$ZodISODuration",
  (inst, def) => {
    def.pattern ?? (def.pattern = duration$1);
    $ZodStringFormat2.init(inst, def);
  },
);
var $ZodIPv42 = /* @__PURE__ */ $constructor2("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv43);
  $ZodStringFormat2.init(inst, def);
  inst._zod.onattach.push((inst$1) => {
    const bag = inst$1._zod.bag;
    bag.format = `ipv4`;
  });
});
var $ZodIPv62 = /* @__PURE__ */ $constructor2("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv63);
  $ZodStringFormat2.init(inst, def);
  inst._zod.onattach.push((inst$1) => {
    const bag = inst$1._zod.bag;
    bag.format = `ipv6`;
  });
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort,
      });
    }
  };
});
var $ZodCIDRv42 = /* @__PURE__ */ $constructor2("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv43);
  $ZodStringFormat2.init(inst, def);
});
var $ZodCIDRv62 = /* @__PURE__ */ $constructor2("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv63);
  $ZodStringFormat2.init(inst, def);
  inst._zod.check = (payload) => {
    const parts = payload.value.split("/");
    try {
      if (parts.length !== 2) throw new Error();
      const [address, prefix] = parts;
      if (!prefix) throw new Error();
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix) throw new Error();
      if (prefixNum < 0 || prefixNum > 128) throw new Error();
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort,
      });
    }
  };
});
function isValidBase642(data) {
  if (data === "") return true;
  if (data.length % 4 !== 0) return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
var $ZodBase642 = /* @__PURE__ */ $constructor2("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base643);
  $ZodStringFormat2.init(inst, def);
  inst._zod.onattach.push((inst$1) => {
    inst$1._zod.bag.contentEncoding = "base64";
  });
  inst._zod.check = (payload) => {
    if (isValidBase642(payload.value)) return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort,
    });
  };
});
function isValidBase64URL2(data) {
  if (!base64url3.test(data)) return false;
  const base64$1 = data.replace(/[-_]/g, (c2) => (c2 === "-" ? "+" : "/"));
  const padded = base64$1.padEnd(Math.ceil(base64$1.length / 4) * 4, "=");
  return isValidBase642(padded);
}
var $ZodBase64URL2 = /* @__PURE__ */ $constructor2(
  "$ZodBase64URL",
  (inst, def) => {
    def.pattern ?? (def.pattern = base64url3);
    $ZodStringFormat2.init(inst, def);
    inst._zod.onattach.push((inst$1) => {
      inst$1._zod.bag.contentEncoding = "base64url";
    });
    inst._zod.check = (payload) => {
      if (isValidBase64URL2(payload.value)) return;
      payload.issues.push({
        code: "invalid_format",
        format: "base64url",
        input: payload.value,
        inst,
        continue: !def.abort,
      });
    };
  },
);
var $ZodE1642 = /* @__PURE__ */ $constructor2("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e1643);
  $ZodStringFormat2.init(inst, def);
});
function isValidJWT3(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3) return false;
    const [header] = tokensParts;
    if (!header) return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT") return false;
    if (!parsedHeader.alg) return false;
    if (
      algorithm &&
      (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm)
    )
      return false;
    return true;
  } catch {
    return false;
  }
}
var $ZodJWT2 = /* @__PURE__ */ $constructor2("$ZodJWT", (inst, def) => {
  $ZodStringFormat2.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT3(payload.value, def.alg)) return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort,
    });
  };
});
var $ZodBoolean2 = /* @__PURE__ */ $constructor2("$ZodBoolean", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.pattern = boolean$1;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_2) {}
    const input = payload.value;
    if (typeof input === "boolean") return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst,
    });
    return payload;
  };
});
var $ZodUnknown2 = /* @__PURE__ */ $constructor2("$ZodUnknown", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodNever2 = /* @__PURE__ */ $constructor2("$ZodNever", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst,
    });
    return payload;
  };
});
function handleArrayResult2(result, final, index) {
  if (result.issues.length)
    final.issues.push(...prefixIssues2(index, result.issues));
  final.value[index] = result.value;
}
var $ZodArray2 = /* @__PURE__ */ $constructor2("$ZodArray", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst,
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i2 = 0; i2 < input.length; i2++) {
      const item = input[i2];
      const result = def.element._zod.run(
        {
          value: item,
          issues: [],
        },
        ctx,
      );
      if (result instanceof Promise)
        proms.push(
          result.then((result$1) => handleArrayResult2(result$1, payload, i2)),
        );
      else handleArrayResult2(result, payload, i2);
    }
    if (proms.length) return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handlePropertyResult2(result, final, key, input) {
  if (result.issues.length)
    final.issues.push(...prefixIssues2(key, result.issues));
  if (result.value === void 0) {
    if (key in input) final.value[key] = void 0;
  } else final.value[key] = result.value;
}
function normalizeDef2(def) {
  const keys = Object.keys(def.shape);
  for (const k of keys)
    if (!def.shape?.[k]?._zod?.traits?.has("$ZodType"))
      throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
  const okeys = optionalKeys2(def.shape);
  return {
    ...def,
    keys,
    keySet: new Set(keys),
    numKeys: keys.length,
    optionalKeys: new Set(okeys),
  };
}
function handleCatchall2(proms, input, payload, ctx, def, inst) {
  const unrecognized = [];
  const keySet = def.keySet;
  const _catchall = def.catchall._zod;
  const t2 = _catchall.def.type;
  for (const key of Object.keys(input)) {
    if (keySet.has(key)) continue;
    if (t2 === "never") {
      unrecognized.push(key);
      continue;
    }
    const r2 = _catchall.run(
      {
        value: input[key],
        issues: [],
      },
      ctx,
    );
    if (r2 instanceof Promise)
      proms.push(
        r2.then((r$1) => handlePropertyResult2(r$1, payload, key, input)),
      );
    else handlePropertyResult2(r2, payload, key, input);
  }
  if (unrecognized.length)
    payload.issues.push({
      code: "unrecognized_keys",
      keys: unrecognized,
      input,
      inst,
    });
  if (!proms.length) return payload;
  return Promise.all(proms).then(() => {
    return payload;
  });
}
var $ZodObject2 = /* @__PURE__ */ $constructor2("$ZodObject", (inst, def) => {
  $ZodType2.init(inst, def);
  const desc = Object.getOwnPropertyDescriptor(def, "shape");
  if (!desc?.get) {
    const sh = def.shape;
    Object.defineProperty(def, "shape", {
      get: () => {
        const newSh = { ...sh };
        Object.defineProperty(def, "shape", { value: newSh });
        return newSh;
      },
    });
  }
  const _normalized = cached2(() => normalizeDef2(def));
  defineLazy2(inst._zod, "propValues", () => {
    const shape = def.shape;
    const propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
        for (const v2 of field.values) propValues[key].add(v2);
      }
    }
    return propValues;
  });
  const isObject$1 = isObject2;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject$1(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst,
      });
      return payload;
    }
    payload.value = {};
    const proms = [];
    const shape = value.shape;
    for (const key of value.keys) {
      const el = shape[key];
      const r2 = el._zod.run(
        {
          value: input[key],
          issues: [],
        },
        ctx,
      );
      if (r2 instanceof Promise)
        proms.push(
          r2.then((r$1) => handlePropertyResult2(r$1, payload, key, input)),
        );
      else handlePropertyResult2(r2, payload, key, input);
    }
    if (!catchall)
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    return handleCatchall2(proms, input, payload, ctx, _normalized.value, inst);
  };
});
var $ZodObjectJIT2 = /* @__PURE__ */ $constructor2(
  "$ZodObjectJIT",
  (inst, def) => {
    $ZodObject2.init(inst, def);
    const superParse = inst._zod.parse;
    const _normalized = cached2(() => normalizeDef2(def));
    const generateFastpass = (shape) => {
      const doc = new Doc2(["shape", "payload", "ctx"]);
      const normalized = _normalized.value;
      const parseStr = (key) => {
        const k = esc2(key);
        return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
      };
      doc.write(`const input = payload.value;`);
      const ids = /* @__PURE__ */ Object.create(null);
      let counter = 0;
      for (const key of normalized.keys) ids[key] = `key_${counter++}`;
      doc.write(`const newResult = {};`);
      for (const key of normalized.keys) {
        const id = ids[key];
        const k = esc2(key);
        doc.write(`const ${id} = ${parseStr(key)};`);
        doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
      }
      doc.write(`payload.value = newResult;`);
      doc.write(`return payload;`);
      const fn = doc.compile();
      return (payload, ctx) => fn(shape, payload, ctx);
    };
    let fastpass;
    const isObject$1 = isObject2;
    const jit = !globalConfig2.jitless;
    const allowsEval$1 = allowsEval2;
    const fastEnabled = jit && allowsEval$1.value;
    const catchall = def.catchall;
    let value;
    inst._zod.parse = (payload, ctx) => {
      value ?? (value = _normalized.value);
      const input = payload.value;
      if (!isObject$1(input)) {
        payload.issues.push({
          expected: "object",
          code: "invalid_type",
          input,
          inst,
        });
        return payload;
      }
      if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
        if (!fastpass) fastpass = generateFastpass(def.shape);
        payload = fastpass(payload, ctx);
        if (!catchall) return payload;
        return handleCatchall2([], input, payload, ctx, value, inst);
      }
      return superParse(payload, ctx);
    };
  },
);
function handleUnionResults2(results, final, inst, ctx) {
  for (const result of results)
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  const nonaborted = results.filter((r2) => !aborted2(r2));
  if (nonaborted.length === 1) {
    final.value = nonaborted[0].value;
    return nonaborted[0];
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) =>
      result.issues.map((iss) => finalizeIssue2(iss, ctx, config2())),
    ),
  });
  return final;
}
var $ZodUnion2 = /* @__PURE__ */ $constructor2("$ZodUnion", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "optin", () =>
    def.options.some((o2) => o2._zod.optin === "optional")
      ? "optional"
      : void 0,
  );
  defineLazy2(inst._zod, "optout", () =>
    def.options.some((o2) => o2._zod.optout === "optional")
      ? "optional"
      : void 0,
  );
  defineLazy2(inst._zod, "values", () => {
    if (def.options.every((o2) => o2._zod.values))
      return new Set(
        def.options.flatMap((option) => Array.from(option._zod.values)),
      );
    return void 0;
  });
  defineLazy2(inst._zod, "pattern", () => {
    if (def.options.every((o2) => o2._zod.pattern)) {
      const patterns = def.options.map((o2) => o2._zod.pattern);
      return /* @__PURE__ */ new RegExp(
        `^(${patterns.map((p2) => cleanRegex2(p2.source)).join("|")})$`,
      );
    }
    return void 0;
  });
  const single = def.options.length === 1;
  const first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single) return first(payload, ctx);
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run(
        {
          value: payload.value,
          issues: [],
        },
        ctx,
      );
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        if (result.issues.length === 0) return result;
        results.push(result);
      }
    }
    if (!async) return handleUnionResults2(results, payload, inst, ctx);
    return Promise.all(results).then((results$1) => {
      return handleUnionResults2(results$1, payload, inst, ctx);
    });
  };
});
var $ZodIntersection2 = /* @__PURE__ */ $constructor2(
  "$ZodIntersection",
  (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      const left = def.left._zod.run(
        {
          value: input,
          issues: [],
        },
        ctx,
      );
      const right = def.right._zod.run(
        {
          value: input,
          issues: [],
        },
        ctx,
      );
      const async = left instanceof Promise || right instanceof Promise;
      if (async)
        return Promise.all([left, right]).then(([left$1, right$1]) => {
          return handleIntersectionResults2(payload, left$1, right$1);
        });
      return handleIntersectionResults2(payload, left, right);
    };
  },
);
function mergeValues3(a2, b2) {
  if (a2 === b2)
    return {
      valid: true,
      data: a2,
    };
  if (a2 instanceof Date && b2 instanceof Date && +a2 === +b2)
    return {
      valid: true,
      data: a2,
    };
  if (isPlainObject4(a2) && isPlainObject4(b2)) {
    const bKeys = Object.keys(b2);
    const sharedKeys = Object.keys(a2).filter(
      (key) => bKeys.indexOf(key) !== -1,
    );
    const newObj = {
      ...a2,
      ...b2,
    };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues3(a2[key], b2[key]);
      if (!sharedValue.valid)
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath],
        };
      newObj[key] = sharedValue.data;
    }
    return {
      valid: true,
      data: newObj,
    };
  }
  if (Array.isArray(a2) && Array.isArray(b2)) {
    if (a2.length !== b2.length)
      return {
        valid: false,
        mergeErrorPath: [],
      };
    const newArray = [];
    for (let index = 0; index < a2.length; index++) {
      const itemA = a2[index];
      const itemB = b2[index];
      const sharedValue = mergeValues3(itemA, itemB);
      if (!sharedValue.valid)
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath],
        };
      newArray.push(sharedValue.data);
    }
    return {
      valid: true,
      data: newArray,
    };
  }
  return {
    valid: false,
    mergeErrorPath: [],
  };
}
function handleIntersectionResults2(result, left, right) {
  if (left.issues.length) result.issues.push(...left.issues);
  if (right.issues.length) result.issues.push(...right.issues);
  if (aborted2(result)) return result;
  const merged = mergeValues3(left.value, right.value);
  if (!merged.valid)
    throw new Error(
      `Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`,
    );
  result.value = merged.data;
  return result;
}
var $ZodEnum2 = /* @__PURE__ */ $constructor2("$ZodEnum", (inst, def) => {
  $ZodType2.init(inst, def);
  const values = getEnumValues2(def.entries);
  const valuesSet = new Set(values);
  inst._zod.values = valuesSet;
  inst._zod.pattern = /* @__PURE__ */ new RegExp(
    `^(${values
      .filter((k) => propertyKeyTypes2.has(typeof k))
      .map((o2) => (typeof o2 === "string" ? escapeRegex2(o2) : o2.toString()))
      .join("|")})$`,
  );
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (valuesSet.has(input)) return payload;
    payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst,
    });
    return payload;
  };
});
var $ZodLiteral2 = /* @__PURE__ */ $constructor2("$ZodLiteral", (inst, def) => {
  $ZodType2.init(inst, def);
  if (def.values.length === 0)
    throw new Error("Cannot create literal schema with no valid values");
  inst._zod.values = new Set(def.values);
  inst._zod.pattern = /* @__PURE__ */ new RegExp(
    `^(${def.values.map((o2) => (typeof o2 === "string" ? escapeRegex2(o2) : o2 ? escapeRegex2(o2.toString()) : String(o2))).join("|")})$`,
  );
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) return payload;
    payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst,
    });
    return payload;
  };
});
var $ZodTransform2 = /* @__PURE__ */ $constructor2(
  "$ZodTransform",
  (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward")
        throw new $ZodEncodeError2(inst.constructor.name);
      const _out = def.transform(payload.value, payload);
      if (ctx.async) {
        const output = _out instanceof Promise ? _out : Promise.resolve(_out);
        return output.then((output$1) => {
          payload.value = output$1;
          return payload;
        });
      }
      if (_out instanceof Promise) throw new $ZodAsyncError2();
      payload.value = _out;
      return payload;
    };
  },
);
function handleOptionalResult2(result, input) {
  if (result.issues.length && input === void 0)
    return {
      issues: [],
      value: void 0,
    };
  return result;
}
var $ZodOptional2 = /* @__PURE__ */ $constructor2(
  "$ZodOptional",
  (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.optin = "optional";
    inst._zod.optout = "optional";
    defineLazy2(inst._zod, "values", () => {
      return def.innerType._zod.values
        ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0])
        : void 0;
    });
    defineLazy2(inst._zod, "pattern", () => {
      const pattern = def.innerType._zod.pattern;
      return pattern
        ? /* @__PURE__ */ new RegExp(`^(${cleanRegex2(pattern.source)})?$`)
        : void 0;
    });
    inst._zod.parse = (payload, ctx) => {
      if (def.innerType._zod.optin === "optional") {
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise)
          return result.then((r2) => handleOptionalResult2(r2, payload.value));
        return handleOptionalResult2(result, payload.value);
      }
      if (payload.value === void 0) return payload;
      return def.innerType._zod.run(payload, ctx);
    };
  },
);
var $ZodNullable2 = /* @__PURE__ */ $constructor2(
  "$ZodNullable",
  (inst, def) => {
    $ZodType2.init(inst, def);
    defineLazy2(inst._zod, "optin", () => def.innerType._zod.optin);
    defineLazy2(inst._zod, "optout", () => def.innerType._zod.optout);
    defineLazy2(inst._zod, "pattern", () => {
      const pattern = def.innerType._zod.pattern;
      return pattern
        ? /* @__PURE__ */ new RegExp(`^(${cleanRegex2(pattern.source)}|null)$`)
        : void 0;
    });
    defineLazy2(inst._zod, "values", () => {
      return def.innerType._zod.values
        ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null])
        : void 0;
    });
    inst._zod.parse = (payload, ctx) => {
      if (payload.value === null) return payload;
      return def.innerType._zod.run(payload, ctx);
    };
  },
);
var $ZodDefault2 = /* @__PURE__ */ $constructor2("$ZodDefault", (inst, def) => {
  $ZodType2.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy2(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward")
      return def.innerType._zod.run(payload, ctx);
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise)
      return result.then((result$1) => handleDefaultResult2(result$1, def));
    return handleDefaultResult2(result, def);
  };
});
function handleDefaultResult2(payload, def) {
  if (payload.value === void 0) payload.value = def.defaultValue;
  return payload;
}
var $ZodPrefault2 = /* @__PURE__ */ $constructor2(
  "$ZodPrefault",
  (inst, def) => {
    $ZodType2.init(inst, def);
    inst._zod.optin = "optional";
    defineLazy2(inst._zod, "values", () => def.innerType._zod.values);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward")
        return def.innerType._zod.run(payload, ctx);
      if (payload.value === void 0) payload.value = def.defaultValue;
      return def.innerType._zod.run(payload, ctx);
    };
  },
);
var $ZodNonOptional2 = /* @__PURE__ */ $constructor2(
  "$ZodNonOptional",
  (inst, def) => {
    $ZodType2.init(inst, def);
    defineLazy2(inst._zod, "values", () => {
      const v2 = def.innerType._zod.values;
      return v2 ? new Set([...v2].filter((x) => x !== void 0)) : void 0;
    });
    inst._zod.parse = (payload, ctx) => {
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise)
        return result.then((result$1) =>
          handleNonOptionalResult2(result$1, inst),
        );
      return handleNonOptionalResult2(result, inst);
    };
  },
);
function handleNonOptionalResult2(payload, inst) {
  if (!payload.issues.length && payload.value === void 0)
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst,
    });
  return payload;
}
var $ZodCatch2 = /* @__PURE__ */ $constructor2("$ZodCatch", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy2(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy2(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward")
      return def.innerType._zod.run(payload, ctx);
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise)
      return result.then((result$1) => {
        payload.value = result$1.value;
        if (result$1.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result$1.issues.map((iss) =>
                finalizeIssue2(iss, ctx, config2()),
              ),
            },
            input: payload.value,
          });
          payload.issues = [];
        }
        return payload;
      });
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) =>
            finalizeIssue2(iss, ctx, config2()),
          ),
        },
        input: payload.value,
      });
      payload.issues = [];
    }
    return payload;
  };
});
var $ZodPipe2 = /* @__PURE__ */ $constructor2("$ZodPipe", (inst, def) => {
  $ZodType2.init(inst, def);
  defineLazy2(inst._zod, "values", () => def.in._zod.values);
  defineLazy2(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy2(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy2(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise)
        return right.then((right$1) => handlePipeResult2(right$1, def.in, ctx));
      return handlePipeResult2(right, def.in, ctx);
    }
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise)
      return left.then((left$1) => handlePipeResult2(left$1, def.out, ctx));
    return handlePipeResult2(left, def.out, ctx);
  };
});
function handlePipeResult2(left, next, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return next._zod.run(
    {
      value: left.value,
      issues: left.issues,
    },
    ctx,
  );
}
var $ZodReadonly2 = /* @__PURE__ */ $constructor2(
  "$ZodReadonly",
  (inst, def) => {
    $ZodType2.init(inst, def);
    defineLazy2(inst._zod, "propValues", () => def.innerType._zod.propValues);
    defineLazy2(inst._zod, "values", () => def.innerType._zod.values);
    defineLazy2(inst._zod, "optin", () => def.innerType._zod.optin);
    defineLazy2(inst._zod, "optout", () => def.innerType._zod.optout);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward")
        return def.innerType._zod.run(payload, ctx);
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) return result.then(handleReadonlyResult2);
      return handleReadonlyResult2(result);
    };
  },
);
function handleReadonlyResult2(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
var $ZodCustom2 = /* @__PURE__ */ $constructor2("$ZodCustom", (inst, def) => {
  $ZodCheck2.init(inst, def);
  $ZodType2.init(inst, def);
  inst._zod.parse = (payload, _2) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r2 = def.fn(input);
    if (r2 instanceof Promise)
      return r2.then((r$1) => handleRefineResult2(r$1, payload, input, inst));
    handleRefineResult2(r2, payload, input, inst);
  };
});
function handleRefineResult2(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      path: [...(inst._zod.def.path ?? [])],
      continue: !inst._zod.def.abort,
    };
    if (inst._zod.def.params) _iss.params = inst._zod.def.params;
    payload.issues.push(issue2(_iss));
  }
}
var $output2 = Symbol("ZodOutput");
var $input2 = Symbol("ZodInput");
var $ZodRegistry2 = class {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap();
    this._idmap = /* @__PURE__ */ new Map();
  }
  add(schema, ..._meta) {
    const meta = _meta[0];
    this._map.set(schema, meta);
    if (meta && typeof meta === "object" && "id" in meta) {
      if (this._idmap.has(meta.id))
        throw new Error(`ID ${meta.id} already exists in the registry`);
      this._idmap.set(meta.id, schema);
    }
    return this;
  }
  clear() {
    this._map = /* @__PURE__ */ new WeakMap();
    this._idmap = /* @__PURE__ */ new Map();
    return this;
  }
  remove(schema) {
    const meta = this._map.get(schema);
    if (meta && typeof meta === "object" && "id" in meta)
      this._idmap.delete(meta.id);
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p2 = schema._zod.parent;
    if (p2) {
      const pm = { ...(this.get(p2) ?? {}) };
      delete pm.id;
      const f2 = {
        ...pm,
        ...this._map.get(schema),
      };
      return Object.keys(f2).length ? f2 : void 0;
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
};
function registry2() {
  return new $ZodRegistry2();
}
var globalRegistry2 = /* @__PURE__ */ registry2();
function _string2(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams2(params),
  });
}
function _email2(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params),
  });
}
function _guid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params),
  });
}
function _uuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params),
  });
}
function _uuidv42(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams2(params),
  });
}
function _uuidv62(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams2(params),
  });
}
function _uuidv72(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams2(params),
  });
}
function _url2(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params),
  });
}
function _emoji3(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params),
  });
}
function _nanoid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params),
  });
}
function _cuid3(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params),
  });
}
function _cuid22(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params),
  });
}
function _ulid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params),
  });
}
function _xid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params),
  });
}
function _ksuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params),
  });
}
function _ipv42(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params),
  });
}
function _ipv62(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params),
  });
}
function _cidrv42(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params),
  });
}
function _cidrv62(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params),
  });
}
function _base642(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params),
  });
}
function _base64url2(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params),
  });
}
function _e1642(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params),
  });
}
function _jwt2(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams2(params),
  });
}
function _isoDateTime2(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams2(params),
  });
}
function _isoDate2(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams2(params),
  });
}
function _isoTime2(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams2(params),
  });
}
function _isoDuration2(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams2(params),
  });
}
function _boolean2(Class2, params) {
  return new Class2({
    type: "boolean",
    ...normalizeParams2(params),
  });
}
function _unknown2(Class2) {
  return new Class2({ type: "unknown" });
}
function _never2(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams2(params),
  });
}
function _maxLength2(maximum, params) {
  const ch = new $ZodCheckMaxLength2({
    check: "max_length",
    ...normalizeParams2(params),
    maximum,
  });
  return ch;
}
function _minLength2(minimum, params) {
  return new $ZodCheckMinLength2({
    check: "min_length",
    ...normalizeParams2(params),
    minimum,
  });
}
function _length2(length, params) {
  return new $ZodCheckLengthEquals2({
    check: "length_equals",
    ...normalizeParams2(params),
    length,
  });
}
function _regex2(pattern, params) {
  return new $ZodCheckRegex2({
    check: "string_format",
    format: "regex",
    ...normalizeParams2(params),
    pattern,
  });
}
function _lowercase2(params) {
  return new $ZodCheckLowerCase2({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams2(params),
  });
}
function _uppercase2(params) {
  return new $ZodCheckUpperCase2({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams2(params),
  });
}
function _includes2(includes, params) {
  return new $ZodCheckIncludes2({
    check: "string_format",
    format: "includes",
    ...normalizeParams2(params),
    includes,
  });
}
function _startsWith2(prefix, params) {
  return new $ZodCheckStartsWith2({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams2(params),
    prefix,
  });
}
function _endsWith2(suffix, params) {
  return new $ZodCheckEndsWith2({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams2(params),
    suffix,
  });
}
function _overwrite2(tx) {
  return new $ZodCheckOverwrite2({
    check: "overwrite",
    tx,
  });
}
function _normalize2(form) {
  return _overwrite2((input) => input.normalize(form));
}
function _trim2() {
  return _overwrite2((input) => input.trim());
}
function _toLowerCase2() {
  return _overwrite2((input) => input.toLowerCase());
}
function _toUpperCase2() {
  return _overwrite2((input) => input.toUpperCase());
}
function _array2(Class2, element, params) {
  return new Class2({
    type: "array",
    element,
    ...normalizeParams2(params),
  });
}
function _refine2(Class2, fn, _params) {
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams2(_params),
  });
  return schema;
}
function _superRefine2(fn) {
  const ch = _check3((payload) => {
    payload.addIssue = (issue$1) => {
      if (typeof issue$1 === "string")
        payload.issues.push(issue2(issue$1, payload.value, ch._zod.def));
      else {
        const _issue = issue$1;
        if (_issue.fatal) _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(issue2(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
function _check3(fn, params) {
  const ch = new $ZodCheck2({
    check: "custom",
    ...normalizeParams2(params),
  });
  ch._zod.check = fn;
  return ch;
}
var ZodISODateTime2 = /* @__PURE__ */ $constructor2(
  "ZodISODateTime",
  (inst, def) => {
    $ZodISODateTime2.init(inst, def);
    ZodStringFormat2.init(inst, def);
  },
);
function datetime3(params) {
  return _isoDateTime2(ZodISODateTime2, params);
}
var ZodISODate2 = /* @__PURE__ */ $constructor2("ZodISODate", (inst, def) => {
  $ZodISODate2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function date5(params) {
  return _isoDate2(ZodISODate2, params);
}
var ZodISOTime2 = /* @__PURE__ */ $constructor2("ZodISOTime", (inst, def) => {
  $ZodISOTime2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
function time3(params) {
  return _isoTime2(ZodISOTime2, params);
}
var ZodISODuration2 = /* @__PURE__ */ $constructor2(
  "ZodISODuration",
  (inst, def) => {
    $ZodISODuration2.init(inst, def);
    ZodStringFormat2.init(inst, def);
  },
);
function duration3(params) {
  return _isoDuration2(ZodISODuration2, params);
}
var initializer3 = (inst, issues) => {
  $ZodError2.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: { value: (mapper) => formatError2(inst, mapper) },
    flatten: { value: (mapper) => flattenError2(inst, mapper) },
    addIssue: {
      value: (issue$1) => {
        inst.issues.push(issue$1);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer2, 2);
      },
    },
    addIssues: {
      value: (issues$1) => {
        inst.issues.push(...issues$1);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer2, 2);
      },
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      },
    },
  });
};
var ZodError3 = $constructor2("ZodError", initializer3);
var ZodRealError2 = $constructor2("ZodError", initializer3, { Parent: Error });
var parse5 = /* @__PURE__ */ _parse3(ZodRealError2);
var parseAsync3 = /* @__PURE__ */ _parseAsync2(ZodRealError2);
var safeParse4 = /* @__PURE__ */ _safeParse2(ZodRealError2);
var safeParseAsync3 = /* @__PURE__ */ _safeParseAsync2(ZodRealError2);
var encode3 = /* @__PURE__ */ _encode2(ZodRealError2);
var decode3 = /* @__PURE__ */ _decode2(ZodRealError2);
var encodeAsync3 = /* @__PURE__ */ _encodeAsync2(ZodRealError2);
var decodeAsync3 = /* @__PURE__ */ _decodeAsync2(ZodRealError2);
var safeEncode3 = /* @__PURE__ */ _safeEncode2(ZodRealError2);
var safeDecode3 = /* @__PURE__ */ _safeDecode2(ZodRealError2);
var safeEncodeAsync3 = /* @__PURE__ */ _safeEncodeAsync2(ZodRealError2);
var safeDecodeAsync3 = /* @__PURE__ */ _safeDecodeAsync2(ZodRealError2);
var ZodType3 = /* @__PURE__ */ $constructor2("ZodType", (inst, def) => {
  $ZodType2.init(inst, def);
  inst.def = def;
  inst.type = def.type;
  Object.defineProperty(inst, "_def", { value: def });
  inst.check = (...checks) => {
    return inst.clone(
      mergeDefs2(def, {
        checks: [
          ...(def.checks ?? []),
          ...checks.map((ch) =>
            typeof ch === "function"
              ? {
                  _zod: {
                    check: ch,
                    def: { check: "custom" },
                    onattach: [],
                  },
                }
              : ch,
          ),
        ],
      }),
    );
  };
  inst.clone = (def$1, params) => clone2(inst, def$1, params);
  inst.brand = () => inst;
  inst.register = (reg, meta) => {
    reg.add(inst, meta);
    return inst;
  };
  inst.parse = (data, params) =>
    parse5(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse4(inst, data, params);
  inst.parseAsync = async (data, params) =>
    parseAsync3(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) =>
    safeParseAsync3(inst, data, params);
  inst.spa = inst.safeParseAsync;
  inst.encode = (data, params) => encode3(inst, data, params);
  inst.decode = (data, params) => decode3(inst, data, params);
  inst.encodeAsync = async (data, params) => encodeAsync3(inst, data, params);
  inst.decodeAsync = async (data, params) => decodeAsync3(inst, data, params);
  inst.safeEncode = (data, params) => safeEncode3(inst, data, params);
  inst.safeDecode = (data, params) => safeDecode3(inst, data, params);
  inst.safeEncodeAsync = async (data, params) =>
    safeEncodeAsync3(inst, data, params);
  inst.safeDecodeAsync = async (data, params) =>
    safeDecodeAsync3(inst, data, params);
  inst.refine = (check2, params) => inst.check(refine2(check2, params));
  inst.superRefine = (refinement) => inst.check(superRefine2(refinement));
  inst.overwrite = (fn) => inst.check(_overwrite2(fn));
  inst.optional = () => optional2(inst);
  inst.nullable = () => nullable2(inst);
  inst.nullish = () => optional2(nullable2(inst));
  inst.nonoptional = (params) => nonoptional2(inst, params);
  inst.array = () => array2(inst);
  inst.or = (arg) => union2([inst, arg]);
  inst.and = (arg) => intersection2(inst, arg);
  inst.transform = (tx) => pipe2(inst, transform2(tx));
  inst.default = (def$1) => _default3(inst, def$1);
  inst.prefault = (def$1) => prefault2(inst, def$1);
  inst.catch = (params) => _catch3(inst, params);
  inst.pipe = (target) => pipe2(inst, target);
  inst.readonly = () => readonly2(inst);
  inst.describe = (description) => {
    const cl = inst.clone();
    globalRegistry2.add(cl, { description });
    return cl;
  };
  Object.defineProperty(inst, "description", {
    get() {
      return globalRegistry2.get(inst)?.description;
    },
    configurable: true,
  });
  inst.meta = (...args) => {
    if (args.length === 0) return globalRegistry2.get(inst);
    const cl = inst.clone();
    globalRegistry2.add(cl, args[0]);
    return cl;
  };
  inst.isOptional = () => inst.safeParse(void 0).success;
  inst.isNullable = () => inst.safeParse(null).success;
  return inst;
});
var _ZodString2 = /* @__PURE__ */ $constructor2("_ZodString", (inst, def) => {
  $ZodString2.init(inst, def);
  ZodType3.init(inst, def);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null;
  inst.minLength = bag.minimum ?? null;
  inst.maxLength = bag.maximum ?? null;
  inst.regex = (...args) => inst.check(_regex2(...args));
  inst.includes = (...args) => inst.check(_includes2(...args));
  inst.startsWith = (...args) => inst.check(_startsWith2(...args));
  inst.endsWith = (...args) => inst.check(_endsWith2(...args));
  inst.min = (...args) => inst.check(_minLength2(...args));
  inst.max = (...args) => inst.check(_maxLength2(...args));
  inst.length = (...args) => inst.check(_length2(...args));
  inst.nonempty = (...args) => inst.check(_minLength2(1, ...args));
  inst.lowercase = (params) => inst.check(_lowercase2(params));
  inst.uppercase = (params) => inst.check(_uppercase2(params));
  inst.trim = () => inst.check(_trim2());
  inst.normalize = (...args) => inst.check(_normalize2(...args));
  inst.toLowerCase = () => inst.check(_toLowerCase2());
  inst.toUpperCase = () => inst.check(_toUpperCase2());
});
var ZodString3 = /* @__PURE__ */ $constructor2("ZodString", (inst, def) => {
  $ZodString2.init(inst, def);
  _ZodString2.init(inst, def);
  inst.email = (params) => inst.check(_email2(ZodEmail2, params));
  inst.url = (params) => inst.check(_url2(ZodURL2, params));
  inst.jwt = (params) => inst.check(_jwt2(ZodJWT2, params));
  inst.emoji = (params) => inst.check(_emoji3(ZodEmoji2, params));
  inst.guid = (params) => inst.check(_guid2(ZodGUID2, params));
  inst.uuid = (params) => inst.check(_uuid2(ZodUUID2, params));
  inst.uuidv4 = (params) => inst.check(_uuidv42(ZodUUID2, params));
  inst.uuidv6 = (params) => inst.check(_uuidv62(ZodUUID2, params));
  inst.uuidv7 = (params) => inst.check(_uuidv72(ZodUUID2, params));
  inst.nanoid = (params) => inst.check(_nanoid2(ZodNanoID2, params));
  inst.guid = (params) => inst.check(_guid2(ZodGUID2, params));
  inst.cuid = (params) => inst.check(_cuid3(ZodCUID3, params));
  inst.cuid2 = (params) => inst.check(_cuid22(ZodCUID22, params));
  inst.ulid = (params) => inst.check(_ulid2(ZodULID2, params));
  inst.base64 = (params) => inst.check(_base642(ZodBase642, params));
  inst.base64url = (params) => inst.check(_base64url2(ZodBase64URL2, params));
  inst.xid = (params) => inst.check(_xid2(ZodXID2, params));
  inst.ksuid = (params) => inst.check(_ksuid2(ZodKSUID2, params));
  inst.ipv4 = (params) => inst.check(_ipv42(ZodIPv42, params));
  inst.ipv6 = (params) => inst.check(_ipv62(ZodIPv62, params));
  inst.cidrv4 = (params) => inst.check(_cidrv42(ZodCIDRv42, params));
  inst.cidrv6 = (params) => inst.check(_cidrv62(ZodCIDRv62, params));
  inst.e164 = (params) => inst.check(_e1642(ZodE1642, params));
  inst.datetime = (params) => inst.check(datetime3(params));
  inst.date = (params) => inst.check(date5(params));
  inst.time = (params) => inst.check(time3(params));
  inst.duration = (params) => inst.check(duration3(params));
});
function string4(params) {
  return _string2(ZodString3, params);
}
var ZodStringFormat2 = /* @__PURE__ */ $constructor2(
  "ZodStringFormat",
  (inst, def) => {
    $ZodStringFormat2.init(inst, def);
    _ZodString2.init(inst, def);
  },
);
var ZodEmail2 = /* @__PURE__ */ $constructor2("ZodEmail", (inst, def) => {
  $ZodEmail2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
var ZodGUID2 = /* @__PURE__ */ $constructor2("ZodGUID", (inst, def) => {
  $ZodGUID2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
var ZodUUID2 = /* @__PURE__ */ $constructor2("ZodUUID", (inst, def) => {
  $ZodUUID2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
var ZodURL2 = /* @__PURE__ */ $constructor2("ZodURL", (inst, def) => {
  $ZodURL2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
var ZodEmoji2 = /* @__PURE__ */ $constructor2("ZodEmoji", (inst, def) => {
  $ZodEmoji2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
var ZodNanoID2 = /* @__PURE__ */ $constructor2("ZodNanoID", (inst, def) => {
  $ZodNanoID2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
var ZodCUID3 = /* @__PURE__ */ $constructor2("ZodCUID", (inst, def) => {
  $ZodCUID3.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
var ZodCUID22 = /* @__PURE__ */ $constructor2("ZodCUID2", (inst, def) => {
  $ZodCUID22.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
var ZodULID2 = /* @__PURE__ */ $constructor2("ZodULID", (inst, def) => {
  $ZodULID2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
var ZodXID2 = /* @__PURE__ */ $constructor2("ZodXID", (inst, def) => {
  $ZodXID2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
var ZodKSUID2 = /* @__PURE__ */ $constructor2("ZodKSUID", (inst, def) => {
  $ZodKSUID2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
var ZodIPv42 = /* @__PURE__ */ $constructor2("ZodIPv4", (inst, def) => {
  $ZodIPv42.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
var ZodIPv62 = /* @__PURE__ */ $constructor2("ZodIPv6", (inst, def) => {
  $ZodIPv62.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
var ZodCIDRv42 = /* @__PURE__ */ $constructor2("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv42.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
var ZodCIDRv62 = /* @__PURE__ */ $constructor2("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv62.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
var ZodBase642 = /* @__PURE__ */ $constructor2("ZodBase64", (inst, def) => {
  $ZodBase642.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
var ZodBase64URL2 = /* @__PURE__ */ $constructor2(
  "ZodBase64URL",
  (inst, def) => {
    $ZodBase64URL2.init(inst, def);
    ZodStringFormat2.init(inst, def);
  },
);
var ZodE1642 = /* @__PURE__ */ $constructor2("ZodE164", (inst, def) => {
  $ZodE1642.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
var ZodJWT2 = /* @__PURE__ */ $constructor2("ZodJWT", (inst, def) => {
  $ZodJWT2.init(inst, def);
  ZodStringFormat2.init(inst, def);
});
var ZodBoolean3 = /* @__PURE__ */ $constructor2("ZodBoolean", (inst, def) => {
  $ZodBoolean2.init(inst, def);
  ZodType3.init(inst, def);
});
function boolean4(params) {
  return _boolean2(ZodBoolean3, params);
}
var ZodUnknown3 = /* @__PURE__ */ $constructor2("ZodUnknown", (inst, def) => {
  $ZodUnknown2.init(inst, def);
  ZodType3.init(inst, def);
});
function unknown2() {
  return _unknown2(ZodUnknown3);
}
var ZodNever3 = /* @__PURE__ */ $constructor2("ZodNever", (inst, def) => {
  $ZodNever2.init(inst, def);
  ZodType3.init(inst, def);
});
function never2(params) {
  return _never2(ZodNever3, params);
}
var ZodArray3 = /* @__PURE__ */ $constructor2("ZodArray", (inst, def) => {
  $ZodArray2.init(inst, def);
  ZodType3.init(inst, def);
  inst.element = def.element;
  inst.min = (minLength, params) => inst.check(_minLength2(minLength, params));
  inst.nonempty = (params) => inst.check(_minLength2(1, params));
  inst.max = (maxLength, params) => inst.check(_maxLength2(maxLength, params));
  inst.length = (len, params) => inst.check(_length2(len, params));
  inst.unwrap = () => inst.element;
});
function array2(element, params) {
  return _array2(ZodArray3, element, params);
}
var ZodObject3 = /* @__PURE__ */ $constructor2("ZodObject", (inst, def) => {
  $ZodObjectJIT2.init(inst, def);
  ZodType3.init(inst, def);
  defineLazy2(inst, "shape", () => {
    return def.shape;
  });
  inst.keyof = () => _enum3(Object.keys(inst._zod.def.shape));
  inst.catchall = (catchall) =>
    inst.clone({
      ...inst._zod.def,
      catchall,
    });
  inst.passthrough = () =>
    inst.clone({
      ...inst._zod.def,
      catchall: unknown2(),
    });
  inst.loose = () =>
    inst.clone({
      ...inst._zod.def,
      catchall: unknown2(),
    });
  inst.strict = () =>
    inst.clone({
      ...inst._zod.def,
      catchall: never2(),
    });
  inst.strip = () =>
    inst.clone({
      ...inst._zod.def,
      catchall: void 0,
    });
  inst.extend = (incoming) => {
    return extend2(inst, incoming);
  };
  inst.safeExtend = (incoming) => {
    return safeExtend2(inst, incoming);
  };
  inst.merge = (other) => merge3(inst, other);
  inst.pick = (mask) => pick2(inst, mask);
  inst.omit = (mask) => omit3(inst, mask);
  inst.partial = (...args) => partial2(ZodOptional3, inst, args[0]);
  inst.required = (...args) => required2(ZodNonOptional2, inst, args[0]);
});
function object3(shape, params) {
  const def = {
    type: "object",
    shape: shape ?? {},
    ...normalizeParams2(params),
  };
  return new ZodObject3(def);
}
var ZodUnion3 = /* @__PURE__ */ $constructor2("ZodUnion", (inst, def) => {
  $ZodUnion2.init(inst, def);
  ZodType3.init(inst, def);
  inst.options = def.options;
});
function union2(options, params) {
  return new ZodUnion3({
    type: "union",
    options,
    ...normalizeParams2(params),
  });
}
var ZodIntersection3 = /* @__PURE__ */ $constructor2(
  "ZodIntersection",
  (inst, def) => {
    $ZodIntersection2.init(inst, def);
    ZodType3.init(inst, def);
  },
);
function intersection2(left, right) {
  return new ZodIntersection3({
    type: "intersection",
    left,
    right,
  });
}
var ZodEnum3 = /* @__PURE__ */ $constructor2("ZodEnum", (inst, def) => {
  $ZodEnum2.init(inst, def);
  ZodType3.init(inst, def);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    const newEntries = {};
    for (const value of values)
      if (keys.has(value)) newEntries[value] = def.entries[value];
      else throw new Error(`Key ${value} not found in enum`);
    return new ZodEnum3({
      ...def,
      checks: [],
      ...normalizeParams2(params),
      entries: newEntries,
    });
  };
  inst.exclude = (values, params) => {
    const newEntries = { ...def.entries };
    for (const value of values)
      if (keys.has(value)) delete newEntries[value];
      else throw new Error(`Key ${value} not found in enum`);
    return new ZodEnum3({
      ...def,
      checks: [],
      ...normalizeParams2(params),
      entries: newEntries,
    });
  };
});
function _enum3(values, params) {
  const entries = Array.isArray(values)
    ? Object.fromEntries(values.map((v2) => [v2, v2]))
    : values;
  return new ZodEnum3({
    type: "enum",
    entries,
    ...normalizeParams2(params),
  });
}
var ZodLiteral3 = /* @__PURE__ */ $constructor2("ZodLiteral", (inst, def) => {
  $ZodLiteral2.init(inst, def);
  ZodType3.init(inst, def);
  inst.values = new Set(def.values);
  Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1)
        throw new Error(
          "This schema contains multiple valid literal values. Use `.values` instead.",
        );
      return def.values[0];
    },
  });
});
function literal2(value, params) {
  return new ZodLiteral3({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams2(params),
  });
}
var ZodTransform2 = /* @__PURE__ */ $constructor2(
  "ZodTransform",
  (inst, def) => {
    $ZodTransform2.init(inst, def);
    ZodType3.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      if (_ctx.direction === "backward")
        throw new $ZodEncodeError2(inst.constructor.name);
      payload.addIssue = (issue$1) => {
        if (typeof issue$1 === "string")
          payload.issues.push(issue2(issue$1, payload.value, def));
        else {
          const _issue = issue$1;
          if (_issue.fatal) _issue.continue = false;
          _issue.code ?? (_issue.code = "custom");
          _issue.input ?? (_issue.input = payload.value);
          _issue.inst ?? (_issue.inst = inst);
          payload.issues.push(issue2(_issue));
        }
      };
      const output = def.transform(payload.value, payload);
      if (output instanceof Promise)
        return output.then((output$1) => {
          payload.value = output$1;
          return payload;
        });
      payload.value = output;
      return payload;
    };
  },
);
function transform2(fn) {
  return new ZodTransform2({
    type: "transform",
    transform: fn,
  });
}
var ZodOptional3 = /* @__PURE__ */ $constructor2("ZodOptional", (inst, def) => {
  $ZodOptional2.init(inst, def);
  ZodType3.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional2(innerType) {
  return new ZodOptional3({
    type: "optional",
    innerType,
  });
}
var ZodNullable3 = /* @__PURE__ */ $constructor2("ZodNullable", (inst, def) => {
  $ZodNullable2.init(inst, def);
  ZodType3.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable2(innerType) {
  return new ZodNullable3({
    type: "nullable",
    innerType,
  });
}
var ZodDefault3 = /* @__PURE__ */ $constructor2("ZodDefault", (inst, def) => {
  $ZodDefault2.init(inst, def);
  ZodType3.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function _default3(innerType, defaultValue) {
  return new ZodDefault3({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function"
        ? defaultValue()
        : shallowClone2(defaultValue);
    },
  });
}
var ZodPrefault2 = /* @__PURE__ */ $constructor2("ZodPrefault", (inst, def) => {
  $ZodPrefault2.init(inst, def);
  ZodType3.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault2(innerType, defaultValue) {
  return new ZodPrefault2({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function"
        ? defaultValue()
        : shallowClone2(defaultValue);
    },
  });
}
var ZodNonOptional2 = /* @__PURE__ */ $constructor2(
  "ZodNonOptional",
  (inst, def) => {
    $ZodNonOptional2.init(inst, def);
    ZodType3.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
  },
);
function nonoptional2(innerType, params) {
  return new ZodNonOptional2({
    type: "nonoptional",
    innerType,
    ...normalizeParams2(params),
  });
}
var ZodCatch3 = /* @__PURE__ */ $constructor2("ZodCatch", (inst, def) => {
  $ZodCatch2.init(inst, def);
  ZodType3.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function _catch3(innerType, catchValue) {
  return new ZodCatch3({
    type: "catch",
    innerType,
    catchValue:
      typeof catchValue === "function" ? catchValue : () => catchValue,
  });
}
var ZodPipe2 = /* @__PURE__ */ $constructor2("ZodPipe", (inst, def) => {
  $ZodPipe2.init(inst, def);
  ZodType3.init(inst, def);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe2(in_, out) {
  return new ZodPipe2({
    type: "pipe",
    in: in_,
    out,
  });
}
var ZodReadonly3 = /* @__PURE__ */ $constructor2("ZodReadonly", (inst, def) => {
  $ZodReadonly2.init(inst, def);
  ZodType3.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function readonly2(innerType) {
  return new ZodReadonly3({
    type: "readonly",
    innerType,
  });
}
var ZodCustom2 = /* @__PURE__ */ $constructor2("ZodCustom", (inst, def) => {
  $ZodCustom2.init(inst, def);
  ZodType3.init(inst, def);
});
function refine2(fn, _params = {}) {
  return _refine2(ZodCustom2, fn, _params);
}
function superRefine2(fn) {
  return _superRefine2(fn);
}
var tools3 = (options) => {
  const tools$1 = {};
  const slackMetadata = findLastMessageMetadata(options.messages);
  if (!slackMetadata && !options.enableToolsIfNotInThread) return tools$1;
  const authorizeSlack = async () => {
    const metadata = slackMetadata;
    return {
      client: await createClient(metadata, options),
      metadata,
    };
  };
  tools$1["slackbot_send_message"] = tool({
    description: "Send a Slack message in response to a thread.",
    inputSchema: object3({
      message: string4()
        .describe(`The message to send to Slack in response to the thread. 

FORMATTING RULES:
- *text* = bold (NOT italics like in standard markdown)
- _text_ = italics  
- \`text\` = inline code
- \`\`\` = code blocks (do NOT put a language after the backticks)
- ~text~ = strikethrough
- <http://example.com|link text> = links
- tables must be in a code block
- user mentions must be in the format <@user_id> (e.g. <@U01UBAM2C4D>)

NEVER USE:
- Headings (#, ##, ###, etc.)
- Double asterisks (**text**) - Slack doesn't support this
- Standard markdown bold/italic conventions
`),
      actions: array2(
        object3({
          type: _enum3(["button"]),
          text: object3({
            type: literal2("plain_text"),
            text: string4(),
          }),
          url: string4(),
        }).describe(
          "Specify external links to show in a message. Common examples are links to pull requests, issues, or other labeled URLs.",
        ),
      ),
      text_snippets: array2(
        object3({
          name: string4(),
          content: string4(),
          type: string4().describe(
            "The type of snippet. Any programming language, or 'text' if it's not a code snippet.",
          ),
        }),
      ).describe(
        "Text snippets to send immediately after the message. Use this for long-form atomized responses, like code snippets, blog posts, tutorials, etc. Reference these snippets in your text response.",
      ),
      image_urls: array2(
        object3({
          url: string4(),
          alt_text: string4(),
        }),
      ).describe("A list of images to show in the message."),
    }),
    execute: async (args) => {
      const { client, metadata } = await authorizeSlack();
      const text2 = formatSlackMessage(args.message);
      const blocks = [
        {
          type: "section",
          text: {
            type: "mrkdwn",
            text: text2.replaceAll("\\n", "\n").replaceAll('\\"', '"'),
          },
        },
      ];
      for (const image_url of args.image_urls)
        blocks.push({
          type: "image",
          image_url: image_url.url,
          alt_text: image_url.alt_text,
        });
      const actions = [];
      args.actions.forEach((action) => {
        actions.push({
          type: "button",
          text: action.text,
          url: action.url,
        });
      });
      if (actions.length > 0)
        blocks.push({
          type: "actions",
          elements: actions,
        });
      await client.chat.postMessage({
        channel: metadata.channel,
        thread_ts: metadata.ts,
        text: "",
        blocks,
      });
      return { success: true };
    },
  });
  tools$1["slackbot_react_to_message"] = tool({
    description: `Add or remove reactions to messages in Slack.`,
    inputSchema: object3({
      ts: string4().describe(`The timestamp of the message to react to.`),
      reaction: string4().describe(`The Slack reaction to add to the message.

Reactions:
- :thumbsup:
- :thumbsdown:
- :laughing:
- :heart:
- :eyes:
- :confused:
- :thinking_face:
- :sob:
- :scream:
- :thinking_face:

This is not an exhaustive list. You can try to add emojis you remember from Slack.

IMPORTANT: This MUST be text, not an emoji.
`),
      remove_reaction: boolean4().describe(
        `Set to true if you want to remove a reaction from a message.`,
      ),
    }),
    execute: async (args) => {
      const { client, metadata } = await authorizeSlack();
      let reaction = args.reaction;
      if (reaction.startsWith(":") && reaction.endsWith(":"))
        reaction = reaction.slice(1, -1);
      if (args.remove_reaction)
        await client.reactions.remove({
          channel: metadata.channel,
          timestamp: args.ts,
          name: reaction,
        });
      else
        await client.reactions.add({
          channel: metadata.channel,
          timestamp: args.ts,
          name: reaction,
        });
      return { success: true };
    },
  });
  return tools$1;
};
var createClient = async (metadata, options) => {
  if (!metadata || !metadata.teamId)
    throw new Error(
      "This chat isn't occurring in a Slack thread! Slack tools will not work.",
    );
  const tokenData = await getRefreshedToken(metadata.teamId);
  if (!tokenData) {
    if (options?.promptUserToAuthorize)
      throw new Error(
        `The Slack Team has not authorized the Slack App. Notify the user to visit the following URL to authorize the app: ${options.promptUserToAuthorize.url}`,
      );
    throw new Error(
      "The Slack bot is not authorized to access this chat. Notify the user to authorize the bot to use Slack tools.",
    );
  }
  return new import_slack_edge2.SlackAPIClient(tokenData.accessToken);
};
var findLastMessageMetadata = (messages) => {
  const asSlackMessages = messages;
  const lastSlackMessage = asSlackMessages.findLast(
    (m2) => m2.metadata?.channel,
  );
  return lastSlackMessage?.metadata;
};
var systemPrompt = `You are chatting with users in Slack.

Prefer short responses. If you need to explain something, do so in a few sentences. Keep responses at a MAXIMUM 2,900 characters.

You MUST use "slackbot" tools to communicate with the user. If you are going to execute a bunch of tools, you MUST react to the user's message with a "thinking_face" reaction (or a relevant, fun emoji). ONLY AFTER you've responded with "slackbot_send_message" remove the reaction.

Mimic the tone of the user's messages. React to messages with relevant, fun emojis.

You MUST use the "slackbot_send_message" tool to send a message in Slack.

If users are chatting in Slack and it does not seem relevant to you, you MUST NOT respond. When you are mentioned with @Blonk, you MUST respond.`;

// node_modules/@blink-sdk/model-intent/dist/index.js
function withModelIntent(tools4, options) {
  const wrapped = {};
  const inputDeltas = {};
  const debounceMs = options?.debounce ?? 50;
  let pendingByToolCallId = {};
  let lastSentByToolCallId = {};
  let debounceTimer = null;
  const flushModelIntents = () => {
    if (!options?.onModelIntents) return;
    const values = Object.values(pendingByToolCallId);
    if (values.length === 0) return;
    const changed = values.filter(
      (intent) =>
        lastSentByToolCallId[intent.toolCallId] !== intent.modelIntent,
    );
    pendingByToolCallId = {};
    if (changed.length === 0) {
      debounceTimer = null;
      return;
    }
    options.onModelIntents(changed);
    for (const intent of changed)
      lastSentByToolCallId[intent.toolCallId] = intent.modelIntent;
    debounceTimer = null;
  };
  const queueModelIntent = (intent) => {
    if (!options?.onModelIntents) return;
    pendingByToolCallId[intent.toolCallId] = intent;
    if (debounceTimer) clearTimeout(debounceTimer);
    debounceTimer = setTimeout(flushModelIntents, debounceMs);
  };
  for (const [key, value] of Object.entries(tools4))
    wrapped[key] = tool({
      ...value,
      inputSchema: external_exports.preprocess(
        (raw) => {
          if (!raw || typeof raw !== "object") return raw;
          const rawObj = raw;
          if ("model_intent" in rawObj && !("properties" in rawObj)) {
            const { model_intent, ...rest } = rawObj;
            return {
              model_intent,
              properties: rest,
            };
          }
          if (!("model_intent" in rawObj) && "properties" in rawObj) {
            const props = rawObj["properties"];
            if (props && typeof props === "object" && "model_intent" in props) {
              const { model_intent, ...rest } = props;
              return {
                model_intent,
                properties: rest,
              };
            }
          }
          return raw;
        },
        external_exports.object({
          model_intent: external_exports
            .string()
            .describe(
              "A short present-participle description of the tool call's purpose.",
            ),
          properties: value.inputSchema,
        }),
      ),
      execute: value.execute
        ? async (input, options$1) => {
            return value.execute(input.properties, options$1);
          }
        : void 0,
      onInputDelta: async ({ inputTextDelta, toolCallId, abortSignal }) => {
        if (abortSignal?.aborted) {
          delete inputDeltas[toolCallId];
          delete pendingByToolCallId[toolCallId];
          delete lastSentByToolCallId[toolCallId];
          return;
        }
        if (abortSignal)
          abortSignal.addEventListener(
            "abort",
            () => {
              delete inputDeltas[toolCallId];
              delete pendingByToolCallId[toolCallId];
              delete lastSentByToolCallId[toolCallId];
              if (
                Object.keys(pendingByToolCallId).length === 0 &&
                debounceTimer
              ) {
                clearTimeout(debounceTimer);
                debounceTimer = null;
              }
            },
            { once: true },
          );
        if (!inputDeltas[toolCallId]) inputDeltas[toolCallId] = "";
        inputDeltas[toolCallId] += inputTextDelta;
        const result = await parsePartialJson(inputDeltas[toolCallId]);
        if (
          result.value &&
          typeof result.value === "object" &&
          "model_intent" in result.value
        )
          queueModelIntent({
            toolName: key,
            toolCallId,
            modelIntent: result.value["model_intent"],
          });
      },
      onInputAvailable: ({ input, toolCallId, abortSignal }) => {
        if (abortSignal?.aborted) {
          delete inputDeltas[toolCallId];
          delete pendingByToolCallId[toolCallId];
          delete lastSentByToolCallId[toolCallId];
          return;
        }
        if (abortSignal)
          abortSignal.addEventListener(
            "abort",
            () => {
              delete inputDeltas[toolCallId];
              delete pendingByToolCallId[toolCallId];
              delete lastSentByToolCallId[toolCallId];
              if (
                Object.keys(pendingByToolCallId).length === 0 &&
                debounceTimer
              ) {
                clearTimeout(debounceTimer);
                debounceTimer = null;
              }
            },
            { once: true },
          );
        queueModelIntent({
          toolName: key,
          toolCallId,
          modelIntent: input.model_intent,
        });
      },
    });
  return wrapped;
}

// agent.ts
async function fetchXml(url2) {
  const res = await fetch(url2, { redirect: "follow" });
  if (!res.ok) throw new Error(`Failed to fetch XML: ${url2} (${res.status})`);
  return await res.text();
}
async function parseSitemap(url2, seen = /* @__PURE__ */ new Set()) {
  if (seen.has(url2)) return [];
  seen.add(url2);
  const parser = new import_fast_xml_parser.XMLParser({
    ignoreAttributes: false,
  });
  const xml = await fetchXml(url2);
  const doc = parser.parse(xml);
  if (doc.sitemapindex?.sitemap) {
    const items = Array.isArray(doc.sitemapindex.sitemap)
      ? doc.sitemapindex.sitemap
      : [doc.sitemapindex.sitemap];
    const nested = await Promise.all(
      items.map((s2) => parseSitemap(s2.loc, seen)),
    );
    return nested.flat();
  }
  if (doc.urlset?.url) {
    const urls = Array.isArray(doc.urlset.url)
      ? doc.urlset.url
      : [doc.urlset.url];
    return urls.map((u2) => ({
      loc: u2.loc,
      lastmod: u2.lastmod,
      changefreq: u2.changefreq,
      priority: u2.priority ? Number(u2.priority) : void 0,
    }));
  }
  return [];
}
function isDocsUrl(url2) {
  try {
    const u2 = new URL(url2);
    return (
      (u2.hostname === "coder.com" || u2.hostname.endsWith(".coder.com")) &&
      (u2.pathname === "/docs" || u2.pathname.startsWith("/docs/"))
    );
  } catch {
    return false;
  }
}
function stripHtml(input, max2 = 220) {
  if (!input) return void 0;
  const s2 = input
    .replace(/<[^>]+>/g, "")
    .replace(/\s+/g, " ")
    .trim();
  return s2.length > max2 ? s2.slice(0, max2 - 1) + "\u2026" : s2;
}
function hierarchyTitle(h2) {
  if (!h2) return void 0;
  const levels = ["lvl1", "lvl2", "lvl0", "lvl3", "lvl4", "lvl5", "lvl6"];
  for (const k of levels) if (h2[k]) return String(h2[k]);
  return void 0;
}
var agent = S2.agent();
agent.on("chat", async ({ messages, context }) => {
  messages = messages.map((m2) => {
    for (const part of m2.parts) {
      if (isToolUIPart(part) && part.state === "output-error") {
        if (part.errorText.length > 2e3) {
          part.errorText = `Error: ${part.errorText.slice(0, 2e3)}... this error was too long to display.`;
        }
      }
    }
    return m2;
  });
  const baseSystem = `You are Blink for Docs \u2014 an agent that answers questions about Coder, prioritizing coder.com/docs.

Principles
- Be fast and precise: retrieve narrowly, cite exact sections, avoid over-searching.
- Docs-first: prefer coder.com/docs; expand only when signals or the user ask.
- Be transparent: state confidence and next best step when uncertain.
- Answer structure: lead with conclusion, then citations, then optional next step.

Docs Retrieval Playbook
- Start with search_docs (mode=light, hitsPerPage=2\u20133) using targeted queries ("<topic> coder").
- If a hit looks promising, go directly to page_section for an exact quote. Use page_outline only when structure is unclear.
- If nothing relevant, try sitemap_list \u2192 page_outline \u2192 page_section.

GitHub Issues/PRs (consented)
- When a user implies something is broken/being changed, ask to check GitHub.
- Use broad\u2192targeted\u2192synthesis:
  1) Landscape: repo:<owner>/<repo> <topic> is:issue (sort updated), scan 3\u20135 items.
  2) Targeted: exact phrases and OR variants ("X not showing" OR "X missing" ...).
  3) Synthesize: lead with exact matches; otherwise summarize related signals or say no direct match.
- Treat "closed in one repo" \u2260 "globally resolved"; confirm status with links and last updates.

Multi-repo Expansion (consented)
- Default repo=coder/coder. If error paths, CLI subcommands, or module names suggest a library/dependency, ask to expand within coder org.
- On consent: run one broad org scan (repo:coder/* <topic> is:issue|is:pr), then targeted searches in candidate repos (e.g., coder/clistat). Consider recent and historical items before concluding.

External References (allowlist)
- Default to coder.com/docs. If user requests or error paths point to an allowlisted source, perform a site-scoped search and cite the external page.

Tool-calling
- Use parallel tool calls for independent steps.
- Include model_intent in every tool call (short present-participle phrase; no underscores).
- Use GitHub tools for read-only; use Workspace tools for writes/exec.

Stop/Ask Rule
- After two hops (e.g., docs \u2192 issues scan), if confidence < 0.6, ask which path to deepen (docs page, issues/PRs, or code).
`;
  let systemPrompt2 = baseSystem;
  const metadata = findLastMessageMetadata(messages);
  if (metadata) {
    systemPrompt2 += `
<formatting-rules>
${systemPrompt}
</formatting-rules>
`;
  }
  const tools4 = withModelIntent(
    {
      ...tools3({ messages, context }),
      search_web: tools2.web_search,
      search_docs: tool({
        description:
          "Search Coder Docs via Algolia DocSearch. Mode 'light' returns url/title/snippet only; 'full' returns hierarchy/content/snippet.",
        inputSchema: external_exports.object({
          query: external_exports.string(),
          page: external_exports.number().int().min(0).optional(),
          hitsPerPage: external_exports
            .number()
            .int()
            .min(1)
            .max(10)
            .optional(),
          facetFilters: external_exports
            .array(
              external_exports.union([
                external_exports.string(),
                external_exports.array(external_exports.string()),
              ]),
            )
            .optional(),
          filters: external_exports.string().optional(),
          mode: external_exports.enum(["light", "full"]).optional(),
        }),
        execute: async (input) => {
          const appId = process.env.ALGOLIA_APP_ID;
          const apiKey = process.env.ALGOLIA_SEARCH_KEY;
          const indexName = process.env.ALGOLIA_INDEX_NAME ?? "docs";
          if (!appId || !apiKey || !indexName) {
            return {
              available: false,
              reason:
                "Missing Algolia env: ALGOLIA_APP_ID, ALGOLIA_SEARCH_KEY, ALGOLIA_INDEX_NAME",
            };
          }
          const mode = input.mode ?? "light";
          const hitsPerPage = Math.min(input.hitsPerPage ?? 3, 5);
          const baseFacetFilters = [];
          if (input.facetFilters && Array.isArray(input.facetFilters)) {
            for (const ff of input.facetFilters) baseFacetFilters.push(ff);
          }
          const hasV2 = baseFacetFilters.some((ff) => {
            if (typeof ff === "string") return ff === "tags:v2";
            return ff.includes("tags:v2");
          });
          if (!hasV2) baseFacetFilters.push("tags:v2");
          const hasMain = baseFacetFilters.some((ff) => {
            if (typeof ff === "string") return ff === "version:main";
            return ff.includes("version:main");
          });
          if (!hasMain) baseFacetFilters.push("version:main");
          const body = {
            query: input.query,
            page: input.page ?? 0,
            hitsPerPage,
            attributesToRetrieve:
              mode === "light"
                ? ["url", "hierarchy", "type"]
                : ["url", "hierarchy", "content", "type"],
            facetFilters: baseFacetFilters,
            filters: input.filters,
          };
          if (mode === "full") body.attributesToSnippet = ["content:40"];
          const res = await fetch(
            `https://${appId}-dsn.algolia.net/1/indexes/${encodeURIComponent(indexName)}/query`,
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "X-Algolia-Application-Id": appId,
                "X-Algolia-API-Key": apiKey,
              },
              body: JSON.stringify(body),
            },
          );
          if (!res.ok) throw new Error(`Algolia error ${res.status}`);
          const data = await res.json();
          const rawHits = data.hits ?? [];
          const filtered = rawHits.filter(
            (h2) => typeof h2.url === "string" && isDocsUrl(h2.url),
          );
          const hits =
            mode === "light"
              ? filtered.map((h2) => ({
                  url: h2.url,
                  title: hierarchyTitle(h2.hierarchy),
                  snippet: stripHtml(h2._snippetResult?.content?.value, 200),
                  objectID: h2.objectID,
                }))
              : filtered.map((h2) => ({
                  url: h2.url,
                  hierarchy: h2.hierarchy,
                  content: h2.content,
                  snippet: stripHtml(h2._snippetResult?.content?.value, 300),
                  type: h2.type,
                  objectID: h2.objectID,
                }));
          return {
            available: true,
            hits,
            page: data.page,
            nbPages: data.nbPages,
            nbHits: data.nbHits,
          };
        },
      }),
      sitemap_list: tool({
        description:
          "Fetch and flatten sitemap URLs (default https://coder.com/sitemap.xml), filtered to coder.com/docs.*",
        inputSchema: external_exports.object({
          sitemapUrl: external_exports.string().url().optional(),
          include: external_exports.array(external_exports.string()).optional(),
          exclude: external_exports.array(external_exports.string()).optional(),
          limit: external_exports.number().int().min(1).max(1e4).optional(),
        }),
        execute: async (input) => {
          const sitemapUrl =
            input.sitemapUrl ?? "https://coder.com/sitemap.xml";
          let entries = await parseSitemap(sitemapUrl);
          entries = entries.filter((e2) => isDocsUrl(e2.loc));
          if (input.include?.length) {
            entries = entries.filter((e2) =>
              input.include.some((p2) => e2.loc.includes(p2)),
            );
          }
          if (input.exclude?.length) {
            entries = entries.filter(
              (e2) => !input.exclude.some((p2) => e2.loc.includes(p2)),
            );
          }
          if (input.limit) entries = entries.slice(0, input.limit);
          return { count: entries.length, entries };
        },
      }),
      page_outline: tool({
        description:
          "Fetch a Docs page and return title and outline (h1\u2013h3 + anchors + internal links).",
        inputSchema: external_exports.object({
          url: external_exports.string().url(),
        }),
        execute: async ({ url: url2 }) => {
          const res = await fetch(url2, { redirect: "follow" });
          if (!res.ok)
            throw new Error(`Failed to fetch page: ${url2} (${res.status})`);
          const html = await res.text();
          const root = (0, import_node_html_parser.parse)(html);
          const title = root.querySelector("title")?.text?.trim() ?? null;
          const headings = [];
          for (const level of [1, 2, 3]) {
            root.querySelectorAll(`h${level}`).forEach((h2) => {
              const id =
                h2.getAttribute("id") ??
                h2.querySelector("a[id]")?.getAttribute("id") ??
                null;
              const text2 = h2.text.trim();
              headings.push({ level, id, text: text2 });
            });
          }
          const anchors = root
            .querySelectorAll('a[href^="#"]')
            .map((a2) => a2.getAttribute("href"))
            .filter((href) => typeof href === "string");
          const internalLinks = root
            .querySelectorAll('a[href^="/"]')
            .map((a2) => a2.getAttribute("href"))
            .filter((u2) => !!u2)
            .filter((u2) => {
              try {
                const full = new URL(u2, url2).toString();
                return isDocsUrl(full);
              } catch {
                return false;
              }
            });
          return { url: url2, title, headings, anchors, internalLinks };
        },
      }),
      page_section: tool({
        description:
          "Return the exact content for a specific Docs page section by anchor or heading text.",
        inputSchema: external_exports.object({
          url: external_exports.string().url(),
          anchorId: external_exports.string().optional(),
          headingText: external_exports.string().optional(),
          maxChars: external_exports
            .number()
            .int()
            .min(100)
            .max(2e4)
            .optional(),
        }),
        execute: async ({ url: url2, anchorId, headingText, maxChars }) => {
          if (!isDocsUrl(url2)) {
            throw new Error("Only coder.com/docs URLs are supported");
          }
          const res = await fetch(url2, { redirect: "follow" });
          if (!res.ok)
            throw new Error(`Failed to fetch page: ${url2} (${res.status})`);
          const html = await res.text();
          const root = (0, import_node_html_parser.parse)(html);
          const headings = root.querySelectorAll("h1, h2, h3, h4, h5, h6");
          function levelOf(tagName) {
            const m2 = tagName?.match(/^h([1-6])$/i);
            return m2 ? parseInt(m2[1], 10) : 6;
          }
          let targetIndex = -1;
          let targetLevel = 6;
          for (let i2 = 0; i2 < headings.length; i2++) {
            const h2 = headings[i2];
            const id =
              h2.getAttribute("id") ??
              h2.querySelector("a[id]")?.getAttribute("id") ??
              null;
            const txt = h2.text.trim();
            if (
              (anchorId && id === anchorId) ||
              (headingText && txt.toLowerCase() === headingText.toLowerCase())
            ) {
              targetIndex = i2;
              targetLevel = levelOf(h2.tagName.toLowerCase());
              break;
            }
          }
          if (targetIndex < 0) {
            return {
              found: false,
              reason: "Section not found by anchorId or headingText.",
            };
          }
          const start = headings[targetIndex];
          let htmlOut = "";
          const codeBlocks = [];
          const textChunks = [];
          let node = start.nextElementSibling;
          const maxLen = maxChars ?? 5e3;
          while (node) {
            const tag = node.tagName?.toLowerCase?.();
            if (tag && tag.match(/^h[1-6]$/)) {
              const nextLevel = levelOf(tag);
              if (nextLevel <= targetLevel) break;
            }
            const snippet = node.toString();
            if (htmlOut.length + snippet.length > maxLen) break;
            htmlOut += snippet;
            if (tag === "pre" || tag === "code") {
              codeBlocks.push(node.text.trim());
            }
            const maybeText = node.text?.trim?.();
            if (maybeText) textChunks.push(maybeText);
            node = node.nextElementSibling;
          }
          return {
            found: true,
            url: url2,
            anchorId:
              anchorId ??
              start.getAttribute("id") ??
              start.querySelector("a[id]")?.getAttribute("id") ??
              null,
            heading: start.text.trim(),
            html: htmlOut,
            text: textChunks.join("\n\n"),
            codeBlocks,
          };
        },
      }),
      ...S2.tools.with(
        {
          github_get_repository: tools.get_repository,
          github_repository_read_file: tools.repository_read_file,
          github_repository_list_directory: tools.repository_list_directory,
          github_repository_grep_file: tools.repository_grep_file,
          github_search_repositories: tools.search_repositories,
          github_search_issues: tools.search_issues,
          github_get_pull_request: tools.get_pull_request,
          github_list_pull_request_files: tools.list_pull_request_files,
          github_get_issue: tools.get_issue,
          github_list_commits: tools.list_commits,
          github_get_commit: tools.get_commit,
          github_get_commit_diff: tools.get_commit_diff,
          github_search_code: tools.search_code,
        },
        { accessToken: process.env.GITHUB_TOKEN },
      ),
    },
    {
      async onModelIntents(modelIntents) {
        const metadata2 = findLastMessageMetadata(messages);
        if (!metadata2) return;
        let statuses = modelIntents.map((i2) => {
          let s2 = i2.modelIntent;
          if (s2.length > 0) s2 = s2.charAt(0).toLowerCase() + s2.slice(1);
          return s2;
        });
        statuses = [...new Set(statuses)];
        const client = await createClient(metadata2);
        try {
          await client.assistant.threads.setStatus({
            channel_id: metadata2.channel,
            thread_ts: metadata2.threadTs ?? metadata2.ts,
            status: `is ${statuses.join(", ")}...`,
          });
        } catch {}
      },
    },
  );
  return streamText2({
    model: "anthropic/claude-sonnet-4",
    system: systemPrompt2,
    messages: convertToModelMessages(messages),
    tools: tools4,
    experimental_transform: smoothStream(),
  });
});
agent.on("request", async (request2, context) => {
  if (isOAuthRequest(request2)) {
    return handleOAuthRequest(request2, context);
  }
  if (isWebhook(request2)) {
    return handleWebhook(request2, context);
  }
});
agent.serve();
/*! Bundled license information:

he/he.js:
  (*! https://mths.be/he v1.2.0 by @mathias | MIT license *)

slack-edge/dist/cookie.js:
  (*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)
*/
